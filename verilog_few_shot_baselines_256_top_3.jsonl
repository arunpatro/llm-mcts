{"task_id": "review2015_fsmonehot", "completion": "\n\n\tassign B3_next = (state[8:0] == 9'b111111111) & d; // if state is B3 and d=1 go to next state\n    \tassign S_next = (state[8:0] == 9'b000000000) & !d | (state[8:0] == 9'b100000000) & d; // if state is S and d=0 or B3 and d=1 go to next state\n    \tassign S1_next = (state[8:0] == 9'b000000001) & !d | (state[8:0] == 9'b100000000) & d; // if state is S1 and d=0 or B3 and d=1 go to next state\n    \tassign Count_next = (state[8:0] == 9'b010000000) & !done_counting | (state[8:0] == 9'b011111"}
{"task_id": "review2015_fsmonehot", "completion": "\n\t\n    // State Transition Logic\n    assign B3_next = (state[4] && d) ? 1'b1 : 1'b0;     // If state is B3 and input 'd' is high, then next state should be B3. Otherwise, it stays in the same state.\n\n\tassign S_next = (~|state[9:5] && ~ack) ? 1'b1 : 1'b0; // If states are S or its subsequent states and 'ack' is low, then next state should be S. Otherwise, it stays in the same state.\n\t\n    assign S1_next = (state[1] && d) ? 1'b1 : 1'b0;      // If state is S1 and input 'd' is high, then next state should be S1. Otherwise, it stays in the same state.\n    \n\tassign Count_next = ((state[5:4] == 2'b11) && done_counting) ? 1'b1 : 1'b0; // If states are B3 or its subsequent states and 'done_"}
{"task_id": "review2015_fsmonehot", "completion": "\n\n\tassign B3_next = state[4] & d; // for B3 state, if the current state is 10'b0001000000 (B3) and input d = 1, then next state should be same as current state i.e., stay at B3\n\tassign S_next = ((~state[8]) & (d ^ state[1])) | (state[8] & ~d); // for S state, if the current state is 10'b0000000001 and input d = 0 or 1 but not both then next state should be S. If current state is S and input d = 0 or 1 but not both then next state should also be S\n\tassign S1_next = (state[8] & d) | ((~state[9]) & ~(d ^ state[1])) | (state[9] & d); // for S1 state, if current state is 10'b0000000010 and input d = 0 then next state should be S. If the current state is 10'b00"}
{"task_id": "dff8ar", "completion": "\n\t\n\talways @ (posedge clk or posedge areset) begin \n\t\tif(areset)\n\t\t\tq <= 8'd0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tq <= 8'h0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset)\n\t        q <= 8'b0;\n\t    else \n\t\t    q <= d;\n\tend\nendmodule\n"}
{"task_id": "kmap3", "completion": "\nalways @(*) begin\n\tif ((~a & ~b & ~c) | (d & ~b & ~c))\n\t\tout = 1'b0;\n\telse if ((~a & ~b & c) | (~a & d & ~c)| (d & b & c) | (~a & b & d)) \n\t\tout = 1'b1;\nend\nendmodule\n"}
{"task_id": "kmap3", "completion": "\n\t// Karnaugh map simplification for the given boolean equation.\n\tassign out = ((~b & ~c) | (d & c)) & a;\nendmodule\n\n"}
{"task_id": "kmap3", "completion": "\n\t// Karnaugh map for abc'd + ac'd'b + bcd' + abcd'\n\t// = !a.b + a.c.d + !b.c.d' + a.b.c.d'\n\tassign out = (!a && b) || (a && c && d) || (!b && c && !d) || (a && b && c && !d);\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\t// State definition\n\tlocalparam LEFT = 2'b01;\n\tlocalparam RIGHT = 2'b10;\n\t\n\t// Internal state signal\n\treg [1:0] state; \n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) // asynchronous reset\n\t\t    state <= LEFT;\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tLEFT: begin\n\t\t\t\t\tif (bump_left && bump_right) \n\t\t\t\t\t\tstate <= LEFT; // stay in left state on both bumps\n\t\t\t\t\telse if (bump_right)\n\t\t\t\t\t\tstate <= RIGHT; // switch to right state if only right bump\n\t\t\t\tend\n\t\t\t\tRIGHT: begin\n\t\t\t\t\tif (bump_left && bump_right) \n\t\t\t\t\t\tstate <= LEFT; // stay in left state on both bumps\n\t\t\t\t\telse if (bump_left)\n\t\t\t\t\t\tstate <= LEFT; // switch to left state if only right bump\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\t// Output assignments based on current"}
{"task_id": "lemmings1", "completion": "\n\treg state;\n\t\n\t// State 0 is walking left and State 1 is walking right.\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= 0;\n\t\telse if (bump_left && !bump_right || (!bump_left && bump_right)) // Bumped on both sides at the same time.\n\t\t\t// Do not change direction.\n\t\t\tstate <= state; \n\t\telse if (bump_left)  \n\t\t\tstate <= 1; // Change to walk right because bumped on left side.\n\t\telse if(bump_right)\n\t\t\tstate <= 0; //Change to walk left because bumped on the right.\n\tend\n\tassign walk_left = state == 0; \n\tassign walk_right = state == 1;\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\t// State encoding 00 = Left, 01 = Right\n\treg [1:0] state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= 2'b00; // Reset to walk left\n\t\telse\n\t\t\tcase(state) \n\t\t\t\t2'b00 : if (bump_right) state <= 2'b10; // If bumped on right, turn right\n\t\t\t         else if (bump_left) state <= 2'b01; // If bumped on left, turn left\n\t\t\t\t\t\telse state <= state; \t\t\t// Else keep going in the same direction\t\n\t\t\t\t2'b01 : if (bump_right) state <= 2'b10;\n\t\t\t         else if (bump_left) state <= 2'b00; // If bumped on left, turn left\n\t\t\t\t\t\telse state <= state; \t\t\t// Else keep going in the same direction\t\n\t\t\t\t2'b10 : if (bump_right) state <= 2'b10;\n\t\t\t         else if (bump"}
{"task_id": "2013_q2afsm", "completion": "\n\t// Define state variables as flip-flops\n\treg [1:0] current_state, next_state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11; // State codes\n\n\t// State table\n\talways @(*) begin\n\t\tcase (current_state) \n\t\t\tA: if (r[3]) next_state = A;\n\t\t\t   else if (!r[2] && !r[1]) next_state = D;\n\t\t\t   else next_state = B;\n\t\t\tB: if (!r[3] && r[1]) next_state = A;\n\t\t\t   else if (r[3]) next_state = B;\n\t\t\t   else if (!r[2]) next_state = C; \n\t\t\t   else next_state = D;\n\t\t\tC: if (!r[2] && !r[1]) next_state = A;\n\t\t\t   else if (r[3]) next_state = B;\n\t\t\t   else if (r[2]) next_state = C; \n"}
{"task_id": "2013_q2afsm", "completion": "\n\t// State definitions\n\tlocalparam A = 2'b00;  // State A\n\tlocalparam B = 2'b01;  // State B (g1=1)\n\tlocalparam C = 2'b10;  // State C (g2=1)\n\tlocalparam D = 2'b11;  // State D\n\t\t\n\t// State flip-flops\n\treg [1:0] state, next_state;  \n\t\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state) \n\t\t\tA:\tif (r[3]) next_state = B; // Device 3 requests\n\t\t\t\telse if (r[2]) next_state = C; // Device 2 requests\n\t\t\t\telse if (r[1]) next_state = D; // Device 1 requests\n\t\t\t\telse next_state = A;\n\t\t\tB:\tif (r[3]) next_state = B; // Stay in state B if device 3 requests\n\t\t\t\telse next_state = A; // Go back to state A when no one is requesting or devices 2 and/or 1 are requested\n"}
{"task_id": "2013_q2afsm", "completion": "verilog\n\t// Define states\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\treg [1:0] state, next_state; // State flip-flops\n\n\t// State table\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA : if (r[3]) begin next_state = B; g[3]=1'b0;g[2]=1'b0;g[1]=1'b0;end // device 3 has priority\n\t\t\t\telse if(r[2])begin next_state = C; g[3]=1'b0;g[2]=1'b0;g[1]=1'b0;end//device 2 has medium priority\n\t\t\t\telse if(r[1])begin next_state = D; g[3]=1'b0;g[2]=1'b0;g[1]=1'b0;end// device 1 has low priority\n\t\t\t\telse begin"}
{"task_id": "fsm_hdlc", "completion": "\n\n    reg [2:0] count;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 3'b000;\n\t\t\tdisc<=1'b0;\n\t\t\tflag<=1'b0;\n\t\t\terr<=1'b0;\n        end \n        else begin  \n            case(count)\n                3'b000: if (in==1'b0) count <= 3'b001; // waiting for the first '1' in a sequence of '11111'\n                3'b001: if (in==1'b1) begin \n                            disc<=1'b1; // signal to be discarded\n                            count <= 3'b010;\n                        end else count <=3'b000; // reset the counter\n                3'b010: if (in==1'b1) begin \n                            count <= 3'b011;\n                        end else count<=3'b000;//reset the counter and signal discarded"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [2:0] state; // 3-bit counter for counting the number of consecutive 1s\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin\n\t\t\t// Asynchronous reset\n\t\t\tstate <= 3'h0;\n\t\t\tdisc <= 1'b0;\n\t\t\tflag <= 1'b0;\n\t\t\terr  <= 1'b0;\n\t\tend else begin\n\t\t\t\tcase(state) \n\t\t\t\t\t3'h7: begin // Error state if there are more than or equal to 8 consecutive 1s.\n\t\t\t\t\t\t\t err <= 1'b1;\n\t\t\t\t\t\t\t disc <= 1'b0;\n\t\t\t\t\t\t\t flag <= 1'b0;\n\t\t\t\t\t\t end\n\t\t\t\t\t3'h6: begin // Flag state if there are exactly 7 consecutive 1s.\n\t\t\t\t\t\t\t err  <= 1'b0;\n\t\t\t\t\t\t\t disc <= 1'b0;\n\t\t\t\t\t\t\t flag <= 1'b1;\n\t\t\t\t\t\t end\n\t\t\t\t\tdefault: begin // Discard state for all other cases (<=5 consecutive 1s)\n\t\t\t\t\t\t\t\t\terr  <= 1'b0;\n"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [2:0] state; \n\twire nextState = in ? (state==3'b111) : 0;\n\t\n\t// Moore machine definition\n\talways @(posedge clk or posedge reset) begin\n\t  if (reset)\n\t    state <= 3'b000;\n\t  else \n\t    case (state)\n\t      3'b000: state <= in ? 3'b1 : 3'b000;\n\t      3'b1  : state <= nextState ? 3'b11 : 3'b00; // count up to 3, then go back to 1\n\t      3'b11 : state <= nextState ? 3'b2  : (in ? 3'b111 : 3'b0); // count up to 4, then go back to 2 or continue at 2 if in=0\n\t      3'b111: state <= ~(nextState | in) ? 3'b111 : (in ? 3'b2  : 3'b0); //"}
{"task_id": "bugs_mux2", "completion": "\nThe bug is in the output type and the assign statement. The mux should select between 8-bit vectors (not single bits), so we need to use a bitwise operator on the input vectors. Here is the correct version of the module:\n\t\nassign out = sel ? b : a;\n\n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug is that the output 'out' should be 8-bit wide but it is only assigned to one bit (1-bit). The solution would be to make 'out' a 8-bit wide. Here is the corrected code :\n\n\tassign out = (~sel & a) | (sel & b);\n\nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug in the code is that the output 'out' has been defined as a register (a single bit) instead of an 8-bit wide bus. The fix to this problem involves changing the definition of 'out' from reg [7:0] out to wire [7:0] out and then assigning it in terms of sel, a and b like so:\n\nmodule top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput wire [7:0] out\n);\n\tassign out = (~sel & a) | (sel & b);\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 10'd0;\n\t\telse if (q == 10'd999)\n\t\t\tq <= 10'd0;\n\t\telse \n\t\t\tq <= q + 10'd1;\n\tend\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\treg [11:0] cnt;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tcnt <= 12'h0;\n\t\telse if (cnt == 12'h3E8)  // 1000 in hexadecimal\n\t\t\tcnt <= 12'h0;\n\t\telse\n\t\t\tcnt <= cnt + 1'b1;\n\tend\n\tassign q = cnt[9:0];\nendmodule\n\n"}
{"task_id": "review2015_count1k", "completion": "\n    always @ (posedge clk or posedge reset) begin\n        if (reset) \n            q <= 10'd0;\n        else \n            q <= q + 10'd1 == 10'd1000 ? 10'd0 : q + 10'd1;\n    end  \nendmodule\n"}
{"task_id": "circuit8", "completion": "\n\treg temp;\n\n\talways @(posedge clock) begin\n\t\tif (!a) begin\n\t\t\tp <= 0;\n\t\t\tq <= temp;\n\t\tend else if (a && !temp) begin \n\t\t\tp <= 1;\n\t\t\tq <= 0;\n\t\tend else if (a && temp) begin\n\t\t\tp <= 0;\n\t\t\tq <= 1;\n\t\tend\n\t\ttemp <= a;\n\tend\n\t\nendmodule\n"}
{"task_id": "circuit8", "completion": "\n\tp = 0;\n\tq = 0;\n\t\n\talways @(posedge clock) begin\n\t    if (!a) begin\n\t\t    p <= 0;\n\t\t    q <= !p;\n\t    end else begin\n\t\t    p <= a;\n\t\t    q <= !p;\n\t    end\n\tend \nendmodule\n"}
{"task_id": "circuit8", "completion": "\nalways @(posedge clock or posedge a) begin\n\tif (a == 1'b0) begin\n\t\tp <= 1'bx;\n\tend else if (q == 1'b1 && p == 1'b1) begin\n\t\tp <= ~p;\n\tend else if (q == 1'b0 && p == 1'b0) begin\n\t\tp <= ~p;\n\tend\n\t\t \n\tif (a == 1'b0 || q == 1'bx) begin\n\t\tq <= 1'bx;\n\tend else if (~q == 1'b0 && ~p == 1'b0) begin\n\t\tq <= ~q;\n\tend else if (~q == 1'b1 && ~p == 1'b1) begin\n\t\tq <= ~q;\n\tend\nend\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\n\tassign out = ~(in1 | in2);\n\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n"}
{"task_id": "vector4", "completion": "\n\n\tassign out = {24{in[7]}, in};\n\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;  // Sign-extending an 8-bit number to 32 bits.\nendmodule\n\n"}
{"task_id": "2014_q3fsm", "completion": "\n\treg [1:0] count;\n\treg [2:0] state;\n\n\t// State encoding 00 - A , 01 - B , 10 - C, 11 - D\n\tparameter [1:0] A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= A; // Reset State\n\t\t\tcount <= 2'b00;\n\t\t\tz <= 1'b0; \n\t\tend \n\t\telse case (state)\n\t\t\tA: if (!s) state <= B; else z <= 1'b0;\n\t\t\t\n\t\t\tB: begin \n\t\t\t\t\tif(s) state <= D;\n\t\t\t\t\telse if (w) count <= count + 2'b01;\n\t\t\t\t\t\t else count <= 2'b00;\n\t\t\t\t\t end\n\n\t\t\tC,D : begin \n\t\t\t\t\tif (!(count == 2'b10)) state <= B; \n"}
{"task_id": "2014_q3fsm", "completion": "\n\n\t// States definition for FSM\n\ttypedef enum {STATE_A, STATE_B} state_t;\n\tstate_t state, next_state;  // current and next states of the machine\n\n\treg [1:0] w_count;          // count of consecutive 1s on w input\n\t\n\t// State transition\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset == 1'b1)\n\t\t    state <= STATE_A;     // Asynchronous reset\n        else\n            state <= next_state;   // Synchronous transitions\n\tend\n\t\n\t// State actions\n\talways @(*) begin \n\t\tcase (state)\n\t\t\tSTATE_A: begin\n\t\t\t\tif (s == 1'b0)\n\t\t\t\t\tnext_state = STATE_A;     // Stay in state A if s = 0\n                else\n                    next_state = STATE_B;     // Move to state B if s = 1\n\t\t\tend\n            \n            STATE_B: begin\n\t\t\t\tif (s == 1'b0)\n\t\t\t\t\tnext_state = STATE_"}
{"task_id": "2014_q3fsm", "completion": "\n\n    reg [1:0] state;\n    reg [2:0] counter = 3'b000;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'h1) begin\n            z <= 1'h0;\n            state <= 2'h0;\n            counter <= 3'b000;\n        end else begin\n            case (state) \n                2'h0: begin // State A\n                    if (s == 1'h1) \n                        state <= 2'h1; // Move to B if s = 1\n                end\n                2'h1: begin // State B\n                    counter <= {w,counter[2:1]}; // Shift w into the MSB and store in counter\n                    if (&counter == 1'h1) begin \n                        state <= 2'h0; // Reset counter and move back to A when all bits of counter are set (i.e., two '1's in a row)\n                    end else if (|counter[1:0] == 1'h1 && w != counter[0"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\nendmodule\n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\nendmodule\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\n\n"}
{"task_id": "always_if2", "completion": "\n\t// module top_module (\n\t//     input      cpu_overheated,\n\t//     output reg shut_off_computer,\n\t//     input      arrived,\n\t//     input      gas_tank_empty,\n\t//     output reg keep_driving  ); //\n\n\talways @(*) begin\n\t    if (cpu_overheated)\n\t       shut_off_computer = 1;\n\t    else \n\t       shut_off_computer = 0;   // Added missing line to reset value of 'shut_off_computer' when cpu_overheated is not true\n\tend\n\n\talways @(*) begin\n\t    if (arrived)\n\t       keep_driving = gas_tank_empty ? 1 : 0; // If arrived and tank empty, keep driving\n\t    else \n\t       keep_driving = 0;   // Added missing line to reset value of 'keep_driving' when not arrived\n\tend\n\n\talways @(*) begin\n\t    if (~arrived)\n\t       keep_driving = gas_tank_empty ? 1 : 0;"}
{"task_id": "always_if2", "completion": "\nalways @(*) begin\n\tif (cpu_overheated)\n\t    shut_off_computer = 1;\n\telse if (!arrived & !gas_tank_empty)\n\t    keep_driving = 0;  // fix for the error in the original code, should be 'else' not 'if'\nend\n\n"}
{"task_id": "always_if2", "completion": "\nalways @(*) begin\n    if (cpu_overheated) \n        shut_off_computer = 1;\n    else\n    \tshut_off_computer = 0;\nend\n\nalways @(*) begin\n    if (arrived == 0) \n       keep_driving = gas_tank_empty ? 0 : 1;\n    else \n      keep_driving = 0; // If the car hasn't arrived, we should never be driving\nend\n"}
{"task_id": "counter_2bc", "completion": "\n    \n\talways @(posedge clk or posedge areset) begin \n        if (areset) \n            state <= 2'b01; // reset to weakly not taken\n        else if (train_valid == 1'b1 && train_taken == 1'b1 && state < 3)  \n            state <= state + 1;\n        else if (train_valid == 1'b1 && train_taken == 1'b0) \n            state <= (state > 0) ? state - 1 : '0; // decrement only when not at zero\n    end\nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset)\n\t        state <= 2'b01;\n        else if(train_valid && train_taken && state < 3 )  //increment when train_taken = 1 and train_valid = 1, up to maximum of 3\n\t            state <= state + 1;  \n\t    else if(train_valid && !train_taken)    //decrement when train_taken=0 and train_valid=1, down to minimum of 0\n\t\t        state <= (state > 0)? state - 1: 0;\n\tend\nendmodule\n\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b01;\n        else if(train_valid) begin\n        \tif(train_taken && state < 3'b10)\n            \tstate <= state + 2'd1;\n        \telse if(!train_taken && state > 2'b00)\n            \tstate <= state - 2'd1;\n        end\n    end\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\tassign q = a ^ b; // XOR gate implementation\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\tassign q = (a & ~b) | (~a & b);\nendmodule\n"}
{"task_id": "circuit1", "completion": "\n\n\t// Implementing combinational circuit using OR and AND gates.\n\tassign q = ((a & ~b) | (~a & b)) ;\nendmodule\n  \n"}
{"task_id": "andgate", "completion": "\n\nassign out = a & b;\nendmodule\n"}
{"task_id": "andgate", "completion": "\n\n\tassign out = a & b;\n\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "mux9to1v", "completion": "\n\talways_comb begin\n\tcase (sel) \n\t\t4'd0 : out = a;\n\t\t4'd1 : out = b;\n\t\t4'd2 : out = c;\n\t\t4'd3 : out = d;\n\t\t4'd4 : out = e;\n\t\t4'd5 : out = f;\n\t\t4'd6 : out = g;\n\t\t4'd7 : out = h;\n\t\t4'd8 : out = i;\n\t\tdefault: out = 16'hFFFF; // All 1s for sel > 8.\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\n\n\talways_comb begin\n\t\tcase(sel) inside \n\t\t\t4'b0000 : out = a;\n\t\t\t4'b0001 : out = b;\n\t\t\t4'b0010 : out = c;\n\t\t\t4'b0011 : out = d;\n\t\t\t4'b0100 : out = e;\n\t\t\t4'b0101 : out = f;\n\t\t\t4'b0110 : out = g;\n\t\t\t4'b0111 : out = h;\n\t\t\t4'b1000 : out = i;\n\t\t\tdefault: out = 16'hFFFF; // All '1' for sel > 8 \n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "mux9to1v", "completion": "\n\nalways_comb begin\n\tcase (sel) \n\t\t4'd0: out = a;\n\t\t4'd1: out = b;\n\t\t4'd2: out = c;\n\t\t4'd3: out = d;\n\t\t4'd4: out = e;\n\t\t4'd5: out = f;\n\t\t4'd6: out = g;\n\t\t4'd7: out = h;\n\t\t4'd8: out = i;\n\t\tdefault: out = 16'hFFFF;\n\tendcase \nend\n\nendmodule\n"}
{"task_id": "2012_q1g", "completion": "\n\t// Implement function f using Karnaugh map\n\tassign f = ((~x[2] & ~x[3]) | (x[2] & ~x[3] & x[4]) | (x[2] & x[3] & x[4]) | (x[3])); \nendmodule\n"}
{"task_id": "2012_q1g", "completion": "\n\talways @(*) begin\n\t\tif (x[3]) begin\n\t\t\tif (x[2])\n\t\t\t\tf = 0;\n\t\t\telse if (!x[1])\n\t\t\t\tf = 1;\n\t\t\telse \n\t\t\t\tf = 0;\n\t\tend else begin\n\t\t\tif (x[4])\n\t\t\t\tf = 1;\n\t\t\telse\n\t\t\t\tf = x[1];\n\t\tend\n\tend\n\t\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\t// Karnaugh map implementation of function f\n\tassign f = ((~x[3] & ~x[2]) | (x[3] & ~x[1] & x[2]) | (x[3] & x[1] & x[2]) | (x[3] & x[1])); \nendmodule\t\n"}
{"task_id": "step_one", "completion": "\n\nassign one = 1'b1;\n\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\n\tassign one = 1'b1;\n\t\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "count1to10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t    q <= 4'b0001; // reset counter to 1\n        else \n            q <= q == 4'd10 ? 4'b0001 : q + 1;  \n\tend\nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0101; // Reset to 5 as binary equivalent of decimal 5. This is done because we are using a 4-bit counter and counting from 1 to 10 inclusive. So, the maximum value that can be represented by 4 bits (binary) is 1010 which corresponds to decimal 10. We choose '5' as it has the binary representation of 1010 in its most significant three bits.\n\t\telse if(q == 4'b1010) // If we reach the max count value, reset back to 1\n\t\t\tq <= 4'b0101; \n\t\telse\n\t\t\tq <= q + 1'b1;\n\tend\nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\treg [3:0] next;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) \n            q <= 4'd1;\n        else \n            q <= next;\n     end\n     \n     always @(*) begin\n         case(q)\n             4'd1 : next = 4'd2;\n             //... continue for all numbers up to 9 and then loop back to 1.\n             4'd9 : next = 4'd1;\n             default : next = q + 1;\n        endcase\n     end\t\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\n\talways @(posedge clk) begin\n\t\tout <= in ^ out;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4d", "completion": "\n\n\tDFF XOR_DFF (.clk(clk), .d(out ^ in), .q(out)); // D flip flop definition\n\nendmodule\n\n// Define the D Flip-Flop\nmodule DFF (\n  input clk,\n  input d,\n  output reg q\n);\n   always @(posedge clk) begin\n     \tq <= d;\n   end\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\n\talways @(posedge cll) begin\n\t\tout <= in ^ out;\n\tend\n\nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\n\treg [1:0] state;\n\tparameter A=2'b01, B=2'b10; // define states as binary numbers\n  \n\t// Asynchronous reset into state B \n\talways @(posedge areset)\n\t  state <= B; \n    \n\t// State transition and outputs\n\talways @(posedge clk) begin\n\t\tcase (state)\n\t\t\tA: if (!in)\n\t\t\t\tstate <= A;\n\t\t\telse\n\t\t\t\tstate <= B;\n\t\t\tB: if (!in)\n\t\t\t\tstate <= B;\n\t\t\telse\n\t\t\t\tstate <= A;\n\t\t\tdefault : state <= B; // default case, to prevent glitches\n\tend \n  \n\t// Outputs depend on states. In this case out is equal to the current state.\n\tassign out = (state == A);\n    \nendmodule\n"}
{"task_id": "fsm1", "completion": "\n    reg [1:0] state;\n    \n    parameter A = 2'b01, B = 2'b10;  // State definitions\n    \n    always @ (posedge clk or posedge areset) begin  \n        if(areset)  \n            state <= B;  // Asynchronous reset into state B when high\n        else \n           case(state)\n               A: if(!in) state <= A; else state <= B;\n               B: if(!in) state <= A; else state <= B;\n           endcase\n    end\n    \n   assign out = (state == B); // Output is high when in state 'B'\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n\treg [1:0] state;  // two bit state machine\n  \n\t// State Machine Logic \n    always @(posedge clk or posedge areset) begin \n        if (areset) \n            state <= 2'b10; \n        else \n\t\t\tcase (state) \n\t\t\t\t2'b00:\tif (!in)\tstate <= 2'b00;\t// A\n                    else    state <= 2'b10;\t// B\n                2'b01:\tif (!in)\tstate <= 2'b00;\t// A\n                    else    state <= 2'b01;  // B\n                2'b10:\tif (!in)\tstate <= 2'b10;\t// B\n\t\t\t\t\telse\tstate <= 2'b01;  // A\n                2'b11:\tif (!in)\tstate <= 2'b11;\t// B\n                    else    state <= 2'b11;  \n            endcase \n    end \n  \n\t// Output Logic - Moore Machine \n\tassign out = (state == 2'b00);\n"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n\tcasex (code) \n\t\t8'h45 : {out,valid} = {4'd1,1'b1}; //1\n        8'h16 : {out,valid} = {4'd2,1'b1}; //2\n        8'h1E : {out,valid} = {4'd3,1'b1}; //3\n        8'h26 : {out,valid} = {4'd4,1'b1}; //4\n\t\t8'h25 : {out,valid} = {4'd5,1'b1}; //5\n        8'h2E : {out,valid} = {4'd6,1'b1}; //6\n        8'h36 : {out,valid} = {4'd7,1'b1}; //7\n        8'h3D : {out,valid} = {4'd8,1'b1}; //8\n        8'h3E : {out,valid} = {4'd9,1'b1}; //"}
{"task_id": "bugs_case", "completion": "\n\n\t// Define the possible key codes for keys 0 through 9.\n\tlocalparam [7:0] CODE_0 = 8'h16;\n\tlocalparam [7:0] CODE_1 = 8'h1E;\n\tlocalparam [7:0] CODE_2 = 8'h26;\n\tlocalparam [7:0] CODE_3 = 8'h25;\n\tlocalparam [7:0] CODE_4 = 8'h2E;\n\tlocalparam [7:0] CODE_5 = 8'h36;\n\tlocalparam [7:0] CODE_6 = 8'h3D;\n\tlocalparam [7:0] CODE_7 = 8'h3E;\n\tlocalparam [7:0] CODE_8 = 8'h45;\n\tlocalparam [7:0] CODE_9 = 8'h46;\n\t\t\n\talways @(*) begin\n\t\tcase (code) \n\t\t\t// If the code matches any of the key codes, set out to the corresponding number and valid to 1"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n\t\tcase (code)\n\t\t\t8'h45 : {out, valid} = {4'd0 , 1'b1}; // 2C\n\t\t\t8'h16 : {out, valid} = {4'd1 , 1'b1}; // 12\n\t\t\t8'h1E : {out, valid} = {4'd2 , 1'b1}; // 1A\n\t\t\t8'h26 : {out, valid} = {4'd3 , 1'b1}; // 26\n\t\t\t8'h25 : {out, valid} = {4'd4 , 1'b1}; // 25\n\t\t\t8'h2E : {out, valid} = {4'd5 , 1'b1}; // 2E\n\t\t\t8'h36 : {out, valid} = {4'd6 , 1'b1}; // 36\n\t\t\t8'h3D : {out, valid} = {4'd7 , 1'b1}; // 3C\n\t\t\t8"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) \n\t\t\tq <= 16'h0;\n\t\telse if (byteena[0]) \n\t\t\tq <= {d[7:0], q[7:8]};\n\t\telse if (byteena[1])\n\t\t\tq <= {q[15:9], d[15:9]};\n\tend\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) \n\t\t\tq <= 16'b0;\n\t\telse if (byteena[1]) \n\t\t\tq <= {d[15:8], q[7:0]};\n\t\telse if (byteena[0])\n\t\t\tq <= {q[15:8], d[7:0]};\n\tend\nendmodule\n\n"}
{"task_id": "dff16e", "completion": "\n\n    always @ (posedge clk or negedge resetn) begin \n        if(!resetn)   // Async Reset\n            q <= 16'h0;\n        else\n            if(byteena[1])     // Upper byte\n                q[15:8] <= d[15:8];   \n            else if (byteena[0])  // Lower Byte\n                q[7:0] <= d[7:0];  \n        \n\tend\n\n"}
{"task_id": "fsm_onehot", "completion": "\n\tassign out1 = state[7]; // Outputs are only 1 when the current states is S7.\n\tassign out2 = in;      // Out2 follows input directly.\n\n\t// State transition logic using one-hot encoding\n\talways @* begin\n\tcase(state)\n\t\t10'b00_000_000_01: next_state = 10'b00_000_000_10; // S0 ->  S1 transition on input\n\t\t10'b00_000_000_10: next_state = in ? 10'b00_000_001_00 : 10'b00_000_000_10; // S1 -> (S2 or S3) transition on input\n\t\t10'b00_000_001_00: next_state = in ? 10'b00_000_010_00 : 10'b00_000_001_0"}
{"task_id": "fsm_onehot", "completion": "\n\n\tassign next_state[0] = ((in == 1'b0) && (state[5]==1'b1)) || ((in == 1'b1) && (state[8]==1'b1));  //S0\n   assign out1 = state[4];\n\tassign out2 = state[6];\n   \n\tgenerate\n\tfor(i = 1; i < 5; i++ ) begin: loop1\n\t\tassign next_state[i]  = ((in == 1'b0) && (state[(3+i)]==1'b1)) || ((in == 1'b1) && (state[(7+i)]==1'b1));   //S1 to S4\n        assign out1 = state[((5 + i + 2)% 6 ) ];\n\t\tassign out2 = ~out1;   \n\tend\n\t\n\tfor(j = 5; j < 8; j++ ) begin: loop2\n\t\tassign next_state[j]  = ((in == 1'b0) && (state[(j+3)]==1'b1)) || ((in == 1'"}
{"task_id": "fsm_onehot", "completion": "\n\n\tassign out1 = ~(state[7]) & ~in;  //out1 is zero for S5,S6 and one for all other states.\n\tassign out2 = state[9];          //out2 corresponds to the current state itself.\n\t\n\t//State transition logic:\n\talways @* begin\n\t\tnext_state = 0;              //Default state\n\t\t\n\t\tcase (state) \n\t\t\t10'b0000000001: next_state = in ? 10'b0000000010 : 10'b0000000000; //S0 to S1 on input transition\n\t\t\t10'b0000000010: next_state = in ? 10'b0000000100 : 10'b0000000001; //S1 to S2 on input transition\n\t\t\t10'b0000000100: next_state = in ? 10'b0000001"}
{"task_id": "conditional", "completion": "\n\talways @* begin\n\t\tif (a<b && a<c && a<d)\n\t\t\tmin = a;\n\t\telse if(b<a && b<c && b<d)\n\t\t\tmin = b;\n\t\telse if(c<a && c<b && c<d)\n\t\t\tmin = c;\n\t\telse \n\t\t\tmin = d;\n\tend\nendmodule\n"}
{"task_id": "conditional", "completion": "\n\n\talways @* begin\n\t    if (a < b && a < c && a < d)\n\t        min = a;\n\t    else if (b < a && b < c && b < d)\n\t        min = b;\n        else if (c < a && c < b && c < d) \n            min = c;\n        else\n            min = d;\n\tend\nendmodule\n"}
{"task_id": "conditional", "completion": "\nalways @* begin\n\tif (a < b && a < c && a < d) \n\t\tmin = a;\n\telse if(b < a && b < c && b < d)\n\t\tmin = b;\n\telse if(c < a && c < b && c < d)\n\t\tmin = c;\n\telse min = d; // If all other conditions fail, the minimum must be 'd'. \nend\n\n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in; // AND Gate\n\tassign out_or  = |in; // OR  Gate\n\tassign out_xor = ^in; // XOR Gate\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule \n\n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in; \nendmodule\n\n"}
{"task_id": "review2015_fancytimer", "completion": "\n\treg [1599:0] pattern;\n\treg [3:0] delay;\n\treg [15:0] counter;\n\tparameter PATTERN = 16'h2D0;  // 1101 in binary\n\talways @(posedge clk) begin\n        if (reset == 1'b1) begin\n            pattern <= 0;\n            delay <= 4'd0;\n            counter <= 16'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            pattern <= {data, pattern[1599:1]};  // Shift in the data bit and keep the rest of the pattern\n            if (pattern == PATTERN) begin  \t// If the pattern is found\n                delay <= {counter[3], counter[2], counter[1], counter[0]}; // The last four bits determine the delay\n\t\t\t\tcounting <= 1'b1; \t\t\t\t    // Begin counting\n\t\t\t\tdone <= 1'b0;\t\t\t\t\t    // Reset done signal\n            end else if (counter == 16'd9"}
{"task_id": "review2015_fancytimer", "completion": "\nreg[1599:0] state = 0; // 2^(4+4)=16 possible states\nparameter [3:0] PATTERN_MATCH = 4'b1101, COUNTING = 4'b1000, FINISHED = 4'b0100, IDLE = 4'b0000;\nreg[3:0] delay, count;\nwire pattern_found = (state[7:4] == PATTERN_MATCH);  // check if the last 4 bits are 1101.\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) state <= 0;  \n\telse begin\n\t\t// Shift in new bit and update state\n\t\tstate <= {state[1598:0], data}; \n\t\t\n\t\tcase (state[7:4])\n\t\t\tIDLE : begin // wait for pattern to be found.\n\t\t\t\tif(pattern_found == 1'b1) state <= {PATTERN_MATCH, state[3:0]};\n\t\t\tend"}
{"task_id": "review2015_fancytimer", "completion": "\n\treg [1599:0] pattern_detector;\n\twire [3:0] delay;\n\treg [12:0] countdown; // 4ms per bit * 16 bits = 64ms for 16 bits, which should be enough to handle a delay of 15.\n    reg searching;\n    \n\tassign done = (searching == 1'b0) ? 1'b1 : 1'b0;\n\tassign count = countdown[12:9]; // Extract only the most significant four bits from the counter.\n        \n\talways @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin\n            pattern_detector <= 0;\n            searching <= 1;\n            countdown <= 0;\n            counting <= 0;\n\t\t    done <= 0;\n\t    end else if (searching == 1'b1 && data == 1'b1) begin\n\t\t    // Shift in the new bit into the pattern detector.\n\t        pattern_detector <= {pattern_detector[1598:0], data};\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg prev_s; // To store the state of previous sensor\n  \n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset) begin\n\t\t\tprev_s <= 0; // Asynchronous reset, all outputs are asserted when reset is active\n\t\t\t{fr3, fr2, fr1, dfr} <= 4'b1111;\n\t\tend\n\t\telse if(s[3]) \n\t\t\t {fr3, fr2, fr1, dfr} <= 4'b0000; // If level is above s[3], no flow\n\t\telse if((~prev_s)&s[2]) begin \n\t\t\t{fr3, fr2, fr1, dfr} <= {1'b0, 1'b0, 1'b1, 1'b0}; // If level is between s[3] and s[2], flow rate increases due to Supplemental flow valve (dfr)\n\t\t\tprev_s <= 0; // Update previous sensor state\n\t\tend\n\t\telse if((~prev_s)&s[1]) begin \n\t\t\t"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [3:0] state;\n\tparameter S1 = 4'b0001, S2 = 4'b0010, S3 = 4'b0100, RESET_STATE = 4'b1111;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= RESET_STATE;\n\t\telse \n\t\t\tcase(s) \n\t\t\t\t3: state <= S3;\n\t\t\t\t2: if (state != S1 && state != RESET_STATE) state <= S2; // Don't allow the water to overflow.\n\t\t\t\t1: if (state == S1 || state == RESET_STATE) state <= S1; \n\t\t\t\tdefault: ;\n\t\t\tendcase\n\tend\n\t\n\talways @(*) begin\n\t\tcase(state)\n\t\t\tS3: {fr3, fr2, fr1, dfr} = 4'b0000; // All off.\n\t\t\tS2: {fr3, fr2, fr1, dfr} = 4'b0"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg prev_reset; // To keep track of the previous state of reset\n\n\t// State machine\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1 && prev_reset == 1'b0) begin \n\t\t\t// Asynchronous active-high reset\n\t\t\tfr3 <= 1'b1;\n\t\t\tfr2 <= 1'b1;\n\t\t\tfr1 <= 1'b1;\n\t\t\tdfr <= 1'b1;\n\t\tend else if (reset == 1'b0) begin \n\t\t\t// Normal operation, no reset\n\t\t\tif (s[3] == 1'b1 && s[2] == 1'b1 && s[1] == 1'b1) begin\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b0;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b0;\n\t\t end else if (s[3] == 1'b1 && s[2] == 1'b1) begin \n\t\t\t\tfr3 <= 1'b0;\n\t\t\t"}
{"task_id": "mux256to1v", "completion": "\n\nassign out = in[((sel+1)*4)-1:(sel*4)];\n\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\tassign out = in[(sel*4)+3 : (sel*4)];\nendmodule\n"}
{"task_id": "mux256to1v", "completion": "\n\n\tassign out = in[(sel*4)+3 : (sel*4)];\n\t\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\tassign sum = a ^ b;\n\tassign cout = a & b;\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\t\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\tassign sum = a^b; // XOR gate to calculate sum\n\tassign cout = a&b; // AND gate to calculate carry-out\nendmodule\n\n"}
{"task_id": "circuit9", "completion": "\n\treg [2:0] nextState;\n\n\t// State transitions\n\talways @(*) begin\n\tcase(q)\n\t\t3'b000: if (a) nextState = 3'b101; else nextState = 3'b001;\n\t\t3'b001: if (a) nextState = 3'b010; else nextState = 3'b000;\n\t\t3'b010: if (a) nextState = 3'b100; else nextState = 3'b001;\n\t\t3'b100: if (a) nextState = 3'b101; else nextState = 3'b010;\n\t\t3'b101: if (a) nextState = 3'b000; else nextState = 3'b100;\n\t\tdefault : nextState = 3'b000;  // default state\n   endcase\nend\n   \n\t// Outputs and register updates\n\talways @(posedge clk) begin\n\t\t q <= nextState;\n\tend\n\nend"}
{"task_id": "circuit9", "completion": "\n\treg [2:0] nextQ;\n\t\n\talways @(posedge clk or negedge clk) begin\n\t\t\tif (~clk) begin\n\t\t\t\tcase({a,q}) \n\t\t\t\t\t3'b000 : nextQ <= 3'd1;\n\t\t\t\t\t3'b001 , 3'b010: nextQ <= 3'd2;\n\t\t\t\t\t3'b011 : nextQ <= 3'd4;\n\t\t\t\t\t3'b100, 3'b111: nextQ <= 3'd5;\n\t\t\t\t\tdefault: nextQ <= q + 1;\n\t\t\t\tendcase\n\t\t\tend else begin\n\t\t\t\tcase({a,q}) \n\t\t\t\t\t3'b000 : nextQ <= 3'd7;\n\t\t\t\t\t3'b001 , 3'b010: nextQ <= 3'd2;\n\t\t\t\t\t3'b011 : nextQ <= 3'd4;\n\t\t\t\t\t3'b100, 3'b111: nextQ <= 3'd5;\n\t\t\t\t\tdefault: nextQ <= q"}
{"task_id": "circuit9", "completion": "\n\treg [2:0] state;\n\talways @(posedge clk) begin\n\t\tif(!a) begin\n\t\t\tcase (state)\n\t\t\t\t3'b000 : state <= 3'b001;  // x to y\n\t\t\t\t3'b001 : state <= 3'b010;  // y to z\n\t\t\t\t3'b010 : state <= 3'b011;  // z to w\n\t\t\t\t3'b011 : state <= 3'b000;  // w to x\n\t\t\tendcase\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\t3'b000 : state <= 3'b010;  // x to z\n\t\t\t\t3'b001 : state <= 3'b000;  // y to x\n\t\t\t\t3'b010 : state <= 3'b001;  // z to y\n\t\t\t\t3'b011 : state <= 3'b011;  // w to w\n\t\t\tendcase\n\t\tend\n\tend\n\tassign q = state;\nend"}
{"task_id": "ece241_2013_q7", "completion": "\nalways @(posedge clk) begin\n\tif(!j && !k) \n\t\tQ <= Q;\n\telse if(!j && k) \n\t\tQ <= 0;\n\telse if(j && !k) \n\t\tQ <= 1;\n\telse if(j && k) \n\t\tQ <= ~Q;\nend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (!j && !k) \n\t\t\tQ <= Q;\n\t\telse if (!j && k)\n\t\t\tQ <= 0;\n\t\telse if (j && !k)\n\t\t\tQ <= 1;\n\t\telse if (j && k)\n\t\t\tQ <= ~Q;\n\tend\n\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n\t\t if ((j == 0) && (k == 0)) \n\t\t\t  Q <= Q;\n\t\t else if((j == 0) && (k == 1)) \n\t\t\t  Q <= 0;\n\t\t else if((j == 1) && (k == 0)) \n\t\t\t  Q <= 1;\n\t\t else if ((j == 1) && (k == 1)) \n\t\t\t  Q <= ~Q;\n\tend\nendmodule\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = (~vibrate_mode) & ring;\n\tassign motor =  vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = ~vibrate_mode & ring;\n\tassign motor = vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\n\tassign ringer = ~vibrate_mode & ring;\n\tassign motor = vibrate_mode | ring;\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\n\treg [3:0] counter;\n\treg start_bit, stop_bit;\n\tparameter START = 4'b1000, STOP = 4'b0111;\n  \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcounter <= 4'd0;\n\t\t\tstart_bit <= 1'd0;\n\t\t\tstop_bit <= 1'd0;\n\t\t\tdone <= 1'd0;\n\t\tend\n\t\telse begin\n\t\t\tcase({start_bit, stop_bit}) \n\t\t\t\t2'b00: if(in == START[0]) counter <= counter + 4'd1; // Waiting for start bit\n\t\t\t  \t     else done <= 1'd0;   \n\t\t\t\t2'b01: if (in == STOP [counter-4'd1]) done <= 1'd1;  // Check stop bits\n\t\t\t\t       else counter <= counter + 4'd1; // Counting data bits\n\t\t\t\tdefault: begin done <= 1'd0; start_bit <= ~start_bit & in["}
{"task_id": "fsm_serial", "completion": "\n\treg [3:0] state;\n\tparameter IDLE = 4'b0001, START = 4'b0010, DATA = 4'b0100, STOP_WAIT = 4'b1000; // states\n\n\t// state transition and output logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tcase (state) \n\t\t\t\tIDLE: if (in == 1'b0) state <= START; // wait for start bit\n\t\t\t\t\n\t\t\t\tSTART: if (in == 1'b1) state <= DATA; else state <= IDLE; // check for correct start bit\n\t\t\t\t\t\t\n\t\t\t\tDATA: begin\n\t\t\t\t\t\tif(~&state) \n\t\t\t\t\t\t   state <= {1'b0, state[3:1]}; // shift right to receive next bit\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= STOP_WAIT;\t// wait for stop bit after all data bits are received\n\t\t\t\t\tend\n\t\t\t\tSTOP_WAIT: if (in == 1'b1) begin"}
{"task_id": "fsm_serial", "completion": "\n\t// State definitions \n\tparameter IDLE = 2'b00;\n\tparameter STARTBIT = 2'b01;\n\tparameter DATA = 2'b10;\n\tparameter STOPBIT = 2'b11;\n\n\t// Registers and wire declarations  \n\treg [1:0] state, next_state;  // State registers \n\twire startbit_detected;\n\twire stopbit_detected;\n\n\t// State transition \n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset)\n\t\t\tstate <= IDLE;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic and outputs\n\talways @(*) begin \n\t\tcase (state)\n\t\t\tIDLE: begin \n\t\t\t\tif (in == 0) // start bit detected, go to STARTBIT state  \n\t\t\t\t\tnext_state = STARTBIT;\n\t\t\t\telse // else stay in IDLE state  \n\t\t\t\t\tnext_state = IDLE;\n\n\t\t\t\t// Outputs \n\t\t\t\tdone = 1'b0; \n\t\t\tend\n"}
{"task_id": "timer", "completion": "\n\n    reg[9:0] count;\n    \n    always @ (posedge clk) begin\n        if(load)\n            count <= data;\n        else if(!tc && count>0)\n            count<=count-1'b1; \n\t\t\t\n\tassign tc = !count;\t\t\t// assert when counter is zero.\n    end\nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count;\n\tassign tc = (count == 10'b0);\n\talways @(posedge clk) begin\n\t\tif(load)\n\t\t\tcount <= data;\n\t\telse if(!tc)\n\t\t\tcount <= count - 10'd1;\n\tend\nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count; //10-bit counter\n    reg flag;      //flag to indicate if the timer is running or not.\n    \n    assign tc = (count == 10'b0) ? 1 : 0;\n    \n\t//Synchronous process with load and decrementing the counter\n\talways @(posedge clk) begin\n\t    if (load) begin\n\t        count <= data;   //Loads the value of data into the counter.\n            flag <= 1'b1;    //Starts counting\n        end \n        else if(flag == 1'b1) begin\n\t\t\tcount <= count - 10'b1; //Decrements the counter by one.\n\t        if (count == 10'b0)   //Check whether the counter has reached zero or not\n                flag <= 1'b0;    //If it reaches zero, stop counting\n        end\n\tend\nendmodule\n\n"}
{"task_id": "circuit7", "completion": "\n\treg temp;\n\talways @(posedge clk) begin\n\t\tif(!a & !temp)\n\t\t\tq <= 1'b0;\n\t\telse if(!a & temp)\n\t\t\tq <= 1'b1; \n\t\t\t\n\t\ttemp <= a;\n\tend\nendmodule\n"}
{"task_id": "circuit7", "completion": "\n    always @(posedge clk) begin\n        if(a == 1'b1)\n            q <= ~q;\n    end\nendmodule\n\n"}
{"task_id": "circuit7", "completion": "\n\treg temp; // temporary register to hold the value of 'q'\n\t\n\talways @(posedge clk) begin\n\t    temp <= a;\n        q <= temp;\n    end\nendmodule\n\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = {in[98], in[98:1] & in[99:2]} ;\n\tassign out_any = {in[98:0] | in[99:1]}; \n\tassign out_different = {in[98], in[98:1]^{in[0], in[99:2]}}; \nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = {in[98:0] & in[99]};\n\tassign out_any = {(in[98:1] | {in[0], in[99]}), 1'b0}; // Adding a trailing '0' because we don't have an output bit for the leftmost input bit.\n\tassign out_different = ({in[98:0] ^ {in[0], in[99]}} | in);  \n\nendmodule\n\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = {in[98:0] & in[99]};\n\tassign out_any = {in[98:0] | in[99]};\n\tassign out_different = {in[99:1], ~|(in ^ {{9{in[99]}}, in[99:1]})}; // XOR with a 9-bit pattern filled with input bit 99, then OR all bits together to check if they are equal.\n\t\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\tassign out = {<<{in}};\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\talways @* begin\n\t\tfor(integer i = 0; i <= 49; i = i + 1) begin\n\t\t\tout[i] <= in[99-i];\n\t\t\tout[99-i] <= in[i];\n\tend\n\tend\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\tassign out = {in[99:0]}; //Reversing bit order is done by reversing the index. \nendmodule\n"}
{"task_id": "countslow", "completion": "\n\n\treg [1:0] count;\n\n\t// Synchronous Reset\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0000;\n\t\telse if (slowena == 1) // Check slowena only when it is high to make the counter slower.\n\t\t\tcase(count)\n\t\t\t\t2'd0: begin q <= 4'b0000; count <= count + 1; end \n\t\t\t\t2'd1: begin q <= 4'b0001; count <= count + 1; end \n\t\t\t\t2'd2: begin q <= 4'b0010; count <= count + 1; end \n\t\t\t\t2'd3: begin q <= 4'b0011; count <= count + 1; end \n\t\t\t\t2'd4: begin q <= 4'b0100; count <= count + 1; end \n\t\t\t\t2'd5: begin q <= 4'b0101; count <= count + 1; end \n\t\t\t\t2'd6: begin q <= 4'b011"}
{"task_id": "countslow", "completion": "\n\treg [3:0] count;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin\n\t\t\tcount <= 4'h0;  // Reset to zero\n\t\tend else if (slowena == 1'b1) begin\n\t\t\t// If counter is less than 9 and slowena is high, increment the count. Otherwise keep the current value of count.\n\t\t\tif(count < 4'h9 && slowena == 1'b1)\n\t\t\t\tcount <= count + 1;   // Increment count if it is not at max and slowena is enabled\n\t\t\telse \n\t\t\t\tcount <= 4'h0;   \t// Reset counter to zero when it reaches maximum value.\n\t\tend\n\t\tq = count;\n\tend\nendmodule\n"}
{"task_id": "countslow", "completion": "\n\treg [3:0] temp;\n\n\talways @(posedge clk or posedge reset) begin\n\t\t if (reset) \n\t\t\t {q, temp} <= 4'b0000_0000; // Resets the counter to 0 when reset is active.\n\t\t else if (slowena) begin\n\t\t\t\t q <= q + 1;  \n\t\t\t\t if(temp == 9) \n\t\t\t\t\t  temp <= 0;   \t\n\t\t\t end\n\tend\n\tassign temp = q[3:0]; // Assigns the lower four bits of q to temp. This is used to count from 0-9 instead of 0-15 like the counter normally does.\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~((A[0] ^ B[0]) | (A[1] ^ B[1]));\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~|((A ^ B) & {2{1'b1}}); // 1 when A == B else 0.\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~(A ^ B);\nendmodule\n\n"}
{"task_id": "always_case", "completion": "\n\n\talways @(*) begin\n\t\tcase (sel) \n\t\t\t3'd0 : out = data0;\n\t\t\t3'd1 : out = data1;\n\t\t\t3'd2 : out = data2;\n\t\t\t3'd3 : out = data3;\n\t\t\t3'd4 : out = data4;\n\t\t\t3'd5 : out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase \n\tend\nendmodule\n\n"}
{"task_id": "always_case", "completion": "\n\talways @(*) begin\n\t\tcase (sel) \n\t\t\t3'b000 : out = data0;\n\t\t\t3'b001 : out = data1;\n\t\t\t3'b010 : out = data2;\n\t\t\t3'b011 : out = data3;\n\t\t\t3'b100 : out = data4;\n\t\t\t3'b101 : out = data5;\n\t\t\tdefault: out = 4'h0;\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "always_case", "completion": "\n\n\talways @(*) begin\n\t\tcase (sel) \n\t\t\t3'b000 : out = data0;\n\t\t\t3'b001 : out = data1;\n\t\t\t3'b010 : out = data2;\n\t\t\t3'b011 : out = data3;\n\t\t\t3'b100 : out = data4;\n\t\t\t3'b101 : out = data5;\n\t\t\tdefault: out = 4'h0;  // Default to zero when sel is not between 0 and 5.\n\tend\n\t\n\tendmodule\n"}
{"task_id": "circuit3", "completion": "\n\twire w;\n\tassign w = a & (b | c) & (c | d) & (~d | b);\n\tassign q = ~w;\nendmodule\n\n"}
{"task_id": "circuit3", "completion": "\n    assign q = ((~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (~a & ~b & c & ~d) | (a & ~b & ~c & ~d));\nendmodule\n\n"}
{"task_id": "circuit3", "completion": "\n\treg temp;\n\talways @(*) begin\n\t\tif (a == 0 && b == 0)\n\t\t\ttemp <= c & ~d;\n\t\telse if( a == 1 && b == 0)\n\t\t\ttemp <= ~c & d;\n\t\telse \n\t\t\ttemp <= c | d;\n\tend\n\nassign q = temp;\n\t\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\twire out1, out2;\n\tA a1(.x(x), .y(y), .z(out1));\n\tB b1(.x(x), .y(y), .z(out2));\n\tOR or1(.a(out1), .b(out2), .c(z));\n\t\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\t// Define the modules A and B\n\tmodule A (\n\t\tinput x, \n\t\tinput y, \n\t\toutput reg z1, \n\t\toutput reg z2);\n\t\t\n\talways @(*) begin\n\t\tz1 = (x^y) & x;\n\t\tz2 = ~((x^y) & x); // Inverse of the boolean function\n\tend\n\tendmodule\n\t\n\t\n\tmodule B (\n\t\tinput x, \n\t\tinput y, \n\t\toutput reg z1, \n\t\toutput reg z2);\n\t\t\n\talways @(*) begin\n\t\tz1 = !y & !x; // Simulation waveform at time = 0ns\n\t\tfor (int i=5; i<90; i+=5) $display(\"%dns\\tx: %b\\ty: %b\\tz: %b\", i, x, y, z1);\n\tend\n\tz2 = !y & x; // Simulation waveform at time > 90ns \n\tend\n\tendmodule\n\t\t\n\t// Top-level module"}
{"task_id": "mt2015_q4", "completion": "\n\t// A submodules\n\twire a1, a2;\n\tA u1 (.x(x), .y(y), .z(a1));\n\tA u2 (.x(~x), .y(~y), .z(a2));\n\n\t// B submodules\n\twire b1, b2;\n\tB u3 (.x(x), .y(y), .z(b1));\n\tB u4 (.x(~x), .y(~y), .z(b2));\n\n\t// Output of the top module is a XOR of OR and AND outputs\n\tassign z = ~(a1 | b1) & ~(a2 & b2);\nendmodule\n\n// A submodules implementation\nmodule A (input x, y, output reg z);\n\talways @* begin\n\t\tz <= (x ^ y) & x;\n\tend\nendmodule\n\n// B submodules implementation\nmodule B (input x, y, output reg z);\n\tinitial begin\n\t\t$display(\"time\\tx\\ty\\tz\");\n\t\t$monitor(\"%d\\t%b\\t%b\\t%"}
{"task_id": "alwaysblock2", "completion": "\n\tassign out_assign = a ^ b; // Using an assign statement\n\n\talways @(*) begin // Using combinational always block\n\t\tout_always_comb <= a ^ b; \n\tend\n\n\talways @(posedge clk) begin // Using clocked (flip-flopped) always block\n\t\tout_always_ff <= a ^ b;\n\tend\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\tassign out_assign = a ^ b;\n\t\n\talways @* begin\n\t\tout_always_comb <= a ^ b;\n\tend \n\t\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// assign statement\n\tassign out_assign = a ^ b;\n\t\n\t// combinational always block\n\talways @(*) begin\n\t\tout_always_comb <= a ^ b;\n\tend\n\n\t// clocked always block\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\n\nendmodule\n\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\treg r;\n\n\talways @(posedge clk) begin\n\t\tif (L) \n\t\t\tr <= r_in;\n\t\telse \n\t\t\tr <= ~r;\n\t\t\t\n\t\tif (L) \n\t\t\tQ <= r_in;\n\t\telse if(r == 1'b0)\n\t\t    Q <= ~q_in;\n\t    else \n\t        Q<= q_in;\n\tend\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\tassign Q = (L)?r_in:q_in;\nendmodule\n\n// The full module can be written as follows.\n\nmodule full_module(\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n\twire q1_out,q2_out,q3_out; // Intermediate outputs for the submodules\n\n\ttop_module u1(clk,L,r[0],q[0],q1_out);\n\ttop_module u2(clk,L,r[1],q1_out,q2_out);\n\ttop_module u3(clk,L,r[2],q2_out,q3_out);\n\t\n    assign q = {q3_out,q2_out,q1_out};  // 2-1 Multiplexer to select the final outputs.\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (L) \n\t\t    Q <= r_in;\n\t\telse\n\t\t    Q <= {Q[1] ^ Q[2], Q[0], Q[2]};\n\tend\n\nendmodule\n\n"}
{"task_id": "m2014_q4j", "completion": "\n\n\tassign sum[0] = x[0] ^ y[0];  // First bit is XOR of first bits of inputs\n\tassign sum[1] = (x[0] & y[0]) | (x[1]^y[1]); // For next bit, it's OR of carry out and XOR of second bit from both inputs\n\tassign sum[2] = (x[1] & y[1]) | (x[2] ^ y[2]) | (sum[1] & x[0]);  // Similar to the above line\n\tassign sum[3] = (x[2] & y[2]) | (x[3] ^ y[3]) | (sum[2] & x[1]);  \n\tassign sum[4] = (x[3] & y[3]) | (sum[3] & x[2]);  // Overflow is AND of carry out and last bit in previous stage\n\t\nendmodule\n\n"}
{"task_id": "m2014_q4j", "completion": "\n\n\t// Full Adder\n\tfunction automatic [2:0] fullAdder(input a, b, cin);\n\t\treturn {cin ^ (a ^ b), a & b | cin & (a ^ b)};\n\tendfunction\n\n\twire c1,c2,c3; // Carries from Full Adders\n\t// 4-bit Adder with overflow\n\tassign sum[0] = x[0] ^ y[0];\n\t{c1,sum[1]} = fullAdder(x[1],y[1],sum[0]);\n\t{c2,sum[2]} = fullAdder(x[2],y[2],c1);\n\t{c3,sum[3]} = fullAdder(x[3],y[3],c2);\n\tsum[4] = ~(sum[3]^c3) & (sum[3] | c3); // Overflow bit calculation\nendmodule\n\n"}
{"task_id": "m2014_q4j", "completion": "\n\n\t// Full Adder\n\tfunction automatic [2:0] fa;\n\t\tinput a, b, cin;\n\t\tbegin\n\t\t\tfa = {cin ^ (a ^ b), a & b | cin & (a ^ b)};  // sum, cout\n\t\tend\n\tendfunction\n  \n\t// 4-bit Adder\n\tfunction automatic [4:0] add_4bits;\n\t\tinput [3:0] x, y;\n\t\tbegin\n\t\t\t{sum[4], sum[3:0]} = fa(x[0], y[0], 1'b0) + fa(x[1], y[1], sum[0]) + fa(x[2], y[2], sum[1]) + fa(x[3], y[3], sum[2]);\n\t\tend\n\tendfunction\n  \n\t// Assign the result to output variable\n\tassign sum = add_4bits(x, y); \n\t\nendmodule\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\n\t// Using built-in NOR function\n    assign out = ~(a | b);\n    \nendmodule\n"}
{"task_id": "norgate", "completion": "\n\n\t// NOR gate\n\tassign out = ~(a | b);\n\nendmodule\n\n"}
{"task_id": "fsm3comb", "completion": "\n\n\talways @(*) begin\n\tcase(state)\n\t\t2'b00 : begin \n\t\t\t\t\tif (in == 0) begin\n\t\t\t\t\t\tnext_state <= 2'b00;  // A -> A\n\t\t\t\t\t\tout = 1'b0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= 2'b01;  // A -> B\n\t\t\t\t\t\tout = 1'b0;\n\t\t\t\t\tend\n\t\t\t   end\n\t\t2'b01 : begin \n\t\t\t\t\tif (in == 0) begin\n\t\t\t\t\t\tnext_state <= 2'b01;  // B -> C\n\t\t\t\t\t\tout = 1'b0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= 2'b10;  // B -> B\n\t\t\t\t\t\tout = 1'b0;\n\t\t\t\t\tend\n\t\t\t   end\n\t\t2'b10 : begin \n\t\t\t\t\tif (in == 0) begin\n\t\t\t\t\t\tnext_state <= 2'b00;  // C -> A\n\t\t\t\t\t\tout = 1'b0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= "}
{"task_id": "fsm3comb", "completion": "\nalways @(*) begin\n\tcase(state) \n\t\t2'b00 : begin\n\t\t\t\tif (in==0) begin\n\t\t\t\t\tnext_state = 2'b00; // A to A\n\t\t\t\tend else begin \n\t\t\t\t\tnext_state = 2'b01; // A to B\n\t\t\t\tend\n\t\t\t\tout = 0;\n\t\t\tend \n        2'b01 : begin\n\t\t\t\tif (in==0) begin\n\t\t\t\t\tnext_state = 2'b00; // B to A\n\t\t\t\tend else begin \n\t\t\t\t\tnext_state = 2'b01; // B to B\n\t\t\t\tend\n\t\t\t\tout = 0;\n\t\t\tend\n        2'b10 : begin\n\t\t\t\tif (in==0) begin\n\t\t\t\t\tnext_state = 2'b10; // C to A\n\t\t\t\tend else begin \n\t\t\t\t\tnext_state = 2'b11; // C to D\n\t\t\t\tend\n\t\t\t\tout = 0;\n\t\t\tend\n        2'b11 : begin\n\t\t\t\tif (in==0) begin\n\t\t\t\t\t"}
{"task_id": "fsm3comb", "completion": "\n\n\t// State Transition Logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t2'b00 : next_state = in ? 2'b01 : 2'b00; // A -> B when input is '1' else remain at state A.\n\t\t\t2'b01 : next_state = in ? 2'b10 : 2'b01; // B -> C when input is '1', else stay at B.\n\t\t\t2'b10 : next_state = in ? 2'b00 : 2'b10; // C -> A when input is '1', else remain at state C.\n\t\t\t2'b11 : next_state = in ? 2'b11 : 2'b10; // D -> B when input is '1', else go to state C.\n\t\tendcase\n\tend\n\t// Output Logic\n\tassign out = (next_state == 2'b10) | (next_state == 2'b11); \n\t\nendmodule\n\n"}
{"task_id": "fsm_serialdata", "completion": "\n\treg [23:0] shift_reg; // 8 bits of data + 1 start bit + 1 stop bit.\n\treg [4:0] state = 5'b11111; // idle state\n\twire start = (state==5'b10000);\n\tassign out_byte = shift_reg[7:0];\n\tassign done = start;\n\n\t// FSM\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin\n\t\t\tstate <= 5'b11111; // idle state\n\t\t\tshift_reg <= 24'd0;\n\t\tend else begin\n\t\t\tcase (state) \n\t\t\t\t5'b10000: if(~in) state <= 5'b00001; // wait for start bit\n\t\t\t\t5'b00001: begin shift_reg[23:16] <= in; state <= 5'b01001; end // receive data bits 7-0\n\t\t\t\t5'b01001: begin shift_reg"}
{"task_id": "fsm_serialdata", "completion": "\n\n\t// State encoding 0 -> 3 for states waiting for start bit and 4-12 for data reception. \n\treg [3:0] state = 4'b0; \n\treg [7:0] out_byte_internal = 8'b0; // Internal output byte to store received bits. \n\twire shift = (state > 4); // Determine whether a bit is being shifted in or not. \n\n\talways @(posedge clk) begin\n\t\tif (reset == 1) begin\n\t\t\tstate <= 4'b0;\n\t\t\tout_byte_internal <= 8'b0;\n\t\t\tdone <= 1'b0;\n\t\tend\n\t\telse if (shift) begin // Shift in new bits when we are not waiting for start bit. \n\t\t\tout_byte_internal <= {in, out_byte_internal[7:1]};\n\t\t\t\tif (state == 8'hD) state <= 4'b0; // If all data has been received. \n\t\t\t\telse state <= state + 2'b10; // Continue to receive more bits if not yet done so.  "}
{"task_id": "fsm_serialdata", "completion": "\n\treg [24:0] shift; // 9 bit to capture start and stop bits as well as data\n\treg [3:0] count = 0;\n\twire started = shift[8];\n\twire stopped = shift[0];\n\tassign out_byte = {shift[7], shift[6], shift[5], shift[4], shift[3], shift[2], shift[1], shift[0]};\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            done <= 0;\n\t\t\tcount <= 0;\n\t\t\tshift <= 0;\n        end\n        else begin \n            shift <= {in, shift[23:1]}; // Shift in the new bit and discard the old one\n            \n            if (started && count < 8) begin // If start bit detected and we're not at full byte yet\n\t\t\t\tcount <= count + 4'h1; \n\t\t\tend  \n\t\t\telse if (!stopped && started && count == 8) begin // If stop bit is detected after 8 bits of data, done = 1\n                done"}
{"task_id": "vector3", "completion": "\n\tassign {w[2:0],x[7:5],y[7:6],z[7:7]} = 3'b111;  // Two 1 bits in LSB positions.\n\tassign w = {a, b};                                // Concatenate a and b into first 8 bit output vector w.\n\tassign x = {c, d};                                // Concatenate c and d into second 8 bit output vector x.\n\tassign y = {e, f};                                // Concatenate e and f into third 8 bit output vector y.\n\tassign z = 5'b10000;                              // Last 5 bits of z are set to '1'. The other bit is left unset as per the problem statement.\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\t//concatenate all the inputs together\n\twire [29:0] concat_in = {a, b, c, d, e, f};\n\n\t//split the concatenated input into 32 bit outputs\n\tassign w = concat_in[7:0];\n\tassign x = concat_in[15:8];\n\tassign y = concat_in[23:16];\n\tassign z = {concat_in[29:24], 2'b00}; //the two 1 bits go to the LSB positions\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:2], w[1], w[0]} = {e, d, c}; // concatenate e, d and c then split into two 3 bit sections and a 1-bit.\n    assign x = 8'b0; // fill with zeros as there is no input for this output.\n\tassign y = {f, b, a}; //concatenate f, b and a and send to y.\n\tassign {z[7:6], z[5:0]} = {2'b11, e, d, c, b, a};// concatenate e, d, c, b, a then split into two 3 bit sections and 2-bit section with 1s.\nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\talways_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            predict_history <= 32'b0;\n         else if(predict_valid)\n             predict_history <= {predict_taken, predict_history[31:1]};\n\tend\n    \n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            predict_history <= 32'b0;\n         else if(train_mispredicted)\n             predict_history <= {train_taken, train_history};\n\tend\n    \nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\t\n\t// Reset register on asynchronous reset signal\n\talways @(posedge areset) begin\n\t\tpredict_history <= 32'b0;\n\tend\n\n\t// Update predict history on clock edge and when valid prediction is made\n\talways @(posedge clk) begin\n\t\tif (predict_valid) begin\n\t\t\tpredict_history <= {predict_taken, predict_history[31:1]};\n\t\tend \n\tend\n\n\t// Update predict history on clock edge and when training a misprediction occurs\n\talways @(posedge clk) begin\n\t\tif (train_mispredicted) begin\n\t\t\tpredict_history <= {train_taken, train_history[30:0]};  // Ignore oldest bit in train_history\n\t\tend \n\tend\n\nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n            predict_history <= 32'b0;\n        else if (predict_valid) \n            predict_history <= {predict_taken, predict_history[31:1]}; // Shift right by one bit.\n    end\n    \n\talways @(posedge clk or posedge areset) begin\n       if (areset)\n           predict_history <= 32'b0;\n        else if (train_mispredicted) \n            predict_history <= {train_taken, train_history}; // Load with new history.\n    end\t\nendmodule\n\n"}
{"task_id": "bugs_addsubz", "completion": "\n    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        default : out = 8'bz; // Default value for undefined inputs.\n        endcase\n\t\t  \n\t\t// The zero flag should only be set if the output is all zeros (i.e., it was subtracted to negative). \n\t\tif(do_sub) begin\n         result_is_zero = (out == 8'b0); // Check if the out value is equal to 8'b0 which means that the result is zero\n        end else begin\n         result_is_zero = 1'bz;  // Zero flag should not be set in addition mode.\n        end\t\n    end\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\nThe problem is that in Verilog, the ~ operator performs logical negation on a bit-by-bit basis. So, if you want to check whether the result of your addition or subtraction is zero, you should use out == 8'b0 instead of ~out. The correct code would look like this:\n\n\talways @(*) begin\n    \tcase (do_sub)\n        \t1'b0: out = a + b;\n         \t1'b1: out = a - b;\n     \tendcase\n      \tif(out == 8'b0) \n          \tresult_is_zero = 1'b1;\n      \telse\n          \tresult_is_zero = 1'b0;\n    end\n    \nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n    always @(*) begin\n        case (do_sub)\n          0: \n\t    begin\n             out = a+b;\n\t     if(out==8'd0) // checking for zero\n\t\t result_is_zero = 1'b1;\n\t     else\n\t\t result_is_zero = 1'b0;  \n\t    end\n          1: \n\t    begin\n             out = a-b;\n\t     if(out==8'd0) // checking for zero\n\t\t result_is_zero = 1'b1;\n\t     else\n\t\t result_is_zero = 1'b0;  \n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = ((~x3)&(~x2)&(~x1)) | ((~x3)&(~x2)&x1) | ((~x3)&x2&(~x1)) | (x3&(~x2)&x1); \nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = ((~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & ~x2 & ~x1));\nendmodule \n\n"}
{"task_id": "truthtable1", "completion": "\n\n\t// Using the truth table, we can create an assign statement that implements this logic.\n\tassign f = ((x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (x3 & x2 & ~x1) | (x3 & x2 & x1)) \n\t\t\t   & ((~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1));\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n\n\talways @(a or b or c or d or e) begin\n\t\tif (a == 4'b1010) \n\t\t\tq <= 4'b0101; // a\n\t\telse if (b == 4'b1010)\n\t\t\tq <= 4'b0101; // b\n\t\telse if (c == 4'b1010)\n\t\t\tq <= 4'b0101; // c\n\t\telse if (d == 4'b1010)\n\t\t\tq <= 4'b0101; // d\n\t\telse if (e == 4'b1010) \n\t\t\tq <= 4'b0101; // e\n\tend\n\t\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n\treg [3:0] temp;\n\talways @(*) begin\n\t\tcase ({a,b,c,d,e}) \n\t\t\t5'b10000 : temp = 4'b0001; // a=1, b=0, c=0, d=0, e=0 -> q = b\n\t\t\t5'b01000 : temp = 4'b0010; // a=0, b=1, c=0, d=0, e=0 -> q = c\n\t\t\t5'b00100 : temp = 4'b0100; // a=0, b=0, c=1, d=0, e=0 -> q = d\n\t\t\t5'b00010 : temp = 4'b1000; // a=0, b=0, c=0, d=1, e=0 -> q = e\n\t\t\t5'b00001 : temp = 4'b0000; // a=0, b=0, c=0, d=0, e"}
{"task_id": "circuit5", "completion": "\n\treg [3:0] temp;\n\talways @(*) begin\n\t\tcase ({a[2:1], b[2:1], c[2:1], d[2:1], e[2:1]}) \n\t\t\t5'b00_000 : temp = a[3:0];\n\t\t\t5'b00_001 : temp = {a[0], b[3:1]};\n\t\t\t5'b00_010 : temp = {b[0], c[3:1]};\n\t\t\t5'b00_011 : temp = {c[0], d[3:1]};\n\t\t\t5'b00_100 : temp = {d[0], e[3:1]};\n\t\t\t5'b00_101 : temp = {e[0], a[3:1]};\n\t\t\t5'b00_110 : temp = b[3:0];\n\t\t\t5'b00_111 : temp = {b[0], c[3:0]};\n\t\t\tdefault : temp"}
{"task_id": "m2014_q3", "completion": "\n\n\tf = ~x[2]&~x[3];\n\nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\n\tf = (x[2] & ~x[3]) | (~x[1] & ~x[2] & x[3]);\n\t\nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\n\tassign f = (~x[2] & ~x[3]) | (x[2] & x[1]);\n\t\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n\tassign #5 in2a = in2; // introduces delay of 5ns for input in2 to simulate bubble effect\n\tand gate(out, in1, in2a);\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\n\n\t// Implementing the circuit with a bubble on in2. \n\tassign out = in1 & ~in2;\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n\n\t// Bubble on in2 input by using a wire and assigning the same value as in2 to it.\n\twire bubble; \n\tassign bubble = in2; \n\t\n\tand (out, in1, bubble); // Connect AND gate output 'out' to inputs 'in1' and 'bubble'.\nendmodule\n\n"}
{"task_id": "gshare", "completion": "\n\treg [1:0] PHT [0:127]; // Pattern History Table\n\treg [6:0] ghr; // Global Branch History Register\n\treg [6:0] predict_history_reg; \n\n\t// Hash function to get the index into the PHT\n\tfunction [6:0] hash;\n\t\tinput [12:0] inp;\n\t\thash = inp ^ ghr;\n\tendfunction\n\n\t// Predict branch taken or not based on the prediction history and the current state of the PHT\n\tassign predict_taken = PHT[hash(predict_pc)] >= 2 ? 1'b1 : 1'b0;\n\tassign predict_history = predict_history_reg;\n\n\t// Training logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin // Asynchronous reset\n\t\t\tfor (integer i = 0; i < 128; i++) \n\t\t\t\tPHT[i] <= 2'b00;\n\t\t\tghr <= 7'h00;\n\t\tend\n\t\telse"}
{"task_id": "gshare", "completion": "\n\treg [1:0] PHT [0:127]; // Pattern History Table.\n\treg [6:0] global_history; \n\n\t// Hash function to convert pc and history into index.\n\tfunction [6:0] hash;\n\t\tinput [6:0] pc, history;\n\t\tbegin\n\t\t\thash = (pc ^ history); // xor is used for hashing\n\t\tend\n\tendfunction \n\n\t// Predict stage\n\talways @(*) begin\n\t\t[predict_taken, predict_history] = PHT[ hash(predict_pc, global_history) ];\n\t\tpredict_valid = 1'b0; // This is a dummy value. The actual implementation should replace it with a signal that connects to the pipeline controller.\n\tend\n\n\t// Train stage\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin \n\t\t\tglobal_history <= 7'b0; // Resets global branch history register on reset.\n\t\tend else if (train_valid == 1'b1) begin\n\t\t\t// Updates the pattern"}
{"task_id": "gshare", "completion": "\n\t// Define the pattern history table (PHT) as an array of two-bit counters.\n\treg [1:0] PHT[0:127];\n\t// The global branch history register is a 7-bit register that tracks the state across multiple branches.\n\treg [6:0] gbr;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tfor (integer i = 0; i < 128; i++) \n\t\t\t\tPHT[i] <= 2'b11; // Reset all PHT entries to weakly taken.\n\t\t\tgbr <= 7'h00; // Clear the global branch history register.\n\t\tend else begin\n\t\t\tif (predict_valid) begin\n\t\t\t\t// Output the prediction based on the current state of the PHT entry for the PC.\n\t\t\t\tpredict_taken <= PHT[{gbr, predict_pc}];\n\t\t\t\tpredict_history <= gbr; // Output the global branch history register state to use as part of the prediction.\n\t\t\tend else if (train_valid) begin\n\t\t\t\t//"}
{"task_id": "vector5", "completion": "\n\tassign out = ~a ^ {b,c,d,e}; // This is just an example, the correct solution would be a bit more complex as it needs 25 different expressions for each of the possible pairs.\nendmodule\n\n"}
{"task_id": "vector5", "completion": "\n\tassign out[24] = ~a ^ a;\n\tassign out[23] = ~a ^ b;\n\tassign out[22] = ~a ^ c;\n\tassign out[21] = ~a ^ d;\n\tassign out[20] = ~a ^ e;\n\tassign out[19] = ~b ^ a;\n\tassign out[18] = ~b ^ b;\n\tassign out[17] = ~b ^ c;\n\tassign out[16] = ~b ^ d;\n\tassign out[15] = ~b ^ e;\n\tassign out[14] = ~c ^ a;\n\tassign out[13] = ~c ^ b;\n\tassign out[12] = ~c ^ c;\n\tassign out[11] = ~c ^ d;\n\tassign out[10] = ~c ^ e;\n\tassign out[ 9] = ~d ^ a;\n\tassign out[ 8] = ~d ^ b;\n\tassign out[ 7] = ~d ^ c;\n\tassign out"}
{"task_id": "vector5", "completion": "\n\n\tassign out[24] = ~a ^ a;  // always equal to zero.\n\tassign out[23] = ~a ^ b;\n\tassign out[22] = ~a ^ c;\n\tassign out[21] = ~a ^ d;\n\tassign out[20] = ~a ^ e;\n\tassign out[19] = ~b ^ a;   // only one of these can be true at any given time.\n\tassign out[18] = ~b ^ b;   // always equal to zero.\n\tassign out[17] = ~b ^ c;\n\tassign out[16] = ~b ^ d;\n\tassign out[15] = ~b ^ e;\n\tassign out[14] = ~c ^ a;\n\tassign out[13] = ~c ^ b;\n\tassign out[12] = ~c ^ c;   // always equal to zero.\n\tassign out[11] = ~c ^ d;\n\tassign out[10] = ~c ^ e;\n\tassign out[ 9] = ~"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x^y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;  // Boolean expression for the function z = (x^y) & x.\nendmodule\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;  // Implement the boolean function z = (x^y) & x.\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\n\treg [7:0] resetVal;\n\t\n\t// Initialize the reset value.\n\tinitial \n\t\tresetVal = 8'h34;\n\t\t\n\talways @(negedge clk) begin\n\t\tif (reset)\n\t\t\tq <= resetVal;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n\treg [7:0] rst = 8'h34; // Reset value\n\n\talways @(negedge clk) begin \n\t\t\tif (reset)\n\t\t\t\tq <= rst;\n\t\t\telse\n\t\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n\treg [7:0] preset;\n   assign preset = 8'h34;\n   \n\talways @(negedge clk) begin\n\t\tif (reset) \n\t\t\tq <= preset;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\n\t// Using the built-in ~ operator to implement a NOT gate. \n\tassign out = ~in;\nendmodule\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\n\t\nendmodule \n"}
{"task_id": "wire4", "completion": "\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n"}
{"task_id": "wire4", "completion": "\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n    assign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n\n"}
{"task_id": "circuit6", "completion": "\n\t// The combinational circuit is based on a simple state machine.\n\t// When the input changes, we move to a new state depending on the current and next value of 'a'.\n\t// We then output the corresponding value from our lookup table.\n\talways @(*) begin\n\t\tcase ({a[1:0], a[2]})\n\t\t\t3'b00X: q <= 16'h1234;   // X is any state, so we can ignore it for now\n\t\t\t3'b01X: q <= 16'haaaa;   \n\t\t\t3'b10X: q <= 16'h5555;   \n\t\t\tdefault: q <= 16'hcccc;  // Default state, should not happen unless 'a' is out of range\n\tendcase\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\talways @(*) begin\n\tcase(a) \n\t\t3'b000 : q = 16'h1232;\n\t\t3'b001 : q = 16'haee0;\n\t\t3'b010 : q = 16'h27d4;\n\t\t3'b011 : q = 16'h5a0e;\n\t\t3'b100 : q = 16'h2066;\n\t\t3'b101 : q = 16'h64ce;\n\t\t3'b110 : q = 16'hc526;\n\t\t3'b111 : q = 16'h2f19;\n\t\tdefault: q = 16'bx; \n\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\treg [7:0] temp; // Temporary variable to hold the result of combinational logic\n\n\t// Implement combinational circuit using switch-case statement.\n\talways @(*) begin \n\t    case (a)\n\t\t    3'b000: temp <= 8'h2f; // a=0, q[15:8]=2F\n                3'b001: temp <= 8'hae; // a=1, q[15:8]=AE\n                3'b010: temp <= 8'h7d; // a=2, q[15:8]=7D\n                3'b011: temp <= 8'he4; // a=3, q[15:8]=E4\n\t\t    3'b100: temp <= 8'hd6; // a=4, q[15:8]=D6\n\t        \tdefault: temp <= 8'h2f; // Default case (a=7 or any other value), q[15:8]=2F\n\t    endcase\n        end \n    \t// Ass"}
{"task_id": "lemmings4", "completion": "\n\n\t// State encoding 01 -> walk right, 10 -> walk left, 11 -> fall/dig\n    reg [1:0] state;\n    \n    // Temporary variable to store the direction of walking when falling or digging starts.\n\treg temp_dir;\n\t\n\t// Counter for counting how many cycles have been spent on falling or digging\n    reg [5:0] counter; \n\t\n\talways @(posedge clk) begin\n        if (areset == 1'b1)\n            state <= 2'h1; // reset to walk right\n\t\t\telse\n\t\t\t\tcase (state)\n\t\t\t\t\t2'h0 : begin // falling or digging state\n\t\t\t\t\t\tif (counter >= 6'd20) \n\t\t\t\t\t\t\tstate <= 2'h3; // if counter reaches 20, splatter and go to idle state\n                        else \n                            counter <= counter + 1'b1; // increment the counter\n\t\t\t\t\tend\n\t\t\t\t\t2'h1 : begin // walk right state\n                        if (ground == 1 && bump_left == 1) begin\n\t\t\t\t\t\t\t// change direction to left when"}
{"task_id": "lemmings4", "completion": "\n\treg walk_left_r;\n\treg walk_right_r;\n\treg aaah_r;\n\treg digging_r;\n\treg falling_cnt_en;\n\treg [5:0] falling_cnt;\n\tparameter FALLING_MAX = 6'd20; // 32 cycles at 1Hz clock, i.e., for 20 clock cycles of falling before ground is back up\n\n\t// state machine\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\twalk_left_r <= 1'b1; // start with left walk by default\n\t\t\tfalling_cnt <= '0; \n\t\tend else begin\n\t\t\t// state transition\n\t\t\tif(dig && ground) begin // can dig only when on the ground\n\t\t\t\tdigging_r <= ~walk_left_r; // continue in opposite direction of walk\n\t\t\tend else if (falling_cnt == FALLING_MAX || bump_right && ~bump_left) begin \n\t\t\t\t// falling for too long or bumped"}
{"task_id": "lemmings4", "completion": "\n\treg falling; // Flag to check if Lemming is in fall state\n\twire [1:0] current_state; // Current State of the FSM\n\twire [1:0] next_state; // Next State for the FSM\n\t// States definition\n\tlocalparam WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01, FALLING = 2'b10, DIGGING = 2'b11;\n\t\n\talways @(posedge clk or posedge areset) begin // Asynchronous reset\n\t\tif (areset == 1'b1) \n\t\t\tcurrent_state <= WALK_LEFT;\n\t\telse \n\t\t\tcurrent_state <= next_state;\n\tend\n\t\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tWALK_LEFT: if ((bump_left == 1'b1) && (ground == 1'b1)) \n\t\t\t\t\t\t\t\tnext_state <= WALK_RIGHT; // If bumped on left and is grounded,"}
{"task_id": "review2015_fsm", "completion": "\n\treg [3:0] state;\n\tparameter IDLE = 4'b0001, SHIFT = 4'b0010, WAIT = 4'b0100, DONE = 4'b1000;\n\twire match = (state[3:2] == 2'b11); // check if last two bits of state are 11\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tcase (state)\n\t\t\t\tIDLE: shift_ena <= 0; counting <= 0; done <= 0; if(match) state <= SHIFT;\n\t\t\t\tSHIFT: if(!match && data) begin state <= WAIT; shift_ena <= 1; end\n\t\t\t\tWAIT: if (done_counting) begin state <= DONE; counting <= 0; end else if (!match && data) state <= IDLE;\n\t\t\t\tDONE: done <= 1; if(ack) state <= IDLE;\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "    \n\treg [3:0] state;\n\tparameter IDLE = 4'b0001, SHIFT = 4'b0010, COUNTING = 4'b0100, DONE = 4'b1000; \n\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset)\n        \tstate <= IDLE;\n    \telse\n        \tcase (state) \n            \tIDLE: if (data) \n                \t\tstate <= SHIFT;\n            \tSHIFT: if (!data)\n                    \tstate <= COUNTING;\n               \tCOUNTING: if (done_counting)\n                        \tstate <= DONE;\n            \tDONE: if (ack)\n                    \tstate <= IDLE;\n        \tendcase \n\tend\n\n    assign shift_ena = (state == SHIFT);\n    assign counting = (state == COUNTING);\n    assign done = (state == DONE);\n    \nendmodule \n\n"}
{"task_id": "review2015_fsm", "completion": "\n    \n    parameter PATTERN = 4'b1101;  // The pattern to start the timer.\n    reg [3:0] shift_reg;  // The current sequence being detected.\n    reg waiting, notified;  // States of the state machine.\n\t\n\t// State machine\n\talways @(posedge clk or posedge reset) begin\n        if (reset) begin\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n            shift_reg <= 4'b0;\n            waiting <= 0;\n            notified <= 0;\n        end else begin\n            case({notified,waiting,done_counting}) \n                3'b000: if (shift_reg == PATTERN) begin\n                            shift_ena <= 1;  // Enable the counter.\n                            waiting <= 1;  // Wait for the counter to finish counting.\n                        end else if (data)\n                            shift_reg <= {shift_reg[2:0], data};  // Shift in a new bit.\n                3'b010: begin  \n                            shift_ena <= "}
{"task_id": "always_casez", "completion": "\n\n\talways @* begin\n\t\tfor(pos = 7; pos >= 0 && !in[pos]; pos = pos - 1);\n\tend\n\t\nendmodule\n\n"}
{"task_id": "always_casez", "completion": "\n\talways @* begin\n\t\tif(in[0]) \n\t\t\tpos = 3'd0;\n\t\telse if(in[1])\n\t\t\tpos = 3'd1;\n\t\telse if(in[2])\n\t\t\tpos = 3'd2;\n\t\telse if(in[3])\n\t\t\tpos = 3'd3;\n\t\telse if(in[4]) \n\t\t\tpos = 3'd4;\n\t\telse if(in[5])\n\t\t\tpos = 3'd5;\n\t\telse if(in[6])\n\t\t\tpos = 3'd6;\n\t\telse if(in[7])\n\t\t\tpos = 3'd7;\n\t\telse \n\t\t\tpos = 3'd0;\n\tend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\talways @* begin\n\t\tfor(pos = 0; pos < 8; pos = pos + 1)\n\t\t\tif(in[pos]) break;\n\tend\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using assign statement\n\tassign out_assign = a & b;\n\n\t// Using combinational always block\n\talways @(*) begin\n\t\tif (a == 1 && b == 1) \n\t\t\tout_alwaysblock = 1;\n\t\telse \n\t\t\tout_alwaysblock = 0;\n\tend\nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using an assign statement to build the AND gate\n\tassign out_assign = a & b;\n\t\n\t// Using combinational always block to build the AND gate\n\talways @(*) begin\n\t   if (a == 1 && b == 1) \n\t   \tout_alwaysblock = 1;\n\t   else \n\t   \tout_alwaysblock = 0;\n    end\nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b;\n\t\n\talways @(*) begin\n\t\tout_alwaysblock <= a & b;\n\tend\nendmodule \n\n"}
{"task_id": "fsm2", "completion": "\n\treg state;\n  \n\talways @(posedge clk or posedge areset) begin \n\t\tif (areset)\n\t\t    state <= 1'b0; // OFF\n        else \n            case ({j, k}) \n                2'b00: state <= state; // ON if k = 0 and j = 0\n                2'b01: state <= ~state; // Toggle on j = 1 \n                2'b10: state <= state; // Stay ON while k = 0\n                2'b11: state <= ~state; // Toggle on k = 1 & j = 1\n            endcase  \n\tend\n       assign out = state;\nendmodule\n"}
{"task_id": "fsm2", "completion": "\nreg state;\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tstate <= 1'b0; // OFF\n\telse\n\t\tcase({j, k})\n\t\t\t2'b00: state <= state; // ON\n\t\t\t2'b01: state <= ~state; // Toggle\n\t\t\t2'b10: state <= state; // ON\n\t\t\t2'b11: state <= ~state; // OFF\n\t\tendcase\nend\nassign out = state;\n\n"}
{"task_id": "fsm2", "completion": "\n\treg state; // State register \n\n\t// Synchronous reset with asynchronous set\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset)\n\t        state <= 0;\n\t    else\n    \t\tcase({j, k}) \n            \t2'b00: state <= state; // OFF --> OFF\n                2'b10: state <= state; // ON --> ON\n\t\t        2'b01: state <= ~state; // OFF --> ON\n                2'b11: state <= ~state; // ON --> OFF\n    \t    endcase \n\tend\n\t// Output assignment \n\tassign out = state;\n\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n\treg [15:0] neighbourCount[15:0]; // array for counting neighbours\n\n\t// calculate the number of alive neighbours for each cell\n\tfor (genvar i = 0; i < 16; ++i) begin : neighbour_counter\n\t  for (genvar j = 0; j < 16; ++j) begin : neighbour_counter2\n\t\talways @(*) begin\n\t\t  neighbourCount[i][j] = q[(i-1)&15][(j+14)&15] + // top right\n\t\t\t  q[i&15][(j+1)&15] + // middle right\n\t\t\t  q[(i+1)&15][(j+1)&15] + // bottom right\n\t\t\t  q[(i-1)&15][j&15] + // top middle\n\t\t\t  q[(i+1)&15][j&15] + // bottom middle\n\t\t\t  q[(i-1)&15][(j-1)&15] + // top left\n\t\t\t  q[i&15][(j-1)&15] + // middle"}
{"task_id": "conwaylife", "completion": "\n\treg [7:0] neighbour_count; \n\twire [15:0] row_masked[15:0];\n\n\tfunction [3:0] count_neighbours(input [255:0] data, input [15:0] mask);\n\t    reg [7:0] i;\n\t    begin\n\t\tfor (i = 0; i < 16; i = i + 1) begin\n\t\t    if ((mask[i] == 1'b1 && data[((i-1)*16+15 +: 16)] == 1'b1) || (mask[i] == 1'b0 && data[(i*16 +: 16)] != 0))\n\t\t\tcount_neighbours = count_neighbours + 1;\n\t\t    if ((mask[i] == 1'b1 && data[(i+1)*16 -: 16] == 1'b1) || (mask[i] == 1'b0 && data[(i*16 +: 16)] != 0))\n\t\t\tcount_neighbours = count_"}
{"task_id": "conwaylife", "completion": "\n\treg [7:0] neighbourCount;\n\tint i, j;\n\talways @(posedge clk) begin\n\t\tif (load == 1'b1) \n\t\t\tq <= data;\n\t\t\t\n\t\telse begin\n\t\t\tfor (i=0; i<16; i++) begin\n\t\t\t\tfor (j=0; j<16; j++) begin\n\t\t\t\t\tneighbourCount <= q[(i>0?(i-1):15)*16+((j>0)?(j-1):15)] + // Top left\n\t\t\t\t\t\t\t\t\t  q[i*16+((j>0)?(j-1):15)] + // Left\n\t\t\t\t\t\t\t\t\t  q[(i<15?(i+1):0)*16+((j>0)?(j-1):15)] + // Bottom left\n\t\t\t\t\t\t\t\t\t  q[(i>0?(i-1):15)*16+j] + // Top\n\t\t\t\t\t\t\t\t\t  q[(i<15?(i+1):0)*16+j] + // Bottom\n\t\t\t\t\t\t\t\t\t  q[(i>0"}
{"task_id": "m2014_q4g", "completion": "\n\nassign #5 out = in2 ~^ in3; //XNOR gate is implemented with the tilde caret operator. XOR gate is implemented using the caret operator.\nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n\tassign out = ^(in1 ~^ in2) ^ in3;  // XNOR and XOR gates implemented using Verilog's bitwise operators\nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n\n\tassign out = (in1 ~^ in2) ^ in3; \nendmodule\n\n"}
{"task_id": "mt2015_q4b", "completion": "\n\treg a, b;\n\tassign z = (a == b) ? a : ~b;\n\talways @* begin  // combinational logic\n\t\tcase({y,x})\n\t\t\t2'b00: {a, b} = 2'b10;\n\t\t\t2'b01: {a, b} = 2'b01;\n\t\t\t2'b10: {a, b} = 2'b11;\n\t\t\tdefault:  // 2'b11\n\t\t\t\t{a, b} = 2'b00;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\twire a = (~x & ~y) | (x & y);\n\tassign z = ~a;\nendmodule\n\n"}
{"task_id": "mt2015_q4b", "completion": "\n\n\treg [2:0] state;\n\n\talways @(*) begin\n\tcase ({y,x}) \n\t\t2'b00: state <= 3'b100;\n\t\t2'b01: state <= 3'b001;\n\t\t2'b10: state <= 3'b011;\n\t\tdefault : state <= {state[2], ~state[2] & state[1], state[2]}; // 3'b010\n\tendcase\n\tend\n\n\tassign z = state[0];\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\n\treg [2:0] state; // State register \n\twire a = !w;     // Not w\n\twire b = ~state[2];   // Inverse of last bit of state (b)\n\t\n\t// Next state logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) \n\t\t    state <= 3'd0; // Reset state to 'A'\n\t\telse\n\t\t    case(state) \n\t\t\t    3'b000: if (a) state <= 3'b001; else state <= state;\n\t\t\t    3'b001: if (!w) state <= 3'b010; else state <= state;\n\t\t\t    3'b010: if (!w) state <= 3'd5; else state <= state;\n\t\t\t    3'b011: if (w)  state <= 3'b010; else state <= state;\n\t\t\t    3'b100: if (a) state <= 3'b101; else state <= state;\n\t\t\t    default: if(w) state"}
{"task_id": "m2014_q6", "completion": "\n\treg [2:0] state;\n\tassign z = state[2]; // Outputs the third bit of state.\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 3'b000; // Reset state to A.\n\t\telse\n\t\t\tcase ({w, state[2]}) // Input w and the third bit of state.\n\t\t\t\t2'b00: state <= 3'b001; // A ->  B\n\t\t\t\t2'b01: state <= 3'b000; // A ->  A\n\t\t\t\t2'b10: state <= 3'b110; // B ->  C\n\t\t\t\t2'b11: state <= 3'b011; // B ->  D\n\t\t\tendcase \n\tend\nendmodule\n\n"}
{"task_id": "m2014_q6", "completion": "\nreg [3:0] state;\nassign z = state[2]; // Assuming the output 'z' is tied to bit 2 of state.\nalways @ (posedge clk or posedge reset) begin\n\tif(reset)\n\t\tstate <= 4'd0;\t// Reset state to A\n\telse case({w,state[2]})\n\t\t2'b00: state <= 4'd1;  // from A to B\n\t\t2'b01: state <= 4'd0;  // from A to A\n\t\t2'b10: state <= 4'd3;  // from B to C\n\t\t2'b11: state <= 4'd4;  // from B to D\n\tendcase\nend\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((a && !b) || (!c && d));\nendmodule\n"}
{"task_id": "kmap2", "completion": "\nassign out = ((a && !b) || (!c && d));\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((~a)&b) | (c&d) | a;\nendmodule\n\n"}
{"task_id": "always_case2", "completion": "\n\talways @(*) begin\n\t\tif      (in[3]) pos = 2'd3;\n\t\telse if (in[2]) pos = 2'd2;\n\t\telse if (in[1]) pos = 2'd1;\n\t\telse if (in[0]) pos = 2'd0;\n\t\telse            pos = 2'b00;\n\tend\n\nendmodule\n\n"}
{"task_id": "always_case2", "completion": "\n\talways @* begin\n\t\tif(in[3]) \n\t\t\tpos = 2'd3;\n\t\telse if(in[2]) \n\t\t\tpos = 2'd2;\n\t\telse if (in[1]) \n\t\t\tpos = 2'd1;\n\t\telse if (in[0]) \n\t\t\tpos = 2'd0;\n\t\telse pos = 2'b0; // none of the bits are high.\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\talways @* begin\n\tif(in[3]) \n\t    pos = 2'd3;\n\telse if(in[2])\n            pos = 2'd2;\n\telse if(in[1])\n            pos = 2'd1;\n\telse if(in[0])\n            pos = 2'd0;\n        else \n            pos = 2'd0; // If all are zero, output should be '0'.\n\tend\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\n\twire q1,q2,q3; // intermediate outputs for flip flops\n\n\t// D Flip-Flop Instances\n\tDFF dff1 (.clk(clk), .d(x), .q(q1));\n\tDFF dff2 (.clk(clk), .d(~x), .q(q2));\n\tDFF dff3 (.clk(clk), .d(~q1 & q2), .q(q3));\n\t\n\t// Output Z calculation based on flip flop outputs\n\tassign z = ~(q1 ^ (q2 | (q1 & ~q3))); \nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\twire q1;\n\tDFF dff1 (.clk(clk), .d(x ^ q1), .q(z)); // D flip flop for Z output\n\t\n\twire q2;\n\tDFF dff2 (.clk(clk), .d((~x) & q2), .q(q1)); // D flip flop for first gate input\n\t\n\twire q3;\n\tDFF dff3 (.clk(clk), .d((~x) | q3), .q(q2)); // D flip flop for second gate input\n\t\n\tDFF dff4 (.clk(clk), .d((~x) ^ q1 ^ (~q2)), .q(q3)); // D flip flop for third gate input\n\t\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\n\twire q1;  // Output from DFF for XOR gate\n\twire q2;  // Output from DFF for AND gate\n\twire q3;  // Output from DFF for OR gate\n\t\n\t// D flip-flops for each of the three gates\n\tDFF dff_x (.clk(clk), .d(x), .q(q1));  \n\tDFF dff_not_x (.clk(clk), .d(~x), .q(q2));  // Complemented input for AND gate and NOT input for OR gate\n\tDFF dff_not_and_or (.clk(clk), .d(~q2 & q1 | ~q1 & q3), .q(z)); // XNOR of the outputs from each D flip-flop\n\t\nendmodule\n\n"}
{"task_id": "rule110", "completion": "\n\treg [511:0] next_q;\n\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tnext_q <= data;\n\t\telse\n\t\t\tfor (integer i = 0; i < 512; i = i + 1) \n\t\t\t\tcase({q[i-1], q[i+1]})   // Right, Left neighbours\n\t\t\t\t\t2'b11: next_q[i] <= 1'b0; \n\t\t\t\t\t2'b10: next_q[i] <= 1'b1;\n\t\t\t\t\t2'b01: next_q[i] <= 1'b1;\n\t\t\t\t\tdefault: next_q[i] <= 1'b0;\n\t\t\t\tendcase\n\t\tq <= next_q;   // update q on clock edge\n\tend\nendmodule\n"}
{"task_id": "rule110", "completion": "\n\treg [511:0] nextQ;\n\tinteger i;\n\n\t// Calculation for the next state based on Rule 110.\n\talways @(*) begin\n\t\tfor (i=0; i<512; i++) begin\n\t\t\tcase({q[i-1], q[i+0], q[i+1]}) // Left, Center and Right neighbours.\n\t\t\t\t3'b001: nextQ[i] = ~(q[i-1] | q[i+1]); \n\t\t\t\t3'b011: nextQ[i] = (~q[i-1]) & q[i+1]; \n\t\t\t\t3'b101: nextQ[i] = ~(q[i-1] | q[i+1]);  \n\t\t\t\t3'b111: nextQ[i] =  q[i-1] & (~q[i+1]) ;   \n\t\t\t\t3'b010, 3'b100, 3'b110, 3'b000: nextQ[i] ="}
{"task_id": "rule110", "completion": "\n\treg [512:1] nextQ;\n\tassign q = load ? data : nextQ[511:0];\n\talways @(posedge clk) begin\n\t\tfor (integer i=1;i<=511;i++) \n\t\t\tcase({q[i-1],q[i+1],q[i]})   // table index is {previous, next, current}\n\t\t\t3'b000: nextQ[i] = 1'b0;     // case -2,-2,0\n      \t3'b001: nextQ[i] = 1'b1;     // case -2,-2,1\n\t\t  3'b010: nextQ[i] = 1'b1;     // case -2,-1,0\n\t\t\t3'b011: nextQ1[i] = 1'b0;    // case -2,-1,1\n\t      3'b100: nextQ[i] = 1'b1;      // case -1,-2,0\n\t\t  3'b101: nextQ"}
{"task_id": "vector1", "completion": "\n\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\n\t\nendmodule \n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\nendmodule\n"}
{"task_id": "vector1", "completion": "\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule \n\n"}
{"task_id": "vector0", "completion": "\n\nassign {o2, o1, o0} = vec;\nassign outv = vec;\n\nendmodule\n"}
{"task_id": "vector0", "completion": "\n\n\tassign o2 = vec[2];\n\tassign o1 = vec[1];\n\tassign o0 = vec[0];\n\tassign outv = vec; \nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\tassign o2 = vec[2];\n\tassign o1 = vec[1];\n\tassign o0 = vec[0];\n\tassign outv = vec; \nendmodule\n\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\n\treg [3:0] temp;  // temporary variable to hold the shifted value.\n  \n\talways @(posedge clk) begin\n\t\tif (shift_ena == 1'b1) begin\n\t\t\ttemp <= {data, q[3:1]};  // Shift data in on most significant bit.\n\t\t\tq <= temp;\n\tend\n\telse if (count_ena == 1'b1)   // decrement the counter\n\t\t\tq <= q - 4'd1;\n\tend\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] tmp;\n\n\talways @(posedge clk) begin\n\t\tif (shift_ena == 1'b1) \n\t\t\ttmp <= {tmp[2:0], data};\n\t\t\t\n\t\telse if (count_ena == 1'b1)\n\t\t\tq <= q - 4'd1;\n\tend\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] temp;  // temporary variable to store the decremented value\n\talways @(posedge clk) begin\n\t\t\tif (shift_ena) begin\n\t\t\t\t// Shift in most significant bit first\n\t\t\t\tq <= {data, q[3:1]};\n\t\t\tend else if (count_ena) begin\n\t\t\t\t// Decrement counter\n\t\t\t\ttemp <= q - 4'b0001;   // decrements the value by 1\n\t\t\t\tq <= temp;             // assigns the temporary variable back to q\n\t\t\tend\n\tend\nendmodule\n"}
{"task_id": "dff8", "completion": "\n\n\t//8 D Flip flops\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend \n\nendmodule\n"}
{"task_id": "dff8", "completion": "\nalways @ (posedge clk) begin\n    q <= d;\nend\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = !(a ^ b);\nendmodule\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\n\tassign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "lemmings3", "completion": "\n\treg [1:0] state;  // 2 bit state register.\n\tparameter LEFT = 2'b01, RIGHT = 2'b10;  \n\n\t// State transition logic.\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t\t    state <= LEFT;\n        else case (state) \n            LEFT:  if (bump_right && ground) \n                        state <= RIGHT;   // Bumped on right, walk right.\n                   else if (bump_left || dig ) \n                        state <= LEFT;    // bumped on left or digging, stay in left.\n            RIGHT: if(bump_left && ground) \n                        state <= LEFT;   // Bumped on left, walk left.\n                   else if (bump_right || dig ) \n                        state <= RIGHT;    // bumped on right or digging, stay in right.\n        endcase\n\tend \n\t// Output logic.\n\tassign walk_left = (state == LEFT);   // If the Lemming is walking left."}
{"task_id": "lemmings3", "completion": "\n\n\t// State encoding is as follows: 00 = walk right, 01 = fall, 10 = walk left, 11 = dig\n\treg [1:0] state;\n\twire falling, walking_left, walking_right, dug;\n\tassign falling = ~ground & (state[0] | state[1]); // If not ground and either in fall or walk state\n\tassign aaah = falling; // When Lemming is falling\n\tassign walking_left = (state == 2'b10) && ground; // If state is walk left and on the ground\n\tassign walk_left = walking_left; \n\tassign walking_right = (state == 2'b00) && ground; // if state is walk right and on the ground\n\tassign walk_right = walking_right;\n\tassign dug = (state == 2'b11) && ground; // If in dig state and on ground\n\tassign digging = dug; \n\t\n\t// State transition logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate"}
{"task_id": "lemmings3", "completion": "\n\treg state;\n\twire falling = !ground && aaah;\n\t\n\t// Moore Machine\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= 1'b0; // walk left on reset.\n\t\telse if ((bump_left | bump_right) && !falling)  \n\t\t\tstate <= !state;  // Switch states when bumped and not falling.\n\t\telse if (dig && ground && !falling)  \n\t\t\tstate <= 1'b1;  // Start digging on the right side of ground.\n\tend\n\n\t// Output logic\n\tassign walk_left = state;\n\tassign walk_right = ~state;\n\tassign aaah = falling;\n\tassign digging = (state | falling) && dig;\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\n\treg [3:0] state;\n\n\t// State transition diagram\n\t// 0 -> 1 -> 2 -> 3\n\t//  |     |     |\n\t//  v     v     v\n\t//  4 -> 5 -> 6 -> 7\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 4'b0001; // Reset state\n\t\telse\n\t\t\tcase(state)\n\t\t\t\t4'b0001: if (!data) state <= 4'b0010; else state <= 4'b1001;\n\t\t\t\t4'b0010: if ( data) state <= 4'b0100; else state <= 4'b0001;\n\t\t\t\t4'b0100: if (!data) state <= 4'b0101; else state <= 4'b0001;\n\t\t\t\t4'b1001: if ( data) state <= 4'b1010; else state <= 4'b0001;\n\t\t\t\t4'b0011: start_"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state; \n\tassign start_shifting = (state==4'b1101);\n\talways @(posedge clk or posedge reset) begin  \n\t    if(reset)\n\t\t    state <= 4'b0000;\n\t    else \n\t        case(state)\n\t            4'b0000: if(data) state <= 4'b0001; //if data is '1', move to next state\n\t            else state <= 4'b0000;               //else remain in current state (i.e., 0000)\n                4'b0001: if(data) state <= 4'b0011;  \n                else state <= 4'b0000;             \t\n\t            4'b0011: if(data) state <= 4'b0110; \n                else state <= 4'b0000;              \n\t            4'b0110: if(data) state <= 4'b1101; //if data is '1', move"}
{"task_id": "review2015_fsmseq", "completion": "\n    reg [3:0] state = 4'b0000;  // Initialize the state to be all zeros.\n    \n\talways @(posedge clk or posedge reset) begin   // Synchronous process with active high reset.\n\t\tif (reset == 1) begin\n\t\t\tstate <= 4'b0000;  // Resetting state back to initial state on the rising edge of reset.\n            start_shifting <= 0;  // Set start_shifting to zero when reset is active.\n\t\tend else begin\n        \tcase (state)  // State transition logic based on current state and input data.\n            \t4'b0000: if(~data) state <= 4'b0001;  // If first bit of sequence is zero, go to next state.\n                4'b0001: if(data ) state <= 4'b0011;  // If second bit of sequence is one, go to next state.\n                4'b0011: if(~data) begin  \n                    \tstate <= 4'b0111;  //"}
{"task_id": "fsm3", "completion": "\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\talways @(posedge clk or posedge areset) begin \n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse \n\t\t\tcase (state) \n\t\t\t\tA: state <= in ? B : A;\n\t\t\t\tB: state <= in ? C : B;\n\t\t\t\tC: state <= in ? A : C;\n\t\t\t\tD: state <= in ? B : D;\n\t\t\tendcase\n\tend\n\tassign out = (state == D);\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n\treg [1:0] nextState;\n\twire [3:0] new_state; // 4 bit to hold states A=2'b00, B=2'b01, C=2'b10, D=2'b11\n    \n    always @(posedge clk or posedge areset) begin  \n\t\tif (areset == 1'b1) state <= 2'b00;  // reset to A on positive edge triggered by asynchronous reset\n        else state <= nextState;             // update the current state\n    end    \n        \n\t// State transition logic\n\talways @(*) begin\n\t    case (state)\n\t\t     2'b00: if (in == 1'b0) {new_state[3], new_state[1]} = 2'b00; // nextState = A for in=0, B for in=1\n\t\t\t     else           {new_state[3], new_state[1]} = 2'b01;\n\t\t     2'b01: if (in == 1'b0"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= A;\n        else \n            case (state) \n                A: begin out <= 0; state <= in ? B : A; end\n                B: begin out <= 0; state <= in ? C : B; end\n                C: begin out <= 1; state <= in ? D : C; end\n                D: begin out <= 1; state <= in ? A : D; end\n            endcase \n    end\nendmodule\n"}
{"task_id": "mux2to1", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1", "completion": "\nassign out = sel ? b : a;\nendmodule  // end of top_module\n"}
{"task_id": "mux2to1", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "lfsr5", "completion": "\n    always @ (posedge clk or posedge reset) begin\n        if(reset) \n            q <= 5'b1; // Reset to all 1s.\n        else \n            q <= {q[4], q[3] ^ q[4], q[2], q[1], q[0]};   // Taps at bit positions 5 and 3, with XOR operation.\n    end\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 5'b1;\n        else \n            q <= {q[3], ~(q[4]^q[2]), q[4], q[0], ~(q[4]^q[3]) }; // taps at bit positions 5 and 3\n    end\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n\t// Galois 5-bit Maximal Length LFSR with Taps at Positions 2 and 1.\n\talways @ (posedge clk or posedge reset) begin\n\t    if(reset)\n\t        q <= 5'b00001; // Reset State is 00001\n\t    else\n\t        q <= {q[3]^q[4], q[4:1]};\n\tend\nendmodule\n"}
{"task_id": "dff", "completion": "\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @ (posedge clk) begin\n\t\tq <= d;  // D flip-flop is implemented using a clocked process in Verilog. The output 'q' changes on every rising edge of the clock, with new input from 'd'.\n\tend\nendmodule\n"}
{"task_id": "dff", "completion": "\n\talways @ (posedge clk) begin\n\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\treg [4:0] taps;\n\t\n\t// The Galois LFSR with tap positions 32, 22, 2 and 1.\n\talways @(posedge clk) begin\n\t    if (reset)\n\t        q <= 32'h1;\n\t    else\n    \t    taps <= {q[29], q[18], q[1], q[0]};\n        \tq <= {q[31:1], ~(taps[4])^taps[3]}; // XNOR of the tap outputs.\n  \tend \nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n    always @ (posedge clk or posedge reset) begin \n        if(reset == 1'b1) \n            q <= 32'h1; \n        else \n            q <= {q[30], q[21] ^ q[31], q[19] ^ q[31], q[1] ^ q[31], q[0:18]}; \n    end\nendmodule \n"}
{"task_id": "lfsr32", "completion": "\n\tinitial begin\n\t\tq <= 32'h1;  // initial state of LFSR is 1\n\tend\n\t\t\n\talways @(posedge clk) begin\n\t\tif (reset)  // reset condition\n\t\t\tq <= 32'h1;  \n\t\telse\n\t\t\tq <= {q[30:0], ^(q[31]^q[21]^q[1]^q[0])}; // XOR gate with taps at bit positions 32, 22, 2 and 1.\n\tend\n\t\t\nendmodule\n"}
{"task_id": "7420", "completion": "\n\t// NAND Gate 1\n\tassign not_p1 = !(p1a & p1b & p1c & p1d);\n\tp1y <= not_p1; // Output\n\t\n\t// NAND Gate 2\n\tassign not_p2 = !(p2a & p2b & p2c & p2d);\n\tp2y <= not_p2; // Output\nendmodule\n\n"}
{"task_id": "7420", "completion": "verilog\nmodule top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\n\t// NAND gate for P1\n\tassign p1y = ~(p1a & p1b & p1c & p1d);\n\n\t// NAND gate for P2\n\tassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n\n"}
{"task_id": "7420", "completion": "\n\twire w1, w2;\n\t\n\t// 7420 gate 1\n\tassign w1 = ~(p1a & p1b & p1c & p1d);\n\tassign p1y = w1;\n\t\n\t// 7420 gate 2\n\tassign w2 = ~(p2a & p2b & p2c & p2d);\n\tassign p2y = w2;\nendmodule\n\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y;\n\t\n\t// State transition function\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t    y <= 3'b000;\n\t\telse\n  \t\t\tcase ({y, x}) \n    \t\t\t\t5'b00001: y <= 3'b000;\n    \t\t\t\t5'b00010: y <= 3'b001;\n    \t\t\t\t5'b00100: y <= 3'b010;\n    \t\t\t\t5'b00101: y <= 3'b001;\n    \t\t\t\t5'b01000: y <= 3'b011;\n   \t\t\t\t        5'b01001: y <= 3'b100;  // No change in state, output z=0\n  \t\t\t\tendcase\n\tend\n\t\t\n\t// Output function\n\tassign z = (y == 3'b100);\n\nendmodule\n\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y;\n    \t\n\t// State-assigned next state and output logic. \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\ty <= 3'b000; // Reset state to 0 on synchronous active high reset.\n\t\telse case(y) \n\t\t\t3'b000: if(!x) y<=3'b000; else y<=3'b001;\n\t\t\t3'b001: if(!x) y<=3'b001; else y<=3'b100; \n\t\t\t3'b010: if(!x) y<=3'b010; else y<=3'b001;  \n\t\t\t3'b011: if(!x) y<=3'b001; else y<=3'b010; \n\t\t\t3'b100: if(!x) y<=3'b011; else y<=3'b100;  "}
{"task_id": "2014_q3bfsm", "completion": "\nreg [2:0] y;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1) \n\tbegin\n\t\ty <= 3'b000;\n\tend\n\telse\n\tbegin\n\t\tcase(y) \n\t\t\t3'b000: if (x == 0) y <= 3'b000; else y <= 3'b001;\n\t\t\t3'b001: if (x == 0) y <= 3'b001; else y <= 3'b100;\n\t\t\t3'b010: if (x == 0) y <= 3'b001; else y <= 3'b001;\n\t\t\t3'b011: if (x == 0) y <= 3'b001; else y <= 3'b010;\n\t\t\t3'b100: if (x == 0) y <= 3'b011; else y <= 3'b100;\n\t\t\tdefault: y <= 3'b000;\n\t\tendcase\n\tend \n"}
{"task_id": "fsm2s", "completion": "\nreg state; // State register\n\nalways @(posedge clk or posedge reset) begin \n    if (reset) \n        state <= 1'b0; // Reset to OFF\n    else \n\tcase({j, k})\t\n\t\t2'b00: state <= state;\t// No change\n        2'b01: state <= ~state; \t// Toggle\n        2'b10: state <= state;  \t// No Change\n        2'b11: state <= ~state;\t// Toggle\t\n        default : state <= state; // No Change\n    endcase\nend\n    \nassign out = state;\n\nendmodule\n\n"}
{"task_id": "fsm2s", "completion": "\n\n\t// Declare the states as local parameters.\n\tlocalparam [1:0] OFF = 2'b00, ON = 2'b01;\n\treg [1:0] state; // Current and next states.\n\twire next_state = j ? (k ? OFF : ON) : (k ? ON : OFF); \n\tassign out = state[0];\n\t// Synchronous reset with asynchronous clock.\n\talways @(posedge clk or posedge reset) begin\n\tif (reset) // Asynchronous reset.\n\tstate <= OFF;\n\telse // Synchronous update.\n\tstate <= next_state; \n\tend\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\nreg state;  // Current State\nwire next;  // Next State\nassign next = (state && (!j || k)) ? 1'b0 : 1'b1;\n\n// Synchronous Reset and Clocked state transitions\nalways @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\tstate <= 1'b0;\n\telse\n\t\tstate <= next;\nend\nassign out = state;\nendmodule\n"}
{"task_id": "m2014_q4b", "completion": "\n\talways @(posedge clk or posedge ar) begin\n\t\tif(ar) \n\t\t\tq <= 1'b0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\talways @(posedge clk or posedge ar) begin\n\t\tif(ar) \n\t\t\tq <= 0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\talways @(posedge clk or posedge ar) begin\n    \tif (ar) \n        \tq <= 0;\n    \telse \n       \t \tq <= d;\n  \tend\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\tassign {cout, sum} = a + b + cin;\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\nassign {cout, sum} = a + b + cin;\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\tassign {cout,sum} = a + b + cin;\nendmodule\n\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] d;\n\tassign out = d[3];\n\t\t\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) \n\t\t\td <= 4'b0000;\n\t\telse \n\t\t\td <= {in, d[3:1]};\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4k", "completion": "\nreg [3:0] q;\nassign out = q[3];\n\nalways @(posedge clk or negedge resetn) begin\n\tif (!resetn) \n\t\tq <= 4'b0;\n\telse \n\t\tq <= {q[2:0], in};\nend\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\n\treg [3:0] d;\n\tassign out = d[0];\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (resetn == 1'b0) \n\t\t\td <= 4'b0000;\n\t\telse \n\t\t\td <= {in, d[3:1]};\n\tend\nendmodule\n"}
{"task_id": "mux256to1", "completion": "\n\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\nassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = ~a[2] & ~b[2] | ~a[1] & ~b[1] | ~a[0] & ~b[0]; \n\tassign out_not = {3'h7 ^ a, 3'h7 ^ b}; // XOR with full bit pattern to get inverse\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = |a || |b; // logical OR of the two vectors\n\tassign out_not = ~{1'b0, a} << 3 | ~{1'b0, b}; // inverse (NOT) of both vectors placed in upper and lower half\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\n\tassign out_or_bitwise = a | b; // bitwise or of the two vectors \n\tassign out_or_logical = (a[2] || b[2]) || ((a[1] || b[1]) || (a[0] || b[0])) ; // logical or of the two vectors  \n\tassign out_not = {~b, ~a}; // inverse of both vectors placed in upper half and lower half respectively \nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\treg [1:0] counter;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tcounter <= 2'h3; // Asserted for four cycles\n\t\telse if(counter > 0)\n\t\t\tcounter <= counter - 1;\n\tend\n\n\tassign shift_ena = (counter==2'h0); // Enable when counter reaches zero\n\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n    reg [1:0] counter;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 2'b11;\n            shift_ena <= 1'b1;\n        end else begin\n            counter <= counter - 1;\n            shift_ena <= |counter; // If counter is not zero, enable the shift register\n        end\n    end\n    \nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\treg [1:0] count;\n  \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tcount <= 2'b11;\n\t\telse if (count != 2'b00) \n\t\t\tcount <= count - 1;\n\tend\n  \n\tassign shift_ena = |count; // Assert when count is not zero.\nendmodule\n"}
{"task_id": "count10", "completion": "\n\n\t// Reset value of counter is 'b1010' which corresponds to decimal 10\n    reg [3:0] count = 'hA;\n\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n\t        count <= 4'd0;     // Reset counter on the rising edge of reset.\n        else\n            count <= count + 1;  // Increment counter at each positive clock cycle.\n    end\n  \n    assign q = count;\nendmodule\n"}
{"task_id": "count10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0;\n\t\telse if (q == 4'd9) // equivalent to 4'h9, which is the binary number for decimal 9.\n\t\t\tq <= 4'b0;\n\t\telse \n\t\t\tq <= q + 1'd1; // equivalent to 1'h1, which is the binary number for decimal 1.\n\tend\nendmodule\n"}
{"task_id": "count10", "completion": "\n\n\talways @ (posedge clk or posedge reset) begin\n\t\tif(reset) \n\t\t\tq <= 4'b0;\n\t\telse \n\t\t\tq <= q + 1;\n\t\t\t\n\t\tif(q == 4'd9) // if counter is at 9, reset it to 0.\n\t\t\tq <= 4'b0;\n\tend\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\talways @(*) begin\n\t\tif ((a==0) && (b==0)) \n\t\t\tout = 0;\n\t\telse if ((c==1) && (d==1))\n\t\t\tout = 0;\n\t\telse if ((a==1) && (d==0))\n\t\t\tout = 1;\n\t\telse if ((b==1) && (c==0)) \n\t\t\tout = 1;\n\tend\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\talways @(*) begin\n\t\tif ((~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (b & c & ~d)) \n\t\t\tout <= 1'b0;\n\t\telse if((~a & ~b & ~c & ~d )|(~a & b & ~c & d )| ( a & ~b & ~c & d ) | (a & b & c & d) |( a & b & ~c & ~d)) \n\t\t\tout <= 1'b1;\n\t\telse out <=1'bx;\n\tend\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\talways @(*) begin\n\t    if((c==0 && d ==0) || (b == 1 && d ==1))\n\t        out = 0;\n        else if ((a==1&& b==0&& c==0 )|| (a==1 && b==1&&d==1 ))\n            out = 1;\n\t    else if(( a==0 &&c==0) ||(b == 1 && d ==1 ))\n\t        out =0 ;\n        else if ((a==1 && c==1) ||( b==1&& d==0 ))\n             out=1;\t  \n    end\nendmodule\n"}
{"task_id": "wire", "completion": "\n\n\t// This module is already behaving like a wire as it has only one input (in) \n        // and output (out). Any logic operation between these two will be ignored. \n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\n\tassign out = in;\nendmodule\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n    reg [1:0] state;\n    \n    parameter A = 2'b00, B = 2'b01; \n\n    always @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) \n            state <= A;\n        else \n            case (state) \n                A: \tif(x==1'b0)\tstate <= B;\n                \telse\t\t\tstate <= A;\n                    \n                B: \tif(x==1'b1)\tstate <= B;\n                \telse\t\t\tstate <= A;\n            endcase\n    end\n    \n    assign z = (state == B && x == 1'b0)? 1 : 0 ;\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01;\n  \n\talways @(posedge clk or posedge areset) begin\n    \tif (areset) \n\t\t\tstate <= A;\n     \telse \n\t\t\tcase (state) \n        \t\tA: state <= x ? B : A;\n          \tB: state <= x ? B : A;\n       \t \tdefault: state <= A;\n      \t\tendcase\n    \tend\n  \n\tassign z = (state == B && x == 1) || (state == A && x == 0);\nendmodule \n\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\treg [1:0] state;\n  \n  // State encoding using one-hot encoding.\n\tparameter A = 2'b00, B = 2'b01;\n  \n\t// Synchronous reset\n\talways @(posedge clk or posedge areset) begin\n    if (areset == 1'b1) state <= A;\n  end\n  \n\t// Mealy State Machine implementation.\n\talways @(posedge clk) begin\n    \tcase (state)\n        \tA: begin z <= 0; \tif (x == 1) state <= B; end\n         \tB: begin z <= 1;  if (x == 1) state <= A; else state <= B; end\n       \tendcase\n    end\nendmodule\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in;\n\tassign out_or = ^(|in);\n\tassign out_xor = ^in;\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or  = |in;\n\tassign out_xor = ^in;\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\treg q_next;\n\talways @(posedge clk) begin\n\t    q <= q_next;\n\tend\n\talways @(negedge clk or posedge d) begin\n\t    if (negedge clk) \n\t\t    q_next = d;\n\t    else\n\t\t    q_next = ~q;\n\tend  \nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\treg q1;  // Internal register for edge detection\n\n\talways @(posedge clk) begin\n\t\tq <= ~d;   // On posedge clock, output flips the input\n\t\tq1 <= d;   // Also store the current state of d in an internal register\n\tend\n\n\t// Output q remains the same until next posedge clock. \n\t// At that time, if inputs were different (detected by checking q1 vs d), output would flip again.\n"}
{"task_id": "dualedge", "completion": "\n\treg oldclk;\n\n    always @ (posedge clk) begin\n        oldclk <= clk;\n         if ((~oldclk) & clk) // detect rising and falling edges of clock\n             q <= ~q;          // flip the output at both edges\n     end\nendmodule \n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;  // ternary operator is used here to choose between 'a' and 'b' based on the value of 'sel'. If 'sel' = 0, then output will be 'a', else 'out' will be 'b'.\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] prev;\n\n\talways @(posedge clk) begin\n\t\tprev <= in;\n\tend\n\n\tassign anyedge = (in & ~prev);  // detecting rising edge\n\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\n\treg [7:0] in_prev;  // previous input value register\n\n\t// Synchronize the inputs and detect edges on the clock edge\n\talways @(posedge clk) begin\n\t\tin_prev <= in;\n\t\tfor (integer i=0; i<8; ++i)\n\t\t\tif ((~in_prev[i]) & in[i])  // from 0 to 1\n\t\t\t\tanyedge[i] <= 1'b1;   // set the cycle after a transition\n\tend\n\t\n\t// Clear edge detect on clock edges\n\talways @(posedge clk or negedge clk) begin\n\t    if (~clk) anyedge <= 8'h00;  // clear all bits when clock is low\n\tend\n\t\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n\n\treg[7:0] in_ff1,in_ff2; // two flip-flops for edge detection\n\n\t// double flopping input to detect the edges\n\talways @(posedge clk) begin \n\t    in_ff1 <= in;\n        in_ff2 <= in_ff1;\n    end\n    \n\t// detecting any edge\n\tassign anyedge = (in_ff1 & ~in_ff2);\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\twire a, b;\n\tassign a = c;\n\tassign b = d;\n    \n    assign mux_in[0] = ~a & ~b; // for ab=00\n    assign mux_in[1] =  a & ~b; // for ab=01\n    assign mux_in[2] =  a &  b; // for ab=11\n    assign mux_in[3] = ~a &  b; // for ab=10\n    \nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign mux_in = {c & ~d, ~c & d, c & d, ~c & ~d};\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign {mux_in[2], mux_in[1], mux_in[3]} = {c^d, c, !d};\n    assign mux_in[0] = ~(c&d);\nendmodule \n\n"}
{"task_id": "circuit10", "completion": "\nreg [1:0] state; // Internal state of the flip flop.\n\nalways @(posedge clk) begin\n\tcase ({a, b}) \n\t\t2'b00 : state <= 2'b00;   // No change in state.\n\t\t2'b01 : state <= 2'b01;   // State goes to 1.\n\t\t2'b10 : state <= 2'b10;   // State goes to 0.\n\t\tdefault: state <= 2'b00;   // Default case for any other inputs.\n\tendcase\nend\n\nassign q = state[0];    // Outputs the current state of the flip flop.\n\n"}
{"task_id": "circuit10", "completion": "\n\treg s;\n\twire nxstate;\n\n\tassign nxstate = !(s ^ a | ~b);\n\tassign state = s;\n\n\talways @(posedge clk) begin\n\t\ts <= nxstate;\n\tend\n\n\tassign q = s;\nendmodule \n"}
{"task_id": "circuit10", "completion": "\n\treg s;\n\n\talways @(posedge clk) begin\n\t\tif (!a & !b) \n\t\t\ts <= 0;\n\t\telse if (a & !b) \n\t\t\ts <=1;\n\t\telse if (b) \n\t\t\ts <= !s;\n\tend\n\t\n\tassign q = s;\n\tassign state = a | b;\nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\n\n\t// State"}
{"task_id": "fsm_ps2data", "completion": "\n\treg ["}
{"task_id": "fsm_ps2data", "completion": "\n\n\treg"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] q;\n\t\n\talways @(posedge clk) begin\n\t\tq <= in;\n\t\t\n\t\tfor (integer i = 0; i < 8; i = i + 1) \n\t\t\tif ((~q[i]) & in[i]) pedge[i] <= 1'b1; // positive edge detection\n\t\t\telse pedge[i] <= 1'b0;\n\tend\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] in_r;\n\n\talways @(posedge clk) begin\n\t\tin_r <= in;  // Register the input signal.\n\tend\n\n\t// Detect positive edges by comparing current and previous inputs.\n\tassign pedge = in & ~in_r;  \n\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n    reg [7:0] q;\n    \n\talways @(posedge clk) begin\n        // Detect the rising edge of input signal. \n\t    pedge <= (~q & in);  \n        \n        // Store current state to detect next cycle's edge.\n        q <= in;              \n    end\nendmodule\n"}
{"task_id": "circuit4", "completion": "\n\tassign q = ((a & ~b) | (~c & d)) ^ (d & ~(c & b));\nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\nassign q = ((a & ~b) | (c & ~d)) ^ ((~a & b) | (~c & d));\nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\nassign q = ((a & ~b & ~c & ~d) | (~a & b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & ~b & ~c & d)) ;  // Use De Morgan's laws to simplify the expression\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n\treg [1:0] state;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin  // Reset is active high\n\t\t\tstate <= 2'b00;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\t2'b00: if(in[3] == 1'b1) state <= 2'b01; // Waiting for the first 1 of message\n\t\t\t\t2'b01: if(in[3] == 1'b0) begin state <= 2'b10; done <= 1'b1; end else state <= 2'b01; // Check second bit, if it is 0 go to next state and set done\n\t\t\t\t2'b10: if(in[3] == 1'b1) state <= 2'b00; else state <= 2'b11; // If third bit is also 1 then reset the process otherwise stay at this state\n\t\t\t\t2'b11: if(in[3] == 1'b0) state <= 2'"}
{"task_id": "fsm_ps2", "completion": "\nreg [1:0] state;  // State register\nwire start = in[3];  // Start bit indicator\n\nalways @(posedge clk or posedge reset) begin  \n\tif (reset)\n\t\tstate <= 2'b00;\n\telse\n\t\tcase (state)\n\t\t\t2'b00: state <= start ? 2'b01 : 2'b00;  // Wait for the start bit\n\t\t\t2'b01: state <= 2'b10;  // We found the start bit, move to next state\n\t\t\t2'b10: state <= in[3] ? 2'b11 : 2'b00;  // Check if we received all three bytes\n\t\t\t2'b11: state <= 2'b11;  // We have received all three bytes, stay here till reset or new message starts.\n\t\tendcase\nend  \nassign done = (state == 2'b11);  // When in the last state, we are done with a message\n"}
{"task_id": "fsm_ps2", "completion": "\n\n    reg [1:0] state;\n    \n    parameter IDLE = 2'b00, SECOND_BYTE = 2'b01, THIRD_BYTE = 2'b10;\n    \n\talways @(posedge clk or posedge reset) begin \n        if (reset) begin\n            state <= IDLE;\n            done <= 1'b0;\n        end else case (state) \n            IDLE : begin\n                if (in[3] == 1'b1) begin\n                    state <= SECOND_BYTE;\n                    done   <= 1'b0;\n                end\n            end\n            \n            SECOND_BYTE: begin\n                if (in[3] == 1'b0) begin\n                    state <= THIRD_BYTE;\n                    done   <= 1'b0;\n                end else \n                    done <= 1'b0;\n            end    \n            \n            THIRD_BYTE: begin\n                if (in[3] == 1'b1) begin\n                    state <= IDLE;\n                    done   <= 1'"}
{"task_id": "count15", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0000;\n\t\telse if(q==4'b1111) // when counter reaches max value of 15, it will roll back to zero.\n\t\t\tq <= 4'b0000;\n\t\telse \n\t\t\tq <= q + 1;\n\tend\nendmodule\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0;\n\t\telse \n\t\t\tq <= q + 1;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "count15", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) \n\t\t\tq <= 4'd0;\n\t\telse\n\t\t\tq <= q + 4'd1;\n\t\t\t\n\t\t// Wrap around counter after reaching maximum value of 15.\n\t\tif (q==4'd15)\n\t\t\tq <= 4'd0;\n\tend\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\treg [3:0] next_state;\n\tassign out = state[0]; // Outputs 1 when the current state is 'D'\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n\t        state <= 2'b00; // Reset to A on a high-active reset signal\n\t    else\n    \t    state <= next_state; \n\tend\n\t// State transition logic:\n\talways @(*) begin\n\t    case (state)\n            2'h0 : next_state = in ? 2'h3 : 2'h1 ; // A -> B if in = 0, or stay at A if in = 1\n            2'h1 : next_end = in ? 2'h2 : 2'h0 ; // B -> C if in = 1, or stay at B if in = 0\n            2'h2 : next_state = in ? 2'h0 : 2'h3 ; // C -> A if in = 0, or stay at D if in = 1\n            2'h"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n  \treg [1:0] nextState;\n \n\t// State transition logic\n\talways @(*) begin\n    \tcase (state) \n        \t2'b00: if (!in) nextState = 2'b00; else nextState = 2'b01;\n       \t\t2'b01: if (!in) nextState = 2'b00; else nextState = 2'b10;\n        \t2'b10: if (!in) nextState = 2'b10; else nextState = 2'b11;\n         \t2'b11: if (!in) nextState = 2'b01; else nextState = 2'b11;\n     \tendcase\n \tend  \n   \n\t// Output logic\n\tassign out = (state == 2'b11);\n    \n\t// Synchronous reset and state update\n\talways @(posedge clk or posedge reset) begin\n      \tif (reset) state <= 2'b00; // Reset to A\n     \telse state <= nextState; \n  "}
{"task_id": "fsm3s", "completion": "\n    reg [1:0] state;\n\treg nextState;\n\tassign {nextState,out} = state;\n    \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) \n\t\t\tstate <= 2'b00; // State A\n\t\telse case(state)\n\t\t\t2'b00: if (in == 1'b0) state <= 2'b00; else state <= 2'b01; // State B\n\t\t\t2'b01: if (in == 1'b0) state <= 2'b10; else state <= 2'b00; // State C\n\t\t\t2'b10: if (in == 1'b0) state <= 2'b11; else state <= 2'b01; // State D\n\t\t\t2'b11: if (in == 1'b0) state <= 2'b01; else state <= 2'b10; // State B\n\t\tendcase\n\tend \nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @(*) begin\n\tcasez ({in,state}) \n\t\t2'b0_0001: {next_state,out} = {4'b0001, 1'b0};\n\t\t2'b0_0010: {next_state,out} = {4'b0010, 1'b0};\n\t\t2'b0_0100: {next_state,out} = {4'b0100, 1'b0};\n\t\t2'b0_1000: {next_state,out} = {4'b1000, 1'b1};\n\t\t// In case the inputs are not defined in table.\n\t\t default : {next_state, out} = 'x;  \n\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t4'b0001 : begin // State A\n\t\t\t\tif (!in) begin\n\t\t\t\t\tnext_state <= 4'b0001; // Stay in state A if input is zero.\n\t\t\t\t\tout = 0; // Output stays the same as well, hence no change. \n\t\t\t\tend else begin\n\t\t\t\t\tnext_state <= 4'b0010; // If input is one, move to state B next.\n\t\t\t\t\tout = 0;  // And output remains zero.\n\t\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\t4'b0010 : begin // State B\n\t\t\t\tif (!in) begin\n\t\t\t\t\tnext_state <= 4'b0100; // If input is zero, move to state C next.\n\t\t\t\t\tout = 0; // And output remains zero as well. \n\t\t\t\tend else begin\n\t\t\t\t\tnext_state <= 4'b0010; // If input is one, stay in State B.\n\t\t\t\t\tout = 0; // Output stays same.\n\t\t\t\tend\n\t\t\tend\n"}
{"task_id": "fsm3onehot", "completion": "\n\tassign out = (state==4'b1000)? 1'b1 : 1'b0;\n\talways @(*) begin\n\t\tcase(state) \n\t\t\t4'b0001: next_state = in? 4'b0010 : 4'b0001; // A->B, B->A\n\t\t\t4'b0010: next_state = in? 4'b0100 : 4'b0010; // B->C, C->B\n\t\t\t4'b0100: next_state = in? 4'b1000 : 4'b0010; // C->A, A->B (not specified)\n\t\t\t4'b1000: next_state = in? 4'b0100 : 4'b1000; // D->C, C->D\n\t\t\tdefault: next_state = 4'bxxxx;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q4a", "completion": "\n\talways @(*) begin\n\t\tif (ena)\n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n\n\talways @(*) begin\n\t\tif (ena) \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\nalways @(*) begin\n\tif(ena) \n\t\tq <= d;\nend\n\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] q; // internal register to store input value on the clock edge\n\t\n\t// synchronous D-FF for resetting\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 32'b0;\n\t\telse \n\t\t\tq <= in;\n\tend\n\n\t// logic to generate output based on the difference between input and internal register value at clock edge\n\talways @(posedge clk) begin\n\t\tfor (int i=0; i<32; i++)\n\t\t\tif (q[i] && ~in[i]) \n\t\t\t\tout[i] <= 1'b1;\n\t\t\telse \n\t\t\t\tout[i] <= 1'b0;\n\tend\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\n\treg [31:0] q; // internal register to store the previous input state\n    \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin \n\t\t\tq <= 32'h0;\n            out <= 32'h0;\n        end else begin\n        \tq <= in; // update internal register with current input state\n    \t    for(integer i = 0; i < 32; ++i)begin // check each bit \n            \tif (in[i] == 1 && q[i] == 0) // if the input changes from 1 to 0 in one clock cycle \n                \tout[i] <= 1; // set output corresponding to that bit\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] last;  // register to hold the previous value of 'in'\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            last <= 32'b0;\n        else \n            last <= in;  \n    end\n\tassign out = in & ~last; // set output bit to '1' only when current input bit is '1' and previous input bit was '0'\nendmodule\n\n"}
{"task_id": "always_nolatches", "completion": "\n\n    always @(scancode) begin\n        case(scancode)\n            16'he06b:  begin left = 1; down = 0; right = 0; up = 0; end // Left Arrow Key\n            16'he072:  begin left = 0; down = 1; right = 0; up = 0; end // Down Arrow Key\n            16'he074:  begin left = 0; down = 0; right = 1; up = 0; end // Right Arrow Key\n            16'he075:  begin left = 0; down = 0; right = 0; up = 1; end  // Up Arrow Key\n            default :   begin left = 0; down = 0; right = 0; up = 0; end  // No key pressed or other scancode\n        endcase\n    end\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n\n\talways @* begin\n\t\tcase(scancode)\n\t\t\t16'he06b: begin left = 1; down =0 ;right=0;up=0; end  //left arrow key pressed\n      \t\t16'he072: begin right = 1;down=0; left=0; up=0; end   //down arrow key pressed\n     \t\t16'he074: begin down =1 ;right=0; left=0;up=0;end    //right arrow key pressed\n      \t\t16'he075: begin right = 0;left=0; up=1;down=0; end   //up arrow key pressed \n    \t\tdefault : begin down =0 ;right= 0; left=0; up=0;end    //no keys pressed\n      \t\tendcase\n    \tend\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n\talways @* begin\n\t\tcase(scancode)\n\t\t\t16'he06b: begin left = 1; down = 0; right = 0; up = 0; end //left arrow\n\t\t\t16'he072: begin left = 0; down = 1; right = 0; up = 0; end //down arrow\n\t\t\t16'he074: begin left = 0; down = 0; right = 1; up = 0; end //right arrow\n\t\t\t16'he075: begin left = 0; down = 0; right = 0; up = 1; end //up arrow\n\t\t\tdefault:   begin left = 0; down = 0; right = 0; up = 0; end //none\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "m2014_q4h", "completion": "\n\n\tassign out = in;\n\t\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n\tassign out[0] = |in; // OR gate\n\tassign out[1] = $countones(in); // built-in function to count ones \nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n\t// Population Count Circuit\n\tassign out = {~in[0] & ~in[1] & ~in[2],  // If all bits are 0, then output is 3'b01. Otherwise it's 3'b10.\n\t\t\t      in[0] | in[1] | in[2]};   // If any of the bits are 1, then output is 3'b10. Otherwise it's 3'b01.\nendmodule\n"}
{"task_id": "popcount3", "completion": "\n\tassign out = sum; //out[0]: least significant bit and out[1]: most significant bit of population count \n\treg [1:0] sum;\n\talways @* begin\n\t\tif(in == 3'b000)\n\t\t\tsum = 2'b00;\n\t\telse if (in == 3'b001 || in == 3'b010 || in == 3'b100)\n\t\t\tsum = 2'b01;\n\t\telse if(in == 3'b011 || in == 3'b101 || in == 3'b110) \n\t\t\tsum = 2'b10;\n\t\telse // in==3'b111\n\t\t\tsum = 2'b11;\n\tend\nendmodule\n"}
{"task_id": "vectorr", "completion": "\n\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\t\nendmodule\n\n"}
{"task_id": "vectorr", "completion": "\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]}; // or you can use built-in function \"reverse\"\nendmodule\n\nor \n\nassign out = {<<{in}};\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\nor \nYou can also use built-in functions to reverse the bit ordering. In Verilog, there is a built-in function called \"reverse\" that you can use for this purpose:\n\n"}
{"task_id": "dff8r", "completion": "\n\n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset)\n\t\t\tq <= 8'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)\n\t\t\tq <= 8'h0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)  // active high reset\n\t\t\tq <= 8'h0;  \n        else\n            q <= d;      \n    end\nendmodule\n\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\treg [1:0] count;\n\treg [2:0] state;  // State machine states\n\tparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\n\talways @(posedge clk or negedge resetn) begin  // Reset synchronous with clock\n\tif(!resetn) begin\n\t\t\tf <= 0;\n\t\t\tg <= 0;\n\t\t\tstate <= A;  \n\t\t\tcount <= 0;\n\tend else case(state)\n\t\t\t\tA: if (!f) begin f <= 1; state <= B; count <= 2'b00; end // Stay in this state until next clock cycle when f=1\n\t\t\t\t\t\telse state <= A;\n\t\t\t\tB: if (count == 2) state <= C;  // If x = 1, 0, 1 for 3 cycles, then go to C state.\n\t\t\t\t\t else begin count <= count + 1'b1; state <= B; end  \n\t\t\t\tC: if (!x & !y"}
{"task_id": "2013_q2bfsm", "completion": "\n\n\treg [1:0] x_sync; // synchronized input x\n\treg [2:0] counter_x; \n\treg g_temp; // temporary variable for g\n\treg y_delayed; // delayed value of y (for 2 cycles)\n\n\t// synchronize the inputs and shift register for x\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tf <= 0;\n\t\t\tx_sync <= 2'b00;\n\t\t\tcounter_x <= 3'b000;\n\t\t\tg_temp <= 1'b0;\n\t\t\ty_delayed <= 1'b0;\n\t\tend else begin\n\t\t\tif (f) // if f is 1 for one clock cycle, reset everything\n\t\t\t\tf <= 0;\n\t\t\telse\n\t\t\t\tf <= 1;\n\t\t\t\t\n\t\t\t// shift register and counter for x\n\t\t\tx_sync <= {x_sync[0], x};\n\t\t\tcounter_x <= (x_sync == 2'b10) ? (counter_x + 1): (y ? 3'b"}
{"task_id": "2013_q2bfsm", "completion": "\n\treg [1:0] count;  // Counter to keep track of sequence 1,0,1.\n\treg last_x;       // To hold the previous x value.\n\treg y_detected;   // Flag to indicate if y has been detected in the next two clock cycles.\n\twire reset = ~resetn; // Synchronous reset signal.\n    \n    always @(posedge clk or posedge reset) begin \n        if (reset) begin\n            f <= 1'b0;\n            g <= 1'b0;\n            count <= 2'b00;\n\t\t\tlast_x <= 1'bx; // Initial value is undefined.\n\t\t\ty_detected <= 1'b0; \n        end else begin\n            if (!f) begin\n                f <= 1'b1;\n\t\t\t\tg <= 1'b1; // Set g to 1 on next clock cycle.\n            end else begin\n                count <= (last_x & x) ? count + 2'd1 : 2'b00; // Update counter if last_x and current x are both 1.\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\n\tassign {overflow,s} = a + b;\n\t\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\twire signed [8:0] sum;  // we need to account for the sign bit\n    always @* begin\n        sum = a + b;\n        overflow = (sum[7] != a[7]) && (a[7] == b[7]);\n        s = sum[7:0];\n    end\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\twire signed [8:0] sum;  // We use an extra bit for the carry-out.\n\tassign sum = {1'b0, a} + {1'b0, b};\n\tassign s = sum[7:0];\n\tassign overflow = |sum[8];   // If there is no overflow, then the sign of sum will not change after addition. So we check if the 8th bit (carry-out) changes.\nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\nThe minimum sum-of-products form of the output is equivalent to the OR operation on all possible input combinations. \nSimilarly, for product-of-sums form we can use AND operation with negation of each individual condition. But here it's not feasible as we need to consider multiple conditions (2,7,15) and (-0,-1,-4,-5,-6,-9,-10,-13,-14).\nHowever, for the sake of answering you can use the following code:\n\n\tassign out_sop = a | b | c | d; // minimum sum-of-products form\n\tassign out_pos = ~(a & ~b & ~c & ~d); // product-of-sums form\n"}
{"task_id": "ece241_2013_q2", "completion": "\nThe minimum sum-of-products form of the output for this problem is as follows.\nout_sop = (~a & b & ~c) | (a & c & d) | (b & c & d) \n\nThe minimum product-of-sums form of the output for this problem is as follows.\nout_pos = ~((a | ~d) & (b | ~c) & (c | ~d))\n"}
{"task_id": "ece241_2013_q2", "completion": "\n// Sum-of-products form is used for minimum logic functions and Product-of-sums form is used to minimize Hamming distance.\n// SOP form of the function is (a+b+c)(d+(not c))' + ((not a) + b + c)((not d)+e)'\n// POS form of the same function would be: (ad + (not c) + e)' + (bc+d)'\n\nassign out_sop = (!a && !b && !c || !d) || \n                 (( a || b || c )&&( d || !e)); \n                 \nassign out_pos = ((a || !c || e ) && (b || !d)) || \n                 (!c && !d);\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = ((y==7)&&(w))? 1 :\n\t\t   ((y==3)||(y==5)||(y==6))? 0 :\n\t\t   ~w;\n\t\t\t   \n\tassign Y4 = ((y==5)&&(w)) ? 1:\n\t\t    (((y==2)||(y==4)||(y==7)) ? 0:\n\t\t\t~w);\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\t// One-Hot Encoding for States A={000001}, B={000010}, C={000100}, D={001000}, E={010000}, F={100000}\n\twire a = y[6]; // State A (0)\n\twire b = y[5]; // State B (0)\n\twire c = y[4]; // State C (0)\n\twire d = y[3]; // State D (0)\n\twire e = y[2]; // State E (1)\n\twire f = y[1]; // State F (1)\n\t\n\t// Next-State Signals for y[2] and y[4]: Y2 and Y4\n\tassign Y2 = a | (b & w) | (c & ~w); \n\tassign Y4 = d | ((e & ~w) | f); \nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = ((y[5]) ? (w) : (~y[3])) | ((~y[5]) & (y[4]) & (~y[1]));\n    assign Y4 = ((y[6]) ? (w) : ((y[5]) ? (~y[2]) : (~y[4])));\nendmodule\n"}
{"task_id": "reduction", "completion": "\n\n\tassign parity = ^in;\n\t\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in; //XOR operator\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in;\nendmodule\n\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor =  ~(a ^ b) ;\n\tassign out_anotb = a & ~b; \nendmodule\n"}
{"task_id": "gates", "completion": "\n    \n    assign out_and = a & b;\n\tassign out_or  = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = a ~^ b;\n\tassign out_anotb  = a & ~b;\n    \nendmodule\n"}
{"task_id": "gates", "completion": "\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule \n"}
{"task_id": "wire_decl", "completion": "\n\t// Intermediate wire declarations\n\twire and1; \n\twire and2;\n\n\t// First layer of gates\n\tassign and1 = a & b;\n\tassign and2 = c & d;\n\n\t// Second layer of gates\n\tassign out = and1 | and2;\n\tassign out_n = ~out;\n\t\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\t// Intermediate wires\n\twire and1;\n\twire and2;\n\t\n\tand #50 (and1, a, b);  // first AND gate\n\tand #50 (and2, c, d);  // second AND gate\n\tor  #50 (out, and1, and2);  // OR gate\n\tnot #50 (out_n, out);  // NOT gate\n\nendmodule\n\n"}
{"task_id": "wire_decl", "completion": "\n\t// Declare intermediate wire\n\twire and1;\n\n\t// First layer of gates\n\tassign and1 = a & b;  // AND gate connected to 'a' and 'b'\n\tassign out = c & d;   // Output OR gate connected to 'c' and 'd'\n\n\t// Second layer of gates, including NOT gate for inverted output 'out_n'\n\tassign out_n = ~(and1 | out);  // Inverted (NOT) gate on the result of first layer operations.\n\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire temp_p1, temp_p2;\n\n\tassign temp_p1 = (p1a & p1b & p1c) | (p1d & p1e & p1f);\n\tassign temp_p2 = (p2a & p2b) | (p2c & p2d);\n\n\tassign p1y = temp_p1;\n\tassign p2y = temp_p2;\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire w1;\n\tassign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);\n\tassign p2y = (p2a & p2b) | (p2c & p2d); \nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire w1;\n\twire w2;\n\twire w3;\n\twire w4;\n\n\tassign p1y = (w1 | w2);\n\tassign p2y = (w3 | w4);\n\n\tassign w1 = p1a & p1b & p1c;\n\tassign w2 = p1d & p1e & p1f;\n\tassign w3 = p2a & p2b;\n\tassign w4 = p2c & p2d;\nendmodule\n\n"}
{"task_id": "2012_q2fsm", "completion": "\n\t// State Codes 0-A, 1-B, 2-C, 3-D, 4-E and 5-F\n\treg [1:0] state;\n\twire [1:0] ns; // Next State\n\t\t  \n\t//State Table\n\talways @(*) begin\n\tcase (state) \n\t\t\t2'b00: if (w==0) ns = 2'b01; else ns = 2'b10;\n\t\t\t2'b01: if (w==0) ns = 2'b00; else ns = 2'b11;\n\t\t\t2'b10: if (w==0) ns = 2'b03; else ns = 2'b02;\n\t\t\t2'b11: if (w==0) ns = 2'b04; else ns = 2'b05; \n\t\t\t2'b02: if (w==0) ns = 2'b10; else ns = 2'b03;\n\t\t\t2'b03: if (w==0) ns = 2'b10; else"}
{"task_id": "2012_q2fsm", "completion": "\n\treg [2:0] current_state; // 3 bit state register\n\tparameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n\tassign z = (current_state == E && w == 1) || current_state == F; // Output depends on the state and input\n\t\n\t// State table\n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset)\n\t\t    current_state <= A; // Reset state to A\n\t\telse\n\t\t    case (current_state)\n\t\t\t    default: current_state <= A;\n\t\t\t    A : if (w == 0) current_state <= A; else current_state <= B; \n\t\t\t    B : if (w == 0) current_state <= A; else current_state <= C;\n\t\t\t    C : if (w == 0) current_state <= D; else current_state <= E;\n\t\t\t    D : if (w == 0) current_state <= A; else current_state <= F"}
{"task_id": "2012_q2fsm", "completion": " \n\t// Define the states as constants\n\tlocalparam [2:0] A = 3'b000;\n\tlocalparam [2:0] B = 3'b010;\n\tlocalparam [2:0] C = 3'b001;\n\tlocalparam [2:0] D = 3'b100;\n\tlocalparam [2:0] E = 3'b110;\n\tlocalparam [2:0] F = 3'b101;\n\n\t// Declare the state flip-flop\n\treg [2:0] state_ff; \n\n\t// State transition table\n\talways @(*) begin\n\t\t\tcase (state_ff)\n\t\t\t\tA : w ? B : A; // If w=0 then stay in A, if w=1 then go to B\n\t\t\t\tB : w ? C : D; // If w=0 then go to D, if w=1 then go to C \n\t\t\t\tC : w ? E : D; // If w=0 then go to D, if w=1 then go to E \n\t\t\t\tD : w"}
{"task_id": "count_clock", "completion": "\n\t// BCD to binary conversion for 4 bits\n\tfunction[3:0] bcd2bin;\n     input [7:0] bcd_in;\n     begin\n        case(bcd_in)\n         8'h04: bcd2bin = 4'd0;  8'h0C: bcd2bin = 4'd1;  8'h1C: bcd2bin = 4'd2; \n         8'h2C: bcd2bin = 4'd3;  8'h3C: bcd2bin = 4'd4;  8'h4C: bcd2bin = 4'd5; \n         8'h5C: bcd2bin = 4'd6;  8'h6C: bcd2bin = 4'd7;  8'h7C: bcd2bin = 4'd8; \n         8'h8C: bcd2bin = 4'd9;  default: bcd2bin = 4'd0;\n        endcase\n     end\n\tendfunction\n\n\t// Binary to B"}
{"task_id": "count_clock", "completion": "\n\talways @(posedge clk or posedge reset) begin \n\t    if (reset == 1'b1) begin\n\t\t    hh <= 8'd1;\n\t\t    mm <= 8'd2;\n\t\t    ss <= 8'd0;\n\t\t    pm <= 1'b0;\n\t\tend\n\t    else if (ena == 1'b1)  begin\n            ss <= ss + 1;\n\t        if(ss==59 && ena == 1'b1) begin\n                ss <= 8'd0;\n\t            mm <= mm +1 ;\n\t\t        if(mm==60 && ena == 1'b1 )begin \n\t\t\t        mm <= 8'd0;\n\t\t\t        hh <= hh + 1;  \n\t\t\t        if((hh[3:0]==4'd9 || hh[3:0]==4'd1)&&(hh[7:4]<2)) begin \n\t\t\t\t       pm <= ~pm;\n\t\t            end   \n                    if (hh == 8'd12 && ena == 1'b1 ) begin  \n\t\t\t           hh"}
{"task_id": "count_clock", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) \n            {hh, mm, ss} <= 8'h1200; // 12:00 AM in BCD.\n         else if (ena == 1'b1) begin\n              ss <= ss + 1;\n            \tif(ss==8'd59)begin   // Once the seconds reach 60, reset and increment minutes.\n                \tss <= 8'h00;\n                    mm <= mm + 1;\n                 \tif(mm==8'd59) begin  // Once the minutes reach 60, reset and increment hours.\n                        mm <= 8'h00;\n                     \thh <= hh + 1;  \n                       if((hh & 8'h0f) > 8'h09 || (hh & 8'h70) > 8'h20) begin // If the tens digit of hours is greater than 2 or ones digit is greater than 9 then add 6 and set PM.\n                        \tpm <= ~pm;   \n                        hh <= (hh"}
{"task_id": "2014_q4a", "completion": "\nalways @(posedge clk) begin\n\tif(R & L) // Loading from input value 'w' when both load and reset are asserted. \n\t\tQ <= w;\n\telse if (E) // Shifting when enable is high.\n\t\tQ <= $urandom;\nend\n\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n\n\t// Flip-Flop with Asynchronous Reset and Synchronous Set\n\talways @(posedge clk or negedge R) begin \n\t    if (!R)\n\t\t    Q <= 0; // reset to 0 when R is 0\n        else if (L)\n            Q <= w; // set to input w when L is 1\n\t    else if (E)\n\t\t      Q <= {Q[$left(Q):1], w}; // shift right on enable\n\tend\n\t\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n\n\talways @(posedge clk) begin\n\t    if(R & L) // Loading from input R when asserted L\n\t\t    Q <= R;\n        else if (E)  // Shift enabled\n            Q <= w;\n\tend\nendmodule\n\n"}
{"task_id": "rule90", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse \n\t\t\tfor (integer i = 1 ; i < 512 ; ++i)\n\t\t\t\tbegin \n\t\t\t\t    q[i] <= ~(q[i-1] ^ q[i+1]);\n\t\t\t\tend\n\tend\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\treg [512:0] next; // Temporal variable for the next state\n\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse begin\n\t\t\tfor (integer i=0; i<512; i++) \n\t\t\t\tcase({q[i-1], q[i+1]}) // Current neighbours\n\t\t\t\t\t2'b11: next[i] = ~q[i]; // Rule 90 application\n\t\t\t\t\t2'b10: next[i] = q[i];\n\t\t\t\t\t2'b01: next[i] = q[i];\n\t\t\t\t\tdefault: next[i] = ~q[i];\n\t\t\t\tendcase\n\t\t\tq <= next[511:0]; // Update current state\n\tend\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse\n\t\t\tfor(int i = 0; i < 512; ++i)\n\t\t\t\tq[i] <= q[i-1] ^ q[(i+1)%512];  // modulus operator to make it a cyclic array (like toroidal space)\n\tend\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\t// Declare states as enum\n    typedef enum logic [1:0] {LEFT = 2'b01, RIGHT = 2'b10} state_t;\n    \n    // Declare the current and next states\n    state_t state, next_state;\n    \n    always @(posedge clk or posedge areset) begin \n        if (areset) begin\n            state <= LEFT;  \n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // State transition logic and output decoding\n\talways_comb begin\n\t    walk_left = 0;\n\t    walk_right = 0;\n        aaah = 0; \n        \n\t\tcase (state)\n\t\t\tLEFT: begin\n\t\t\t\tif(bump_right & ~ground) begin\n                    next_state = RIGHT; // Bumped right, fall and switch direction\n                end else if (~bump_left | ground )begin\n\t\t\t\t    walk_left = 1'b1; \n\t\t\t\t    aaah = ~(bump_left&~ground); // Say \"aaah"}
{"task_id": "lemmings2", "completion": "\n\t// Declare states \n\ttypedef enum logic [1:0] {LEFT = 2'b01, RIGHT = 2'b10} State;\n\tState state; // Current State \n\tState next_state; // Next State\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin // Reseting to default LEFT\n            state <= LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\t\n\t// Next State Logic \n\talways @(*) begin\n\t    unique case (1'b1)\n\t        state == LEFT: begin\n\t            if ((ground == 1'b0) && bump_left == 1'b0 && bump_right == 1'b0 ) next_state = RIGHT; // falling, do nothing \n                else if(bump_left == 1'b1) next_state = RIGHT;   //bumping left, walk right\n\t            else if ((ground==1'b1 || (ground ==1'b0 && bump_right == 1'b1))"}
{"task_id": "lemmings2", "completion": "\n\n\t// Define the states\n\ttypedef enum logic [1:0] {LEFT = 2'b00, RIGHT = 2'b01, FALLING = 2'b10} state_t;\n\tstate_t current_state, next_state;\n    \n    // State transition\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tcurrent_state <= LEFT;\n\t\telse \n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// Next state and outputs decoding\n\talways_comb begin\n\t\tcase(current_state)\n\t\t\tLEFT: begin\n\t\t\t\tif (ground == 0) \n\t\t\t\t\tnext_state = FALLING;\n\t\t\t\telse if (bump_right) \n\t\t\t\t\tnext_state = RIGHT;\n\t\t\t\telse \n\t\t\t\t\tnext_state = LEFT;\n                 walk_left = 1'b1;\n                walk_right = 1'b0;\n                aaah = 1'b0;\n\t\t\tend\n           \n\t\t\tRIGHT: begin\n\t\t\t\tif ("}
{"task_id": "ece241_2014_q5a", "completion": "\n\t// Define the states of Moore machine\n\ttypedef enum {IDLE, START_NEGATE, NEGATING} state_t;\n\tstate_t state, nextState;\n\n\treg [31:0] shiftRegister;  // Use a 32-bit register to handle maximum length input numbers\n\twire shiftedX = x ^ (shiftRegister[31] & ~areset);  \n\tassign z = ~(state == NEGATING) & shiftRegister[31];\n\n\t// Next state logic and output logic in the Moore machine\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: nextState = x ? START_NEGATE : IDLE;\n\t\t\tSTART_NEGATE: nextState = NEGATING;\n\t\t\tNEGATING: nextState = shiftedX ? NEGATING : IDLE;  // Go back to idle state when shifting in a new bit\n\t\tendcase\n\tend\n\n\t// Synchronous part of Moore machine\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <="}
{"task_id": "ece241_2014_q5a", "completion": " \n    reg [23:0] q; // assuming the input number is of 24 bit length. You may adjust this as per your requirement\n    \n\talways @(posedge clk or posedge areset) begin\n        if (areset == 1'b1)\n            q <= 24'd0;  \n        else \n            q <= {q[22:0], x}; // shift the input bits to left and append new bit on MSB position.\n    end\n    \n\tassign z = q[23]; // output the most significant bit as it is complement of the input number\nendmodule  \n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\n\treg [31:0] state;\n\tassign z = state[31];\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) \n\t\t\tstate <= 32'h0;\n\t\telse if (areset == 1'b0) \n\t\t\tstate <= {state[30:0], x};\n\tend\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule \n\n"}
{"task_id": "vector2", "completion": "\n\n\tassign out = {in[7:0],in[15:8],in[23:16],in[31:24]};\n\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @* begin\n\tcase (y) \n\t\t3'b000 : if(!w) Y2 = 1; else Y2 = 0; // State A\n\t\t3'b001 : if(!w) Y2 = 0; else Y2 = 0; // State B\n\t\t3'b010 : if(!w) Y2 = 1; else Y2 = 0; // State C\n\t\t3'b011 : if(!w) Y2 = 1; else Y2 = 0; // State D\n\t\t3'b100 : if( w) Y2 = y[1]; else Y2 = 0; // State E\n\t\t3'b101 : if(!w) Y2 = 1; else Y2 = 0; // State F\n\t\t// default case is not needed as each state will be covered by above cases \n\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\nalways @(*) begin\n\tcase (y) \n\t\t3'b000 : if (w) Y2 = 1; else Y2 = 0; // State A\n\t\t3'b001 : if (w) Y2 = 0; else Y2 = 0; // State B\n\t\t3'b010 : if (w) Y2 = 1; else Y2 = 1; // State C\n\t\t3'b011 : if (w) Y2 = 0; else Y2 = 0; // State D\n\t\t3'b100 : if (w) Y2 = 1; else Y2 = 0; // State E\n\t\t// 3'b101 : If w=0 then stay in state F, else go back to state D.\n\t\t3'b101 : if (w) Y2 = 0; else Y2 = 1; \n\t\tdefault: Y2 = 0; // Default State\n\tendcase\nend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\nalways @(*) begin\n    case ({y[3],y[2],w}) \n        3'b000: begin Y2 = 0; end // A\n        3'b100: begin Y2 = 1; end // B\n        3'b110: begin Y2 = 0; end // C\n        3'b001: begin Y2 = 0; end // D\n        3'b011: begin Y2 = 1; end // E\n        3'b010: begin Y2 = 0; end // F\n        default: begin Y2 = 'x; end \n    endcase\nend  \n"}
{"task_id": "kmap1", "completion": "\n    assign out = (b & ~c) | (~a & c) | (~a & ~b) | (a & ~c & ~b) | (a & c & ~b);\n    \nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n    assign out = (!b && !c) || (a && !c) || (a && b) || (!a && c);\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\nassign out = (b & ~c) | a | (b & c);\nendmodule\n"}
{"task_id": "circuit2", "completion": "\n\twire [3:0] data;\n\tassign data = {a,b,c,d};\n\t\n\talways @(*) begin\n\tcase (data)\n\t\t4'h1 : q = 0;  // a=0 b=0 c=0 d=1\n\t\t4'h2 : q = 0;  // a=0 b=0 c=1 d=0\n\t\t4'h3 : q = 0;  // a=0 b=0 c=1 d=1\n\t\t4'h8 : q = 0;  // a=0 b=1 c=0 d=0\n\t\t// ...\n\t\t4'he: q = 1;  // a=1 b=e c=0 d=0\n\t\t4'hf: q = 1;  // a=1 b=f c=0 d=0\n\t\tdefault : q = data[3];  // default value for other cases\n\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "circuit2", "completion": "\n\treg [3:0] state;\n\n\talways @(*) begin\n\t\tcase({a,b,c,d})\n\t\t\t4'b0000 : state = 4'b1 ;  // initial state\n      \t\t4'b0001 : state = 4'b0 ; \n      \t\t4'b0010 : state = 4'b1 ; \n      \t\t4'b0011 : state = 4'b0 ; \n      \t\t4'b0100 : state = 4'b1 ;  \n\t\t// and so on...\n\t\t\t4'b1110 : state = 4'b0 ;\n      \t\t4'b1111 : state = 4'b1 ; // loop back to initial state\n    \t\tdefault : state = 4'bx;  // undefined state\n  \t\tendcase\n   \tend\n\tassign q = state[3]; // assign output q as the fourth bit of state\n\nendmodule\n"}
{"task_id": "circuit2", "completion": "\nreg q;\nalways @(*) begin\n\tcase({a,b,c,d})\n\t\t4'b0001 : q <= 1;\n\t\t4'b0010 : q <= 0;\n\t\t4'b0011 : q <= 1;\n\t\t4'b0100 : q <= 0;\n\t\t4'b0101 : q <= 1;\n\t\t4'b0110 : q <= 1;\n\t\t4'b0111 : q <= 0;\n\t\t4'b1000 : q <= 0;\n\t\t4'b1001 : q <= 1;\n\t\t4'b1010 : q <= 1;\n\t\t4'b1011 : q <= 0;\n\t\t4'b1100 : q <= 0;\n\t\t4'b1101 : q <= 1;\n\t\t4'b1110 : q <= 1;\n\t\t4'b1111 : q <= 0;\n\t\tdefault:  q <= 'x; // undefined\n\tendcase\nend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a; \n\n\talways @(*) begin  \n\t\tif (sel_b1 & sel_b2)\n\t\t\tout_always <= b;\n\t\telse \n\t\t\tout_always <= a;\n\tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statement\n    assign out_assign = sel_b1 && sel_b2 ? b : a;\n    \n    // Using always procedural block\n\talways @(*) begin \n\t\tif (sel_b1 && sel_b2)\n\t\t\tout_always = b;\n\t\telse\n\t\t\tout_always = a;\n\tend\n\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t\n\t// Using assign statements.\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\t\n\t// Using procedural if statement.\n\talways @(*) begin \n\t\tif ((sel_b1 == 1'b1) && (sel_b2 == 1'b1))\n\t\t\tout_always = b;\n\t\telse\n\t\t\tout_always = a;\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\t// Declare the 8-bit shift register and its flip flops\n\treg [7:0] Q;\n\n\t// The always block to handle clocked operations\n\talways @(posedge clk) begin\n\t\tif (enable)\n\t\t\tQ <= {Q[6:0], S}; // Shift in the input bit when enable is high\n\tend \n\n\t// Declare multiplexers for each ABC combination and assign them to Z\n\tassign Z = A ? Q[1] :\n\t\t\t   B ? Q[2] :\n\t\t\t   C ? Q[3] :\n\t\t\t\t Q[0]; // Defaults to Q[0] if ABC is 000\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\t// Internal signals for flip-flops and shift register\n\treg [7:0] Q_reg;\n\twire [8:0] shifted_Q; // 9 bits to accommodate the shifting of Q[0] into S\n\tassign Z = ({A, B, C} == 3'b000) ? Q_reg[0] : \n\t\t\t   ({A, B, C} == 3'b001) ? Q_reg[1] :\n\t\t\t   ({A, B, C} == 3'b010) ? Q_reg[2] : \n\t\t\t   ({A, B, C} == 3'b011) ? Q_reg[3] : \n\t\t\t   ({A, B, C} == 3'b100) ? Q_reg[4] : \n\t\t\t   ({A, B, C} == 3'b101) ? Q_reg[5] : \n\t\t\t   ({A, B, C} == 3'b110) ? Q_reg[6] : \n\t\t\t   ({A, B"}
{"task_id": "ece241_2013_q12", "completion": "\n\treg [7:0] Q;  //8-bit shift register\n\twire [2:0] ABC = {A,B,C};\n\tassign Z = Q[ABC];\n\n\talways @(posedge clk) begin\n\t\tif (enable)\n\t\t\tQ <= {S, Q[7:1]};  //Shift in S and shift out the MSB\n\tend\nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 4'h0;\n\t\telse if (load) \n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tq <= {q[2:0], 1'b0};\n\tend\n\nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 4'b0;\n\t\telse if (load) \n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tq <= {q[2:0], 1'b0};\n\tend\n\nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t   q <= 4'b0;\n\telse if (load)\n\t   q <= data;\n        else if (ena) \n\t    q <= {q[2:0],1'b0};\n    end \nendmodule\n"}
{"task_id": "shift18", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= {q[62:0],1'b0}; // Shift Left by 1 bit\n\t\t\t\t2'b01: q <= {q[55:0],8'h0};  // Shift left by 8 bits\n\t\t\t\t2'b10: q <= {1'b0,q[63:1]};  // Arithmetic Right shift by 1 bit\n\t\t\t\t2'b11: q <= {8'h0,q[55:0]};   // Arithmetic Right Shift by 8 bits\n\t\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "shift18", "completion": "\n\n\t// Shift Left by 1 bit\n\tfunction[63:0] shift_left_by_one;\n\t\tinput [63:0] x;\n\t\tshift_left_by_one = {x[62:0], x[63]};\n\tendfunction\n\t\n\t// Shift Left by 8 bits\n\tfunction[63:0] shift_left_by_eight;\n\t\tinput [63:0] x;\n\t\tshift_left_by_eight = {x[55:0], x[63:56]};\n\tendfunction\n\t\n\t// Shift Right by 1 bit (Arithmetic right)\n\tfunction[63:0] shift_right_by_one;\n\t\tinput [63:0] x;\n\t\tshift_right_by_one = {x[62], x[63:1]};\n\tendfunction\n\t\n\t// Shift Right by 8 bits (Arithmetic right)\n\tfunction[63:0] shift_right_by_eight;\n\t\tinput [63:0] x;\n"}
{"task_id": "shift18", "completion": "\n\t\n\t\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tcase (amount)\n\t\t\t\t2'b00 : q <= {q[62:0],1'b0};\n\t\t\t\t2'b01 : q <= {q[55:0],8'h0};\n\t\t\t\t2'b10 : q <= {1'b0,q[63:1]};\n\t\t\t\t2'b11 : q <= {8'h0,q[55:0]};\n\t\t\tendcase\n\tend\nendmodule \n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n\t\tif(r) \n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\nalways @(posedge clk or posedge r) begin\n\tif(r == 1'b1)  //reset active high\n\t\tq <= 0;\n\telse if (d != 1'bx && d != 1'bz)  //ignore undefined states on inputs\n\t\tq <= d;\nend\nendmodule\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n\t\tif (r) \n\t\t\tq <= 1'b0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\t// State definitions \n\tlocalparam [1:0] S0 = 2'd0;\n\tlocalparam [1:0] S1 = 2'd1;\n\tlocalparam [1:0] S2 = 2'd2;\n\t\t  \n\t// Current state and next state signals\n\treg [1:0] current_state, next_state;\n\t\t\t \n\t// FSM state transition logic\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn) \n\t\t\tcurrent_state <= S0; // reset to state 0 on asynchronous reset\n\t\telse \n\t\t\tcurrent_state <= next_state;\n\tend\n\t\t\t \n\t// FSM output logic\n\talways @(*) begin \n\t    case (current_state) \n\t        S1: if (x) begin z = 1'b1; end else z=0; // If in state 1, assert z on input x.\n\t        default: z = 1'b0; // In other states, deassert z.\n\t    endcase\n\tend\n\t\t\t  \n\t// FSM next-state"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state;\n\tparameter S0 = 2'd0, S1 = 2'd1, S2 = 2'd2;\n\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif(!aresetn) \n\t\t\tstate <= S0;\n\t\telse\n\t\t\tcase (state)\n\t\t\t\tS0: if(x) state <= S1;\n\t\t\t\tS1: if(x) state <= S2; else state <= S0;\n\t\t\t\tS2: if(x) begin state <= S2; z <= 1'b1; end else begin state <= S0; z <= 1'b0; end\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state;\n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif(!aresetn) begin \n\t\t\tstate <= S0;\n\t\t\tz <= 0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tS0: if (x == 1'b1) begin state <= S1; z <= 0; end else state <= S0;\n\t\t\t\tS1: if (x == 1'b0) begin state <= S2; z <= 0; end else state <= S1;\n\t\t\t\tS2: if (x == 1'b1) begin state <= S0; z <= 1; end else begin state <= S2; z <= 0; end \n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n\n"}
{"task_id": "fsm1s", "completion": "\n\treg state; // State variable\n    \n    always @(posedge clk or posedge reset) begin  // Synchronous part\n        if (reset)  \n            state <= 1'b0;  // Reset to state B\n        else \n           case (state) \n              1'b0: state <= in;\n              1'b1: state <= ~in;\n           endcase   \n    end\n    \n    assign out = state; // Output assignment based on state variable\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n\n\treg state;\n\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset)\n        \tstate <= 1'b0; // B State\n    \telse if (!in && state == 1'b0) \n        \tstate <= 1'b0;\n        else if (in && state == 1'b0) \n        \tstate <= 1'b1;\n        else if (!in && state == 1'b1)  \n            state <= 1'b1;\n    \telse // in==1 and state is A or any other value\n        \tstate <= 1'b0;\n    end\n\t\n\t// Output Logic\n\tassign out = state;\nendmodule\n\n"}
{"task_id": "fsm1s", "completion": "\n\treg state; // State variable to hold the current state.\n\twire nextState;\n\tassign nextState = !state && in || state && !in; \n\tassign out=state;\n\t// Synchronous reset and state transition\n\talways @(posedge clk or posedge reset) begin\n\tif (reset) // Reset condition, set the initial state B.\n\t\t\tstate <= 1'b1;  \n\telse       // Normal operation, update state based on nextState logic\n\t\t\tstate <= nextState; \n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n    \n    assign out = 1'b0;\nendmodule\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\n\tassign out = 1'b0;\n\t\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\treg [2:0] count;\n\tassign ena = {count[2], count[1], 1'b0};\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'h0;\n\t\t\tcount <= 3'h4; // start from 999 instead of 000 for the first increment\n\t\tend else if (count[2:1] == 2'b11) begin\n\t\t\tq <= {q[8:0], q[15]}; // rotate right by one bit, discarding the leftmost bit\n\t\t\tcount <= 3'h4;  // reset count to start from 9 again after incrementing all digits\n\t\tend else begin\n\t\t\tcase (count)\n\t\t\t\t2'b00: q[15:8] <= q[15:8] + 1; ena[3:1] <= 1'b0; // tens digit, no need to enable\n\t\t\t\t2'b01: q[7:4]  <= q[7:4]  + 1;"}
{"task_id": "countbcd", "completion": "\n\n\treg [2:0] digit = 0; // Select the current digit to be incremented. \n\tassign ena[digit+1] = (q[(4*(digit+1)-1):(4*digit)] != 9); // If not a nine, enable next digit.\n\t\t\n\talways @(posedge clk) begin\n\t    if (reset == 1'b1) begin\n\t        q <= 0;\n\t        digit <= 2'b0;\n\t    end \n\t    else if ((q[(4*(digit+1)-1):(4*digit)] != 9)) begin // If the current digit is not a nine, increment it.\n\t    \tq[((digit+1)*4-1):(digit*4)] <= q[((digit+1)*4-1):(digit*4)] + 4'b0001; \n\t    end  \n\t    else if ((q[(4*(digit+1)-1):(4*digit)] == 9) && (digit < 2)) begin // If the current digit is a nine, reset it and increment next digit."}
{"task_id": "countbcd", "completion": "\n\n\t// Define states for each digit of the BCD counter\n\tlocalparam [4:0] ZERO = 5'b0_0000; // 0\n\tlocalparam [4:0] ONE  = 5'b1_0000; // 1, enable tens\n\tlocalparam [4:0] TWO  = 5'b0_1000; // 2, disable all\n\tlocalparam [4:0] THREE = 5'b1_1000;// 3, enable hundreds\n\tlocalparam [4:0] FOUR = 5'b0_0100; // 4, disable tens and tens_enable\n\tlocalparam [4:0] FIVE  = 5'b1_0100; // 5, enable thousands\n\tlocalparam [4:0] SIX   = 5'b0_1100; // 6, disable hundreds_enable\n\tlocalparam [4:0] SEVEN = 5'b1_1100;// 7, enable all\n\tlocalparam [4:0] E"}
{"task_id": "popcount255", "completion": "\n    always @(in) begin\n        out = 8'd0;\n        for(integer i=0; i<255; i++) \n            if (in[i]) \n                out = out + 1;\n   end\nendmodule\n\n"}
{"task_id": "popcount255", "completion": "\n\talways @(*) begin\n\t\tout = 8'b0;\n\t\tfor (integer i=0;i<255;i++) \n\t\t\tif (in[i]) \n\t\t\t\tout = out + 1;\n\tend\n\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\talways @* begin\n\t\tout = 'b0;\n\t\tfor(integer i=0 ; i< 255; i++) begin\n\t\t\tif (in[i]) \n\t\t\t\tout +=1;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n\treg [2:0] next_state;\n\talways @(*) begin\n\t\tcase (y) \n\t\t\t3'b000: if (x==1'b0) next_state <= 3'b000; else next_state <= 3'b001;\n      \t\t3'b001: if (x==1'b0) next_state <= 3'b001; else next_state <= 3'b100;\n\t        \t3'b010: if (x==1'b0) next_state <= 3'b010; else next_state <= 3'b001;\n      \t\t3'b011: if (x==1'b0) next_state <= 3'b001; else next_state <= 3'b010;\n      \t\t3'b100: if (x==1'b0) next_state <= 3'b011; else next_state <= 3'b100;\n    \t\tendcase\n  \tend \n\n\talways @(posedge cl"}
{"task_id": "2014_q3c", "completion": "\n\n\talways @(posedge clk) begin\n\tcase({x,y})\n\t\t3'b0_00 : begin Y[2:0] <= 3'd0; z <= 1'b0; end\n\t\t3'b0_01 : begin Y[2:0] <= 3'd0; z <= 1'b0; end\n\t\t3'b0_10 : begin Y[2:0] <= 3'd1; z <= 1'b0; end\n\t\t3'b1_01 : begin Y[2:0] <= 3'd0; z <= 1'b1; end \n\t\t3'b0_11 : begin Y[2:0] <= 3'd1; z <= 1'b0; end\n\t\t3'b1_10 : begin Y[2:0] <= 3'd3; z <= 1'b1; end\n\t\tdefault  : begin Y[2:0] <= y;   z <= x;    end // No change\n\tendcase\n\tY0 <= Y[0];\n\tend\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\nalways @(posedge clk) begin\n\tcase({x,y}) \n\t\t3'b0_00: {Y0, y} <= 3'b0_00; // next state is the same as current\n\t\t3'b1_00: {Y0, y} <= 3'b0_01; // go to state 001 if x=1 and y = 000\n\t\t3'b0_01: {Y0, y} <= (x)?3'b1_00:3'b0_01; // stay at state 001 or move to state 100 if x=1\n\t\t3'b0_10: {Y0, y} <= 3'b0_10; // go to state 010 if x = 0 and y =  000\n\t\t3'b1_10: {Y0, y} <= (x)?3'b0_01:3'b0_10;// stay at state 010 or move to state 001 if x=1\t\n\t\t3'b"}
{"task_id": "thermostat", "completion": "\n\tassign heater = (mode == 1'b0) & too_cold; // in cooling mode and if it is too cold turn on the heater\n\tassign aircon = (mode == 1'b1) & too_hot;  // in heating mode and if it is too hot turn on the air conditioning\n\tassign fan = |{heater, aircon} | fan_on;   // turn on the fan when either of the heater or air conditioner is on or requested by user. \n\t\nendmodule\n"}
{"task_id": "thermostat", "completion": "\n\tassign heater = (mode == 1'b0) ? 1'b0 : too_cold;\n\tassign aircon = (mode == 1'b1) ? 1'b0 : too_hot;\n\tassign fan = ((heater | aircon) == 1'b1) | fan_on;\nendmodule\n"}
{"task_id": "thermostat", "completion": "\nassign heater = (mode & ~too_cold) | fan_on;\nassign aircon = ~mode & too_hot;\nassign fan = heater | aircon | fan_on;\nendmodule \n\n"}
{"task_id": "2012_q2b", "completion": "\n\n\t// Assuming the state flip flops are synchronous and active high.\n\tassign Y1 = w && (y[2]); // For state B or D\n\tassign Y3 = w && (y[4] | y[5]) || !(w && y[0]) && y[1]; // For states C, E, F or A\n\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\n    assign Y1 = |({w,y[4],y[2],y[0]} & 6'h1f); // Bitwise and with the one-hot encoding to selectively extract bits. Then OR gate is used for any of them being '1'.\n\tassign Y3 = |({w,y[4],y[2],~y[0]} & 6'h1f); // For y[3] bit we need to invert the y[0].\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\tassign Y1 = w ? (y[4]) : (y[2]);\n\tassign Y3 = w ? (y[6] | ~(y[5])) : (~(y[3]) & y[0]);\nendmodule\n\n"}
