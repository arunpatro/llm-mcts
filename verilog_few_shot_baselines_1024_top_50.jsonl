{"task_id": "review2015_fsmonehot", "completion": "\n   assign B3_next = (state[7] & d) | state[8]; // go to next state at every clock cycle as long as in the B3 state \n\tassign S_next = ~state[0] & ~(state[1] & d);\n\tassign S1_next = ~state[1] & (d|state[2]);\n    assign Count_next = state[8] & done_counting; // stay in the counting state as long as counter is not done \n    assign Wait_next = state[9] & ack ;// go to S after one clock cycle if in waiting state and ack is received\n\tassign done = ~state[1]; // when in B3 (done=0) and in all other states(done=1). This logic is used to inform the outside world that counting/shifting has finished.\n    assign counting = state[8];  // if at state Count\n\tassign shift_ena = |state[7:4]; // enabled as long as machine is in B0, B1, B2 or B3 states. This signal tells outside the component to start shifting (to count)  \n"}
{"task_id": "review2015_fsmonehot", "completion": "\n// state definitions\nlocalparam [9:0] S     = 10'b0000000001;\nlocalparam [9:0] S1    = 10'b0000000010;\nlocalparam [9:0] S11   = 10'b0000000100;\nlocalparam [9:0] S110  = 10'b0000001000;\nlocalparam [9:0] B0    = 10'b0000010000;\nlocalparam [9:0] B1    = 10'b0000100000;\nlocalparam [9:0] B2    = 10'b0001000000;\nlocalparam [9:0] B3    = 10'b0010000000;\nlocalparam [9:0] Count = 10'b0100000000;\nlocalparam [9:0] Wait  = 10'b1000000000;\n\t\n// next-state logic and output decoding\nalways @(*) begin\n    B3_next = state[B3];  // stay in B3 unless shift_ena goes high\n    S_next  = (~state[Count] & ~state[Wait]) | (d & state[S1]);     // to S from S if not counting or waiting, and also from S1 when d=1\n    S1_next = (d & state[S]) | (~state[Count] & ~state[Wait] & ~state[B3]);   // to S1 from S when d=1, otherwise stay in S1 unless counting or waiting or shifting\n\tcounting = ~state[Wait];  // counting is active if not in Wait state\n    Count_next = (done_counting & ~state[Count]) | (d & state[B3]);   // to Count from B3 when done_counting=1, otherwise stay in Count unless d=1\n\tWait_next = ~(ack & state[Count]);  // go to Wait if not ack and counting states active\n    shift_ena = |state[B0:B3];   // shift_ena goes high if any of B0-B3 states are active\n    done = state[Wait] & ~d;     // done is asserted when in the waiting state and d=0\nend \n\t\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign S_next = (state[0] & ~d) | (state[1] & d);\n    \n    assign S1_next = (state[1] & ~d) | (state[2] & d);\n    \n    //counting state and its next state\n    assign Count_next = state[9];   // always stay in the counting state when done_counting = 0 else move to Wait state.\n    assign counting = state[9];\n      \n\tassign B3_next = (state[7] & d) | (Count_next & ~done_counting); \n    \n\tassign Wait_next= (state[8] & ack) ; // when done = 1 and ack = 1, go back to state S.\n   \n\t//output logic\n    assign done = state[9];          // done will be '1' if we are in the Count state else '0'.\n    \n\tassign shift_ena= state[7] | state[8];  // shift_ena is '1' if we are either in B3 or Wait state.\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign {B3_next, S_next, S1_next, Count_next, Wait_next} = state;  // next-state logic for each state\n    \n\tassign counting = (state == 10'b1000000000);    // counting is high if current state is 'Count'\n\tassign done = (state == 10'b1000000000) & ~done_counting;  // done is high if current state is 'Count' and 'done_counting' is low\n    \n\tassign shift_ena = ~(state == {B3, S, S1, Count, Wait});   // shift enable is active only when not in states B3, S, S1 or Count or Wait\n    \n\tassign S_next = (state[0] == 1) & ~d;    // next state for 'S'\n\tassign S1_next = ((state[1] | state[2]) == 1) & d;  // next state for 'S1' and 'S11'\n\tassign B3_next = (state[6:5] == 2'b01) & ~d;   // next state for 'B3'\n    \n\tassign Count_next = ((state == {9{10'b1000000000}}) | done_counting);  // counting is high if current state is 'Count' or 'done_counting' is high\n\tassign Wait_next = ~ack & (state == 10'b1000000000) & done_counting;    // next state for 'Wait'\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\talways @(*) begin\n\t    B3_next = 0;      // default values\n        S_next = 0; \n        S1_next = 0;  \n        Count_next = 0;\n        Wait_next = 0;   \n        done = 0;       // default values\n        counting = 0;        \n        shift_ena = 0;     \n\t    \n\t    if(state[8]) begin  // B3 state\n            if (d) begin   // stay in the same state\n                B3_next = 1; \n            end else begin  // go to next state\n                Count_next = 1;   \n            end          \n        end else if(state[0]) begin // S state\n            if (d==0 && ack) begin   // stay in the same state\n                S_next = 1; \n            end else if (d==1 & !ack) begin  // go to next state\n                B3_next = 1;   \n            end              \n        end else if(state[1]) begin  // S1 state\n\t\t\tif(!d) begin   // stay in the same state\n\t\t\t\tS1_next = 1;\n\t\t\tend else begin  // go to next state\n                B3_next = 1;    \n            end              \n        end else if(state[9]) begin  // Count state\n            counting = 1;   \n            done = done_counting;  \n            shift_ena = 1;        \n\t\tend else begin // Wait state\n\t\t\tif(ack) begin   // go to next state\n\t\t\t\tS_next = 1;     \n            end              \n        end \n    end    \nendmodule\n\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign B3_next = (state[7:0] == 9'b10000000) ? 1'b1 : 1'b0; // B3 is the last state\n    assign S_next   = (state[8:0] == 10'b000000001) ? 1'b1 : 1'b0;\n\tassign S1_next  = (state[8:0] == 10'b000000010) ? 1'b1 : 1'b0;\n    assign Count_next = ((state[9:7]==3'b100)&~done_counting)|((state[9:7]==3'b101)&(dones))? 1'b1 : 1'b0;// count state after counting or done is set\n    assign Wait_next = (state[8:6] == 3'b011) & ack ? 1'b1 : 1'b0; // wait state and move to S when ack is high\n\tassign done   = ((state[9:7]==3'b101)&done_counting)?1'b1:1'b0;//done = count and done_counting are high\n    assign counting= (state[9:7] == 3'b100) ? 1'b1 : 1'b0 ; // counting is in Count state\n\tassign shift_ena = ~(((state[8:6]==3'b001)&d)|((state[8:6]==3'b010)&d)|((state[9:7]==3'b100)&d))& ~done;// enable when shift state is B0,B1 and not done\n\t\nendmodule\n\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign B3_next = state[5] && (d == 0); // if we are in state B3 and d=0 then stay in B3 on the next cycle\n   assign S_next = ((state == 10'b0000000001) && !d) || (B3_next && d==1); \n\tassign S1_next = ((state == 10'b0000000010) && d) || (S_next && d==0); // if we are in state B3 and d=1 or in state S after one cycle when d = 0 then go to state S1\n   assign Count_next = ((state == 10'b0100000000) && !done_counting) || (S1_next && done_counting); // if we are in state S1 and not counting or when done is 0 then go to count state\n   assign Wait_next = ((state == 10'b0100000000) && done_counting) || (Count_next && !ack);// if we were in Count and ack was received then back to S1 else stay in Wait\n   \tassign counting = state[4]; // counting is the fourth bit of the current state (count = 1 when in count state, 0 otherwise)\n   assign done = state[9] && !ack;// if we are in wait and ack=0 then done is 1 else it's 0\n   \tassign shift_ena = (B3_next || S_next || S1_next); // enable when going to B3, S or S1 states for shift operation. \n\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n    \n    // State transition logic equations\n\tassign B3_next = state[7];       // For B3, always stay at the same state if d=0 else move to next state\n\tassign S_next = ~d & (state[1] | ((~state[2]) & ~(state[4]|state[5])) |  (state[8] & done_counting));  // For S, go to B3 on d=1 and stay at S if d=0 and count is not done\n\tassign S1_next = (d | state[2]) & ~(state[4]|state[5]);    // For S1, move to next state on d=1 else remain in current state\n\tassign Count_next = ~done_counting | (state[7]&ack);   // Go to Wait state if count is done and ack is high\n\tassign Wait_next = ack;    // Remain at wait state until ack goes high\n    \n\t// Output logic equations\n\tassign counting = state[8];  // Counting equals 1 when in the Count state\n\tassign done = ~(state[8] | (state[4]|state[5])) & ~d;   // Done is asserted if at either B0 or Wait state\n\tassign shift_ena = state[7] | (state[3]&ack);  // Shift enable will go high in B states and stay high till ack is high\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign B3_next = state[7] & (~done_counting);  // State transitions for B3 are based on the input of done_counting.\n\t\n\talways @(*) begin\n\t    S_next = 0;    // Initialize all next-state signals to 0 by default\n\t    S1_next = 0;\n\t    Count_next = 0;\n\t    Wait_next = 0;\n\t    \n        if (state[0])   // Check the current state, only update corresponding next-state signal if we are in this state.\n            S_next = ((~d) & ~ack) | (d & ack);  // S --> S or S1 based on d and ack inputs.\n        else if (state[1]) begin\n            S_next = d & ~ack;  // S1 --> S only when both d and not(ack) are 1\n            S1_next = ~d | ack;   // S1 --> S1 or S only when either d or ack is 1.\n        end else if (state[4]) begin  // Similar logic for states B3, Count and Wait.\n            Count_next = done_counting & state[8];    // Count --> Count while counting=1 and done_counting=1\n            S1_next = ~d | ack;\n        end else if (state[9]) begin\n            Wait_next = ((~done_counting) & d & ~ack);  // Wait --> Wait only when both d and not(ack) are 1.\n\t    Count_next = done_counting & state[8];\n\tend\n    end\n    \n\tassign counting = state[4] | state[9];   // Assign counting=1 for states Count and Wait\n\tassign shift_ena = ~state[3] & (~done_counting | state[7]);  // Shift enable is always available when we are not in B0,B1,B2 or Count state. And while counting=1 for Count or Wait.\n\tassign done = (~done_counting) & state[9];    // done signal is only generated if we are in the \"Wait\" state and not counting.\n    \nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n   assign B3_next = state[5] && d;     // B3 transitions only when d is 1\n   assign S_next = ~state[0] && ~d || (state[8] && ack);    // Transitions to S unless in B3 or Count\n   assign S1_next = state[1] && d || ~state[7];     // S transitions when d is 1, and not at end of count\n   assign Count_next = ~state[4] || (state[8] && done_counting);    // Count only if in B3 or start from S with !done_counting\n   assign Wait_next = state[9] || ~(state[8] ^ ack) && d;  // In Wait unless return to S after counting and ack=1\n\t\n   assign done = ~state[4];    // Only true in Count, which is the end of count state\n   assign counting = state[2] || state[9];  // True if at B3 or Wait\n   assign shift_ena = state[6];     // Shifting enable during B3 only\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": " \n\treg [9:0] B3,S,S1,Count,Wait;     // Declare the state register\n        reg [7:0] nextState;              // Temporary variable used to calculate the next state\n        assign {B3_next, S_next, S1_next, Count_next, Wait_next} = nextState;  // Assign the calculated next state to the output variables\n        \n\talways @(*) begin                 // Combinational logic block\n\t    case (state)                   // State selection using one-hot encoding\n                'b0000000001: if(d==0)    nextState = 8'b10000000;   // S -- d=0--> S\n                           else        nextState = 8'b01000000;  // S -- d=1--> S1\n                'b0000000010: if(d==0)    nextState = 8'b10000000;   // S1 -- d=0--> S\n                           else        nextState = 8'b10000010;  // S1 -- d=1--> S11\n                'b0000000100: if(d==1)    nextState = 8'b10100000;   // S11 -- d=1--> S11\n                           else        nextState = 8'b10100000;  // S11 -- d=0--> S11\n                'b0000100000: if(~d)      nextState = 8'b00100000;   // B3 -- shift_ena=1 and d=0--> B2\n                           else        nextState = 8'b00100000;  // B3 -- shift_ena=1 and d=1--> B3\n                'b0000010000: if(d)      nextState = 8'b00011000;   // Count -- done_counting--> Wait\n                           else        nextState = 8'b00010100;  // Count -- !done_counting--> Count\n                'b0100000000: if(~ack)    nextState = 8'b01000000;   // Wait -- done=1 and ack=0--> Wait\n                           else        nextState = 8'b00000000;  // Wait -- done=1 and ack=1--> S\n                default:                  nextState = 8'b00000000;    // Default state\n\t    endcase  \n\tend     \n         assign counting = (state==6) ? 1'b1 : 1'b0;     // Check if we are in Count state, assign output 'counting' accordingly\n        assign done = (state == 7 ) ? 1'b1: 1'b0;          // Check if we are in Wait state and ack=1, assign output 'done' accordingly\n        assign shift_ena = ~(|(state & {8{d}}));           // If the current state is B3 or after it and d==1 then shift_ena =0 else 1.\n        \nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\talways @(*) begin\n        B3_next = state[6];\n\t    S_next = (state[0] & !d) | (state[1] & d);\n    \tS1_next = (state[1] & !d) | (state[2] & d);\n    \tCount_next = ((state[7] & done_counting) | state[8]) & !ack;\n\t    Wait_next = (state[9] & done_counting & ack);\n\t    done = state[9];\n        counting = state[8];\n        shift_ena = |(state[6:3]);\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": " \n\tassign B3_next = (state[4] | state[7]);\t// if current state is B3 or B2, next state will be B3; otherwise it will remain the same.\n\tassign S1_next = (state[0] & d) | ((~&(state[9:5])) & ~d); // If at state S and input d = 1 then go to state S1. Otherwise if not in states S,S1,S11,S110 then remain the same\n\tassign Count_next = (state[8] | ((~&(state[9:5])) & done_counting)); // If at state Count or not in states S,S1,S11,S110 and input done_counting = 1 then go to state Count. Otherwise remain the same\n\tassign Wait_next = (state[9] | ((~&(state[9:5])) & ack)); // If at state Wait or not in states S,S1,S11,S110 and input ack = 1 then go to state Wait. Otherwise remain the same\n\tassign done = state[9];   \t// 'done' signal is active when the state machine is in state 'Wait'.\n\tassign counting = |state[7:5]; // The counting signal is active when the state machine is in states S1 or S11 or S110. (States 6, 7 and 8)\n\tassign shift_ena = ~|state[4:2]; // 'shift_ena' is active while the state is not at state B3(5),B2(6) or B1(7). i.e., it remains inactive when we are in these states. (States 0, 1 and 2)\n\tassign S_next = ((state[9:8]==2'b00) & ~d); // If current state is not at state S1 or S11 then if input d = 0 go to state S; else remain the same.\n\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign B3_next = (state[4] == 1'b1) && d;\n\tassign S_next  = (state[0] == 1'b1) ? ((d || state[1]) ? 1'b0 : 1'b1) : 1'b0;\n\tassign S1_next = (state[1] == 1'b1) ? ((d || state[2]) ? 1'b0 : 1'b1) : 1'b0;\n\tassign Count_next = (state[9] == 1'b1) && done_counting;\n\tassign Wait_next  = (state[8] == 1'b1) && ack;\n\t\t\n\t// Output Logic\n    assign counting = state[9];  // set if in 'Count' state\n    assign shift_ena = ~state[4]; // Set when not in B3 state, as per requirement\n    assign done  = state[8] || ((state[7:5] == 3'b0) && ack); //set when in Wait or S and ack is asserted\n\t\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\t\n\t// Next-State Logic and Output Logic Derivation\n\tassign B3_next = (state[4] & ~done_counting) | ((~d & state[5]) | (d & done_counting));\n\tassign S_next = (B3_next & ~ack) | (state[0]);\n\tassign S1_next = (S_next & ack);\n\tassign Count_next = (((S1_next | state[2]) & d) | ((state[6] & done_counting) | (~d & count_old)));   // This assumes that the previous 'Count' state is stored in variable 'count_old'.\n\tassign Wait_next = ~ack & state[9]; \t// This would be the 'done' logic.\n\tassign counting = Count_next;\t\t\t    // If this signal changes, it indicates that we are now counting.\n\tassign done = (state[6] | ~Wait_next);  \t// This would be the 'counting' logic.\n\tassign shift_ena = ~((state[4] & state[7]) | ((d ^ count_old) & state[5]));  // This assumes that the previous 'Count' state is stored in variable 'count_old'.\nendmodule\n\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign B3_next = state[7];     // next-state logic for state B3 (B3 is the 8th bit from right in binary representation of states)\n\tassign S_next = ~(state[0] & ((d ^ state[1]) | done_counting));   // next-state transition for state S\n\tassign S1_next = (state[0] & ((d^state[2])|done_counting)) ;  // similarly for state S1, shifting by one place and XOR with d and counting bit\n\tassign Count_next = ~(ack | done_counting) & state[9];    // next-state transition to Count if not ack or done_counting else stay in the same state\n\tassign Wait_next = (done_counting & ack)  ;   // next-state for state wait, move to S only when done_counting and ack are active\n    \n    assign counting = state[9]; // counting is present if we are at Count State i.e., the last bit from right in binary representation of states\n\tassign done = ~(state[8] | state[6]);   // done is high when we are not in B3 or Wait stage\n\tassign shift_ena = (state[7:1] == 6'b0);    // shift enable is present if all the bits except rightmost bit are zero\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "verilog\n    \n\tassign B3_next = (state[3] & ~d) | (state[4]); // for state 10'b0000000100 (B3) go to next state when d=0 or stay at B3 if d=1\n\tassign S_next  = (~state[9]) & ((~d&~done_counting) | state[7]); // for idle state, go to S1 when !(d & done_counting) otherwise stay in idle\n\tassign S1_next = (state[8] & ~d) | (state[0]); // for state 10'b0000000100 (S1) go to next state when d=0 or stay at S1 if d=1\n    assign Count_next = ((state[3]&done_counting)&d) | state[5]; // go from B3 to Count when done_counting & d is 1 otherwise stays in same state.\n\tassign Wait_next = (state[6]&ack) | state[9];// for state 'Count' wait for ack=1, then reset to idle state i.e S if ack goes high\n    \n\t//Outputs:\n\tassign done   = state[6]; // 1 when in state 'Count'\n    assign counting = state[5] | state[4]; // 1 when either in 'B3' or 'Count' states (i.e., counter is active)\n\tassign shift_ena = state[7]; // always high if we are in any state from B0 to B3. This could be used as a clock enable, assuming it is the last state of each cycle\n    \nendmodule \n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign {B3_next, S_next, S1_next, Count_next, Wait_next} = state[8:4] & 5'b0; // assuming that reset is not required as the question does not specify it. \n     assign counting = (state == 10'b1000000000);\n\tassign done  = (state == 10'b0111011000);   // at this state, if ack==1 the machine goes back to S and else remain in Wait. \n     assign shift_ena = (state[3:0] != 4'b0);    // all states except for B0 have shift enabled.\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n\tassign {B3_next, S_next, S1_next, Count_next, Wait_next} = (state[8:0] << 1) | ({9{state[9]}} & {~done_counting, done_counting, ~(ack|d), 2'b00});\n\tassign counting = state[4];\n\tassign shift_ena = state[3];\n\tassign done = ack & state[8];\n    \nendmodule   // This code generates the next-state logic and output signals for Moore State machine as per given state transitions.\n"}
{"task_id": "review2015_fsmonehot", "completion": "\n    // State transitions \n\tassign B3_next = state[6] & !d;  \t// If in B3 and d==0 then next state is current state. Else no change in state.\n\tassign S_next = ~state[8] & ~state[9];      // if not already at S (state 2) then go to it on reset/idle condition.\n\tassign S1_next = (state[0] | state[8]) & !d;  \t// If in S1 and d==1 then next state is S11 else return to S.\n\tassign Count_next = (~done_counting & state[7]);  // If not counting yet and in the count state then start counting.\n\tassign Wait_next = ~state[9] & done_counting & ack;  \t// if done_counting=1 and ack==1 then go to S.\n\t\n    // Outputs\n\tassign done = (state[7] && done_counting) || state[8];  // If in count state or waiting state then output is true else false.\n\tassign counting = state[7];\t// If in Count state, indicating counting mode else not in that mode.\n\tassign shift_ena = ~(state[6:5]==2'b10);  \t// If B0/B1/B2 states then enable shifting else disable it.\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n  always @(posedge clk or posedge areset) begin\n      if (areset == 1'b1)  // Asynchronous reset\n          q <= 8'd0;     // Reset the outputs to zero on asynchronous reset\n      else \n           q <= d;         // Else, update q with input value 'd'.\n    end\nendmodule\n"}
{"task_id": "dff8ar", "completion": "\n\t// 8 D flip-flop code\n\talways @ (posedge clk or posedge areset) begin\n    \tif(areset)\n        \tq <= 8'b0;\n    \telse\n        \tq <= d;\n  \tend\n\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n            q <= 8'd0;\n         else\n             q <= d;\n    end\n    \nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @ (posedge clk or posedge areset) begin\n    \tif(areset) \n        \tq <= 8'b0;\n    \telse\n        \tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\t\t\n\talways @ (posedge clk or posedge areset) begin\n\t\tif(areset) \n\t\t\tq <= 8'b0;\n\t\telse \n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "dff8ar", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) \n            q <= 8'd0;\n        else \n            q <= d;\n    end\n    \nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n    \tif (areset) \n        \tq <= 8'b0;\n    \telse \n        \tq <= d;\n    end\nendmodule\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n    if (areset) \n        q <= 8'b0;\n    else \n        q <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t\t    q <= 8'b0;\n        else  \n            q <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tq <= 8'h0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) \n\t\t\tq <= 8'h0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 8'b0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @ (posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) \n\t\t\tq <= 8'd0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 8'b0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1) \n\t\tq <= 8'b0;\n\telse \n\t\tq <= d;\nend\nendmodule\n"}
{"task_id": "dff8ar", "completion": "\nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1) \n\t\tq <= 8'd0;\n\telse \n\t\tq <= d;\nend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 8'b0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t    q <= 8'b0;\n\telse\n            q <= d;\n    end\nendmodule\n"}
{"task_id": "dff8ar", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 8'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8ar", "completion": "\nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1) \n\t\tq <= 8'd0;\n\telse\n\t\tq <= d;\nend\n\t\t\nendmodule\n\n"}
{"task_id": "kmap3", "completion": "\n\talways @(*) begin\n\t\tif(!c && !b)\n\t\t    out = ~a;\n        else if(!d)\n            out = a | b;\n        else \n            out=1'bX;     // 'x' is used in case of d being don't care.\n\tend\nendmodule\n"}
{"task_id": "kmap3", "completion": "\n\t// Karnaugh map gives following simplified form of the equation : ~a.b + c.~d + a.~c + ~(a+b).d \n\tassign out = ~a & b | c & ~d | a & ~c | ~(a|b) & d;\n\nendmodule\n"}
{"task_id": "kmap3", "completion": "\n\talways @(*) begin\n    if(c == 1'b0 && d == 1'b1) // case 01 and 11\n        out = ~a;\n\telse if (c == 1'b1 && d == 1'b0) // case 10 and 11\n\t    out = b;\n    else if(c == 1'b0 && d == 1'b0) // case 00 and 10\n        out = ~a & b;\n\telse // case 01 and 11, 00 and 10 (dont care cases)\n\t    out = a | b;  \n\tend\nendmodule\n"}
{"task_id": "kmap3", "completion": "\nalways @(*) begin\n\tcase({a,b,c,d})\n\t\t4'b0001, 4'b0010, 4'b0110, 4'b1110: out = 0;\n\t\t4'b0011, 4'b0101, 4'b1101, 4'b1111: out = 1;\n\t\tdefault: out = d; // If none of the above cases match, set 'd' to output. It is the don't care case\n\tendcase\nend\n\n"}
{"task_id": "kmap3", "completion": "\nalways @* begin\n\tcase({a,b,c,d}) \n\t\t4'b000?: out = 1'b0; //cd=00 or ab=00\n\t\t4'b010?: out = 1'b0; //cd=01 or ab=00\n\t\t4'b1111: out = 1'b1; //cd=11 or ab=11\n\t\tdefault:  out = ~c;   //remaining cases, d is don't care so c can be either value.\n\tendcase\nend\n\n"}
{"task_id": "kmap3", "completion": "\nalways @(*) begin\n    if(!c && !b)      // for inputs 00 and 10\n        out = a;      // output depends on input b and c\n    else if (!d && !a)// for inputs 01 and 11\n\t\tout = ~b;  \t// output depends on input a and d\n\telse               // for all other states\n\t\tout = d;       // output is don't care, so it can be any value.\nend\n\n"}
{"task_id": "kmap3", "completion": "\nassign out = ((~b & ~c & ~d) | (~a & ~c & ~d));\nendmodule\n\n"}
{"task_id": "kmap3", "completion": "\nalways @(*) begin\n\tcase({a,b,c,d})\n\t\t4'b000?: out <= 1'b0; //0\n\t\t4'b?10?: out <= 1'b0; //0\n\t\t4'b001?: out <= 1'b1; //1\n\t\tdefault : out <= ~c & (a | b) ;// 1'b1;\n\tendcase\nend\n"}
{"task_id": "kmap3", "completion": "\nalways @* begin\n\tif(c)begin\n\t\tif(b & ~a | ~d & ~a ) \n\t\t\tout = 1'b0;\n\t\telse if (~b & a & ~d| d & ~a ) \n\t\t\tout = 1'b1;\n\tend else begin\n\t\tif(~d)\n\t\t\tout = b & c & a;\n\t\telse \n\t\t\tout = ~(b ^ c | b & d);\n\tend\nend\nendmodule\n"}
{"task_id": "kmap3", "completion": "\n    always @* begin\n        case({c,b}) \n            2'b00 : out = a;\n            2'b10 : out = ~a & ~d;\n            2'b01 : out = ~a | d;\n            default : out = a | d;\n        endcase\n    end\t    \nendmodule\n"}
{"task_id": "kmap3", "completion": "\n\tif(d) begin\n\t\t// no need to change the value of 'out' as it is already defined based on the Karnaugh map. So don't write anything here.\n\tend else begin \n\t\tcase({a,b,c}) inside\n\t\t\t3'b00: out <= 0;\n\t\t\t3'b10: out <= 1;\n\t\t\tdefault: ; // when a=1 and b=d or c=d we do not care about the value of 'out', so don't write anything here.\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "kmap3", "completion": "\n    \n\t//The Karnaugh map gives us the following outputs for each state. We can see that '10' and '01' are both covered by the same output ('1'), and '11', '00' are also covered by another output ('0'). \n\talways @(*) begin\n\t\tif (c)\n\t\t\tout = a;\n\t\telse if (b)\n\t\t\tout = ~d;\n\t\telse\n\t\t\tout = d;\n\tend\n    \nendmodule\n"}
{"task_id": "kmap3", "completion": "\n    always @(*) begin\n        if (!c && !b && a) out <= 1; // 01\n        else if (d || !a && !b && c) out <= 0; // 00, 10\n        else out <= d; // 11, 01\n    end\nendmodule\n"}
{"task_id": "kmap3", "completion": "\n\t// Assuming d is don't care. \n\tcasex({a,b,c,d})\n\t\t4'b0?: out = 1'b0; // 0 when c=0 and d are anything\n\t  4'b10: out = 1'b0; // 0 when b=1 and c=0\n      4'bx1: out = 1'b0; // 0 when a is anything and c=1 (or both a & c)\n\t\t4'b11: out = 1'b1; // 1 when a=b=c are 1 (and d is anything) or b=1,d are 0/1 (and c is 1).\n\t\tdefault : out = d; // If all inputs are known except for 'a', assign the don't-care value to output.\n\tendcase\n  \nendmodule\n"}
{"task_id": "kmap3", "completion": "\n\talways @(*) begin\n\t\tif (!c && !b) begin //01 or 10\n\t\t\tif (a || d)\n\t\t\t\tout <= 0;\n\t\t\telse\n\t\t\t\tout <= 1;\n\t\tend else if (c && b) begin //11\n\t\t\tout <= 1;\n\t end else out <= d;   //00, 11\n\tend\nendmodule\n"}
{"task_id": "kmap3", "completion": "\n\tassign out = ((~a) & ~b & (c | d)) | (a & b & (~d));\nendmodule\n\n"}
{"task_id": "kmap3", "completion": "\n\t\n\t// Karnaugh map simplification gives us the following boolean expression for the output 'out':\n\t// out = (~c . ~d) + (~a . b) + a \n\tassign out = (~c & ~d) | (~a & b) | a; \n\nendmodule\n"}
{"task_id": "kmap3", "completion": "\n// Karnaugh map simplification for the given logic expression\nassign out = (!b & !c) | (a & !d) | a;  // simplified expression after Karnaugh map simplification\nendmodule\n\n"}
{"task_id": "kmap3", "completion": "\n\talways @(*) begin\n\t\tif (!c && !d)\n\t\t\tout = a;\n\t\telse if (b || d)\n\t\t\tout = 1'b0;\n\t\telse if (!a)\n\t\t\tout = 1'b1;\n\tend\nendmodule\n\n"}
{"task_id": "kmap3", "completion": "\n\talways @(a or b or c) begin\n\t\tif ((c == 0 && b==1'b1 ) || (d ==1'b1 && a==1'b1 ))\n\t\t\tout <= 1;\n\t\telse if((~c == 1'b1 && ~b == 1'b0 ) || (c== 1'b1 && a == 1'b1) ||(c==1'b1&& b ==1'b1)||(d==1'b0))\n\t\t\tout <= 0;\n\t\telse\n\t\t\tout <= d; //if don't care then choose any value.\n\tend \n\nendmodule \n"}
{"task_id": "lemmings1", "completion": "\nreg [1:0] state; // internal state register\nwire nextState = {bump_left, bump_right}; // two bit value that determines the next state\nparameter [1:0] LEFT = 2'b01, RIGHT = 2'b10; // left and right states\n\n// State transitions\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tstate <= LEFT; // asynchronous reset to initial state LEFT\n\telse if (nextState == LEFT)\n\t\tstate <= LEFT;\n\telse if (nextState == RIGHT)\n\t\tstate <= RIGHT;\nend\n\n// Outputs based on state\nassign walk_left = (state == LEFT); // output for walking left\nassign walk_right = (state == RIGHT); // output for walking right\n"}
{"task_id": "lemmings1", "completion": " \n\n\treg state; //define the state as reg. This will hold either of two values: 0 or 1.\n\n\t// State transition diagram :\n\t// state 0 --bump left--> state 1\n\t// state 1 --bump right--> state 0\n\t// state any --both bumps--> remain in same state\n\t\n\talways @(posedge clk) begin //synchronous reset on rising edge of clock\n    \tif (areset)\n        \tstate <= 1'b0; //reset to initial/first state, walking left\n    \telse \n       \t\tcase({bump_right, bump_left}) //multiplexor for state transitions\n            \t\t2'b00: state <= state; //remain in the same state if neither bump is detected\n                \t2'b10: state <= 1'b1; //change to walk right if bumped on left, remain at 1 (right) otherwise\n               \t \t2'b01: state <= 1'b0; //change to walk left if bumped on right, remain at 0(left) otherwise\n                \tdefault: state <= state; //remain in the same state for other scenarios\n        \tendcase  \n    end\n    \n\t// Outputs are assigned based on current state.\n\tassign walk_right = state; //if state is 1, walk right (bump_left will be set)\n    assign walk_left = ~state; //if state is 0, walk left (bump_right will be set)\n    \nendmodule\n"}
{"task_id": "lemmings1", "completion": "\nreg state; // 0 for walk left and 1 for walk right\n    \nalways @(posedge clk or posedge areset) begin\n\tif (areset)\n\t\tstate <= 0; // reset to walk_left state\n\telse if(bump_right & ~bump_left ) \n\t\tstate <= 1; // change to walk_right state\n\telse if (bump_left & ~bump_right)\n\t\tstate <= 0; // change to walk_left state\n\t//else no change in state i.e do not turn around\nend\n    \nassign walk_left = state;\nassign walk_right = ~state; \n\n"}
{"task_id": "lemmings1", "completion": "\n\treg state; // Internal registers to hold the current and next states.\n  \n\t// State transition function\n\talways @(posedge clk or posedge areset)  begin   \n\t\tif (areset) \n\t\t\tstate <= 1'b0;       // Async reset, return to initial state.\n\t   \telse\n\t    \tcase ({bump_right, bump_left})          \n\t\t\t2'b00: state <= state;   // No bumps, stay in current state.\n       \t\t 2'b10: state <= ~state; // Right bump, flip direction.\n        \t 2'b01: state <= ~state; // Left bump, flip direction.\n\t\t\t 2'b11: state <= state;   // Both bumps, stay in current state.\t    \n\t\t    endcase\n\tend\n      \n\t// State to output decoding\n\tassign walk_left = (state == 1'b0); // If state is 0, walk left.\n\tassign walk_right = ~(state == 1'b0); // If state is not 0, walk right.\n   \nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\treg [1:0] state;  // Define the states\n    parameter LEFT = 2'b01, RIGHT = 2'b10;   // States encoding\n    \n    always @(posedge clk or posedge areset) begin  // Asynchronous reset on positive edge of clock or asynchonous reset.\n        if (areset) begin\n            state <= LEFT;\n\t\t\twalk_left <= 1'b1;\n\t\t\twalk_right <= 1'b0;\n        end else case(state)  \n            LEFT:begin    // State 1 - Walk left\n                walk_left <= 1'b1;\n                walk_right <= 1'b0;\n\t\t\t\tif (bump_right == 1) begin\t// Change state on bump right\n                    state <= RIGHT;\n                end\n            end\n            \n            RIGHT:begin   // State 2 - Walk right\n                walk_left <= 1'b0;\n                walk_right <= 1'b1;\n\t\t\t\tif (bump_left == 1) begin\t// Change state on bump left\n                    state <= LEFT;\n                end\n            end\n            \n        endcase         // State 2 ends\n    end                 // Synchronous programming ends\nendmodule              // Module top_module ends\n"}
{"task_id": "lemmings1", "completion": "\n\t//define states and outputs\n\ttypedef enum {WALK_LEFT = 1'b0, WALK_RIGHT=1'b1} state_t;\n\tstate_t state, nextState;\n\tassign walk_left = (state == WALK_LEFT)? 1 : 0;\n\tassign walk_right = (state == WALK_RIGHT)? 1: 0;\n\n\t//reset synchronously\n\talways @(posedge clk or posedge areset) begin\n\t    if(areset)\n\t        state <= WALK_LEFT;\n\t    else\n\t        state <= nextState;\n\tend\n\n\t//state transitions and outputs logic\n\talways@(*)\n\tcase (state) \n\t\tWALK_LEFT : if(bump_right && bump_left )   nextState = WALK_RIGHT ; //if two bumps then switch to right state\n\t\t             else if(!bump_right && !bump_left )  nextState = WALK_LEFT;//if neither, stay in left state\n\t\t\t\t     else if(bump_right)    nextState=WALK_RIGHT; //switch to right when bumped on the right side\n\t\t             else   nextState = WALK_LEFT ; //stay as it is \n\t      \n\t\tWALK_RIGHT : if(!bump_left && !bump_right )  nextState= WALK_LEFT;//if neither, stay in right state\n\t\t              else if(bump_left)    nextState = WALK_LEFT; //switch to left when bumped on the left side\n\t\t\t\t      else   nextState = WALK_RIGHT ; //stay as it is \n\tendcase\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\nreg curr_state; // 0 for walk left and 1 for walk right.\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset)\n\t\tcurr_state <= 1'b0; // Reset to the initial state\n\telse\n\t\tcase ({bump_left, bump_right}) \n\t\t\t2'b00: curr_state <= curr_state;     // Stay in the same state if no bump is detected\n\t\t\t2'b01: curr_state <= 1'b0;           // Change to walk left if only right bump is detected\n\t\t\t2'b10: curr_state <= 1'b1;           // Change to walk right if only left bump is detected\n\t\t\tdefault: curr_state <= ~curr_state;  // Change direction otherwise\n\t\tendcase\nend\n\nassign walk_left = curr_state;\nassign walk_right = ~curr_state;\n\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\treg state;\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\t\tif (areset == 1'b1 ) \n\t\t\t\tstate <= 1'b1; // Walk left as initial state. \n\t\t\telse if ((bump_left == 1'b1) && (bump_right == 1'b0))  \n\t\t\t\tstate <= 1'b0; // Bumped on left, walk right. \n\t\t\telse if((bump_right== 1'b1 )&&(bump_left ==1'b0 ))\n\t\t\t    state <= 1'b1;//Bumped on Right , Walk Left\n            else if ( bump_left== 1'b1 && bump_right== 1'b1)   // If it is bumped at both sides, keep its current state\n                state <=state ;       //Do nothing\n\tend \n    \n    assign walk_left = state; \n\tassign walk_right = ~state;//since we are flipping the states. \n\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n    reg state; // 0 for left walking and 1 for right walking\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 0; // reset to walk left\n        else \n            unique case ({bump_left, bump_right})\n                2'b10: state <= ~state;    // If bumped on right, change direction.\n                2'b01: state <= ~state;    // If bumped on left, change direction.\n                default: state <= state;   // if no bump or both bumps then keep current direction \n            endcase\n    end\n    \n    assign walk_left = (state == 0) ? 1'b1 : 1'b0;\n\tassign walk_right= (state == 1) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\treg state; // 0 - walk left , 1 - walk right\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= 0; // reset to walk_left\n\t\telse if (bump_right && bump_left)\n\t\t\t// no change\n\t\t\tstate <= state;\n\t\telse if (bump_left || bump_right) \n\t\t\t // switch states only when bumped on one side, not both\n\t\t\tstate <= ~state;  \n\tend\n\t\n\tassign walk_left = state;\n\tassign walk_right = ~state;\n\t\nendmodule\n\n"}
{"task_id": "lemmings1", "completion": "\n\treg current_state; //0 is walk left and 1 is walk right.\n    \n\talways @(posedge clk or posedge areset) begin\n\tif (areset == 1) begin\n\t    current_state <= 0;  \n\tend else begin\n\t\tcase ({bump_left, bump_right}) \n\t\t\t2'b00: ; //Do nothing.\n\t\t\t2'b01: current_state <= 0; //Bumped on left so walk left\n\t\t\t2'b10: current_state <= 1; //Bumped on right so walk right\n\t\t\tdefault: current_state <= !current_state;  //Bumped on both sides, switch directions.\n\t\tendcase\n\tend  \n     end\n        \n    assign walk_left = current_state == 0 ? 1'b1 : 1'b0;\n    assign walk_right = current_state == 1 ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\t//State encoding: 00 = Right state, 11 = Left State\n\treg [1:0] curr_state;\n\tparameter RIGHT = 2'b00;\n\tparameter LEFT = 2'b11;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tcurr_state <= RIGHT; // reset to right state\n\t\telse \n\t\t\tcase (curr_state)\n\t\t\t\tRIGHT: begin  \n\t\t\t\t\tif (bump_right && bump_left)   \n\t\t\t\t\t\tcurr_state <= LEFT;     // change to left if both bumps are received\n\t\t\t\t\telse if(bump_right || bump_left) \n\t\t\t\t\t\tcurr_state <= RIGHT;   // maintain in right state if just one bump is received\n\t\t\t\tend\n\t\t\t\tLEFT: begin   \n\t\t\t\t\tif (bump_right && bump_left)\n\t\t\t\t\t\tcurr_state <= LEFT;     // change to left if both bumps are received\n\t\t\t\t\telse if(bump_right || bump_left) \n\t\t\t\t\t\tcurr_state <= RIGHT;   // maintain in right state if just one bump is received\n\t\t\t\tend\n\t\t\tendcase\n\tend\n\n\tassign walk_right = (curr_state == LEFT)? 1'b0 : 1'b1; //Set output accordingly\n\tassign walk_left  = (curr_state == RIGHT)? 1'b0: 1'b1;  \nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\t//Declare states as 0 and 1.\n\tlocalparam [1:0] WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01;\n\treg [1:0] state, next_state; //current state & next state\n\n\t//State transition logic - Moore machine\n\talways @(*) begin\n\t    case (state)\n\t        WALK_LEFT :  if (~bump_right & bump_left )  \n\t\t\t         next_state = WALK_RIGHT; //Change state to walk right, on left bump\n\t\t          else if (bump_left & bump_right)\n\t\t\t         next_state = state;   \t     //Stay in current state when both are bumped at same time\n\t\t          else \n\t\t\t         next_state = WALK_LEFT;     \t     //Else stay in walk left state on no bumps\n\t        WALK_RIGHT : if (~bump_left & bump_right ) \n\t\t\t         next_state = WALK_LEFT;  \t     //Change to walk left, when right side is bumped.\n\t\t          else if (bump_left & bump_right)\n\t\t\t         next_state = state;      \t     //Stay in current state when both are bumped at the same time\n\t\t          else \n\t\t\t         next_state = WALK_RIGHT;   \t     //Else stay in walk right state on no bumps\n            default : next_state = WALK_LEFT ;     \t   //Default to idle state\n\t    endcase\n\tend\n      \n\t//Output decoding logic. \n        assign walk_left  = (state == WALK_LEFT ); //1 when in walk left state, 0 otherwise\n        assign walk_right = (state == WALK_RIGHT); //1 when in walk right state, 0 otherwise\n\t      \n\t//Synchronous reset\n\talways @(posedge clk or posedge areset) begin\n\t  if(areset) \n\t    state <= WALK_LEFT ; \n\t  else\n\t    state <= next_state; //Transition to next state on positive clock edge\n        end \nendmodule\n"}
{"task_id": "lemmings1", "completion": "\nreg currentState; // 0 for walking left and 1 for right.\n    \nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        currentState <= 0;       // Set to default state on reset.\n    else\n        case ({bump_left, bump_right})   // 2-bit state encoding for Moore FSM.\n            2'b10:  currentState <= 1;  // Go right if left bumped only.\n            2'b01:  currentState <= 0;  // Go left if right bumped only.\n            default: ;         // No change when both bumped or neither bumped.\n        endcase\nend\n    \nassign walk_left = currentState;    // Output depends on state.\nassign walk_right = ~currentState;   // Invert of the output for right direction. \n\nendmodule\n"}
{"task_id": "lemmings1", "completion": " \n     reg current_state; // current state of the finite machine (0 or 1)\n      \n      always @(posedge clk or posedge areset) begin\n        if(areset) \n            current_state <= 1'b0; \n         else if((bump_left == 1'b1) && (bump_right ==1'b0)) // if left bumped and right not, walk right  \n             current_state <= 1'b1; \n          else if ((bump_right == 1'b1) && (bump_left==1'b0)) // if right bumped and left not, walk left\n             current_state <=1'b0; \n      end  \n     assign walk_right = current_state; \n     assign walk_left = ~current_state;\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\t//define states\n\ttypedef enum {WALKING_LEFT, WALKING_RIGHT} state_t;\n\tstate_t state, nextState;\n\t\n\t// State transitions and outputs \n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= WALKING_LEFT;\n\t\telse\n\t\t\tstate <= nextState;\n\tend\n\t\n\talways @(*) begin\n\t\tcase(state) \n\t\t\t\tWALKING_LEFT: begin\n\t\t\t\t\twalk_left = 1'b1; \n\t\t\t\t\twalk_right= 1'b0;  \n\t\t\t\t\tif (bump_right)\n\t\t\t\t\t\tnextState = WALKING_RIGHT; //transition to walking right state on bumping into obstacle.\n\t\t\t\t\telse\n\t\t\t\t\t\tnextState = WALKING_LEFT;  //stay in same left state without any input.\n\t\t\t\tend\t\t\n\t\t\t\tWALKING_RIGHT: begin  \n\t\t\t\t\twalk_left = 1'b0;   \n\t\t\t\t\twalk_right= 1'b1; \n\t\t\t\t\tif (bump_left)      //if bumped to the left\n\t\t\t\t\t\tnextState = WALKING_LEFT;//transition back to walking state on bumping into obstacle.  \n\t\t\t\t\telse\n\t\t\t\t\t\tnextState =  WALKING_RIGHT; //stay in same right state without any input\n\t\t\t\tend \t\t    \t       \n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n  reg state; // 0 = walk left, 1 = walk right\n  \n  always @(posedge clk or posedge areset) begin\n    if (areset)\n      state <= 0;\n    else\n      case(state)\n        0 : if (bump_right == 1'b1 )\n                state <= 1;\n       \n        1 : if (bump_left  == 1'b1 )\n                state <= 0;\n       endcase\n  end\n  \n assign walk_left = state == 0 ? 1'b1: 1'b0 ;\n assign walk_right = state == 1? 1'b1 : 1'b0 ;\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n    \n    reg current_state;  // state register, 0=walk left, 1=walk right\n\twire next_state;\t// next state is determined by the outputs of a combinational block based on bump_left and bump_right inputs\n        \n\talways @(posedge clk or posedge areset) begin // asynchronous reset on positive edge of clock\n\tif (areset) \n\t    current_state <= 0;   // reset to walk left state\n\telse \n            current_state <= next_state;    // update the state register with our next state value\n\tend    \n        \n        assign next_state = bump_left ? ~current_state : (bump_right ? ~current_state: current_state);   // Combinational logic for determining next state based on current state and bump inputs \n\t// if bump left or right is set, we negate the current state, i.e., walk to the opposite direction of the current state. If neither bumps are set then maintain the same state.\n        \n        assign walk_left = current_state;   // Assign outputs based on the value in our state register\n\tassign walk_right = ~current_state;    // complementary assignment, i.e., if we are walking left, we will be walking right and vice-versa\n    \nendmodule \n\n"}
{"task_id": "lemmings1", "completion": "\n\t// State encoding: 0 -> walk right, 1 -> walk left.\n\treg [1:0] state;\n\t\t\n\t// Synchronous reset and state machine logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t    state <= 2'b00; // Reset to walking right\n  \t    else case ({bump_left, bump_right})\n\t\t\t    2'b10: state <= state;          // Bumped left and not right\n\t\t\t    2'b01: state <= ~state;        // Bumped right and not left\n\t\t\t    2'b11: state <= ~(state[0]);  // Bumped on both sides, reverse direction\n\t\t      \tdefault: state <= state;         // Not bumped or any other case, stay at current state.\n  \t\t    endcase\n\tend\n\t\t\n\t// Output decoding\n\tassign walk_left = (state == 2'b01); \n\tassign walk_right = (state == 2'b00);\n\t\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\n\n    reg [1:0] state = 2'b0; // Initialize to 00 state\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset == 1)\n            state <= 2'b0;\n        else begin\n            case(state)\n                2'b00: begin // Walk Left State\n                    walk_left = 1'b1; \n                    walk_right = 1'b0;\n                    \n                    if (bump_right == 1)  \n                        state <= 2'b01; // Change to right walking state\n                end\n                \n                2'b01: begin // Walk Right State\n                    walk_left = 1'b0; \n                    walk_right = 1'b1;\n                    \n                    if (bump_left == 1)  \n                        state <= 2'b00; // Change to left walking state\n                end\n                \n            endcase\n        end\n    end\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n\t// State definitions\n\tlocalparam A = 3'b001;\n\tlocalparam B = 3'b010;\n\tlocalparam C = 3'b011;\n\tlocalparam D = 3'b100;\n\t\n\treg [2:0] state, next_state;\t// State flip-flops\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (~resetn) \n\t\t\tstate <= A;\t// Reset to initial state\n\t\telse \n\t\t\tstate <= next_state; // Transition to next state\n\tend\n\n\t\n\t// Next-state logic and output decoding in combinational block:\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: if (r[1] | r[2] | r[3]) \n\t\t\t    // If any device requests access, move to corresponding state. Otherwise remain in A\n\t\t\t    next_state = (r[1]) ? B : ((r[2]) ? C : D);\n\t\t\tB: if (~r[1]) \n\t\t\t    // If r1=0 then go back to A\n\t\t\t    next_state = A;\n\t\t\tC: if (~r[2]) \n\t\t\t    // If r2=0 then go back to A\n\t\t\t    next_state = A;\n\t\t\tD: if (~(r[1] | r[2])) \n\t\t\t    // If neither r1 nor r2 is set then move to A\n\t\t\t    next_state = A;\n\t\t\tdefault : next_state = state;\t// Hold the current state for any unknown states\n\t\tendcase\n\tend\n  \n\t// Output logic that assigns g[i] = 1 if a device is in its corresponding state. Else 0.\n\tassign g[3:1] = ~(r[1] & (state==B)) | ~(r[2] & (state==C)) | r[3];\n  \nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\nlocalparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;  //state codes\nreg [1:0] state, next_state;\nassign g = (state == A) ? {3{~(|r)}} :     //no devices are granted at the start or during idle states.\n\t   (state == B) ? {2'b01, ~r[2], 1'b0} :     \n\t   (state == C) ? {2'b10, ~r[1], 1'b0} :      \n\t   3'b0;     //no device granted if both r2 and r3 are requested.\nalways @(posedge clk or negedge resetn) begin    //syncronous state flip-flop\n\tif (~resetn)\n\t\tstate <= A;\t//active low asynchornous reset \n\telse\n\t\tstate <= next_state; \nend\n//state table\nalways @(*) begin\n\tcase(state)\n\tA: if (r[1])     //device 1 request and FSM is in state A.\n\t    next_state = B;  \t//move to State B and grant device 1.\n\telse if (r[2])       //device 2 request and FSM is in state A.\n\t   next_state = C;   \t//move to state C and grant device 2.\n\telse if (r[3])      //device 3 request and FSM is in state A.\n\t    next_state = D;   //move to State D and grant device 3.\n\telse\n\t   next_state = A;    \t//maintain at state A, no requests detected.\n\t \n\tB: if (r[1])    //device 1 request while in State B.\n\t    next_state = B;    //stay in State B and grant device 1.\n\telse   \n\t   next_state = A;    \t//move to state A, no longer device 1's turn.\n\t\t\n\tC: if (r[2])      //device 2 request while in state C.\n\t    next_state = C;     //stay in State C and grant device 2.\n\telse   \n\t   next_state = A;      \t//move to state A, no longer device 2's turn.\n\t\t\t\n\tD: if (r[3])        //device 3 request while in state D.\n\t    next_state = D;      //stay in State D and grant device 3.\n\telse   \n\t   next_state = A;      \t//move to state A, no longer device 3's turn.\n\t\t\n\tdefault: next_state = A;     //should not reach here unless reset is active. If so, go back to A. \n\tendcase\nend\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n// State codes 0-7 represent states A-D and B in order of priority. \nparameter [2:0] A = 3'b000;   // (r1=0, r2=0, r3=0)\nparameter [2:0] B = 3'b001;   // (r1=1)\nparameter [2:0] C = 3'b010;   // (r1=0, r2=1)\nparameter [2:0] D = 3'b100;   // (r1=0, r2=0, r3=0)\n\nreg [2:0] state, next_state;  // Current and next states for FSM\n\nalways @(posedge clk or negedge resetn) begin\n\tif(!resetn)       state <= A;   // Reset to state 'A' on a low active reset signal\n\telse              state <= next_state;    // Update the current state on clock edge\nend\n\n// State table: Decide which state to go to given input and current state.\nalways @(*) begin \n\tcase (state)  \n\t\tA : if      (r[1])     next_state = B;       \t// Request from r1, no other requests -> move to B.\n\t\t\telse if ((~r[3:2]))    next_state = A;       // No request -> stay in state A.\n\t\t\telse if (!(r[1] & ~r[2]) )   next_state = C;\t// Request from r3, no other requests -> move to C\n\t\t\telse                      next_state = D;   \t// Request from both r2 and r3 -> move to state D.\n\t\tB : if      (~r[1])     next_state = A;        // No request -> stay in state B.\n\t\t\telse                next_state = B;         // Stay in state B as long as device 1 requests.\n\t\tC : if      (~r[2])    next_state = A;        \t// No request -> stay in state C.\n\t\t\telse                next_state = C;         \t// Stay in state C as long as device 2 requests.\n\t\tD : if ((r[1] & r[2]))   next_state = D;        // Request from both r1 and r2 -> stay at D, no change.\n\t\t\telse               next_state = A;        \t// No request or only one request -> move back to state A.\n\t\tdefault :              next_state = A;   \t   // Default case: reset state\n\tendcase\nend\n\n// Outputs g[i]\nassign g[1] = (state == B); \t\t\t// If in state 'B', then grant for device 1 is active.\nassign g[2] = ((state == C) | (state == D)) ? 1'b1 : 1'b0; // For states 'C' and 'D', grant to device 2 is active. In any other state, it remains inactive.\n// Device 3 does not have a grant output because there is no corresponding logic for its case in the state table or in the above assign statements.\n\t\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\nreg [1:0] state, next_state;\n\n// State table\nalways @(*) begin\n\tcase (state) \n\tA : if(r[3]) next_state = B;\n\t    else if(r[2]) next_state = C;\n\t    else if(r[1]) next_state = D;\n            else next_state = A;\n        B : if(r[3]) next_state = B;\n           else next_state = A;  // g[B] = 1 when r[3] is high. If not, we are back to state A since there was no request for the resource by device 2 and 1 (as stated in problem description)\n\tC : if(r[2]) next_state = C;\n           else next_state = A; // g[C] = 1 when r[3] is high. If not, we are back to state A since there was no request for the resource by device 3 (as stated in problem description)\n\tD : if(r[1]) next_state = D;\n           else next_state = A; // g[D] = 1 when r[2] is high. If not, we are back to state A since there was no request for the resource by device 3 (as stated in problem description)\n\tendcase\nend  \n\n// State flip-flops\nalways @(posedge clk or negedge resetn) begin\n\tif(!resetn)\n\t\tstate <= A; // Reset synchronous active low. When the system is reset, we return to state A\n\telse\n\t\tstate <= next_state;  \nend \n\n// Outputs g[i] are the same as the states but inverted (0 means that device i has access and hence 'g' should be high). This is due to FSM design where the devices have a higher priority. Hence, if there is more than one request for the resource, only the highest priority requests can get access to it.\nassign g[3] = ~state[1]; // Device 3 has lower priority\nassign g[2] = ~state[0]; // Device 2 has middle priority\nassign g[1] = ~(state == A); // Device 1 has highest priority in case of multiple requests and the FSM is not in state A.  \t\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\nlocalparam  A = 3'b001;\t// State codes\nlocalparam  B = 3'b010;\nlocalparam  C = 3'b100;\nlocalparam  D = 3'b011;\n\t    \nreg [2:0] state, next_state; // State flip-flops\n\n// State table\nalways @(*) begin\n\tcase (state)\n\t\tA:\tif (r[1]) \n\t\t\t\tnext_state = B;\n\t\t\telse if (r[2] | r[3])\n\t\t\t\tnext_state = C;\n\t\t\telse if (~|r[1:3])\n\t\t\t\tnext_state = D;\n\t\t\telse \n\t\t\t\tnext_state = A;\n\t\t\t\t\n\t\tB:\tif (r[1]) \n\t\t\t\tnext_state = B;\n\t\t\telse   // g1 = 1 for device 2 or 3\n\t\t\t\tnext_state = A;\n\t\t\t\t\n\t\tC:\tif (r[2] & ~r[1])  // r2 and not r1, i.e., only r2 is set\n\t\t\t\tnext_state = C;  \n\t\t\telse // g2 = 1 for device 1 or 3 when r1=0,r2=1 or r1=0,r3=1, then return to state A\n\t\t\t\tnext_state = A;\n\t\t\t\t\n\t\tD:\tif (~|r[1:3])\n\t\t\t\tnext_state = D; // no requests, stays in state D until a request occurs\n\t\t\telse \n\t\t\t\tnext_state = A;  \n\t\t\t\t\t    \n\t\tdefault: next_state = A; \t// Default state to A\n\tendcase\nend\n\n// Flip-flop logic for synchronous reset\nalways @(posedge clk or negedge resetn) begin\n\tif (~resetn) \n\t\tstate <= A;\n\telse \n\t\tstate <= next_state;\nend\n    \n// Outputs g[i] generation\nassign g = state; // Assign the current state to output 'g' as a binary representation of its state code.\n\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n   localparam A = 3'b001; // State code for state A\n\tlocalparam B = 3'b010; // State code for state B\n\tlocalparam C = 3'b011; // State code for state C\n\tlocalparam D = 3'b100; // State code for state D\n\n\t// Declaration of the current and next states \n\treg [2:0] state, next_state;\n\n\t// Flip-flops to store the FSM state\n\talways @(posedge clk or negedge resetn) begin\n\t    if(!resetn) \n\t\t      state <= A; // Asynchronous reset\n        else \n            state <= next_state; \n    end\n\t \n\t// State table: determine what action to take in each possible state\n\talways @(*) begin\n\t\t\tcase (state)\n\t\t\t\tA: if ((r[1] | r[2]) | r[3]) // If any of the request inputs is set, go into B or C state. \n\t\t\t\t\t\t next_state = (~r[3] & ~r[2]) ? A : D; // Device 3 has less priority than device 2 which in turn has less priority than device 1. So if r[3] and r[2] are not set, stay at state A else go to state D\n\t\t\t\t else next_state = A; \n\t\t\t\tB: if(r[1]) // If device 1 is still requesting, stay in B state (g1=1)\n\t\t\t\t\t\t next_state = B;\n\t\t\t\t else next_state = A; // If device 1 has not requested anymore, go to state A and set g1 to 0.\n\t\t\t\tC: if(r[2]) // Same as for B state but this time check the request of device 2 (g2=1).\n\t\t\t\t\t\t next_state = C;  \n\t\t\t\t else next_state = A; // If not, go back to A and set g2 to 0.\n\t\t\t\tD: if((~r[3] & r[1]) | r[2])// Check for the highest priority device which is device 2 or device 1 in this state (g1=1 OR g2=1).\n\t\t\t\t\t\t next_state = D;  \n\t\t\t\t else next_state = A; // If none of them are requesting, go to state A.\n\t\t\tendcase\n    end\n\t \n\t// Outputs from the FSM: define what happens in each state\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: g = 3'b000;  // All outputs set to zero while in state 'A'.\n\t\t\tB: g = {1'b1,2'b00};// Device 1 gets the resource so g1=1 and g2=0.\n\t\t\tC: g = {1'b0,2'b10};// Device 2 gets the resource so g1=0 and g2=1.\n\t\t\tD: g = 3'b010; // Device 3 gets the resource (g3=1).\n\t\tendcase\n    end\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n\t// state declarations\n\tparameter A = 2'b00; \n\tparameter B = 2'b01; \n\tparameter C = 2'b10; \n\tparameter D = 2'b11;\n\n\treg [1:0] current_state, next_state; // state flip-flops\n\n\t// state transition table\n\talways @(*) begin\n\t\tcase (current_state) \n\t\t\tA: if (r[3]) next_state = B;  \n\t\t\t\telse if (~r[2]) next_state = D;\n\t\t\t\t     else next_state = C;\n\t\t\tB: if (r[1]) next_state = A;\n\t\t\t\telse next_state = B;\n\t\t\tC: if (r[2]) next_state = A; \n\t\t\t\telse next_state = C;\n\t\t\tD: if (~r[3]&~r[2]&~r[1]) next_state = D; // no request\n\t\t\t\telse next_state = A;\n\t\tendcase\n\tend\n\n\t// output table \n\talways @(*) begin \n\t\tcase (current_state) \n\t\t\tA: g <= 3'b000; \n\t\t\tB: g[1] <= 1'b1; \n\t\t\tC: g[2] <= 1'b1;\n\t\t\tD: g <= 3'b000;   // no grant in state D\n\t\tendcase\n\tend\n\n\t// reset and clocked state flip-flops\n\talways @(posedge clk or negedge resetn) begin \n\t\tif (!resetn) current_state <= A; // reset to initial state\n\t\telse current_state <= next_state; \n\tend\n\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n\t// Define state codes\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\n\t// State flip-flop\n\treg [1:0] current_state, next_state;\n\n\t// State table\n\talways @* begin\n\t\tcase (current_state)\n\t\t\tA: \tif(r[3]) \n\t\t\t\t\t\tnext_state = B;\n\t\t\t\t\telse if(|r[2:1]) \n\t\t\t\t\t\tnext_state = C;\n\t\t\t\t\telse if(~|r)\n\t\t\t\t\t\tnext_state = A;\n\t\t\t\t\telse \n\t\t\t\t\t\tnext_state = D;\n\t\t\tB: \tif (r[3]) \n\t\t\t\t\t\tnext_state = B;\n\t\t\t\t\telse begin\n\t\t\t\t\t\tg = 3'b100; // set g[2]=1, reset others\n\t\t\t\t\t\tnext_state = A;\n\t\t\t\t\tend\n\t\t\tC: \tif (r[2]) \n\t\t\t\t\t\tnext_state = C;\n\t\t\t\t\telse begin\n\t\t\t\t\t\tg = 3'b010; // set g[1]=1, reset others\n\t\t\t\t\t\tnext_state = A;\n\t\t\t\t\tend\n\t\t\tD: \tif(|r) \n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tg = 3'b001; // set g[0]=1, reset others\n\t\t\t\t\t\t\tnext_state = A;\n\t\t\t\t\t\tend\n\t\t\t\t\telse \n\t\t\t\t\t\tnext_state = D;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\t// Synchronous flip-flop\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (~resetn)\n\t\t\tcurrent_state <= A;\n\t\telse \n\t\t\tcurrent_state <= next_state;\n\tend\n\t\n\t// Assign outputs based on state\n\tassign g = current_state[2:0]; // {g0,g1,g2} = {3'b000,3'b001,3'b010,3'b100}[current_state]\n\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n  reg[2:0] state; // Define the states\n  localparam A = 3'b000;\n  localparam B = 3'b001;\n  localparam C = 3'b010;\n  localparam D = 3'b011;\n  \n  always @(posedge clk or negedge resetn) begin // Synchronous reset flops\n    if(!resetn)\n      state <= A;\n    else\n      case (state)\n        A: if (r[2]) // From A to B with r1=0, r3=1\n          state <= B;\n        else if (|r[1:0])  // From A to C or D with r1=0 and r2=1 or both at the same time\n          state <= C;\n          \n        B: if(r[2]==0) // From B to A when r1 goes away\n          state <= A;\n      \t  \n        default : ; \t// For states C & D, do nothing since they are terminal states\n      endcase\n  end\n    assign g = (state == B)? {{3{~r[2]}}, {~r[1], ~r[0]}} : //If in state B then g=1 if r3 is not requested and device with the lower request comes next. Otherwise, do nothing (g=0)\n  \t            (|state[2:1])? {{2{~r[2]}}, {~r[1], ~r[0]}} : 8'b0; //If in state C or D then g=1 if r2 is requested. Otherwise, do nothing (g=0)\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n    localparam C = 2'b10;\n    \n    reg [1:0] state, next_state;\n    \n    always @(*) begin\n        case (state) \n            A : if (r[1]) next_state = B;\n                else if (~|r) next_state = A;\n                else next_state = C;\n            B : if (~r[1]) next_state = A;\n                else next_state = B;\n            C : if (~r[2]) next_state = A;\n                else next_state = C;\n        endcase \n    end \n    \n\talways @(posedge clk or negedge resetn) begin\n        if (~resetn) state <= A;\n        else state <= next_state;\n    end \n     \n    always @(*) begin\n        case (state)   // Assign the outputs based on current state\n            A : g <= 3'b000;\n            B : g <= 3'b001;\n            C : g <= 3'b010;\n\tend \n    end        \nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n    localparam [2:0] A = 3'b000, B = 3'b001, C=3'b010, D = 3'b011; // States\n    \n\treg [2:0] current_state, next_state;  // State registers\n    \n    always @(posedge clk or negedge resetn) begin   // State flip flops with reset\n        if (resetn == 1'b0)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end \n\n\talways @(*) begin     // State table\n\t    case (current_state)\n\t        A: \n\t        \tif (r[1] | r[2] | r[3])\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse \n\t\t\t\t\tnext_state = A;\n\t\t\tB: \n\t        \tif (r[1])\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse if (!r[1] & r[2])\n\t\t\t\t\tnext_state = C;\n\t\t\t\telse if (!r[1] & !r[2] & r[3])\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse \n\t\t\t\t\tnext_state = A;\n\t\t\tC: \n\t        \tif (r[2])\n\t\t\t\t\tnext_state = C;\n\t\t\t\telse if (!r[1] & !r[2] & r[3])\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tD: \n\t        \tif (r[3])\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse \n\t\t\t\t\tnext_state = A;\n\t        default : next_state = current_state;    // Default case, when state is not defined.\n\t    endcase\n\tend \n    \n\tassign g[1] = (current_state == B & r[1]) | (current_state == C & r[2]);   // Assign outputs based on the current states\n\tassign g[2] = 0;\n\tassign g[3] = (current_state == D & r[3]);\n    \nendmodule \n"}
{"task_id": "2013_q2afsm", "completion": "\n\tparameter A = 2'b00;  // state codes for states A, B, C and D\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\treg [1:0] state;  // state flip-flop\n\twire [3:1] nstate;  // next state logic output\n\n\t// State table (combinational circuit)\n\talways @(*) begin\n\t\tcase(state) \n\t\t\tA: if(r[1]) nstate = B; else\n\t\t\t   \tif(~&r & ~r[2] & r[3]) nstate = D; else \n\t\t\t\t\tnstate = A;  \n\t\t\tB: if (r[1]) nstate = B; else nstate = A; \n\t\t\tC: if (~|r) nstate = A; else nstate = C; \n\t\t\tD: if(~&r & r[2] & ~r[3]) nstate = D; else \n\t\t\t\t\tif(~|r) nstate=A;else nstate=C;  \n\t\t\tdefault: nstate = 3'bx;\n\t\tendcase\n\tend\n\n\t// State flip-flops (sequential circuits)\n\talways @(posedge clk or negedge resetn) begin  // synchronous reset\n\t\tif(~resetn) state <= A;  \n\t\telse state <= nstate;  \n\tend\n\t\t\n\t// Output logic: g[i] = (state == i), where i is the device number.\n\tassign g = state;\n\t\t\t\t   \nendmodule \n"}
{"task_id": "2013_q2afsm", "completion": "\nlocalparam \n  STATE_A = 2'b00,\n  STATE_B = 2'b01,\n  STATE_C = 2'b10,\n  STATE_D = 2'b11;\n  \nreg [1:0] currentState, nextState;\n\nalways @(*) begin // state transition logic\n\tcase (currentState)\n\t\tSTATE_A : if (r[3])\n\t\t\t\t      nextState = STATE_B;\n\t\t\t     else if (r[2]) \n\t\t\t\t      nextState = STATE_C;\n\t\t\t     else if (r[1])\n\t\t\t\t      nextState = STATE_D;\n\t\t\t     else\n\t\t\t\t      nextState = STATE_A;\n\t\tSTATE_B : if (~r[3])\n\t\t\t\t      nextState = STATE_A; \n\t\t\t     else \n\t\t\t\t\t  nextState = STATE_B;    // Stay in B state as long as r3 is high.\n\t\tSTATE_C : if (~r[2]) \n\t\t\t\t\t   nextState = STATE_A; // Go to A when r2 goes low.\n\t\t\t      else \n\t\t\t\t        nextState = STATE_C;     // Stay in C state as long as r2 is high.\n\t\tSTATE_D : if (~r[1]) \n\t\t\t\t\t   nextState = STATE_A; // Go to A when r1 goes low.\n\t\t\t      else \n\t\t\t\t        nextState = STATE_D;     // Stay in D state as long as r1 is high.   \n\tendcase\nend\n\nalways @(posedge clk or negedge resetn) begin // flip-flop to hold the state\n\tif (~resetn) \n\t\tcurrentState <= STATE_A;\n\telse \n\t\tcurrentState <= nextState;\nend\n  \n// Output Logic : Device priority from high to low. Hence, r[1] gives g[1], r[2] gives g[2], and so on..\nassign g = {~r[3], ~r[2], ~r[1]};  // Devices 3, 2, 1 respectively are granted the resource if their request i.e., r[i] is high. Inverting these to give a logical '1' for those devices that get the grant (priority order).\n  \t\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n\treg [2:0] state; // 3 bit state register\n\tlocalparam A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011;  \n\t// State codes: A=000, B=001, C=010, D=011\n\t\n\talways @(posedge clk or negedge resetn) begin  // synchronous reset\n\t\tif (!resetn) state <= A; // asynchronous reset into state A\n\t\telse case (state) \n\t\t\tA: if (r[3]) state <= B; else if (r[2]|(r[1]&~r[3])) state <= C; else if ((~r[1]) & r[3]) state<=D ; // A --r1=0,r2=1--> C ,A --r1=0,r3=0,r2=0--> D\n\t\t\tB: if (r[3]) begin end else if (~r[1]) state <= A;// B (g1=1) --r1=0--> A\n\t\t\t   // no else because we don't need to go back to the other states from B\n\t\t\tC: if(~r[2] & ~r[3]) state<=A ; // C (g2=1) --r2=0,r3=0--> A \n\t\t\t   else if (!r[1]) begin g[3] <= 1; end // C (g2=1) --r1=0--> give grant to device 3.\n\t\t\tD: if(~r[1]&~r[2]) state<=A; // D (g3=1) --r1=0,r2=0--> A, no else as we need r1 or r2 for transition.\n\t\t\t   \n        endcase\n   g[1] <= ((state==B)&(|r));//  device 1 has a higher priority and continues to grant once in the B state unless there is any other request.\n\tg[2] <= (~(&r))&((state == C)|(state == D)) ; // device 2 gives its grant only when all three devices are making requests. Device 2 can only be active if all three devices are making requests or in the state of C and D where r[3] is not set by any request from other device.\n\tg[3] <= ((state ==C)&r[1]); // device 3 grants when it's in the 'C' state (with no other requests) and receives a signal r1 from some device.\nendmodule \t\t \t\t\t   \n"}
{"task_id": "2013_q2afsm", "completion": "\nlocalparam A = 2'b00;\n\tlocalparam B = 2'b01;\n\tlocalparam C = 2'b10;\n\tlocalparam D = 2'b11;\n\t\n\treg [1:0] state, next_state;\n\talways @(posedge clk or negedge resetn) begin\n\t\tif(!resetn)\n\t\t\tstate <= A;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t\n\t\t\tA: if (r[1]) \n\t\t\t\t\tnext_state = B;\n\t\t\t   else if (~r[2] & r[3])\n\t\t\t\t\tnext_state = C;\n\t\t\t\telse if (~r[2] & ~r[3])\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\t\t\t\n\t\t\tB: if(~r[1]) \n\t\t\t\t\tnext_state = A;\n\t\t\t   else \n\t\t\t\t\tnext_state = B;\n\t\t\t\t\t\n\t\t\tC: if (~r[2]) \n\t\t\t\t\tnext_state = A;\n\t\t\t\telse\n\t\t\t\t\tnext_state = C;\n\t\t\t\t\t\n\t\t\tD: next_state = A;\n\t\t\t\t\t\n\t\tendcase\n\tend\n\tassign g = {2'b0, ~(state == B), ~(state == C)} & r;\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\nlocalparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11; // State codes \nreg [1:0] state, next_state;\n\n//State table\nalways @* begin\n\tcase(state)\n\t\tA: if (r[3]) next_state = B;\n\t\t   else if (r[2]) next_state = C;\n\t\t   else if (r[1]) next_state = D;\n\t\t   else next_state = A;\n\t\t\t   \n\t\tB: if (r[3]) next_state = B;\n\t\t   else next_state = A; \n\t   \n\t\tC: if (r[2]) next_state = C;\n\t\t   else next_state = A;\n\t\t\t \n\t\tD: next_state = A;\t \n\t\t\t\t\t   \n\tendcase\nend\n\n// State Flip Flops\nalways @(posedge clk or negedge resetn) begin\n\tif (!resetn) state <= A; // asynchronous active low reset\n\telse state <= next_state; \t\t  \t\t\t    \t   \t\t     \t \nend\n\n// Outputs g[i] depend on the current state:\nassign g = (state == B || state == D)? {3{1'b0}} : state[1:0]; // g1 and g2 are active when in states A, not in state C. For all other cases g1=g2=0.\nendmodule\t  \t\t     \t \t     \n"}
{"task_id": "2013_q2afsm", "completion": "\n\t// Define states as constants\n\tlocalparam [2:0] A = 3'b000;\n\tlocalparam [2:0] B = 3'b001;\n\tlocalparam [2:0] C = 3'b010;\n\tlocalparam [2:0] D = 3'b011;\n\t\n\t// State register and next state logic\n\treg [2:0] current_state, next_state;\n\talways @(posedge clk or negedge resetn) begin \n\t\tif (!resetn) // Asynchronous active-low reset\n\t\t\tcurrent_state <= A;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\t\t\t\n\t// Next state logic\n\talways @* begin\n\t\tcase (current_state)\n\t\t\tA: if (r[1]|(r[2]&~r[3])) \n\t\t\t\t\tnext_state = B;\n\t\t\t   else if (r[3]) \n\t\t\t\t\tnext_state = D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A; // If no request, stay in state A\n\t\t\tB: if (!(r[1]&~r[2])) \n\t\t\t\t\tnext_state = A;\n\t\t\t   else\n\t\t\t\t\tnext_state = B;\n\t\t\tC: if (!(r[2]&~r[3])) \n\t\t\t\t\tnext_state = A;\n\t\t\t   else\n\t\t\t\t\tnext_state = C;\n\t\t\tD: if (r[1]) \n\t\t\t\t\tnext_state = B;\n\t\t\t\telse if (r[3]) \n\t\t\t\t\tnext_state = D;\n\t\t\t   else\n\t\t\t\t\tnext_state = A; // If no request, stay in state A\n\t\tendcase\n\tend\n\t\n\t// Output logic to generate g signals\n\tassign g[1] = ~(current_state == B);  // Device 1: not at state B (g1=0 when at B)\n\tassign g[2] = (current_state != A & current_state != D);  \n\t// Device 2: Not in states A or D (g2 = 1 if not in these states). This will be high only when the state is C.\n\tassign g[3] = ~(current_state == D) | r[3]; // Device 3: not at state D unless device 3's own request is set (r3 and g3 are active high)\n\t\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\nreg [1:0] state, next_state;  // State flip-flops\n\nalways @(posedge clk or negedge resetn) begin\n\tif (!resetn)\n\t\tstate <= A; // Reset state to A on synchronous reset\n\telse\n\t\tstate <= next_state; // Update state\nend\n\n// Next State Decoder \nalways @* begin  \n\tcase (state)\n\t\tA: if(r[3]) next_state = B;    // If r3=1 go to B\n\t\t\telse if(r[2]) next_state = C; // Else, if r2=1 go to C\n\t\t\telse if(r[1]) next_state = D; // Else, if r1=1 go to D\n\t\t\telse next_state = A;   // Maintain state A \n\t\t\t\n\t\tB: if (r[3]) next_state = B;    \n\t\t\telse if(!r[2] & !r[1]) next_state = A;    // Else, If r2=0 and r1=0 go to A\n\t\t\telse next_state = B; \n\t\t\t\n\t\tC: if (r[3]) next_state = C;    \n\t\t\telse if(!r[2] & !r[1]) next_state = A;    // Else, If r2=0 and r1=0 go to A\n\t\t\telse next_state = B; \n\t\t\t\n\t\tD: if(r[3]) next_state = D;    \n\t\t\telse next_state = A;   //Else, go to state A\n\tendcase\nend\n\n// Output Decoder \nassign g[3] = (state == B); \nassign g[2] = ((state==C)|(r[2]))&((state !=D));\nassign g[1] = ((state==D) | (state == A & r[1]) ) ;// If in state D or if in A and r1 is set then give grant \nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n// State Codes\n\t// A = 2'b00\n\t// B = 2'b01\n\t// C = 2'b10\n\t// D = 2'b11\n\n\treg [1:0] state, next_state; // State flip-flops\n\twire [3:0] ns_out; // Next state outputs\n\tassign g = state[3:2]; // FSM output based on current state \n  \n\t// Next state logic table \n\talways @* begin \n\t    case (state)\n\t\t    2'b00: if (!r[1] & !r[2]) ns_out = 4'b01; else if (r[1]) ns_out = 4'b11; else if (~|r[3:2])  ns_out= 4'b00;\n\t\t    2'b01: if (!r[1] ) ns_out = 4'b00; else if (r[1])   ns_out = 4'b10; \n\t\t    2'b10: if (!r[2]) ns_out= 4'b00; else if (r[2])    ns_out=4'b11;\n\t\t    2'b11: if(!r[3] & !r[1])  ns_out = 4'b00; else if(|r[3:2])   ns_out= 4'b00;\n\t        default : ns_out=4'b00;  //default condition\t\t        \n\t    endcase\n\tend\n     \n\t// Synchronous state flip-flop   \n\talways @(posedge clk or negedge resetn) begin\n\t  if (!resetn)\n\t      state <= 2'b00;   // Asynchronous reset\n\t  else \n\t      state <= next_state;    \n\tend     \n\t\t\n\t// Determine the next state from the next state output values\n\tassign next_state = ns_out[3:2];   \n\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\n\t// States declaration\n\tlocalparam  A = 2'b00;\n\tlocalparam  B = 2'b01;\n\tlocalparam  C = 2'b10;\n\tlocalparam  D = 2'b11;\n\t\n\t// State register\n\treg [1:0] state_reg, state_next;\n\t\n\t// Outputs declaration\n\twire [3:1] g_internal; // internal value for the output based on current state\n\tassign g = g_internal;\n\t\n\t// Next-state logic and outputs decoding\n\talways @* begin \n\t\t case (state_reg)\n\t\t\t A : if (r[3])  begin state_next = B; g_internal = 4'b0100; end // r1=1, go to state B, set g1=1\n\t\t\t\telse if (~r[2] & ~r[1]) begin state_next = A; g_internal = 4'b0000; end // r1=0 and r2=0, stay in state A, reset g1=0\n\t\t\t\telse if (r[2])  begin state_next = C; g_internal = 4'b1000; end // r2=1, go to state C, set g2=1\n\t\t\t\telse if (~r[3] & ~r[1]) begin state_next = D; g_internal = 4'b0010; end // r1=0 and r2=0, r3=1, go to state D, set g3=1\n\t\n\t\t\t B : if (~r[1] & ~r[3]) begin state_next = A; g_internal = 4'b0000; end // r1=0 and r2=1, stay in state B, reset g1=0\n\t\t\t\t else if (r[1])  begin state_next = B; g_internal = 4'b0100; end // r1=1, stay in state B, set g1=1\n\t\n\t\t\t C : if (~r[2] & ~r[3]) begin state_next = A; g_internal = 4'b0000; end // r1=1 and r2=0, go to state A, reset g2=0\n\t\t\t\t else if (r[2])  begin state_next = C; g_internal = 4'b1000; end // r2=1, stay in state C, set g2=1\n\t\n\t\t\t D : if (~r[3] & ~r[1]) begin state_next = A; g_internal = 4'b0000; end // r1=0 and r2=0 and r3=0, stay in state C, reset g3=0\n\t\t\t\t else if (r[3])  begin state_next = D; g_internal = 4'b0010; end // r3=1, stay in state D, set g3=1\n\t\tendcase\t\t\t  \n\tend   \t\t\n\t\n\t// Synchronous reset and state flip-flops\n\talways @(posedge clk or negedge resetn) begin \n\t\tif (~resetn) state_reg <= A; // asynchonous reset to state A\n\t\telse state_reg <= state_next; // synchronous state update\n\tend\t\t  \t\t\t   \t\t\t\t    \t\t       \nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n    \n    reg [3:0] counter;\n    reg tmp_in; // Temporary input for synchronization\n  \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin \n            counter <= 4'h0;\n\t    disc<=1'b0; flag<=1'b0; err <=1'b0; tmp_in <= 1'b0;\n\tend  \n\telse begin\n            tmp_in <= in; // Synchronizing the input\n            \n            case (counter)\n                4'hF: disc <= 1'b1; // Discard flag is active when 7 consecutive '1s' have been detected\n                4'hE: flag <= 1'b1; // Frame begin/end flag is active when we see the end of first '11111' sequence\n                default : err <= tmp_in; // Error signal is asserted if more than 5 consecutive '1s' are seen consecutively\n            endcase\n            \n\t    counter <= (tmp_in == 1'b1) ? counter + 4'h1 : 4'h0; // Incrementing/Resetting the counter based on the input value\n\tend      \n    end\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [2:0] shift; // Shift register to capture the 3 most recent inputs\n\ttypedef enum {WAIT_FOR_FLAG, WAIT_FOR_DISCARD, WAIT_FOR_ERROR} state_t;\n\tstate_t state, next_state;\n\t\n\t// State transitions and output logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tWAIT_FOR_FLAG: if (!in && shift[0] && !shift[1] && !shift[2]) \n\t\t\t\tnext_state = WAIT_FOR_DISCARD; // 0111110\n\t\t\telse next_state = in ? FLAG : state; // 1xxx or ...1xx\n\t\t\tWAIT_FOR_DISCARD: if (shift[2]) // The third bit is a '1'\n\t\t\t\tnext_state = ERROR; // Error due to a discard signal of 1\n\t\t\telse next_state = in ? FLAG : state; // 1xxx or ...1xx\n\t\t\tWAIT_FOR_ERROR: if (in) next_state = ERROR; // Stay at the same state as long as we're seeing 1s\n\t\t\t else next_state = flag ? FLAG : state; // Go back to normal after discarding error signal and start looking for flags again.\n\t\t\tdefault: next_state = reset ? WAIT_FOR_FLAG : state; // Reset or unknown states -> go back to waiting for a flag.\n\t\tendcase \n\n\t\tcase (state)\n\t\t\tWAIT_FOR_DISCARD, WAIT_FOR_ERROR: {disc, err} = 2'b10; // discard and error signals active high\n\t\t\tWAIT_FOR_FLAG: begin {disc, err, flag} = 3'b010; end // Only one of the flags are active at once. \n\t\t\tdefault: {disc, err, flag} = 3'b000; // No signal when not in any state.\n\t\tendcase\n\tend\n\t\n\t// Update the current state on clock edge (using positive edge triggered DFF)\n\talways @(posedge clk or posedge reset) \n\t\tif (reset) \n\t\t\tstate <= WAIT_FOR_FLAG; // Asynchronous active high reset\n\t\telse \n\t\t\tstate <= next_state; \n\t\t\t\n\t// Shift register to capture the last three inputs.\n\talways @(posedge clk) begin\n\t\tshift[0] <= in;\n\t\tif (state != WAIT_FOR_ERROR) // Don't shift during error state\n\t\t\tshift[2:1] <= shift[1:0]; \n\tend  \n\t\t\t\nendmodule \n"}
{"task_id": "fsm_hdlc", "completion": "\n   reg [2:0] count;\n   \n   always @(posedge clk or posedge reset) begin\n      if (reset == 1'b1) begin\n         count <= 3'b000;  // reset to zero on reset signal.\n         disc   <= 1'b0;\n         flag   <= 1'b0;\n         err    <= 1'b0;\n          end\n      else begin\n        case (count)\n          3'b000: if (in == 1'b0) count <= 3'b001; // start of sequence detection.\n          3'b001: if (in == 1'b1) count <= 3'b011; \n          3'b011: begin \n            if(in == 1'b1) begin\n              disc <= 1'b1; // raise signal after seeing first five ones.\n              flag <= 1'b1;\n            end  \n          else count <= 3'b000;  \n          end\n          3'b100: if (in == 1'b1) begin \n            err   <= 1'b1; // raise error when seven ones are seen.\n             flag  <= in;\n          end\n         default: count <= 3'b000;   \n        endcase\n      end  \n   end    \nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [2:0] state;\n  \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 3'b010; // Reset to middle of a \"0\" frame.\n\t\telse case(state)\n\t\t\t3'b010: if (in) state <= 3'b110; else disc <= 1; // Waiting for a '1'.\n\t\t\t3'b110: if (~in) state <= state + 3'd1; else flag <= 1; // Discarding the middle bit.\n\t\t\tdefault: state[2:1]<={state[0],in};if(state==3'b111)begin err<=1;state<=3'b010;end  end// Counting 1s.\n\tend\n\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [2:0] count;\n\twire falling_edge = !in && prev_in;\n\treg prev_in;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcount <= 3'b0;\n\t\t\tprev_in <= 1'b0;\n\t\tend else begin\n\t\t\tprev_in <= in;\n\t\t\t\n\t\t\tcase ({in, count})\n\t\t\t\t2'b10:  count <= 2'b01; //incrementing state machine\n\t\t\t\t2'b11:  count <= 3'b111; //error state\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign disc = (count == 3'b001) & falling_edge;\n\tassign flag = in & (count == 3'b011);\n\tassign err  = count[2] & falling_edge;\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\n    reg [2:0] state;\n    \n    // State transition diagram\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= 3'b110;  \n        else case(state)\n            3'b110 : if(!in) state <= 3'b110; // wait for the first '0' to transition from state \"110\" \n                     else state <= 3'b000; // '1' transitions directly to \"000\"  \n            3'b000 : if(!in) state <= 3'b001; // wait for next bit to be '0', transitioning into state \"001\" \n                     else state <= 3'b000; // keep in state \"000\" until we see a '1'  \n            3'b001 : if(!in) state <= 3'b011; // wait for next bit to be '0', transitioning into state \"011\" \n                     else state <= 3'b001; // keep in state \"001\" until we see a '1'  \n            3'b011 : if(!in) state <= 3'b101; // wait for next bit to be '0', transitioning into state \"101\" \n                     else state <= 3'b011; // keep in state \"011\" until we see a '1'  \n            3'b101 : if(!in) state <= 3'b111; // wait for next bit to be '0', transitioning into state \"111\" \n                     else state <= 3'b101; // keep in state \"101\" until we see a '1'  \n            default: state <= 3'b110;           // reset to state \"110\" when an invalid bit sequence is encountered.\n        endcase\n    end \n    \n    assign disc = (state == 3'b000);\n    assign flag = (state == 3'b011 || state == 3'b110 );\n    assign err  = (state == 3'b111   );\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n   reg [2:0] counter;  // count the number of ones\n   \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin\n\t\t\tcounter <= 3'b000;\n\t\t\tdisc <= 1'b0;\n\t\t\tflag <= 1'b0;\n\t\t\terr <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tcase(in) \n\t\t\t\t1'b0: counter <= (counter == 3'b111)? 3'b000 : counter + 1; // for '0', reset the counter if it reaches 7, else increment\n\t\t\t\t1'b1: begin\n\t\t\t\t\t\tdisc <= 1'b0;  // always reset disc on a new '1'\n            flag <= (counter == 6);   // check if we have exactly 6 consecutive ones (flag starts from zero)\n\t\t\t\t\t\terr  <= (counter > 5);    // check if more than 5 consecutive ones, signal error\n\t\t\t\t\t\t\tcounter <= 3'b001;  // reset counter for new sequence of '1's\n\t\t\t\t\tend\n\t\t\tendcase\n        end\n\tend\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [2:0] counter;\n\twire disc_cond, flag_cond, err_cond;\n  \n\tassign disc_cond = (counter == 5) && in;\n\tassign flag_cond = (counter == 6) && ~in;\n\tassign err_cond = (counter > 6) && in;\n  \n\talways @(posedge clk or posedge reset) begin \n\t\tif(reset) begin\n\t\t\tdisc <= 0;\n\t\t\tflag <= 0;\n\t\t\terr  <= 0;\n\t\t\tcounter <= 3'b000;\n\t\tend else begin\n\t\t\tdisc <= disc_cond;\n\t\t\tflag <= flag_cond;\n\t\t\terr <= err_cond;\n\t\t\tif(in) \n\t\t\t\tcounter <= counter + 1'b1;\n\t\t\telse\n\t\t\t\tcounter <= 3'b000;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\nreg [2:0] count; // Counter to keep track of 1's sequence.\nwire detect_flag = (count == 6);\nwire detect_disc = (count >= 5) && (count < 7);\nwire detect_err = (count > 6);\n\t\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\t// Reset the counter.\n\t\tcount <= 3'b0;\n\t\t\n\t\t// Deactivate all outputs.\n\t\t{disc, flag, err} <= 3'b0;\n\tend else begin\n\t\t// Update the counter based on input in.\n\t\tif (in) begin\n\t\t\tcount <= count + 1;\n\t\tend else begin\n\t\t\tcount <= 3'b0;\n\t end\n\t \n\t // Set outputs according to detected sequences.\n\t disc <= detect_disc;\n\t flag <= detect_flag;\n\t err  <= detect_err;\n  end\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": " \n   reg [3:0] state; // 4-bit state register\n   \n   parameter IDLE = 4'b0000;\n   parameter WAIT1 = 4'b0001;\n   parameter FLAG_START = 4'b0010;\n   parameter DISCARD = 4'b0011;\n   parameter ERROR = 4'b0100;\n   \n\talways @(posedge clk or posedge reset) begin // State register\n      if (reset) \n         state <= IDLE;\n      else \n\t\t\tcase (state) \n\t\t\t\tIDLE:       if (in) state <= WAIT1;\n           \tFLAG_START: if (~in) state <= IDLE;\n               DISCARD:   if (~in) state <= IDLE;\n               ERROR:     if (~in) state <= IDLE;\n\t\t\t\tdefault:    state <= IDLE; // IDLE case as default\n\t\t\tendcase \n\t\tend \n\n\tassign disc = (state==DISCARD); // Output signals \n   assign flag = (state==FLAG_START || state==IDLE);\n   assign err  = (state==ERROR    || state==IDLE);\n   \n\talways @(posedge clk) begin // Next state logic \n      case (state) \n\t\t\tIDLE:       if (in) state <= WAIT1;\n            FLAG_START: if (~in) state <= IDLE;\n               DISCARD:   if (~in) state <= IDLE;\n               ERROR:     if (~in) state <= IDLE; \n\t\t\tdefault:    state <= IDLE; // IDLE case as default\n\t\tendcase \n\tend\n   \nendmodule \n"}
{"task_id": "fsm_hdlc", "completion": "\n    reg [2:0] state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= 3'b110; // The initial state should be any value but 7'b0, to avoid the condition in the else-if.\n        else case (state)\n            3'b110: if (in) state <=  3'b110;    // If 0, remain in same state.\n                    else begin disc <= 1; state <= 3'b001; end // If 1, shift and wait for next input.\n            3'b001: if (in) state <= 3'b011;     // Waiting for another 5 zeros to appear.\n                    else begin disc <= 0; state <= 3'b110; end // If not, back to initial and start counting again.\n            3'b011: if (in) state <=  3'b101;    // Waiting for the flagged 6 zeros followed by a one to appear.\n                    else begin err <= 1; state <= 3'b110; end // If not, error and back to initial.\n            3'b101: if (in) state <=  3'b101;    // Flagged six zeros followed by a one is already detected. Wait for next input.\n                    else begin flag <= 1; state <= 3'b110; end // If not, the frame starts and signal that a frame is being found.\n            default: state <= 3'b110;             // To avoid any other condition but the above cases.\n        endcase \n    end \nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": " \n    reg [3:0] state;\n    parameter IDLE = 4'b0001, DATA_5 = 4'b0010, FLAG = 4'b0100, DISC = 4'b1000;\n    \n    always @(posedge clk or posedge reset) begin \n        if (reset) \n            state <= IDLE;\n            \n        else case (state) \n            IDLE: \n                if (!in) \n                    state <= DATA_5;\n                \n            DATA_5: \n                if (!in) \n                    state <= FLAG;\n                    \n                else begin\n                    disc <= 1'b0;\n                    flag <= 1'b0;\n                    err <= 1'b0;\n                    state <= IDLE;\n                end   \n                \n            FLAG: \n                if (in) begin\n                    flag <= 1'b1;\n                    state <= DISC;\n                end  \n            \n            else begin\n                    disc <= 1'b0;\n                    flag <= 1'b0;\n                    err <= 1'b0;\n                    state <= DATA_5; \n                 end\n                     \n            DISC: \n                if (in) begin\n                    disc <= 1'b1;\n                    state <= IDLE;\n                    \n                end else begin\n                        disc <= 1'b0;\n                        flag <= 1'b0;\n                        err <= 1'b0;\n                        state <= DATA_5; \n                       end      \n            default: state <= IDLE;       \n        \n        endcase  \n    end    \nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [3:0] shift_register;\n    \n    localparam START = 4'b1110; \n    localparam FLAG  = 4'b11110;\n    localparam ERROR = 4'b11111;\n\n\t//State machine\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset == 1) begin\n    \t\tshift_register <= 4'b0; \n        \tdisc <= 0;\n            flag <= 0;\n            err  <= 0;\n        end\n\t    else begin  \n    \t    shift_register <= {shift_register[2:0],in}; // Shift register.\n            \n      \t    if (shift_register == START) begin \n        \t    disc <= 1; // If five '1's detected, discard next bit.\n            end else begin\n            \tdisc <= 0;\n    \t        end  \n         \tif (shift_register[3:0] == FLAG) begin \n             \tflag <= 1; // Frame boundary found.\n        \t    end else begin\n             \tflag <=0;\n          \t    end     \n      \t      if (|(shift_register & ERROR)) begin   \n                err  <= 1; // Error, 7 or more consecutive \u20181\u2019s detected.\n            end else begin\n            \terr <= 0;\n       \t        end  \n        \tend\n    \tend\n\tendmodule\n\n"}
{"task_id": "fsm_hdlc", "completion": "\n\n\treg [3:0] counter;\n    reg prevInput;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 4'b1000; // Previous input was 0.\n\t    disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n        \tprevInput <= in;\n\t\tif(in == prevInput && in == 1) begin\n\t\t    counter <= counter + 1'b1; // Increment counter if same bit is seen twice.\n                case (counter[2:0]) \n                    3'b011 : disc <= 1; // Discard after seeing three consecutive ones.\n                    3'b111 : begin flag <= 1; counter <= 4'b1000; end // Flag at the end of frame.\n\t\t     default : err  <= 1 ;   // Error when 7 or more consecutive ones are seen.\n                endcase            \t    \n\t    end else if (in != prevInput) begin    // Reset counter on change of bit.\n\t        disc <= 0;\n        \terr <= 0;\n        \tif(in == 0 && counter[2:0] ==3'b110)  begin \n\t\t     flag <= 1; counter <= 4'b1000; end   // Frame boundary at the start of frame.\n\t\telse  counter <= 4'b1000;\n            end   \n        end        \nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [3:0] state;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 4'b1000;\n\t\telse case (state)\n\t\t\t4'b1000: if (in == 0) state <= 4'b0001; else state <= 4'b1001;\n\t\t\t4'b1001: if (in == 0) state <= 4'b1101; else state <= 4'b1001;\n\t\t\t4'b0001: if (in == 0) state <= 4'b0011; else state <= 4'b1000;\n\t\t\t4'b1101: if (in == 0) begin disc <=1 ; state <= 4'b0000; end \n\t\t\t\t\telse if(~&state[3:2]) state <= state + 2'd1; else begin err<=1; state <= 4'b0000; end\n\t\t\t4'b0011: if (in == 0) state <= 4'b1110; else state <= 4'b0000;\n\t\t\tdefault: state <= 4'b1000;  // idle or erroneous\n\tendcase\n\tflag <= &state[3:2];\n\tend\n\t\n"}
{"task_id": "fsm_hdlc", "completion": "\n    \n    reg [2:0] cnt; // Counter to count consecutive 1s.\n    parameter PARAM_7 = 3'b1111111;  // 6 consecutive 1 followed by a zero (i.e., 'flag')\n    parameter PARAM_5 = 3'b11111;   // Consecutive five 1s (i.e., discard)\n    \n\talways @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin\n            cnt <= 0;\n\t        disc <= 0;\n            flag <= 0;\n            err <= 0;\n\t    end\n         else begin\n\t\t\tcase(cnt) \n\t\t\t    3'b000: if (!in) cnt <= cnt + 1; // idle state. wait for a '1'.\n\t\t\t\t    PARAM_5 : begin\n                        disc <= 1; // Discard next bit since we detected the sequence of five consecutive '1s'.\n\t\t\t\t\t\tcnt <= 3'b000; \n                    end \n\t\t\t    3'b1[2:0]: if (in) cnt <= cnt + 1; else disc <= 0; // Counting until three. Wait for a zero to complete the count. If in comes as '1', restart from idle state.\n                PARAM_7 : begin \n                        flag <= 1; // We detected our frame boundary sequence.\n\t\t\t\t\t\tcnt <= 3'b000;  \t\n                    end\t\t    \n                 default: if (in) begin cnt <= cnt + 1; err <= 0; end else begin cnt <= 3'b000; err <= 1; end;  // Counting until seven and wait for '0'. If in comes as '1', restart from idle state.\n\t\t\tendcase\t\t\t    \n        end  \n    end\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\t// declare state type and register\n\ttypedef enum {S0, S1, S2, S3, ERR} state_type;\n\tstate_type state, next_state;\n\t\n\t// define state transition table\n\talways @(posedge clk or posedge reset) begin \n\tif (reset) begin // asynchronous reset\n\t\t\tstate <= S0; \n\t\t\tend  \n\telse\n\t\t\tstate<=next_state; \n\t\tend    \n\t\n\t// state transition logic\n\talways @(in,state) begin   \n\tcase(state)\n\t\tS0: if (~in) next_state = S1; else next_state = ERR;\n\t\tS1: if ( in) next_state = S2; else next_state = S0;\n\t\tS2: if (~in) next_state = S3; else next_state = ERR;\n\t\tS3: if ( in) next_state = ERR; else next_state = S1;\n\t\tERR:if ( in) next_state=ERR; else next_state=S0; \n\tendcase   \n\tend     \n\t\n\t// output logic\n\tassign disc = (state == S3);\n\tassign flag = (state == S2 || state == S1); // end of frame or start of frame\n\tassign err  = (state == ERR);\n\t\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\n\t// FSM state encoding\n\tparameter S0 = 3'b001; // wait for 0 to occur\n\tparameter S1 = 3'b010; // wait for 5 consecutive 1s\n\tparameter S2 = 3'b100; // waiting for next bit after discard sequence\n\t\n\t// state register and next state logic\n\treg [2:0] state_r, state_nxt;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate_r <= S0;\n\t\telse\n\t\t\tstate_r <= state_nxt;\n\tend\n\t\n\t// next-state logic and output decoding\n\talways @* begin\n\t\tcase(state_r)\n\t\t\tS0: begin\n\t\t\t\tif (in == 1'b0) \n\t\t\t\t\tstate_nxt = S1; // go to state after we see a 5 consecutive ones\n\t\t\t\telse \n\t\t\t\t\tstate_nxt = S0; // stay in current state if we see zero or more than five ones\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (in == 1'b1) \n\t\t\t\t\tstate_nxt = S2; // go to waiting for next bit after discard sequence\n\t\t\t\telse \n\t\t\t\t\tstate_nxt = S0; // transition back to start if zero occurs\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (in == 1'b1) \n\t\t\t\t\tstate_nxt = S2; // stay in the same state if more than five ones occur or zero is seen\n\t\t\t\telse \n\t\t\t\t\tstate_nxt = S0; // transition back to start if we see a single zero after discard sequence\n\t\t\tend\n\t\t\tdefault: state_nxt = S0; // default state, go back to beginning for any other cases\n\t\tendcase\n\tend\n\t\n\t// output decoding \n\tassign disc = (state_r == S1); // signal a bit needs to be discarded when in state after seeing one zero followed by five ones\n\tassign flag = (state_r == S0 && in == 1'b0) || (state_r == S2); // flag the beginning/end of frame when we see 6 consecutive ones or detect an error when more than seven consecutive ones occur.\n\tassign err  = (state_r == S1 && in == 1'b1); // signal an error when five consecutive ones are seen\n\nendmodule\n\n"}
{"task_id": "fsm_hdlc", "completion": "\n\t// State definitions for FSM\n\tlocalparam IDLE = 3'b001; // Initial state.\n\tlocalparam WAIT_FOR_ZERO = 3'b010; // After a sequence of 5 ones, waiting for zero.\n\tlocalparam SEARCHING = 3'b100; // Searching for flag or error pattern.\n\n\t// State register and next state logic\n\treg [2:0] state_r, next_state;\n\talways @(posedge clk) begin\n\tif (reset) \n\t\tstate_r <= IDLE;\n\telse \n\t\tstate_r <= next_state;\n\tend\n\t// Output logic and state transition\n\tassign disc = (state_r == WAIT_FOR_ZERO)?1'b1:1'b0;\n\tassign flag = (state_r[2] | state_r[0])?1'b1:1'b0;\n\tassign err = (state_r[1])?1'b1:1'b0;\n\t// Next State Logic\n\talways @(*) begin\n\tcase (state_r) \n\tIDLE: next_state = in ? SEARCHING : IDLE; // If in is 1 move to searching state.\n\tWAIT_FOR_ZERO: next_state = in ? WAIT_FOR_ZERO : SEARCHING; //If zero after sequence, move to search for flag or error.\n\tSEARCHING: next_state = ({in, state_r[1:0]} == 3'b010) ? WAIT_FOR_ZERO : SEARCHING; // If 5 ones encountered, move to wait for zero after the sequence.\n\tdefault: next_state = IDLE;\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\n\treg [2:0] state;\n\twire next_state = in ? state + 1'b1 : 3'h0;\n   wire discard = ~(state[2] & ~state[1]);\n   wire detect = ~(state == 3'h5) ;\n   \n\talways @ (posedge clk or posedge reset) begin\n\t\tif(reset) state <= 3'b0;\n      else if((discard && in) || (detect )) begin \n          disc<=1'b1; //assert for a cycle when it is supposed to discard\n\t\t  flag<=1'b0; //de-assert frame indicator and error signal as these occur at same time.\n\t\t  err<=1'b0;\n\t   end else if(state == 3'h5 && in) begin\n          state <= next_state ;\n\t      disc <= 1'b0; // de-assert discard bit because of error sequence\n\t      flag <= 1'b0; //de-assert frame indicator and assert error signal as these occur at same time.\n\t\t  err<=1'b1;  \n       end else if(state[2:1] == 2'h3 && ~in) begin\t    \n          state <= next_state ;\n\t      disc <= 1'b0; // de-assert discard bit because sequence ends with zero\n         flag <= ~state[0];  // assert frame indicator when it is supposed to be the end of a frame.\n\t\t err<=1'b0;  //de-assert error signal as this occurs at same time with flag assertion\n       end else begin\t    \n          state <= next_state ;\n\t      disc <= 1'b0; // de-assert discard bit because sequence does not occur in the middle of frame.\n         flag<=1'b0;   //de-assert frame indicator as it is supposed to be the start/end of a frame.\n\t\t err <=1'b0 ;  //de assert error signal as this does not apply during valid frame condition.\t  \t   \n       end   \n\tend\nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\n\n\tassign out = sel ? b : a; // corrected mux expression.\n\t\t  \nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\nThe code should be fixed by replacing the assign statement with always @(*) block for handling all possible combinations. Because multiplexer output is not a signal that can be directly assigned (it must be a register), we need to use always blocks or flip-flops in order to update its value at each clock cycle. \n\nmodule top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\nalways @(*) begin\n\tif (sel)\n\t    out = b;\n\telse \n\t    out = a;\nend\nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug is in the output declaration. The output \"out\" should be an 8-bit wide wire or register if you are assigning it with a value from within combinational logic (like below). Also, your mux implementation seems correct according to its description but I suggest to use a conditional operator instead of long concatenation which can make the code more readable.\n\t\n\t//Corrected module\n\tmodule top_module(\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out);\n\t\n\talways @(*) begin\n\t    if (sel) \n\t\t    out = b; // If sel == 1 then select input b else a. This is the same as your original logic.\n        else \n            out = a;  \n\tend\n\t\n\t// or using conditional operator in one line\n\t// assign out = sel ? b : a;\n    \nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug in the given code is that it does not correctly implement the 2-to-1 mux. Instead of selecting between the two inputs based on sel (which should select from a or b), the mux seems to always output either input A or B. The correct way to do this would be:\n\n\tassign out = sel ? b : a; // ternary operator\nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug in the code is that it's not correctly multiplexing the 8-bit inputs 'a' and 'b'. The logic expression `(~sel & a) | (sel & b)` should be changed to `((~sel)&{8{a}}) | ((sel)&{8{b}})` because of the bitwise AND operation.\nThe fixed code is:\n"}
{"task_id": "bugs_mux2", "completion": "\nThere is no bug in the given code. However, it seems to be missing an assignment of output 'out'. We need to assign 'out' as a combination of 'sel', 'a' and 'b':\n\n\tassign out = (~sel & a) | (sel & b);\n"}
{"task_id": "bugs_mux2", "completion": "\n\t// The bug is in the output type. It should be an 8-bit wide register because it's being assigned with two 8-bit inputs (a & b).\n\t\n\talways @(*) begin\n        \tif(~sel)\n\t\t   out <= a;\n        \telse\n\t\t   out <= b;\n    \tend\n\nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug is that the output 'out' in the above code is 8-bit wide but assigned with a single bit. To fix this error, the line should be modified to select a single bit from either of the input arrays according to sel value. This can be done by changing out[7:0] to just out.\n\tassign out = (~sel & a) | (sel & b); //Selecting bitwise\n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug is that the output `out` should be a wire or 8-bit wide register since it's not updated within an always block. Also, you need to use bitwise OR for every bit in the 8-bit input as well because when sel = 0, out[i] = a[i], and when sel = 1, out[i] = b[i].\n\nThe corrected code is:\n\n\tassign out = (~sel & a) | (sel & b);\n"}
{"task_id": "bugs_mux2", "completion": "\n\tThe bug is that the output type is reg and not wire. \n\tMux outputs should be of wire data type as it is combinational logic or register outputs for sequential design. \n\tSo, instead of using 'reg', we use 'wire'. The correct code would be :\n\t"}
{"task_id": "bugs_mux2", "completion": "\nThere's no bug in this code. It is already correct 2-to-1 mux that selects between inputs a and b based on sel input. However if you want to return a single bit output rather than an 8-bit, the following modification can be made:\n\n\tassign out = sel ? b : a;   //if sel is high then output will come from 'b' else it will come from 'a'\n\nendmodule \n"}
{"task_id": "bugs_mux2", "completion": "\n\tThe bug lies in the use of 'or' operation when both inputs are required. This will not yield correct output if either input is all 1s (i.e., -1 for signed numbers or 255 for unsigned ones). Therefore, we should instead use an 'if-else' construct to ensure that only valid bits pass through the mux based on sel bit:\n\t\n\tassign out = sel ? b : a;\n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug is that the output should be an array of 8 bits, not one single bit. The correct code would be like this:\n\nout = (~sel & a) | (sel & b);\nendmodule\n\n"}
{"task_id": "bugs_mux2", "completion": "\nThere's no bug. The given code is correct as it performs 2-to-1 multiplexing where \"sel\" selects between inputs 'a' and 'b'. If sel = 0, the output will be same as input a; if sel = 1, then the output will be same as input b.\n"}
{"task_id": "bugs_mux2", "completion": "\n\tThe output 'out' is 8-bit wide but the assign statement only has one bit. Thus, we need to replace \u2018out\u2019 with a vector of 8 bits in order for this mux to work correctly. Here's how you can fix it:\n\t\n\tfor (i = 0; i < 8; i++) begin : gen_mux\n\t    assign out[i] = (~sel & a[i]) | (sel & b[i]);\n\tend \n"}
{"task_id": "bugs_mux2", "completion": "\n\tThe bug in this code is that it's only handling one bit of the 8-bit bus. This means that the 'out' signal will always be the selected value from either 'a' or 'b', regardless of whether sel is high (1) or low (0). We should select bits independently for each position in a, b and sel to get a 8-bit mux.\n\t\n\tThe fixed code:\n"}
{"task_id": "bugs_mux2", "completion": "\nThe problem in this code is that it's assigning the output to be an 8-bit wide signal. Therefore, if sel = 1 (true), then both a and b are completely ignored because the mux operation only outputs one bit at a time. The fixed version of this code would look like:\n\n\tassign out = sel ? b : a; // Use ternary operator instead of an assign statement to correctly select between two inputs. \n"}
{"task_id": "bugs_mux2", "completion": "\nThe bug is that the output of mux is 8 bits wide but there are no bits specified for assignment. To fix this, we need to iterate through each bit of the input and select which bit should be assigned depending on the sel value. Here's how you can do it in verilog:\n\n\tassign out = sel ? b : a;\n"}
{"task_id": "bugs_mux2", "completion": "\n\tThe issue in this module is that the output 'out' should be 8 bit wide and not just single bit. We need to match the width of 'a' and 'b'. Here is the corrected code:\n\tassign out = (~sel & a) | (sel & b);\nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\nThe issue here is that the 'out' variable is declared as a single bit instead of an 8-bit wide bus. This causes a signal mismatch error when using it in an assignment and will give you a compilation error. Here is the correct code:\n\n\tassign out = (~sel & a) | (sel & b);\n\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 10'd0;\n\telse\n\t\tq <= q ==  10'd999 ? 10'd0 : q +  10'd1 ;\nend\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\nalways @ (posedge clk or posedge reset) begin\n\tif (reset == 1'b1) \n\t\tq <= 10'd0;\n\telse if(q < 10'd999) \n\t\tq <= q + 1;\n\telse if (q >= 10'd999) // If counter is at max value, reset it to 0\n\t\tq <= 10'd0;  \nend\n"}
{"task_id": "review2015_count1k", "completion": "\nalways @ (posedge clk or posedge reset) begin\n\tif(reset)\n\t\tq <= 10'd0;\n\telse if(q == 10'd999) \n\t\tq <= 10'd0;\n\telse\n\t\tq <= q + 1'b1;\nend\n\n"}
{"task_id": "review2015_count1k", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) \n\t\tq <= 10'd0;\n\telse if (q < 10'd999) \n\t\tq <= q + 1;\nend\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\t\n\t// Declare internal variables for counting\n\treg [9:0] nextQ; // Next counter value\n\twire [10:0] t_q = {2'b0, q}; // 11-bit temporary variable for adding 1 to counter.\n\n\talways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\t\tnextQ <= 9'd0; // Reset the counter if reset is active\n\telse \n\t\t\tnextQ <= t_q[10:1]; // Adding 1 to counter and shifting right by one place.\n\tend\n\n\tassign q = nextQ;\n\t\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\n\treg [9:0] cnt;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            cnt <= 10'd0;  \n        else \n\t\t\tcnt <= (cnt == 10'd999) ? 10'd0 : cnt + 1'b1;  // modulo operation in a one-liner\n\tend\n    \n    assign q = cnt;\nendmodule\n\n"}
{"task_id": "review2015_count1k", "completion": "\n   always @(posedge clk or posedge reset) begin\n      if (reset == 1'b1) \n         q <= 10'd0;\n      else if(q==10'd999) // if counter reaches maximum value, wrap around to 0\n          q<=10'd0;\n      else  \n\t       q <= q + 1'b1; // increment by one on each clock cycle.\n   end\nendmodule\n\n"}
{"task_id": "review2015_count1k", "completion": "\n\treg [9:0] count;\n  \n\talways @ (posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) \n\t\t\tcount <= 1000;\n\t\telse if (count != 0 ) \n\t\t\tcount <= count - 1;\n\tend\n\tassign q = count;\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 10'b0;\n\telse if (q == 10'd999)\n        \tq <= 10'b0;\n    \telse  \n      \t\tq <= q + 1;\nend\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\n\t// This code assumes that the clock is a rising edge triggered signal. \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t    // Resetting counter to 0 on high active 'reset' input synchronous with clock\n\t\t\tq <= 10'd0;  \n\t\telse if (q < 10'd999)\n\t\t\t// Incrementing the count in every rising edge of clock until reaching 999.\n\t\t    q <= q + 1;    \n        else \n            // If counter has reached max value, then resetting it to start counting from beginning again (modulo operation).\n\t\t\tq <= 10'd0;     \n\tend\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\treg [9:0] count;\n\t\n\t// reset counter when reset input is high\n\talways @(posedge reset) begin \n\t\tcount <= 10'd0;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset == 1'b0) begin\n\t\t\tcount <= count + 1;\n\t\t\t// once counter reaches max value, reset it\n\t\t\tif(count == 10'd999) \n\t\t\t\tcount <= 10'd0;\n\t\tend\n\tend\n\tassign q = count;\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\n\t// Declare an internal register for counting purposes\n\treg [9:0] count; \n\n\talways @ (posedge clk or posedge reset) begin\n\t    if(reset) \n\t        // Reset to zero when reset is active high\n\t\t    count <= 10'b0; \n        else \n            // Increment counter on each clock cycle until it reaches 999, then reset back to zero.\n\t\t    count <= (count == 999)? 10'b0 : count + 1; \n\tend\n\n\t// Output the current value of the counter\n\tassign q = count;\n\t\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 10'd0;\n        else \n            q <= q + 10'd1 == 10'd1000 ? 10'd0 : q + 10'd1;\n    end\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\n\t// 10 bits are used to represent a decimal number up to 999. Therefore, the maximum count should be 2^10 - 1 = 1023. But we need one more clock cycle for overflow detection and subtracting it from counter. So, considering 1024 cycles gives us an extra clock cycle for checking the rollover condition after reaching the value of 1023.\n\tlocalparam MAX_COUNT = 'd1024;\n\t\t\n\t// Synchronous reset and synchronous active high count logic\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t        q <= 10'b0;\n    \telse if (q >= MAX_COUNT - 1) \n        \tq <= 10'b0;\n    \telse \n        \tq <= q + 1;\n\tend  \n\t\t\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)  // active high synchronous reset\n\t\t\tq <= 10'h0;    // reset counter to 0 on a rising clock edge while reset is asserted\n\t\telse if(q < 10'd999 )// if the counter is less than or equal to 999, count up normally.\n\t\t\t q <= q + 10'b1;   // Increase by 1 in each cycle of the clock\n\t\t else\n             q <= 10'h3E8;\t// If the counter reaches its maximum value of 999, reset to 0 after a rising clock edge\t\n    end\nendmodule \n\n"}
{"task_id": "review2015_count1k", "completion": "\n   always @ (posedge clk or posedge reset) begin\n      if (reset) \n         q <= 10'b0;\n      else \n         q <= q + 10'd1;\n\tend\nendmodule\n\n"}
{"task_id": "review2015_count1k", "completion": "\n\treg [10:0] count; // We need one more bit for the overflow check\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) \n\t\t\tcount <= 11'h3e8; // Reset to 999 in hexadecimal\n\t\telse \n\t\t\tcount <= count + 11'h01; // Increment the counter\n\t\t\t\n\t\tq = count[9:0];\t// Output only least significant 10 bits\n\tend\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\treg [9:0] next;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tnext <= 10'h3E8; // equivalent to 999 in decimal, this is used so that the counter overflows and resets to 0 after reaching its maximum count.\n\t\tend else begin\n\t\t\tq <= next;\n\t\t\tnext <= next + 1'b1;\n\t\tend\n\tend\n\t\n\t// The reset signal is synchronous active high, meaning if it goes high during the clock cycle, it will be recognized at the following positive edge of clk. \n\t// And the counter counts from 0 to 999 (inclusive) in 1000 cycles since the clock rate is the same as the counting frequency.\n\t\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n\treg [9:0] count;\n\talways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\tcount <= 10'd0;\n\tq <= 10'd0;\nend else begin\n\tif(count == 10'd998)  //since we need a period of 1000 cycles, the last increment will be out of range, so it should reset.\n\t\tbegin\n\t\t\tcount <= 10'd0;\n\t\t\tq <= 10'd0;\n\t\tend\n\telse begin\n\t\tcount <= count + 10'd1;\n\t\tq <= count[9:0];\n\tend\n    end \nend\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\n   always @ (posedge clk or posedge reset) begin\n   \tif (reset) \n      \tq <= 10'd0;\n      else if(q == 10'd999) // when the counter reaches its maximum, we wrap it back to zero\n        q <= 10'd0;\n      else\n    \t   q <= q + 10'd1;  // increment the counter\n    end\nendmodule\n"}
{"task_id": "circuit8", "completion": "\nalways @(posedge clock) begin\n\tif (a==1'b0) begin\n\t    p <= 1'bx;\n        q <= 1'bx;\n    end else if ((q == 1'b0 && a == 1'b1) || (p == 1'b1 && a ==1'b1)) begin\n\t\tp <= ~q;\n        q <= p; \n\tend else begin \n\t    p <= p;  \n        q <= q;   \n    end\nend\n"}
{"task_id": "circuit8", "completion": "\n\tp = 0;\n\tq = 0;\n\talways @(posedge clock) begin\n\t    if (a == 1'b1)begin\n\t        {p,q} = {~p & q , p ^ q};\n        end  \n    end \nendmodule\n\n"}
{"task_id": "circuit8", "completion": "\nreg temp; // Temporary register for flip flop's output\n\nalways @(posedge clock) begin\n\tif (a == 1'b0) begin\n\t\tp <= 1'bx;\n\t\tq <= 1'bx;\n\tend else if (temp == 1'b1) begin\n\t\tp <= a ^ q;\n\t\tq <= p ^ a;\n\tend else begin\n\t\tp <= a ^ q;\n\t\tq <= p ^ a;\n\tend \t\t\n\t\n\ttemp <= a; // Temporary register for flip flop's output update\nend\nendmodule\n"}
{"task_id": "circuit8", "completion": "\n\treg [1:0] state;\n\talways @(posedge clock) begin\n\t\tcase (state)\n\t\t\t2'b00 : if (a==1) begin state <= 2'b01; p<=1'b0; q<=1'b0; end else begin state <= state; p<=p; q<=q; end \n      \t\t2'b01 : if (a==1) begin state <= 2'b10; p<=1'b0; q<=1'b1; end else begin state <= state; p<=p; q<=q; end \n      \t\t2'b10 : if (a==1) begin state <= 2'b00; p<=1'b1; q<=1'b0; end else begin state <= state; p<=p; q<=q; end \n\t\tdefault: ;\n    \tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit8", "completion": "\n\talways @(posedge clock) begin\n\t\tif (!a) begin\n\t\t\tp <= 1'b0;\n\t\t\tq <= !p;\n\t\tend else begin\n\t\t\tp <= 1'b1;\n\t\t\tq <= ~a;\n\tend \nend \nendmodule\n"}
{"task_id": "circuit8", "completion": "\n\tp <= ~a;\n\t\n\talways @(posedge clock) begin\n\t    q <= a;\n\tend\n\t\t\nendmodule\n\n"}
{"task_id": "circuit8", "completion": "\ninitial begin\n\tp = 1'bX; // initializing p and q to X for simulation.\n\tq = 1'bx; \nend\n\nalways @(posedge clock or negedge a) begin\n\tif (!a) begin // if input a is zero, do nothing.\n\t\tp <= p;\n\t\tq <= q;\n\tend\n\telse begin // if input a is one, flip the bits of p and q.\n\t\tp <= ~p; \n\t\tq <= ~q;\n\tend\nend\n"}
{"task_id": "circuit8", "completion": "\n\tp <= (a == 1'b1) ? ~q : 'x;\n\n\talways @(posedge clock) begin\n\t    q <= ~p;\n\tend\nendmodule \n"}
{"task_id": "circuit8", "completion": "\np <= clock ? ((~a & ~q) | (a & p)) : 1'bz;\nq <= clock ? (a ^ p) : 1'bz;\n"}
{"task_id": "circuit8", "completion": "\nalways @(posedge clock) begin\n\tif(!a) begin\n\t\tp <= 0;\n\t\tq <= !p;\n\tend else begin\n\t\tp <= 1;\n\t\tq <= !p;\n\tend\nend\nendmodule\n"}
{"task_id": "circuit8", "completion": "\n\tp <= a;\n\talways @(posedge clock) begin\n\t\tif (!a) begin\n\t\t\tq <= 0;\n\t\tend else if (p == 1 && q != 1) begin\n\t\t\tq <= 1;\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "circuit8", "completion": "\nalways @(posedge clock) begin\n\tif (a == 1'b0) begin\n\t\tp <= 1'bx;\n\t\tq <= 1'bx;\n\tend else if (a == 1'b1) begin\n\t\t{p, q} <= {q, p}; //Rotate right by one bit \n\tend\nendmodule\n"}
{"task_id": "circuit8", "completion": "\n\t// Detailed Implementation Starts Here //\n\tp = a;\n\tq = ~a & ~p;\n\talways @(posedge clock) begin\n\t\tif (a == 1'b0 && p != 1'b1)\n\t\t\tq <= 1'b1;\n\t\telse \n\t\t\tq <= 1'b0;\n\tend\n\t// Detailed Implementation Ends Here //\n"}
{"task_id": "circuit8", "completion": "\n\treg temp;\n\n\talways @(posedge clock) begin\n\t\t\n\t\tif(!a & !p)begin\n\t\t\t\tp <= 1'b0;\n\t\t\t\tq <= temp;\n\t\tend \n\t\t\n\t\telse if (!a & p)begin\n\t\t\t\tp <= 1'b1;\n\t\t\t\ttemp <= q;\n\t\t\t\tq <= ~q;\n\t\tend \n\n\t\telse begin\n\t\t\t\tp<=p;\n\t\t\t\tq<=q;\n\t\tend\n\tend\n\n"}
{"task_id": "circuit8", "completion": "\np <= a;\nq <= (a && !p) || (!a && p);\nalways @(posedge clock) begin\n\tif(!clock)begin\n\tp <= 0;\n\tq <= 0;\n\tend\nend\nendmodule\n\n"}
{"task_id": "circuit8", "completion": "\n\tp <= a;\n\talways @(posedge clock) begin\n\t\tif (a == 1'b0) begin\n\t\t\tq <= ~p;\n\t\tend else begin\n\t\t\tq <= p;\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "circuit8", "completion": "\n\treg [1:0] state;\n\n\t// State transition diagram\n\talways @(posedge clock) begin\n\tcasez (state)\n\t\t2'b0?: if (!a) state <= 3; // 0 -> 0, 0 -> 3\n\t\t2'b10: if ( a) state <= {~q, p}; // 2 -> b, 1 -> c\n\t\t2'b11: if (!a) state <= 0; // 3 -> 0, 4 -> 0\n\tendcase\n\tend\n\t\n\t// Output decoding\n\tp <= (state == 2'b10);\n\tq <= (state == 2'b11);\n\n"}
{"task_id": "circuit8", "completion": "\n\tp = ~a & ~q;\n\tq = a & p;\n\t\n\talways @(posedge clock) begin\n\t   p <= ~a & ~q;\n       q <= a & p;\n    end\nendmodule\n\n"}
{"task_id": "circuit8", "completion": "\n    always @(posedge clock) begin\n\tif(a) begin\n\t    p <= 0;\n            q <= ~p;\n        end else begin\n\t    p <= q;\n            q <= ~q;\n\tend\n    end\n    \nendmodule \n\n"}
{"task_id": "circuit8", "completion": "\n\tp = ~a; // inverting gate\n\talways @(posedge clock) begin\n\t\tq <= a; // D flip-flop\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n    \n    assign out = ~(in1 | in2);\n    \nendmodule\n  \n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\n    always_comb begin\n        out = ~(in1 | in2);\n    end\nendmodule \n\n"}
{"task_id": "m2014_q4e", "completion": "\n\n\tassign out = ~(in1 | in2);\n\t\t\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n    \n    assign out = ~(in1 | in2);\n    \nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\t//NOR Gate Implementation\n\tassign out = ~(in1 | in2);\nendmodule \n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\n\tassign out = ~(in1 | in2);\nendmodule\n"}
{"task_id": "m2014_q4e", "completion": "\n\n\tassign out = ~(in1 | in2);\n\nendmodule\n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule \n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule\n"}
{"task_id": "m2014_q4e", "completion": "\n\nassign out = ~(in1 | in2);\n\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\n\t// 2-input NOR Gate Implementation\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n\n\tassign out = ~(in1 | in2);\n\t\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n    assign out = ~(in1 | in2);\nendmodule \n"}
{"task_id": "m2014_q4e", "completion": "\n\tassign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "m2014_q4e", "completion": "\n    assign out = ~(in1 | in2);\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\t// Replicate bit[7] 24 times and concatenate with input.\n\tassign out = {24{in[7]}, in};\nendmodule\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = { {24{in[7]}}, in };\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\nassign out = {24{in[7]}, in};\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in; \nendmodule\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = { {24{in[7]}}, in };\nendmodule \n\n"}
{"task_id": "vector4", "completion": "\n\n\tassign out = {24{in[7]}}, in; // Use replicate operator to extend sign and concatenate 8-bit input into a 32-bit output.\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\n\tassign out = {24{in[7]}}, in;\n\t\nendmodule \n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in; \nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\t// Assuming that the sign bit of an 8-bit value is located at position 7.\n\tassign out = {24{in[7]}}, in;   // Replicate the most significant bit (sign) 24 times and then concatenate with the number itself.\nendmodule\n"}
{"task_id": "vector4", "completion": "\nassign out = {24{in[7]}}, in;\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}, in};\nendmodule\n\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in;\nendmodule\n"}
{"task_id": "vector4", "completion": "\n\tassign out = {24{in[7]}}, in; //replicate sign bit 24 times and then append the input number itself\nendmodule\n\n"}
{"task_id": "2014_q3fsm", "completion": " \n\ttypedef enum {A=2'b01, B=2'b10} state;\n\tstate [1:0] curr_state, next_state;\n\treg [2:0] cnt;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tcurr_state <= A;\n\t\telse \n\t\t\tcurr_state <= next_state;\n\tend\n\t// State transition logic.\n\talways @(*) begin\n\t\tcase (curr_state)\n\t\t\tA: if (!s) \n\t\t\t\tnext_state = A; // stay in state A until s = 1 is detected.\n\t\t\telse \n\t\t\t\tnext_state = B; // move to state B when s = 1.\n\t\t\tB: next_state = A; // always remain in state B and reset count cnt.\n\t\tendcase\n\tend\n\t// Output logic based on current state and counter value.\n\talways @(*) begin\n\t\tcase (curr_state)\n\t\t\tA: begin \n\t\t\t\tcnt = 3'b0; // No need to keep track of previous values.\n\t\t\t\tz = 1'b0; // reset z when in state A.\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif ((cnt == 3'b0) || (cnt == 3'b1)) \n\t\t\t\t\tcnt = w ? cnt + 1 : cnt; // Increment the counter if w=1.\n\t\t\t\telse \n\t\t\t\t\tcnt = 3'b1; // else, start count again after a single clock cycle in state B.\n\t\t\t\tz = (cnt == 2) && (w); // Set z to 1 if w was high exactly two clock cycles ago and current clock cycle.\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "\n\treg [1:0] counter;  // Counter to count the number of '1's in three clock cycles.\n\treg [2:0] state;   // State register for FSM.\n\n\t// Define states for FSM.\n\tparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100; \n\t\n\talways @(posedge clk or posedge reset) begin   // Asynchronous reset.\n\t\tif (reset == 1) begin    // Reset state A when reset is active high.\n\t\t\tstate <= A;\n\t\t\tcounter <= 2'b00;\n\t\tend else case (state) \n\n\t\t\tA: if(s==0)      // State remains in A unless s = 1.\n\t\t\t\t   state <= B;\n\t\t\t\telse   \n\t\t\t\t   state <= A;\n        \n        B: begin            // State transitions to C when s becomes '1'.\n                state <= C; \n                counter <= 2'b00; \n            end\n\t\t\tC: if(w==1)      // Counts '1' in next three clock cycles.\n\t\t\t\t   counter <= counter + 1'b1;\n\t\t\t\telse   \n\t\t\t\t   counter <= counter;\n        \n        D: begin            \n                state <= E; \n                z <= 0;  // Sets Z to 0 as w doesn't occur exactly twice in next three clock cycles.\n            end\n\t\t\tE: if(w==1)     // Counts '1' in next three clock cycles.\n\t\t\t\t   counter <= counter + 1'b1;\n\t\t\t\telse   \n\t\t\t\t   counter <= counter; \n        \n        default: state <= A;  // Default case to go back to start for invalid states.\n\t\tendcase\n\tend\n\t// Setting z = 1 when the count of '1's in last three clock cycles is exactly two.\n\tassign z = (state == E && counter == 2) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "\n\n\treg [1:0] counter; //counter to count the number of 1s in next three clock cycles\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] state; // current and next state\n\n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset) \n\t\t\tstate <= A;\n\t\telse\n\t\t\tcase (state) \n\t\t\t\tA : if (s == 1'b0) \n\t\t\t\t\t\tstate <= B; // stay in state A until s=1, then move to B\n\t\t\t\t\telse \n\t\t\t\t\t\tstate <= A;\n\n\t\t\t\tB : begin\n\t\t\t\t\tif(w==1'b1) begin\n\t\t\t\t\t\tcounter <= counter + 2'b01;// if w=1, increment the count\n\t\t\t\t\tend\n\t\t\t\t\tif (counter == 2'b10) // after two 1s in next three clock cycles move to C\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\telse \n\t\t\t\t\t\tstate <= B; // keep at B until counter reaches 2\n\t\t\t\tend\n\n\t\t\t\tC : begin \n\t\t\t\t\tif(w==1'b1) \n\t\t\t\t\t\tcounter <= 2'b01;// if w=1, reset the count to 1\n\t\t\t\t\telse  \n\t\t\t\t\t\tstate <= D; // else move to state D\n\t\t\tend\n\n\t\t\tD : begin\n\t\t\t\tif (s == 1'b1) begin\n\t\t\t\t\tz <= 1'b1; // when s goes high in state D set z=1 and keep it\n\t\t\t\tend \n\t\t\t\telse if (s == 1'b0) begin\n\t\t\t\t\tstate <= A; // else move back to A on next clock cycle, and reset z.\n\t\t\t\t\tz <= 1'b0;\n\t\t\t\tend  \n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "\n\treg [1:0] state;\n\treg [2:0] counter;  // Counter for the number of occurrences of 'w' in three cycles.\n\t\n\talways @(posedge clk, posedge reset) begin\n\t\t\n\t\tif (reset == 1) begin\n\t\t\t// Resetting to state A.\n\t\t\tstate <= 0;  \n\t\t\tcounter <= 3'b000;  // Initialising the counter to zero.\n\t\t\tz <= 0;  // Reseting output 'z'.\n\t\t\t\n\t\tend else if (s == 1 && state != 1) begin\n\t\t\t// Transitioning into state B from A or remains in A if s = 0.\n\t\t\tstate <= 1;  \n\t\tend\n\t\telse if (s == 0 && state == 1 ) begin \n\t\t\tif(w==1 && counter < 5) begin // Increment the counter only when w=1\n\t\t\t\t// Moving into a new cycle after transitioning to B.\n\t\t\t\tcounter <= counter + 3'b001;  \n\t\t\tend else if (w == 0 || counter >= 5 ) begin\n\t\t\t \tif(counter>=5) // Reset the counter since we have found two '1's in three cycles, and now it is checking for another series of three cycles. \n\t\t\t\t    counter <= 3'b000;  \n\t\t\tend else if (w==1 && counter >=3 ) begin\n\t\t\t\t// Setting z = 1 on the fourth clock cycle after we have found two '1's in three cycles and now it is checking for another series of three cycles.\n\t\t\t\tz <= 1;  // Outputting 'z'.\n\t\t\tend else if (w==1 && counter < 3 ) begin\n\t\t\t\t// Only incrementing the counter because w=1, but not enough to set z = 1 yet.\n\t\t\t\tcounter <= counter + 3'b001;  \n\t\t\t\tend\n\t  end\n    end \nendmodule\n\n"}
{"task_id": "2014_q3fsm", "completion": "\n\n\t//Defining states\n\ttypedef enum { A = 2'b01, B = 2'b10} state;  // Using typedef to make the code cleaner and more readable.\n\tstate present_state = A;\n\tstate next_state = A;\n    \n    reg [2:0] cnt = 3'd0;  // Counter for the three clock cycles of checking w input\n  \n\t// State transition logic and output z logic\n\talways @(*) begin\n\t    if (reset)\n\t        present_state <= A;\n        else\n            present_state <= next_state;\n            \n         case (present_state) \n           A : if (!s) begin\n                   next_state = A;\n               end \n               else \n                  next_state = B;\n          B : cnt = w ? cnt + 1'd1:3'b000; // Incrementing the count when w = 1\n         endcase\n\tend  \n    \n\t// Output z logic\n    always @(posedge clk) begin \n        if (reset) \n            z <= 0;\n        else if (!s && present_state == B && cnt == 3'd2) // Checking when two of w = 1 occurs and FSM is in state B\n            z <= 1;\n        else\n           z <= 0;  \n    end \nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "\n\t// State definitions\n\ttypedef enum {A=2'b00, B=2'b01, C=2'b10, D=2'b11} state_t;\n\tstate_t state, next_state;\n\treg [1:0] counter; // used to count 3 cycles in a row with w = 1.\n    \n\t// State transition logic & data path\n\talways @(posedge clk or posedge reset) begin : main_proc\n      if (reset == 1'b1) state <= A;\n\telse  state <= next_state;\n   end\n\n   always @(*) begin: nextStateLogic\n\tif (s == 0)\tnext_state = A; // Always stay in State A until s=1\n        else if (w==0) begin counter = 2'b00; next_state = B; end  // If w=0 start from B, but count zero cycles with w=0.\n\telse case(counter)\n        \t    2'b00: begin counter = 2'b01; next_state = C; end   // First clock cycle where w=1, set the state to C and move one step forward. \n         \t    2'b01: begin counter = 2'b10; next_state = D; end   \n              \tdefault : begin counter = 2'b00; z = 1'b1; next_state = B;end // In case of any other values, reset the counter and set z=1.\n        \t    endcase\n   end    \n\nendmodule \n"}
{"task_id": "2014_q3fsm", "completion": "\n\t//Declare states for FSM\n\ttypedef enum logic[2:0] {STATE_A = 3'b001, STATE_B = 3'b010} state_t;\n\tstate_t state;\n\tlogic [1:0] w_delay; //To store last two inputs of 'w'\n\talways @(posedge clk or posedge reset) begin \n\t    if (reset == 1'b1) begin\n\t        z <= 1'b0;    \n\t\t    state <= STATE_A;  \n\t\t\tw_delay <= 2'b00; //Reset Delay register after reset\n\t    end else case(state)\n\t\t    STATE_A: begin \n\t\t\t\tif (s == 1'b0) begin \n\t\t\t\t\tz<= 1'b0; //If s = 0, z is off.\n\t\t\t\tend  \n\t\t        if(s == 1'b1) state <= STATE_B; \n\t\t    end\n\t\t    STATE_B: begin \n\t\t\t\tif (&w_delay ==1'b1 ) begin //If w=1 for two cycles, set z = 1\n\t\t\t\t\tz <= 1'b1; \n\t\t\t\telse \n\t\t\t\t\tz <= 1'b0;//else keep z off\n\t\t    end  \n\t    endcase\n\t    if (state==STATE_B) w_delay <= {w_delay[0],w}; //Shift register of last two 'w' inputs.\n\tend\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": " \nparameter [2:0] STATE_A = 3'b000;\nparameter [2:0] STATE_B1 = 3'b001;\nparameter [2:0] STATE_B2 = 3'b010;\nparameter [2:0] STATE_C  = 3'b100;\n\t\nreg [2:0] state = STATE_A;\nreg [1:0] wCount = 2'b00;  // Counter for the number of 'w' transitions.\n    \nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= STATE_A;\n\t\twCount <= 2'b00;\n\tend else begin\n\t\tcase (state) \n\t\t\tSTATE_A : if (s == 1'b0) state <= STATE_B1; // s=0 stays in A.\n\t\t\tSTATE_B1: if (s == 1'b1) begin             // Transition to B when s=1 from A.\n\t\t\t\t       state <= STATE_C ;               // Counter will start incrementing after two clock cycles \n\t\t\t       \t\t\tif(w == 1'b1) wCount <= 2'b01;      // and w becomes 1 for first time.  \n\t\t\t\t\t     end\t\n\t\t\tSTATE_B2: if (s == 1'b1) begin             // Continues to stay in B while s=1 from B.\n\t\t\t\t       state <= STATE_C ;               // Counter will start incrementing after two more clock cycles \n\t\t\t       \t\t\tif(w == 1'b1) wCount <= 2'b10;      // and w becomes 1 for second time.  \t\n\t\t\t\t\t     end\t\t\t\t\t\t\t\n\t\t\tSTATE_C : begin                               // Stay in counter state if s=1 from B, or stay in A while s=0.\n\t\t\t\t       if(s == 1'b0) state <= STATE_A;       \n\t\t\t       \t\t\tif (wCount > 2'b0) wCount <= 2'b00;   // Reset counter when s=1 and wCount != 0\n\t\t\t\t\t     end \n\t\tendcase\n\tend   \nend\nassign z = ((state == STATE_C ) && (wCount == 2'b1))? 1 : 0 ;// Set output z = 1 if in state C and w has appeared for two cycles.\n"}
{"task_id": "2014_q3fsm", "completion": "\n\ttypedef enum {A, B1, B2, B3} state;\n\tstate currState, nextState;\n\treg [1:0] count;  // count the number of times w == 1 in the last three cycles\n\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n\t        currState <= A;\n\t    else\n\t        currState <= nextState;\n\tend\n\t\t\n\talways @(*) begin\n\t    case(currState)\n\t        A:  if (s == 0)\n\t                nextState = A;\n\t            else\n\t                begin\n\t                    count = 2'b00;\n\t                    nextState = B1;\n\t                end\n\t        B1,B2,B3:  \n\t            begin\n\t                if (w == 1) \n\t                   count += 1; // increase counter by one for each w==1.\n\t        \n\t                if ((count > 0) && s != 0 )\n\t                    nextState = A;    // set z=1 in the following clock cycle and reset counter\n\t                else if (s == 0) \n\t                    begin\n\t                        count = 2'b00;\n\t                        nextState = B1;   // move to the first state of new sequence\n\t                    end\n\t            end\n\t        default:    nextState = A;\n\t    endcase\n\tend\n\t\t    \n\t// output z is set in every clock cycle after current one, considering last three.\n\tassign z = (count > 0) && (currState == B3);  \nendmodule \n"}
{"task_id": "2014_q3fsm", "completion": "\n\treg [1:0] cnt; // 2-bit counter to count the number of '1's in the three clock cycles.\n\treg stb;      // Strobe signal that triggers each three clock cycles.\n    \t\n\t// State A reset state.\n\tinitial begin\n\t    if (reset) begin \n\t        z <= 0;  \n\t        cnt <= 0;\n\t        stb <= 0;\n\t    end      \n\tend\n\t\t        \n        always @(posedge clk or posedge reset) begin // Clocked by the clock signal or synchronous reset.\n            if (reset) begin \n                z <= 0;  \n                cnt <= 0;\n                stb <= 0;\n\t    end else begin    \t      \n\t        if (!s) begin           // State A, if s == 0\n                    cnt <= 0;\n                    stb <= 0;\n            \tend else begin          // State B, if s == 1\n                    if (stb) begin    // If the strobe signal is active.\n                        z <= (cnt == 2);  // Set z to '1' if exactly two of w were '1'. Otherwise set it to '0'.\n                        cnt <= 0;        // Reset counter.\n                    end else begin     // No strobe, just count the number of '1's seen in each three clock cycles.\n                        cnt <= (w ? (cnt + 1) : 0);   \n\t\t\tend \n                    stb <= !stb;       // Toggle every three cycles to inspect w for the next three cycles.\n\t        end  \n            end        \n        end\nendmodule \n"}
{"task_id": "2014_q3fsm", "completion": "\n\treg [1:0] counter;\n\treg [1:0] w_buffer;\n\treg state;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcounter <= 2'b00;\n\t\t\tw_buffer <= 2'b00;\n\t\t\tstate <= 1'b0;\n\t\t\tz <= 1'b0;\n\t\tend else if (!s && !state) begin // State A\n\t\t\tif (w) \n\t\t\t\tcounter <= counter + 2'b01;\n\t\tend else if (s && !state) begin // Transition to state B\n\t\t\tstate <= 1'b1;\n\t\tend else if (!s && state) begin // State B\n\t\t\t// Store w in a buffer and shift it on each clock cycle.\n\t\t\tw_buffer <= {w, w_buffer[1]};\n\t\t\t\n\t\t\tif (counter == 2'b10) begin // If 2 bits from the left have been read, compare them to the stored value.\n\t\t\t\t// If they are equal, set z and reset counter. Otherwise, just shift the buffer.\n\t\t\t\tz <= (w_buffer[0] == w_buffer[1]) ? 1'b1 : 1'b0;\n\t\t\t\tcounter <= 2'b00;\n\t\t\tend else begin // If not all three bits have been read yet, increment counter and shift buffer.\n\t\t\t\tcounter <= counter + 2'b01;\n\t\t\t\tw_buffer <= {w, w_buffer[1]};\n\t\t\tend\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "\n\t// Define states\n\ttypedef enum { A=2'b01, B=2'b10 } state_t;  // state machine states\n\tstate_t state, next_state;  // current and next states\n\n\treg [1:0] counter;    // count the number of ones detected by w in the last three clock cycles\n  \n\t// State transitions\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) state <= A;\n\t\telse       state <= next_state;\n  end\n\n\t// Next state logic and outputs\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: if (s == 0 && w == 1) counter <= 2'b01; // reset the count of ones in the last three clock cycles when s = 0\n\t\t\t\telse                  next_state <= A;  // stay at state A otherwise\n  \n\t\t\tB: begin\n\t\t\t\t\tif (w == 1)       counter <= counter + 2'b01; // increment the count of ones if w=1\n\t\t\t\t\tnext_state          <= B;         // stay at state B\n\t\t\t      end\n\t\t\tdefault: next_state <= A;  // default to A, in case something goes wrong.\n        endcase\n    end\n  \n\t// z output\n\tassign z = (counter == 2'b10) ? 1 : 0 ;// set z = 1 if w=1 for exactly two clock cycles\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "\n\treg [1:0] cnt; // Counter for 3 clock cycles.\n\treg st;       // State of FSM. \n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcnt <= 2'h0;\n\t\t\tz <= 1'b0;\n\t\t\tst <= 1'b0;\n\t\tend\n\t\telse if (!s) // State A.\n\t\t\tz <= w; \n\t\telse if (s && !st) begin// State B.\n\t\t\tcnt <= 2'h0;\n\t\t\tst <= 1'b1;\n\t\tend\n\t\telse begin\t// States C, D and E.\n\t\t\tif (cnt == 2'h3) // Back to state A if the counter reaches 3.\n\t\t\t\tbegin st <= 1'b0; cnt <= 2'h0; end\n\t\t\telse begin\n\t\t\t\tcnt <= cnt + 1;\n\t\t\t\t\n\t\t\t\tif(cnt[0] && w) z <= 1'b1; // If exactly two clock cycles are counted and w=1 then set z to 1.\n\t\t\t\telse if (cnt == 2'h3)  begin st <= 1'b0; cnt <= 2'h0; end// Otherwise reset counter and go back to state A.\n\t\t\tend\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "2014_q3fsm", "completion": "\nreg [1:0] count;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset)  begin\n\t\tcount <= 2'b00;\n\t\tz <= 1'b0;\n\tend\n\telse if (s == 1'b0 && w == 1'b1) \n\t\t count <= count + 2'b01;\n    else if(s==1'b0)  \n        begin\n         z<=0;\n         count<=count;\n       end\t\n\telse if (s == 1'b1 && w == 1'b0 ) \n\t\t count <= 2'b00;\n\telse if(count >= 2'b10 || s==1'b1) begin\n\t    z <= 1'b1;\n        count<=2'b00;\t    \n\tend   else   \n            begin \n                count <= count ; \n\t\t         z  <= 1'b0;\n               end\nend\nendmodule \n"}
{"task_id": "2014_q3fsm", "completion": " \n    \n    localparam [1:0] A = 2'b00;\n    localparam [1:0] B = 2'b01;\n    localparam [1:0] C = 2'b10;\n\tlocalparam [1:0] D = 2'b11;\n    \n    reg [1:0] state;\n    integer count;  // To count the number of w=1 in 3 consecutive cycles.\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            z <= 0;\n            state <= A;\n            count <= 0;\n        end else begin\n\t\t\tcase(state) \n                A: if (!s) \n                        state <= B;     // If s is '0', go to State B.\n                    else \n                        state <= A;    // If s is '1', stay in State A.\n                \n\t\t\t\tB: begin             // In State B, check for w and move to next states.\n\t\t\t\t\tif (!s) \n\t\t\t\t\t\tstate <= C;   // If s is still '0' move to state C\n                    else \n                        state <= D;\t// If s becomes '1', go to State D after the first clock cycle.\n                end   \n                    \n\t\t\t\tC: begin             // In this state, we check if w=1 in two of the next three cycles.\n\t\t\t\t\tif (!s) \n\t\t\t\t\t\tstate <= C;   // If s is still '0', stay at State C.\n                    else begin         // If s becomes '1', go to State D after the first clock cycle and start counting w.\n                        state <= D;   \n                        if (w) count <= count + 1; \n                end              \n                    \n\t\t\t\tD: begin             // In this state we have counted the number of consecutive w=1 in three cycles.\n\t\t\t\t\tif (!s) begin  \n\t\t\t\t\t\tif (count == 2)\t// If s is '0' and there are two w=1, set z to 1 in next clock cycle.\n\t\t\t\t\t\t\tz <= 1;     // And move to state A after the next clock cycle.\n                        else if(w==1 && count>=3) begin  \n                            z <= 1;     // If three consecutive w=1 are found, reset counter and set z =1 \n                            count <= 0; \n\t\t\t\t\t\tend   \n                        state <= B;\t// Move back to State A after the next clock cycle.\n                    end else begin\n                        if(count>=3)begin  \n                            z<= 1;        // If there are three w=1 in a row, set output z = 1\n                            count <= 0;  // and go to state D. Reset counter for new sequence of consecutive 1's\n\t\t\t\t\t\tend else begin\n                        if(w) count <= count + 1;  // If s is '1', keep counting the number of w=1 in four cycles after state D, until a three cycle period ends with w = 0 or s=0.\n                        end       \n                    end  \n\t\t\t\tend   \n\t\t\tendcase        \n        end                  \n    end            \nendmodule \n"}
{"task_id": "2014_q3fsm", "completion": "\n\treg [1:0] state;\n\tinteger count = 2'd0;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= 2'b00;\n\t\t\tcount <= 2'd0;\n\t\t\tz <= 1'b0;\n\t\tend \n\t\telse if (!s && count == 2'd3) begin\n\t\t\tif(w)\n\t\t\t\tz <= ~z;\n\t\t\tstate <= 2'd0;\n\t\t\tcount <= 2'd0;\n\t\tend \n\t\telse if(!s) begin\n\t\t\tstate <= 2'b10;\n\t\t\tcount <= count + 2'd1;\n\t\tend\n\t\telse if(s && !w)\n\t\t\tstate <= 2'b11;\n\tend\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "\n// FSM states\nlocalparam A = 1'b0;\nlocalparam B = 1'b1;\n\n// State variables\nreg state, next_state;\n\n// Counters and counters reset signals\nwire count_reset, count_enable;\nreg [2:0] counter;\nassign count_reset = (state == A) ? 1 : ((counter == 3) ? 1 : 0);\nassign count_enable = (state == B) && w;\n\nalways @(posedge clk or posedge reset) begin\n\tif(reset) begin // Reset state\n\t\tstate <= A;\n\tend else begin // Update the FSM states\n\t\tstate <= next_state;\n\t\t// Counters updating\n\t\tif (count_reset == 1'b1)\n\t\t\tcounter <= 3'b000;\n\t\telse if (count_enable == 1'b1 && counter != 3'b111)\n\t\t\tcounter <= counter + 1'b1;\n\tend\nend\n\n// Output z depends on the state and the count value\nassign z = (state == B) ? ((counter == 3'b010) ? 1 : 0) : 0;\n\n// Next State Logic\nalways @(*) begin\n\tif (reset) begin // Reset next_state if reset is high\n\t\tnext_state <= A;\n\tend else begin // Update the FSM states\n\t\tif(s == 1'b1) // If s==1, go to state B\n\t\t\tnext_state <= B;\n\t\telse // If s==0 or z in two of last three cycles ==1 , return to A\n\t\t\tnext_state <= A;\n\tend\nend\n\n"}
{"task_id": "2014_q3fsm", "completion": "\nenum logic [1:0] {A = 2'b00, B = 2'b01} state;\nreg [1:0] counter;\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) begin\n\t\tstate <= A;\n\tend else if ((s == 1'b0 && w == 1'b1) || (state == B && counter == 2'b11)) begin  // transition to state A when s=0 or in state B with exactly 2 consecutive 1's on w \n\t\tstate <= A;\n\tend else if ((s == 1'b1) || (state == B && w == 1'b1 && counter < 2'b11)) begin // transition to state B and count up when s=1 or in state B with 1 on w, but not exactly two consecutive 1's\n\t\tstate <= B;\n\t\tif (w == 1) counter <= counter + 2'b01;\n\tend  \n\t//set output z based on whether we are in state A or B and if there were at least two consective '1''s on w\n\tz <= ((state == A && counter >= 2'b10) || (state == B)) ? 1'b1 : 1'b0;   \nend  \n"}
{"task_id": "2014_q3fsm", "completion": "\n\t// Define states 0 to 5 for FSM\n\tlocalparam [2:0] A = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, C = 3'b100, D = 3'b101;\n\treg [2:0] state;\t// current and next states\n\n\talways @(posedge clk or posedge reset) begin // reset synchronously\n\t\tif (reset)\n\t\t\tstate <= A;\n\t\telse \n\t\t\tcase (state)\n\t\t\t\tA : if (!s) state <= A; else state <= B1;\n\t\t\t\tB1: state <= B2;\n\t\t\t\tB2: state <= B3;\n\t\t\t\tB3: begin\n\t\t\t\t\tif (w && !z) z <= 1;\t// if w is 1 in last 3 cycles, set z = 1 on next clock cycle\n\t\t\t\t\telse z <= 0;\n\t\t\t\t\tstate <= C;\t\t\t// stay at B3 until the countdown completes\n\t\t\t\tend\n\t\t\t\tC : state <= D;\n\t\t\t\tD : begin\n\t\t\t\t\tif (w) z <= 1;\t\t// if w is 1 in last 2 cycles, set z = 1 on next clock cycle\n\t\t\t\t\telse z <= 0;\t\t\t// else reset z to 0\n\t\t\t\t\tstate <= A;\t\t\t\t// move back to state A after setting z value.\n\t\t\t\tend\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "\n\treg [1:0] state;\n\tlocalparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= A;\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tA: if (s == 0) state <= A; else state <= B;\n\t\t\t\tB: if (s == 1) state <= C; else state <= D;\n\t\t\t\tC: if (w == 1 && w == state[2]) state <= {z, 1'b0}; else state <= D;\n\t\t\tdefault :state <= A;\n\t\t\tendcase\n\t\tend\n\tend\n\tassign z = (state[0]==state[1]); // check if the count of ones is equal to two in the last three states.\n\nendmodule\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\n\nendmodule \n\n"}
{"task_id": "zero", "completion": "\n    \n    assign zero = 1'b0;\n  \nendmodule \n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\nendmodule\n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\nendmodule \n\n"}
{"task_id": "zero", "completion": "\n\n\tassign zero = 1'b0;\n\t\nendmodule \n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\n\nendmodule\n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\nendmodule\n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\nendmodule\n\n"}
{"task_id": "zero", "completion": "\nassign zero = 1'b0; \n"}
{"task_id": "zero", "completion": "\n    assign zero = 1'b0; \n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\nendmodule \n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;  //Assigning the output to low\nendmodule\n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;  // assigning the output to be low (1'b0)\nendmodule\n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\n\t\nendmodule \n\n"}
{"task_id": "zero", "completion": "\nassign zero = 1'b0;\nendmodule \n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\n\t\nendmodule \n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\nendmodule\n\n"}
{"task_id": "zero", "completion": "\nassign zero = 1'b0; \n\n"}
{"task_id": "zero", "completion": "\n\tassign zero = 1'b0;\n\nendmodule\n"}
{"task_id": "zero", "completion": "\n\n\tassign zero = 1'b0;\n\nendmodule\n\n"}
{"task_id": "always_if2", "completion": "\nThe code has no syntax errors. But the always @(*) blocks are incorrect in terms of sequencing and priority for the outputs based on conditions given. They will only take into account one condition at a time but not all together as needed, resulting in possibly wrong output values. It should be modified as shown below:\n\t\n\talways @(*) begin\n        \tif (cpu_overheated) \n\t\t\tbegin\n            \t\tshut_off_computer = 1;\n            \tend\n        \telse if (arrived & gas_tank_empty) \n\t\t\tbegin\n            \t\tkeep_driving = 0; //If the cpu is not overheated and we are arrived and the tank is empty then we should stop driving.\n\t\t\tshut_off_computer = 0; //This line might be unnecessary as shut_off_computer doesn't depend on whether cpu_overheated is true or false, but it has been included to avoid any unintentional output changes.\n        \tend \n        \telse if (arrived & ~gas_tank_empty) // If we are arrived and the tank is not empty then we should keep driving.\n\t\t\tbegin\n            \t\tkeep_driving = 1;\n\t\t\t    shut_off_computer = 0; //Again, this might be unnecessary but included for consistency with previous conditions.\n        \tend \n\t\telse begin\n\t\t\t//Default values in case no condition is met (i.e., cpu isn't overheated and we aren't arrived)\n            \tkeep_driving = 0;\n\t\t\t    shut_off_computer = 0;\n\t    \tend\n\tend\n\nendmodule\n"}
{"task_id": "always_if2", "completion": "\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  );\n\n    always @(*) begin\n        if (cpu_overheated)\n           shut_off_computer = 1;\n\t\telse \n\t\t   shut_off_computer = 0; // Reset value for the signal\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n\t\telse \n\t\t   keep_driving = 0; // Reset value for the signal\n    end\n\nendmodule\n"}
{"task_id": "always_if2", "completion": "\nalways @(*) begin\n\tif (cpu_overheated) begin\n\t\tshut_off_computer = 1;\n        keep_driving = 0;  // add this line to make sure that if the cpu_overheated, then shut_off_computer is high and keep_driving is low.\n    end else if (~arrived) begin\n\t\tshut_off_computer = 0; //add this line to ensure that if arrived signal is 1, shut_off_computer should be off.\n        keep_driving = ~gas_tank_empty;  \n\tend else begin\n\t\tshut_off_computer = 0;\n\t    keep_driving = 0; //add this line to ensure that if neither cpu_overheated nor arrived signal is high, then computer should not be kept driving.\n    end\nend\n\n"}
{"task_id": "always_if2", "completion": "\n\nalways @(*) begin\n\tif (cpu_overheated) \n        shut_off_computer = 1;\n    else if (~arrived && gas_tank_empty == 0) // Added comparison with 0 to avoid race condition.\n\t    keep_driving = 1;\n\telse if ((cpu_overheated || arrived) || gas_tank_empty) begin //Added extra parentheses for logical readability, and corrected the conditions\n        shut_off_computer = 0;\n        keep_driving = 0;\n    end  \nend\n\t\nendmodule \n\n"}
{"task_id": "always_if2", "completion": "\n\talways @(*) begin\n        if (cpu_overheated)\n           shut_off_computer = 1;\n        else \n\t\t   shut_off_computer = 0; // Reset the value when cpu_overheated is False.\n    end\n\n    always @(*) begin\n\t\tif (arrived == 0 ) // ~arrived\n            keep_driving = gas_tank_empty ? 1'b0 : 1'b1; // If gas tank empty, don't drive else keep driving\n        else \n\t\t   keep_driving = 0 ; // Reset the value when arrived is False.\n    end\nendmodule\n\n"}
{"task_id": "always_if2", "completion": "\n// There are two problems with this code. \n// Firstly, the always @(*) blocks will never run because they have no sensitivity list. They can't trigger without any inputs changing.\n// Secondly, there should be a reset input to shut_off_computer and keep_driving so that their value could be set back to 0 manually or by an asynchronous reset signal. Let's add reset as well.\n\ninput reset; // Added new line\n\nalways @(*) begin\n\tif (cpu_overheated)\n\t\tshut_off_computer = 1;\n\telse if (reset)\n\t\tshut_off_computer = 0; \nend\n\nalways @(*) begin\n\tif (~arrived)\n\t\tkeep_driving = gas_tank_empty ? 0 : 1; // Added condition to handle empty tank case.\n\telse if (reset) \n\t\tkeep_driving = 0;   // Added reset case\nend\n"}
{"task_id": "always_if2", "completion": "\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t   shut_off_computer = 1;\n\t    else if (~arrived & ~gas_tank_empty) \n\t\t   keep_driving = 0;\n\t\telse \n           {shut_off_computer,keep_driving} = 2'b00; // to prevent latching, set shut_off_computer and keep_driving to zero in every state when there is no conflict\n   end\nendmodule\n"}
{"task_id": "always_if2", "completion": "\n\talways @(*) begin\n\t    if (cpu_overheated)\n\t        shut_off_computer = 1;\n        else \n            shut_off_computer = 0;\n\tend\n\n    always @(*) begin\n        if (!arrived)   //use ! instead of ~ to avoid warnings\n            keep_driving = !gas_tank_empty;\n        else \n            keep_driving = 1'b0; //avoid latch, use an explicit value\n\tend\n\nendmodule\n"}
{"task_id": "always_if2", "completion": "\n\nalways @(*) begin\n\tif (cpu_overheated)\n\t   shut_off_computer = 1;\n\telse \n\t   shut_off_computer = 0;\nend\n\nalways @(*) begin\n\tif (arrived==0) //use ~arrived instead of 0 for correct statement\n\t   keep_driving = ~gas_tank_empty;\n\telse if (cpu_overheated) //cpu_overheat not cpu_overheated\n\t   keep_driving =1 ;\n\telse\n\t   keep_driving=0;\nend \nendmodule\n"}
{"task_id": "always_if2", "completion": "\nalways @(*) begin\n    if (cpu_overheated)\n       shut_off_computer = 1;\n    else \n\t   shut_off_computer = 0; // added missing else case, which would be triggered when cpu_overheated is 0.\nend\n\nalways @(*) begin\n\tif (arrived)\n        keep_driving = gas_tank_empty ? 0 : 1; // fixed the condition for keep_driving\n\telse \n       keep_driving = 1'b0; // added missing else case, which would be triggered when arrived is 0.\nend\n\nendmodule\n\n"}
{"task_id": "always_if2", "completion": "\n\talways @(*) begin\n\t    if (cpu_overheated)\n\t        shut_off_computer = 1;\n        else \n            shut_off_computer = 0;\n    end\n    \n\talways @(*) begin\n        if (arrived == 0) // Assuming a '1' value indicates \"not arrived\"\n\t        keep_driving = gas_tank_empty ? 0 : 1;\n      \telse\n            keep_driving = 0;  \n    end\nendmodule\n"}
{"task_id": "always_if2", "completion": "\n// The original code has a race condition. If the CPU overheats at the same time as it arrives and the gas tank becomes empty, then both conditions are met in different clock cycles. This will cause an unwanted behavior. \n// So we need to use synchronous active high reset method instead of always @(*) construct for shut_off_computer and keep_driving outputs. We also forgot to reset the value after shutting off so it should be added too. \n\nalways @(posedge cpu_overheated, posedge arrived) begin\n    if (cpu_overheated || ~arrived && gas_tank_empty ) \n        shut_off_computer <= 1; // active high reset\n\telse \n\t    shut_off_computer <= 0; // reset value\nend\n\nalways @(posedge arrived, posedge gas_tank_empty) begin\n\tif (~arrived || gas_tank_empty ) \n        keep_driving <= 1'b0;   // active high reset\n\telse \n\t    keep_driving <= 1'b1;    // reset value\nend\n"}
{"task_id": "always_if2", "completion": "\n\n\talways @(*) begin\n        if (cpu_overheated)\n           shut_off_computer = 1;\n        else \n\t\t   shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n           keep_driving = ~gas_tank_empty;\n        else \n\t\t   keep_driving = 0;\n    end\t\n\nendmodule\n"}
{"task_id": "always_if2", "completion": "\nalways @(*) begin\n    if (cpu_overheated)\n       shut_off_computer = 1;\n    else \n       shut_off_computer = 0;\nend\n\nalways @(*) begin\n    if (arrived)\n        keep_driving = ~gas_tank_empty;\n    else \n\t   keep_driving = gas_tank_empty;\nend\n\n"}
{"task_id": "always_if2", "completion": "\n\t// module top_module (\n\t// \tinput      cpu_overheated,\n\t// \toutput reg shut_off_computer,\n\t// \tinput      arrived,\n\t// \tinput      gas_tank_empty,\n\t// \toutput reg keep_driving  \n\t// );\n\n\talways @(*) begin\n\t    if (cpu_overheated)\n\t\t    shut_off_computer = 1;\n\t    else\n\t\t    shut_off_operations = 0; // This line is incorrect. Correct variable name was not specified in the problem\n\tend\n\n\talways @(*) begin\n\t    if (~arrived) \n\t\t    keep_driving = ~gas_tank_empty;\n\t    else \n            keep_driving = gas_tank_empty; // This line should be fixed, it's likely that we want to keep driving when the passenger arrives and there is no gas in the tank. The original condition was wrong.\n\tend\n\n\t// endmodule\n"}
{"task_id": "always_if2", "completion": "\nalways @(*) begin\n\tif (cpu_overheated)\n\t    shut_off_computer = 1;\n\telse\n        shut_off_computer = 0;\nend\n\nalways @(*) begin\n\tif (!arrived && !gas_tank_empty) // change '~' to '!' due to syntax error in given code, \n    // if the driver hasn't arrived and gas tank is not empty then keep driving else don't.\n\t    keep_driving = 1;\n\telse\n        keep_driving = 0;\nend\n\n"}
{"task_id": "always_if2", "completion": "\n\talways @(*) begin\n        if (cpu_overheated)\n           shut_off_computer = 1;\n        else \n           shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (arrived == 1'b0)\n           keep_driving = gas_tank_empty ? 1'b0 : 1'b1;\n        else \n           keep_driving = 1'b0; // Keep driving until arrived is true again.\n    end\nendmodule\n\n"}
{"task_id": "always_if2", "completion": "\n\talways @(*) begin\n\t    if (cpu_overheated) begin\n    \t   shut_off_computer = 1;  // If the cpu overheated turn on shutdown output\n        end \n        else begin\n            shut_off_computer = 0;  // Otherwise, keep it off\n       end\n    end\n\n    always @(*) begin\n\tif (arrived == 0) begin // If you haven't arrived yet\n\t    keep_driving = gas_tank_empty ? 1 : 0;  // If the tank is empty drive else don't. \n\tend  \n\telse begin\n            keep_driving = 0; // Once you arrive, never leave\n        end\n    end\nendmodule\n"}
{"task_id": "always_if2", "completion": "\n\t// First bug was in the sensitivity list of both always blocks. It should only be triggered by a change of either input variable (cpu_overheated and arrived). \n\t// The other bug is with the second always block, where if 'arrived' condition isn't met then keep_driving doesn\u2019t stop driving when gas_tank_empty is true. \n\t\n\talways @(*) begin\n        if (cpu_overheated)\n           shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // This line was missing, so it needed to be added back in.\n    end\n\n    always @(*) begin\n        if (!arrived) \n\t\t\tkeep_driving = !gas_tank_empty;\n        else\n            keep_driving = 1'b0; // Added this line to stop driving when arrived is true.\n    end\nendmodule\n"}
{"task_id": "always_if2", "completion": "\nalways @(*) begin\n\tif (cpu_overheated)\n       shut_off_computer = 1;\n    else if (~arrived && gas_tank_empty)  // Changed condition to avoid latch inferred\n\t   keep_driving = 0;\t// Corrected the inversion for driving action\nend\n"}
{"task_id": "counter_2bc", "completion": "\n    \n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n\t\t\tstate <= 2'b01;\n         else if (train_valid && train_taken) \n\t\t\t    state <= state + 1'b1 > 3 ? 3 : state + 1'b1;   // Increments until reaching maximum of 3\n           else if(train_valid && !train_taken) \n\t\t\t     state <=  state - 1'b1 < 0 ? 0 : state - 1'b1;  // Decrement until reaching minimum of 0\n\tend\nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset == 1'b1)\n            state <= 2'b01;  // Resets counter to weakly not-taken.\n        else if ((train_valid == 1'b1) && (train_taken == 1'b1)) begin\n\t\t    if(state < 3)\t\t// Saturation at maximum of 3.\n            \tstate <= state + 2'd1;   // Increments counter\n       end\n\t    else if ((train_valid == 1'b1) && (train_taken == 1'b0)) begin\n\t\t    if(state > 0)\t\t// Saturation at minimum of 0.\n            \tstate <= state - 2'd1;   // Decrements counter\n        end\n\tend\nendmodule\n\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin \n\t\tif (areset) \n\t\t\tstate <= 2'b01; // Weakly not taken \n\t\telse if (train_valid == 1'b1 && train_taken == 1'b1) begin\n\t\t    // Incrementing condition: \n\t\t\tcase(state)\n\t\t\t\t2'b01: state <= 2'b10;\n\t\t\t\t2'b10: state <= 2'b11;\n\t\t\t\tdefault: ; // Do nothing, stay at maximum (3)\n\t\t\tendcase\n\t\tend else if (train_valid == 1'b1 && train_taken == 1'b0) begin \n\t\t\t// Decrementing condition: \n            case(state)\n                2'b11: state <= 2'b10;\n                2'b10: state <= 2'b01;\n                default: ; // Do nothing, stay at minimum (0)\n            endcase\n\t\tend else begin\n\t\t\t// No training, no change \n\t\tend  \n\tend\nendmodule\n\n"}
{"task_id": "counter_2bc", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= 2'b01;\n    else if (train_valid && train_taken && state < 3'b10) \n        state <= state + 1'd1;\n    else if (train_valid && !train_taken && state > 2'b00) \n        state <= state - 1'd1;\nend\n        \nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\nalways @(posedge clk or posedge areset) begin\n  if (areset)\n  \tstate <= 2'b01; // reset to weakly not-taken\n  else if (train_valid && train_taken && state < 3'd3)\n    state <= state + 1; // increment if training and taken, up to max of 3\n  else if(train_valid && !train_taken && state > 2'b00)  \n    state <= state - 1; // decrement if training and not taken, down to min of 0\nend\n\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) \n            state <= 2'h01;\n         else if (train_valid == 1'b1 && train_taken == 1'b1 && state < 3)\n             state <= state + 2'd1;\n          else if(train_valid == 1'b1 && train_taken == 1'b0 ) \n              state <= state - 2'd1;\n    end\nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b01;\n        else if (train_valid && train_taken && state < 3'b11)  \n            state <= state + 1;    // increment\n        else if (train_valid && !train_taken && state > 2'b00) \n            state <= state - 1;    // decrement\n\tend\nendmodule\n"}
{"task_id": "counter_2bc", "completion": " \n\talways @ (posedge clk or posedge areset) begin\n\t\tif(areset)\n\t\t\tstate <= 2'b01;\n\t\telse if(train_valid && train_taken) begin\n            case(state)\n                2'b10, 2'b11: state <= state + 1;\n                default: state <= state;\n            endcase\n        end \n\t\telse if(train_valid && !train_taken) begin\n\t\t\tcase (state)\n\t\t\t    2'b00: state <= 2'b00; // do nothing in this case to keep it at 0.\n                 default: state <= state - 1;  \n            endcase \n        end else state <= state;\n\tend\nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @ (posedge clk or posedge areset) begin \n    \tif(areset)\n        \tstate <= 2'b01;\n        else if (train_valid && train_taken && state < 3'd3)  \n        \tstate <= state + 1;\n      \telse if (train_valid && !train_taken && state > 3'd0) \n          \tstate <= state - 1;   \n    end \nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b01;\n        else if (train_valid && train_taken) begin\n            if (state < 3)\n                state <= state + 1;\n        end\n        else if (train_valid && !train_taken) begin\n            if (state > 0) \n                state <= state - 1;\n        end  \n    end\nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b01;\n         else if (train_valid & train_taken)\n\t\t\tif (state < 3)\n                state <= state + 1;\n     \telse\n              state <= 3;\n        else if (train_valid & ~train_taken)\n\t\t\tif (state > 0) \n            \tstate <= state - 1;\n         else \n              state <= 0;  \n     end\nendmodule\n\n"}
{"task_id": "counter_2bc", "completion": " \n\talways @(posedge clk or posedge areset) begin\n        if (areset == 1'b1)\n            state <= 2'd1;\n        else if (train_valid == 1'b1 && train_taken == 1'b1 && state < 3 ) \n\t\t\tstate <= state + 1;\n\t\telse if(train_valid == 1'b1 && train_taken == 1'b0)\n            state <= state - 1;\n    end\nendmodule \n\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin \n        if (areset) \n            state <= 2'b01; // reset to weakly not taken\n        else if (train_valid == 1'b1 && train_taken == 1'b1 && state < 2'b11)  \n            state <= state + 1'b1; // increment on valid and take when counter is less than max 3\n        else if (train_valid == 1'b1 && train_taken == 1'b0 && state > 2'b00)\n            state <= state - 1'b1; // decrement on valid and not-take when counter is more than min 0\n    end\t  \nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n    \n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b01;\n        else if (train_valid && train_taken && state < 3'd3)   // Incrementing\n            state <= state + 1;\n        else if (train_valid && !train_taken && state > 2'b00)  // Decrementing\n            state <= state - 1;\n\tend\nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @ (posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b01;\n         else if(train_valid == 1 && train_taken ==1 )begin  \n                if(state != 3)    // Max limit of counter is 3, so no incrementing when it reaches to maximum.\n                     state <= state + 1;\t    \n        end \n        else if (train_valid == 1 && train_taken==0 ) begin\n            if(state != 2'b00)   // Min limit of counter is 0, so no decrementing when it reaches to minimum.\n                 state <= state - 1;\t    \n         end      \t\t            \n    end     \nendmodule \n"}
{"task_id": "counter_2bc", "completion": "\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b01;\n        else if (train_valid && train_taken && state < 3'b11) \n            state <= state + 1;\n        else if (train_valid && !train_taken && state > 3'b00) \n            state <= state - 1;\n    end\n    \nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n    \n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t        state <= 2'b01;\n        else if (train_valid == 1'b1 && train_taken == 1'b1) \n\t\t\tif (state < 3'd3) \n                state <= state + 1;\n            else \n                state <= state;    \n\t    else if (train_valid == 1'b1 && train_taken == 1'b0) \n\t        if(state > 2'd0) \n\t        \tstate <= state - 1;\n\t\t    else \n\t\t\t    state <= state; \n        else  \n            state <= state;     // Not Training: Counter value unchanged.\n    end\nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n    always @ (posedge clk or posedge areset) begin\n        if(areset) \n            state <= 2'b01; // reset counter to weakly not-taken\n        else if(train_valid == 1 && train_taken == 1 && state < 3'd3 )\n                state <= state + 2'd1;// increment counter when train is valid and taken\n         else if (train_valid == 1 && train_taken == 0) \n            state <= state - 2'd1; // decrement counter when train is valid but not taken\n        end  \nendmodule   \n\n"}
{"task_id": "counter_2bc", "completion": " \n\talways @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 2'b01;\n       else if(train_valid == 1'b1 && train_taken == 1'b1 && state != 2'b11) \n            state <= state + 1;\n        else if(train_valid == 1'b1 && train_taken == 1'b0 && state != 2'b00) \n            state <= state - 1;\n\tend\nendmodule\n"}
{"task_id": "counter_2bc", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 2'b01;\n        else if (train_valid && train_taken && state < 3)\n            state <= state + 1;\n        else if (train_valid && !train_taken && state > 0)\n            state <= state - 1;\n    end\nendmodule\n"}
{"task_id": "circuit1", "completion": "\nassign q = a^b;\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\treg x;\n\talways @(*) begin\n        x = a & b;\n        #5; // to match the simulation time delay with real-time delay\n    end\n    \n    assign q = x; \nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\tassign q = a & ~b | ~a & b;\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\nreg tmp;\n\tassign q = a & ~b | tmp;\n\talways @(posedge a or posedge b) begin\n\t\tif (a && !b)\n\t\t\ttmp <= 1'b0;\n\t\telse if (!a && b)\n\t\t\ttmp <= 1'b1;\n\tend \nendmodule\n"}
{"task_id": "circuit1", "completion": "\n\n\tassign q = (a & ~b) | (~a & b);\nendmodule\n"}
{"task_id": "circuit1", "completion": "\nassign q = (a && !b) || (!a && b);\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n   assign q = ((~a & ~b) | (~a & b) | (a & ~b) | (a & b));\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\nassign q = (~a & ~b) | (~a & b) | (a & ~b) | (a & b);\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\n\tassign q = (a&~b) | (~a&b);\nendmodule\n"}
{"task_id": "circuit1", "completion": "\nassign q = a | ((~b) & a);\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\tassign q = (a & ~b) | (~a & b);\nendmodule\n"}
{"task_id": "circuit1", "completion": "\n\n\tassign q = a | (b & ~a);\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n   assign #5 (a | ~b) #5 ~(a & b);\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n     assign #2 q = (a&~b) | ~(a|b);\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\n\tassign #5 q = (~a & ~b) | (a & b); // The circuit does not change with time but will hold its state until one of the inputs changes. This is a combinational logic and doesn't seem to be a classic digital circuit like an AND, OR or XOR gate\n\t\nendmodule \n"}
{"task_id": "circuit1", "completion": "\nassign #5 a | b;\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\t// Output of the circuit is Q=A'B+AB'. So to implement it in verilog code.\n\tassign q = a&b | ~a&~b;\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\nassign q = ((~a) & ~b ) | ((~a) & b) | (a & ~b) | (a & b);\nendmodule\n\n"}
{"task_id": "circuit1", "completion": "\n\nassign q = (a & ~b) | (~a & b);\nendmodule\n"}
{"task_id": "circuit1", "completion": "\n\tassign q = ((~a & ~b) | (~a & b) | (a & ~b)) & a;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n    assign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n"}
{"task_id": "andgate", "completion": "\n\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n    assign out = a & b;\nendmodule\n"}
{"task_id": "andgate", "completion": "\n\n\tassign out = a & b;\n\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\nassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n"}
{"task_id": "andgate", "completion": "\n    assign out = a & b;\nendmodule\n"}
{"task_id": "andgate", "completion": "\n    assign out = a & b;\nendmodule\n"}
{"task_id": "andgate", "completion": "\n\tassign out = a & b;\nendmodule\n\n"}
{"task_id": "mux9to1v", "completion": "\n  always_comb begin\n    case(sel)\n      4'b0000: out = a;\n      4'b0001: out = b;\n      4'b0010: out = c;\n      4'b0011: out = d;\n      4'b0100: out = e;\n      4'b0101: out = f;\n      4'b0110: out = g;\n      4'b0111: out = h;\n      4'b1000: out = i;\n      default: out = 16'hffff; // For sel=9 to 15, set all output bits to '1'.\n    endcase\n  end\nendmodule\n\n"}
{"task_id": "mux9to1v", "completion": "\n    always_comb begin\n        case(sel)\n            4'h0: out = a;\n            4'h1: out = b;\n            4'h2: out = c;\n            4'h3: out = d;\n            4'h4: out = e;\n            4'h5: out = f;\n            4'h6: out = g;\n            4'h7: out = h;\n            4'h8: out = i;\n            default: out = 16'b1111_1111_1111_1111; // Use all 1s for unhandled cases\n        endcase\n    end\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\nalways @(*) begin \n\tcase (sel) \n\t\t4'h0 : out = a;\n\t\t4'h1 : out = b;\n\t\t4'h2 : out = c;\n\t\t4'h3 : out = d;\n\t\t4'h4 : out = e;\n\t\t4'h5 : out = f;\n\t\t4'h6 : out = g;\n\t\t4'h7 : out = h;\n\t\t4'h8 : out = i;\n\t\tdefault: out = 16'b1111_1111_1111_1111;  //all bits to 1 if sel is greater than or equal to 9\n\tendcase \nend \nendmodule\n\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb \nbegin\n\tcase(sel) \n\t\t4'b0000 : out = a;\n\t\t4'b0001 : out = b;\n\t\t4'b0010 : out = c;\n\t\t4'b0011 : out = d;\n\t\t4'b0100 : out = e;\n\t\t4'b0101 : out = f;\n\t\t4'b0110 : out = g;\n\t\t4'b0111 : out = h;\n\t\t4'b1000 : out = i;\n\t\tdefault : out = 16'hFFFF;\n\tendcase\nend \nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\n\talways_comb begin\n\t\tcase(sel) inside\n\t\t\t4'd0 : out = a;\n\t\t\t4'd1 : out = b;\n\t\t\t4'd2 : out = c;\n\t\t\t4'd3 : out = d;\n\t\t\t4'd4 : out = e;\n\t\t\t4'd5 : out = f;\n\t\t\t4'd6 : out = g;\n\t\t\t4'd7 : out = h;\n\t\t\t4'd8 : out = i;\n\t\t\tdefault: out = 16'b1111_1111_1111_1111; // default to all 1s for unselected cases\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "mux9to1v", "completion": "\n\talways_comb begin\n        case (sel)\n            4'd0  : out = a;\n            4'd1  : out = b;\n            4'd2  : out = c;\n            4'd3  : out = d;\n            4'd4  : out = e;\n            4'd5  : out = f;\n            4'd6  : out = g;\n            4'd7  : out = h;\n            4'd8  : out = i;\n            default: out = 16'b1111_1111_1111_1111; // 'all bits on' for unused cases\n        endcase\n    end\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb begin \n    case (sel)\n        4'd0 : out = a;\n        4'd1 : out = b;\n        4'd2 : out = c;\n        4'd3 : out = d;\n        4'd4 : out = e;\n        4'd5 : out = f;\n        4'd6 : out = g;\n        4'd7 : out = h;\n        4'd8 : out = i;\n        default: out = 16'hFFFF; // all '1's for values 9 to 15\n    endcase\nend\n\n"}
{"task_id": "mux9to1v", "completion": "\n  always @(*) begin\n    case (sel) inside\n      4'b0000 : out = a;\n      4'b0001 : out = b;\n      4'b0010 : out = c;\n      4'b0011 : out = d;\n      4'b0100 : out = e;\n      4'b0101 : out = f;\n      4'b0110 : out = g;\n      4'b0111 : out = h;\n      4'b1000 : out = i;\n      default: out = 16'hFFFF; // '1's for unused cases (sel=9 to 15)\n    endcase\n  end  \nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\n\n\t// Declare array of 16-bit input vectors\n\tlogic [15:0] inputs[8:0]; // The index is in range 9 because we don't use the first element (index 0) for sel=0 which falls outside given mux conditions.\n\tassign inputs = {h,g,f,e,d,c,b,a}; // Arranging inputs array\n\t// Use casex statement to handle fallthrough and ensure '1' for all unselected cases\n\tcase (sel) inside\n\t\t4'd0: out <= a;\n\t\t4'd1: out <= b;\n\t\t4'd2: out <= c;\n\t\t4'd3: out <= d;\n\t\t4'd4: out <= e;\n\t\t4'd5: out <= f;\n\t\t4'd6: out <= g;\n\t\t4'd7: out <= h;\n\t\t4'd8: out <= i;\n\tendcase\n\t// Set '1' for all unused cases (sel = 9 to 15)\n\tfor(int unsigned k=0;k<$size(inputs);++k) begin : SET_DEFAULT\n\t    if ((sel-4'(k))[3]) begin // If sel is outside [0..8] range, then select '1'\n\t\t    out <= {16{1'b1}};  \n        end else begin\n           continue; // Else do nothing (already assigned in case statement) \n       end \n\tend : SET_DEFAULT\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb \n    begin\n        case (sel)\n            4'b0000 : out = a;\n            4'b0001 : out = b;\n            4'b0010 : out = c;\n            4'b0011 : out = d;\n            4'b0100 : out = e;\n            4'b0101 : out = f;\n            4'b0110 : out = g;\n            4'b0111 : out = h;\n            4'b1000 : out = i;\n            default: \tout = 16'hFFFF; // For sel=9 to 15, set all output bits to '1'\n        endcase\n    end\nendmodule\n"}
{"task_id": "mux9to1v", "completion": " \nalways_comb begin\n\tcase(sel)\n\t\t4'd0 : out = a;\n\t\t4'd1 : out = b;\n\t\t4'd2 : out = c;\n\t\t4'd3 : out = d;\n\t\t4'd4 : out = e;\n\t\t4'd5 : out = f;\n\t\t4'd6 : out = g;\n\t\t4'd7 : out = h;\n\t\t4'd8 : out = i;\n\t\tdefault: out = 16'hFFFF;  // All bits set to '1' for sel=9-15.\n\tendcase\nend\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb begin\n\tcase(sel) \n\t\t4'b0000: out = a;\n\t\t4'b0001: out = b;\n\t\t4'b0010: out = c;\n\t\t4'b0011: out = d;\n\t\t4'b0100: out = e;\n\t\t4'b0101: out = f;\n\t\t4'b0110: out = g;\n\t\t4'b0111: out = h;\n\t\t4'b1000: out = i;\n\t\tdefault: out = ~{<<{sel}};  // for sel>=9, set all output bits to '1' using bitwise negation\n\tendcase\nend\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb begin\n\tcase(sel)\n\t\t4'd0 : out = a;\n\t\t4'd1 : out = b;\n\t\t4'd2 : out = c;\n\t\t4'd3 : out = d;\n\t\t4'd4 : out = e;\n\t\t4'd5 : out = f;\n\t\t4'd6 : out = g;\n\t\t4'd7 : out = h;\n\t\t4'd8 : out = i;\n\t\tdefault: out = 16'hFFFF; // If sel > 9, select all bits to 1.\n\tendcase\nend\nendmodule\n\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb begin \n\tcase (sel)\n\t\t4'd0 : out = a;\n\t\t4'd1 : out = b;\n\t\t4'd2 : out = c;\n\t\t4'd3 : out = d;\n\t\t4'd4 : out = e;\n\t\t4'd5 : out = f;\n\t\t4'd6 : out = g;\n\t\t4'd7 : out = h;\n\t\t4'd8 : out = i;\n\t\tdefault: out = 16'hFFFF;  // Selected for values 9-15.\n\tendcase\nend\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\n   always @(*) begin\n       case (sel) \n           4'b0000: out = a;\n           4'b0001: out = b;\n           4'b0010: out = c;\n           4'b0011: out = d;\n           4'b0100: out = e;\n           4'b0101: out = f;\n           4'b0110: out = g;\n           4'b0111: out = h;\n           4'b1000: out = i;\n           default : out = 16'hffff; //for sel=9 to 15, setting output as all '1's\n       endcase\n    end  \nendmodule\n"}
{"task_id": "mux9to1v", "completion": " \nalways_comb begin\n\tcase(sel)\n\t\t4'b0000: out = a;\n\t\t4'b0001: out = b;\n\t\t4'b0010: out = c;\n\t\t4'b0011: out = d;\n\t\t4'b0100: out = e;\n\t\t4'b0101: out = f;\n\t\t4'b0110: out = g;\n\t\t4'b0111: out = h;\n\t\t4'b1000: out = i;\n\t\tdefault: out = 16'hFFFF; // Unused cases set all bits to '1'.\n\tendcase\nend \nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb begin \n\tcase(sel)\n\t\t4'd0 : out = a;\n\t\t4'd1 : out = b;\n\t\t4'd2 : out = c;\n\t\t4'd3 : out = d;\n\t\t4'd4 : out = e;\n\t\t4'd5 : out = f;\n\t\t4'd6 : out = g;\n\t\t4'd7 : out = h;\n\t\t4'd8 : out = i;\n\t\tdefault: out = 16'b1111_1111_1111_1111;\n\tendcase\nend\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb begin \n\tcase(sel)  \n\t\t4'b0000 : out = a;  \n\t\t4'b0001 : out = b;  \n\t\t4'b0010 : out = c;  \n\t\t4'b0011 : out = d;  \n\t\t4'b0100 : out = e;  \n\t\t4'b0101 : out = f; \n\t\t4'b0110 : out = g;  \n\t\t4'b0111 : out = h;  \n\t\t4'b1000 : out = i;   \n\t\tdefault: out = 16'hFFFF;  //All bits set to '1' for values not considered in the case statement.\n\tendcase \nend\nendmodule\n\n"}
{"task_id": "mux9to1v", "completion": "\nalways_comb begin \n\tcase (sel) inside\n\t\t4'b0000 : out = a;\n\t\t4'b0001 : out = b;\n\t\t4'b0010 : out = c;\n\t\t4'b0011 : out = d;\n\t\t4'b0100 : out = e;\n\t\t4'b0101 : out = f;\n\t\t4'b0110 : out = g;\n\t\t4'b0111 : out = h;\n\t\t4'b1000 : out = i;\n\t\tdefault: out = 16'hFFFF; // for sel > 9, all output bits set to '1'.\n\tendcase\nend\nendmodule\n"}
{"task_id": "mux9to1v", "completion": " \n\talways_comb begin\n\t\t\tcase (sel)\n\t\t\t\t4'b0000 : out = a;\n\t\t\t\t4'b0001 : out = b;\n\t\t\t\t4'b0010 : out = c;\n\t\t\t\t4'b0011 : out = d;\n\t\t\t\t4'b0100 : out = e;\n\t\t\t\t4'b0101 : out = f;\n\t\t\t\t4'b0110 : out = g;\n\t\t\t\t4'b0111 : out = h;\n\t\t\t\t4'b1000 : out = i;\n\t\t\t\tdefault : out = ~'(16'd0); // use the ~ operator to invert all bits in 16-bit value 0, equivalent to 15 times '1'.\n\t\t\tendcase\n\t\tend\nendmodule\n"}
{"task_id": "2012_q1g", "completion": "\n    \n    assign f = ~x[3] & ~x[2] & x[1] & x[4]; \nendmodule\n  \n"}
{"task_id": "2012_q1g", "completion": "\n\tassign f = ((~x[2]) & (~x[3])) | (x[3] & (~x[4])) | (x[2] & x[4]) | (x[1] & x[4]);\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\tassign f = !x[2] & x[1]; // !x[2] and x[1] are the terms in the K-map corresponding to 00 (the minterms) which when simplified give us 'f'\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\t// Function implemented using combinational logic based on Karnaugh map\n\tassign f = ((~x[2])&(~x[3])) | (x[2]&x[1]);\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\tassign f = ((~x[3]) & (~x[2]) & (~x[1])) |\n\t\t\t   ((~x[3]) &  x[2]  &  x[1])  |\n\t\t        x[3]  & x[2]  & (~x[1])   |\n               x[3]  & (~x[2]) & x[1];\nendmodule\n"}
{"task_id": "2012_q1g", "completion": "\n\n\tassign f = !x[2] & !x[3];\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\n\tassign f = (!x[3]&~x[2])|(x[3]&x[4]);\n\t\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\t\n\talways @* begin\n\t\tif (x[3]) begin\n\t\t\tif(x[2]) begin  // 11 case\n\t\t\t\tf = x[4];\n\t\t\tend else begin  // 01, 10 cases\n\t\t\t\tf = ~x[1] & x[4];  \n\t\t end\n\t  end else begin\n\t      if (x[2]) begin  // 01 case\n            f = ~x[3] & ~x[1] & x[4];\n\t\t end else begin  // 00, 10 cases\n            f = x[4];  \n\t    end\n\tend\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n    assign f = !x[3]&~x[2]&x[1]|x[2]&x[1];\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\tassign f = !x[3] & (!x[2] | x[1]) & x[4];\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\nalways @* begin\n\tcase(x)\n\t\t4'b0000: f = 1'b0;\n\t\t4'b0001: f = 1'b0;\n\t\t4'b0011: f = 1'b0;\n\t\t4'b0010: f = 1'b0;\n\t\t4'b0100: f = 1'b0;\n\t\t4'b0101: f = 1'b0;\n\t\t4'b0111: f = 1'b0;\n\t\t4'b0110: f = 1'b0;\n\t\t4'b1100: f = 1'b0;\n\t\t4'b1101: f = 1'b0;\n\t\t4'b1111: f = 1'b0;\n\t\t4'b1110: f = 1'b1;\n\t\tdefault: f = 1'bx; // undefined inputs\n\tendcase \nend\n"}
{"task_id": "2012_q1g", "completion": "\n\n\talways @(*) begin\n\t\tcase ({x[3], x[2], x[1]}) \n\t\t\t3'b000 : f = ~x[4];\n\t\t\t3'b001 : f = x[4];\n\t\t\t3'b011 : f = x[4];\n\t\t\t3'b111 : f = ~x[4];\n\t\t\tdefault: f = 1'bx;  // undefined case\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\tfunction [3:0] kmap;\n\t\tinput[2:0] x;\n\t\tbegin\n\t\t\tcase(x)\n\t\t\t\t3'b000: kmap = 4'd0;  //  00--> 1 -> (not x[3] and not x[2]) --> |   1| = NOT x[3] AND NOT x[2]  --> not_x3and_not_x2\n\t\t\t\t3'b001: kmap = 4'd1;  //  01--> 0 -> (x[4] and not x[3])     --> |   2| = X[4] AND NOT X[3]         --> x4and_not_x3\n\t\t\t\t3'b011: kmap = 4'd1;  //  11--> 1 -> (not x[4] and not x[2]) --> |   8| = NOT X[4] AND NOT X[2]      --> not_x4and_not_x2\n\t\t\t\t3'b010: kmap = 4'd0;  //  10--> 0 -> (not x[2] and x[3])      --> |   7| = NOT X[2] AND X[3]         --> not_x2and_x3\n\t\t\t\t3default: kmap = 4'dx; // others, error state\n\t\t\tendcase\n\t\tend\n\tendfunction \n\tassign f = (kmap( { x[1], ~x[2],  ~x[3] } ) | kmap( { ~x[1], x[2],  ~x[3]} )  | kmap( {~x[1],  ~x[2], x[3] }) |\n\t            kmap( { x[1], x[2], x[3]}) );\nendmodule \n"}
{"task_id": "2012_q1g", "completion": "\n    assign f = ((~x[2]) & (~x[3])) | (x[1] & x[2]) | (x[1] & x[3]);\nendmodule \n\n"}
{"task_id": "2012_q1g", "completion": "\n\tassign f = ((~x[2]&~x[3]) | (x[2]&~x[1])) & ~(x[3]&x[4]);\nendmodule \n"}
{"task_id": "2012_q1g", "completion": "\n\talways @* begin\n\t    case({x[3],x[2]})\n\t\t        2'b00 : f = x[4];\n\t\t        2'b01 : f = ~(x[1]);\n\t\t        default : f = (x[1])^(x[2]); // for 2'b10 and 2'b11\n\t    endcase\n\tend\nendmodule\n"}
{"task_id": "2012_q1g", "completion": "\n\n\tfunction integer karnaugh(input integer i);\n    begin\n      case(i) \n        4'b0000 : return 0; // 00 -> 0\n\t\t  4'b0001 : return 0; // 01 -> 0\n\t    4'b0011 : return 0; // 11 -> 1\n        4'b0010 : return 0; // 10 -> 0\n\t\t  4'b0100 : return 1; // 00 -> 0\n\t    4'b0101 : return 1; // 01 -> 1\n        4'b0111 : return 1; // 11 -> 0\n        4'b0110 : return 1; // 10 -> 1\n\t\t  4'b1100 : return 0; // 00 -> 0\n\t    4'b1101 : return 0; // 01 -> 0\n        4'b1111 : return 0; // 11 -> 1\n        4'b1110 : return 1; // 10 -> 1\n\t\t  4'b1000 : return 1; // 00 -> 1\n\t    4'b1001 : return 1; // 01 -> 1\n        4'b1011 : return 1; // 11 -> 0\n        4'b1010 : return 0; // 10 -> 0\n      endcase\n    end\n\tendfunction\n\t\n\tassign f = karnaugh(x);\n    \nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n    assign f = (~x[2]) & (x[3] | x[4]);\nendmodule \n"}
{"task_id": "2012_q1g", "completion": "\n\tassign f = ((~x[2]) & (~x[3])) | (x[2] & x[1]);\nendmodule\n\n"}
{"task_id": "2012_q1g", "completion": "\n\n\tassign f = !x[2]; // The function is implemented by assigning the output as the negation of the 2nd input bit.\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\n\tassign one = 1'b1;\n\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\n\tassign one = 1'b1;\n\t\nendmodule\n"}
{"task_id": "step_one", "completion": "\n\n\tassign one = 1'b1; // Drive output high with '1'\n\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n"}
{"task_id": "step_one", "completion": "\n\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n   assign one = 1'b1; //assigning the constant value of 1 to the output 'one'\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "step_one", "completion": "\n\tassign one = 1'b1;\nendmodule\n\n"}
{"task_id": "count1to10", "completion": "\nalways @(posedge clk) begin\n\tif (reset)\n\t\tq <= 4'b1;\n\telse if (q == 4'd9)  // decimal value of 9 in binary is 1001, so we are checking for overflow/rollover here.\n\t\tq <= 4'b1;        // reset the counter to 1 once it reaches 9 and rolls over.\n\telse\n\t\tq <= q + 1;       // increment the counter value on each clock cycle.\nend\nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 4'b0101; // reset to 5 as binary for counting from 1 to ten, 5 = 8 + 2 in binary\n\t\telse\n\t\t\tq <= q == 9 ? 4'b0101 : (q[3:2] == 2'b10 ? {q[1], q[3:2]} + 1 : q+1); // check if at 9 and reset or continue counting with correct binary increment\n\tend\nendmodule\n"}
{"task_id": "count1to10", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 4'b0001;\n        else \n            case(q)\n                4'b0001: q <= 4'b0010;\n                4'b0010: q <= 4'b0011;\n                4'b0011: q <= 4'b0100;\n                4'b0100: q <= 4'b0101;\n                4'b0101: q <= 4'b0110;\n                4'b0110: q <= 4'b0111;\n                4'b0111: q <= 4'b1000;\n                4'b1000: q <= 4'b1001;\n                4'b1001: q <= 4'b1010;\n                default: q <= 4'b0001; //back to 1 after 10\n            endcase\n    end  \nendmodule \n"}
{"task_id": "count1to10", "completion": "\n\n\talways @ (posedge clk or posedge reset) begin\n\t  if(reset == 1'b1) \n\t    q <= 4'd1; // reset counter to '1'\n\t  else \n\t    if(q < 4'd9) \n\t      q <= q + 1'd1; // increment counter until it reaches '9'\n\tend\nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t  if (reset) \n\t\t    q <= 4'b0001;\n      else \n\t\t    q <= {q[2:0],~q[3]}; // The MSB of the counter is complemented and shifted in as the LSB to create a simple binary counter with overflow.\n\tend\n\t  \nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\t\n\talways @ (posedge clk or posedge reset) begin\n    \tif (reset) \n        \tq <= 4'b0001; // reset to '1' on the active high reset signal\n    \telse \n        \tq <= q == 4'd10 ? 4'b0001 : q + 1;\n   end\nendmodule\n"}
{"task_id": "count1to10", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 4'b1;\n\telse if (q < 4'd10) \n\t\tq <= q + 2'd1;\nend\n\nendmodule\n\n"}
{"task_id": "count1to10", "completion": "\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n        q <= 4'b0001;\n    else \n        q <= q + 4'b0001;\nend\n\n"}
{"task_id": "count1to10", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'd1;\n\t\telse if (q == 4'd9)\n\t\t\tq <= 4'd0;\n\t\telse\n\t\t\tq <= q + 1;\n\tend\nendmodule\n\n"}
{"task_id": "count1to10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t    if(reset == 1'b1) \n\t        q <= 4'd1;\n        else if (q < 4'd9) \n            q <= q + 1;\n        else if (q == 4'd9) \n             q <= 4'd0;\t\t  \t     //when it reaches 9 reset back to 0.\n    end\nendmodule\n"}
{"task_id": "count1to10", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 4'b0001; // Resets the counter to 1 on reset.\n\telse if (&q[3:0]==0 && q[3]) \n\t\tq <= q + 1; // Increments when reaching 9, resets otherwise.\n\telse if (~|q)\n\t\tq <= 4'b0001;// Resets to 1 when all zeros.\nend\n\n"}
{"task_id": "count1to10", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) \n\t\tq <= 4'd1;\n\telse if (q < 4'd10)\n\t\tq <= q + 1;\nend\nendmodule\n\n"}
{"task_id": "count1to10", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 4'b0001;\n        else \n            q <= {q[2:0], ~&q[3]}; // shifts bits and increments when not all are '1', equivalent to adding 1.\n    end\nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset) \n        \tq <= 4'd1;  \t\t\t// Reset to 1 when reset is high\n   \t\telse if (q == 4'd9)  \t// If count has reached 9, then start over\n         \tq <= 4'd1;\n     \telse\n         \tq <= q + 1;  \t\t// Increment counter by 1 otherwise.\n\tend\n\t\n"}
{"task_id": "count1to10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n    \tif(reset) \n        \tq <= 4'b0;\n    \telse if (q < 10 && ~|q) \n        \tq <= q + 1;\n    end\nendmodule\n\n"}
{"task_id": "count1to10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t\tif(reset) \n\t\t\tq <= 4'd1;\n\t\telse if(q == 4'd10)\n\t\t\tq <= 4'd1;\n\t\telse\n\t\t\tq <= q + 1;\n\tend\nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0101; // Any value greater than 9 will get you back to 1. We used 0101 because when decremented by 1, it results in the desired value of 1 and won't go negative.\n\t\telse \n\t\t\tq <= q + 1'b1;\n\t\tif (q==4'd10) // if counter has reached 10\n\t\t   q <= 4'b0101; // Resetting the value to count from 1 again, same trick used in reset.\n\tend\nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t\tif(reset == 1'b1)\n\t\t\tq <= 4'd1;\n\t\telse if (q < 4'd10)\n\t\t\tq <= q + 1'd1;\n\tend \nendmodule\n"}
{"task_id": "count1to10", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0001; // reset to 1\n\t\telse if (q == 4'd10) \n\t\t\tq <= 4'b0001; // overflow, wrap around to 1\n\t\telse \n\t\t\tq <= q + 1'b1; // increment normally\n\tend\nendmodule\n\n"}
{"task_id": "count1to10", "completion": "\n   always @ (posedge clk or posedge reset) begin\n      if (reset == 1'b1)\n         q <= 4'd1;  // Reset count to 1.\n      else if (q < 4'd9)\n         q <= q + 1'd1;  // Increment count.\n      else \n         q <= 4'd0;   // If count is already at max, wrap around to zero.\n    end\nendmodule \n"}
{"task_id": "m2014_q4d", "completion": "\n\n\talways @(posedge clk) begin\n\t\tout <= in ^ out;  // XOR operation between input and output of D flip-flop\n\tend\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\t// D flip flop\n\talways @(posedge clk) begin \n\tout <= xorGate; // flip-flop output is driven by the XOR gate result\n\tend\n\n\t// XOR Gate\n\tlogic xorGate;\n\tassign xorGate = in ^ out;\n  \nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\n\tDFF dff (.clk(clk), .d(out ^ in), .q(out));\n    \nendmodule\n\n// Define D flip flop\nmodule DFF (\n    input clk,\n    input d,\n    output reg q);\n    \nalways @(posedge clk) \n\tq <= d;\n\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\nalways @(posedge clk) begin\n\tout <= in ^ out;\nend\n\n"}
{"task_id": "m2014_q4d", "completion": "\nDff (.clk(clk), .in((in^out)||0), .out(out));  // XOR with zero to prevent undefined outputs at start.\nendmodule\n\nmodule Dff (\n    input clk,\n    input in,\n    output reg out);\n\talways @(posedge clk) begin\n        out <= in;\n    end\nendmodule  \n"}
{"task_id": "m2014_q4d", "completion": "\n    \n\talways @(posedge cll) begin\n\t\tout <= ^{in, out};\n\tend\n\t\nendmodule\n\n"}
{"task_id": "m2014_q4d", "completion": "\n\t\n    dff DFF1 (.clk(clk), .d(in ^ out), .q(out));\n    \nendmodule\n\nmodule dff ( \n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge cll) begin\n        q <= d;\n    end\n\t\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n    \n    always @(posedge clk) begin\n        out <= in ^ out;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4d", "completion": "\n\tdff dff0 (.clk(clk), .D((in^out)), .Q(out));\nendmodule\n\nmodule dff (\n  input      clk,\n  input      D,\n  output reg Q\n);\n  always @(posedge cll)\n    Q <= D;\nendmodule\n\n"}
{"task_id": "m2014_q4d", "completion": "\n\t\n\talways @(posedge clk) begin\n\t    out <= in ^ out;\n\tend\n    \nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\t//D flip flop\n    always @(posedge clk) begin\n        out <= xor_out;\n    end \n    \n   // XOR gate\n   wire xor_out = in ^ out;\n\t\nendmodule\n\n"}
{"task_id": "m2014_q4d", "completion": "\n\n\tDFF dff (.clk(clk), .d(in ^ out), .q(out));\nendmodule \n\nmodule DFF (\n\tinput clk,\n\tinput d,\n\toutput reg q\n);\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\tDff ff1 (.clk(clk), .d(xored), .q(out));\n\tXor xor2(.a(in),.b(out,.z(xored)));\nendmodule\n\nmodule Dff (input clk, input d, output reg q); \n    always @ (posedge clk)\n        q <= d; \nendmodule\n\nmodule Xor (input a, b, output z); \n    assign z = a ^ b; \nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\tDFF dff1(.clk(clk), .d((in^out)), .q(out));\nendmodule\n\nmodule DFF(\n  input clk,\n  input d,\n  output reg q\n);\nalways @(posedge cll)\n    q <= d;\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\nalways @(posedge cll) begin\n\tout <= in ^ out;  // XOR gate implementation\nend\n\n"}
{"task_id": "m2014_q4d", "completion": "\n\t\n\t// D Flip Flop\n\talways @(posedge clk) begin\n\t   out <= xor_out;\n\tend\n\n\t// XOR Gate \n\tlogic xor_out;\n\tassign xor_out = in ^ out;\n\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\n\t// D Flip flop\n\talways @(posedge clk) begin \n        out <= xor_out; //assign flip-flop output to XOR output\n    end \n    \n   // Two input XOR\n   logic xor_out;\n   assign xor_out = in ^ out;\n\t\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\t\n\tDFF XOR_DFF (.clk(clk), .d((in^out)), .q(out));\nendmodule \n\n// D flip-flop module\nmodule DFF (\n\tinput clk,\n\tinput d,\n\toutput reg q\n);\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\n\tDFF dff(\n\t\t.clk(clk), \n\t\t.d(xor_out), \n\t\t.q(out)\n\t);\n\t\n\tXOR #1 xor_gate (\n\t\t.a(in),\n\t\t.b(out),\n\t\t.o(xor_out)\n\t);\nendmodule\n\n"}
{"task_id": "m2014_q4d", "completion": "\n\tdff xor_out(.*); // instantiate DFF\n    \n    always @(posedge clk) begin\n        out <= in ^ dff.q; \n    end\nendmodule\n\n// sub module for the D flip-flop\nmodule dff (clk, q);\n\tinput clk;\n\toutput logic q;\n\talways_ff @(posedge clk) begin\n\t    q <= 1'b0; // or 1'bx depending on what you want to reset to.\n\tend\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n\treg [1:0] state;\n    \n    // Define the states\n    parameter A = 2'b10, B = 2'b01; \n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;   // Asynchronous reset into state B\n        else\n            case (state)\n                A:   state <= in ? A : B;\n                B:   state <= in ? B : A;\n                default: state <= A;  // If an unpredicted value occurs, default to state 'A'\n            endcase\n    end\n    \n    assign out = (state == A);  // Assign the output based on the current state. In state 'A', it will be high\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n\treg [1:0] state;\n  \tparameter A=2'b00, B=2'b01;\n   \tassign out = (state == B) ? 1 : 0 ;\n\n\talways @(posedge clk or posedge areset) begin\n      \tif (areset)\n        \tstate <= B;\n    \telse if(in == 1'b1) // move to next state based on input signal\n            case(state)\n                A: \n                    state<=B;\n                default:  \n                     state<=A;                  \n            endcase     \n      \telse\n          \tstate <= state ;     // keep current state if no transition\n    end\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n     reg [1:0] state; \n     \n     always @(posedge clk or posedge areset) begin\n       if (areset)\n         state <= 2'b10; // reset to state B.\n       else \n         case(state)\n           2'b01: if (!in) state <= 2'b01; else state <= 2'b10;\n           2'b10: if ( in) state <= 2'b11; else state <= 2'b01;\n           2'b11: if (!in) state <= 2'b10; else state <= 2'b11;\n         endcase\n     end\n     \n     assign out = state[0]; // the output is the first bit of our two-bit state.\nendmodule \n\n"}
{"task_id": "fsm1", "completion": "\n\treg [1:0] state; // 2-bit state register\n\tparameter A = 2'b00, B = 2'b01; // states\n\tassign out = (state == B) ? 1'b1 : 1'b0; // output is 1 when in state B\n\talways @(posedge clk or posedge areset) begin\n\t    if(areset) \n\t\t    state <= B; // reset to B on high pulse of areset\n\t    else begin\n\t\t     case (state)\n\t\t\t      A: if(!in) state <= B;\n\t\t\t\t   else state <= A;\n\t\t\t      B: if(!in) state <= A;\n\t\t\t\t   else state <= B;\n\t\t\t endcase\t\n\t\t  end\n    end\nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\n  reg [1:0] state; // two bit state register\n  \n  parameter B = 2'b01;\n  parameter A = 2'b10;\n  \n  always @(posedge clk or posedge areset) begin\n    if (areset == 1'b1) // Asynchronous reset\n      state <= B;\n    else\n\tcase(state)\n\t  B: state <= in ? A : B;\t  \n\t  A: state <= in ? A : B; \t\t    \t      \n        endcase\n  end\n\nassign out = (state == A); // Outputs the result of the machine\n\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n\t// Declaration of states\n\tlocalparam A = 1'b0;\n\tlocalparam B = 1'b1;\n\n\t// State variable declaration\n\treg state;\n\n\t// Synchronous process for state transition\n\talways @(posedge clk or posedge areset) begin \n    \tif (areset) // Asynchronous reset\n        \tstate <= B;\n        else\n\t        case(state)\n            \tB: if(in == 1'b0)\n                \tstate <= A;\n                else if(in == 1'b1)\n                    state <= B;\n            A: if (in == 1'b0)\n               \t\tstate <= B;\n             \telse if(in == 1'b1)\n                    state <= A;\n           endcase\n     end \n    // Output generation for out based on states\n\tassign out = (state == B)? 1'b1:1'b0; \nendmodule\n"}
{"task_id": "fsm1", "completion": "\n\n\treg [1:0] state; \n\tparameter A = 2'b01, B = 2'b10;\n\t\t  \n\tassign out = (state == B) ? 1'b1 : 1'b0;\t\t// Output is 1 if in state B otherwise it remains 0.\n\n\talways @(posedge clk or posedge areset) begin\n\t   \tif (areset)\t\t     // Asynchronous reset\n            state <= B;\n        else\n        \tcase(state)\n            \tA: if(in==1'b0) \t// A and in = 0 transition to B.\n                    state <= B;\n               \telse  \t\t\t    // A and in = 1 remain in A.\n                    state <= A;\n            \tB: if(in==1'b1)\t    // B and in =1 transition to A.\n                    \tstate <= A; \n                \telse               // B and in =0 remain in B.\n                    \tstate <= B;     \n        \tendcase\t\t\n    \tend\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n    \n    reg [1:0] state;\n    \n    parameter A = 2'b10;  // State A binary representation.\n    parameter B = 2'b01;  // State B binary representation.\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)  \n            state <= B;\n        else \n\t\t\tcase (state) \n            \tA: \tif (in) state <= A;\n                 \telse state <= B;\n                B: \tif (in) state <= B;\n                 \telse state <= A;    \n        \tendcase\n    end\n    \n    assign out = state[0]; // State output.\n\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n   reg [1:0] state; \n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b10;\n        else case(state)\n            2'b00: state <= in ? 2'b1 : 2'b0 ; // A state\n            2'b01: state <= in ? 2'b0 : 2'b1 ; // B state\n\t\t\t      default: state <= 2'b10;    // Default is B state\n        endcase\n\tend\n   assign out = (state==2'b00); \n\nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\n\n\treg [1:0] state; // Use two bits to represent the four states.\n\tparameter A = 2'b01, B = 2'b10; \n\tassign out = state[0];\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= B; // Reset to B if reset is high.\n\t\telse\n\t\tcase (state)\n\t\t\tA: \n\t\t\t\tif (in)\n\t\t\t\t\tstate <= A;\n\t\t\t\telse\n\t\t\t\t\tstate <= B;\n\t\t\tB: \n\t\t\t\tif (in)\n\t\t\t\t\tstate <= B;\n\t\t\t\telse\n\t\t\t\t\tstate <= A;\n\t\t\tdefault: state <= B; // Default state is B.\n\tend\nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\n\n\treg state; // define the state as a register\n\n\t// Asynchronous reset to B\n\talways @(posedge areset) \n\t    state <= 1'b0;\n\n\t// Synchronous operation of state machine    \n\talways @(posedge clk) begin\n\t        case (state)  \n\t\t    2'b00: if (in==0) state<=2'b01; // move to B for 0 input\n\t\t    2'b01: if (in==0) state<=2'b10; // stay in A for 0 input, go to A for 1 input\n\t            default: state <= 2'b00; //default condition or when no inputs are given. it returns to B for any other case\n\t        endcase  \n        end  \n        \n\t// Output Logic based on current state\n        assign out = (state == 2'b01); \nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\nreg [1:0] state;\nwire b_to_a, b_to_b, a_to_b, a_to_a;\n\nassign out = state[0];\nassign b_to_a  = in && !state[0];\nassign b_to_b  = ~in && !state[0]; \nassign a_to_b  = in && state[0];   \nassign a_to_a = ~in && state[0];\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset)\n\t\tstate <= 2'h1; // State B reset value \n\telse \n\t\tcase ({b_to_a, b_to_b, a_to_b, a_to_a})  \n\t\t\t4'h0: state <= 2'h1; //State B\n\t\t\t4'h1: state <= 2'h0; //State A\n\t\t\tdefault: state <= state; \n\t\tendcase\nend \n\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n    reg [1:0] state; // two-bit state register\n    parameter A = 2'b00, B = 2'b01; // states represented as binary values\n    \n    always @(posedge clk or posedge areset) begin \n        if (areset) \n            state <= B; \n        else \n           case(state)  \n              A: state <= in ? A : B;\n              B: state <= in ? B : A;\n            endcase      \n    end\n    \n\tassign out = state == B ? 1'b0 : 1'b1 ; // output depends on current state \nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\nreg [1:0] state; // two bit state register\nparameter A = 2'b01, B = 2'b10; // State constants\n\nalways @(posedge clk or posedge areset) begin \n\tif (areset) \n\t\tstate <= B;  \n\telse \n\t\tcase (state) \n\t\t\tA: state <= in ? A : B; \n\t\t\tB: state <= in ? B : A; \n\t\tendcase \nend \n\nassign out = state == A; // output is high when state is A\n\n"}
{"task_id": "fsm1", "completion": "\n    reg [1:0] state; // two bits state\n\tassign out = state[0]; \n    \n    always @(posedge clk or posedge areset) begin  \n        if (areset == 1'b1) \n            state <= 2'b10; // reset to B on active high reset\n        else \n            case(state) \n                2'b00: if (in == 1'b0) state <= 2'b01;\n                        else state <= 2'b10;\n                2'b01: if (in == 1'b0) state <= 2'b00;\n                        else state <= 2'b11; \n                2'b10, 2'b11: ; // do nothing   \n            endcase\t    \n    end  \nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\n\treg [1:0] state;\n  \n  parameter A = 2'b01;\n  parameter B = 2'b10;\n    \n  assign out = (state == B);    // Output is only high in State B.\n      \n  always @(posedge clk or posedge areset) begin\n      if(areset == 1'h1) \n        state <= B;            // Async Reset\n      else\n         case(state)  \n           A: if (in==1'h0) \n              state <= B;    // Transition to State B when in is high.\n             else\n               state <= A;     // Stay in State A otherwise\n           \n           B: if (in==1'h1) \n              state <= B;      // Transition to State B when in is high.\n             else  \n               state <= A;    // Transition to State A otherwise.        \n        endcase    \n\tend      \nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\n\n\treg [1:0] state;\n  \n\tparameter A = 2'b00, B = 2'b01;\n  \n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t\t    state <= B;\n\t    else \n\t\t    case (state) \n\t\t\t    A : if (in == 1)\n\t\t\t\t        state <= B;\n\t\t\t\t    else \n\t\t\t\t        state <= A;\n\t\t\t    B : if (in == 1) \n\t\t\t\t        state <= A;\n\t\t\t\t    else \n\t\t\t\t        state <= B;\n\t\t\tendcase\n\tend  \n  \n\tassign out = (state == A); // If state is A, output 1 otherwise 0\n\t    \nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\n\treg [1:0] state;\n  \tparameter A = 2'b01, B = 2'b10;\n   \n  always @ (posedge clk or posedge areset) begin\n    \tif(areset)\n        \tstate <= B;\n        else\n            case(state)\n                A: state <= in ? A : B;\n                B: state <= in ? B : A;\n                default: state <= B;\n           endcase\n   end\n    assign out = state == A ? 1'b0 : 1'b1;\nendmodule\n\n"}
{"task_id": "fsm1", "completion": "\nreg [1:0] current_state; // 2-bit state register\n\tparameter A = 2'b01, B = 2'b00; // State encoding\n\n\t// Asynchronous reset into state B if areset is high.\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t\t    current_state <= B;\n\t\telse \n            case (current_state)\n                A: if (in == 1'b0) \n                       current_state <= B;\n                   else \n                       current_state <= A;\n                B: if (in == 1'b0)  \n                       current_state <= B;\n                   else \n                       current_state <= A;\n            endcase\n    end\n\tassign out = (current_state == A); // Set output depending on the state.\nendmodule\n"}
{"task_id": "fsm1", "completion": "\n    reg [1:0] state; // 2-bit state register\n    \n    parameter A = 2'b01, B = 2'b10; // States definition\n    \n    always @ (posedge clk or posedge areset) begin // Synchronous reset\n        if(areset)\n            state <= B; \n        else  \n        case (state)\n            A:\n                if(!in) \n                    state <= B;\n                else \n                    state <= A;\n                \n            B:    \n                if(!in) \n                    state <= B;\n                else \n                    state <= A;\n         endcase       \n    end  \n      assign out = (state == B); //Output depending on the current state, '1' for state B and '0' otherwise.\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n        casex (code) \n            8'h45 : {valid,out} = 4'b1001; //1\n            8'h16 : {valid,out} = 4'b1000; //0\n            8'h1E : {valid,out} = 4'b1010; //2\n            8'h26 : {valid,out} = 4'b1011; //3\n            8'h25 : {valid,out} = 4'b1100; //4\n            8'h2E : {valid,out} = 4'b1101; //5\n            8'h36 : {valid,out} = 4'b1110; //6\n            8'h3D : {valid,out} = 4'b1111; //7\n            8'h3E : {valid,out} = 4'b0100; //8\n            8'h46 : {valid,out} = 4'b0101; //9\n            default :{valid, out} =  4'b0000; //default to 0 if no match\n        endcase\n    end\nendmodule\n\n"}
{"task_id": "bugs_case", "completion": "\n    always @(*) begin\n        case (code) \n            8'h45 : {valid, out} = {1'b1, 4'd0}; // Key 'E' = 0x45\n            8'h16 : {valid, out} = {1'b1, 4'd1}; // Key 'Q' = 0x16\n            8'h1e : {valid, out} = {1'b1, 4'd2}; // Key 'W' = 0x1E\n            8'h26 : {valid, out} = {1'b1, 4'd3}; // Key 'A' = 0x26\n            8'h25 : {valid, out} = {1'b1, 4'd4}; // Key 'S' = 0x25\n            8'h2e : {valid, out} = {1'b1, 4'd5}; // Key 'Z' = 0x2E\n            8'h36 : {valid, out} = {1'b1, 4'd6}; // Key 'X' = 0x36\n            8'h3D : {valid, out} = {1'b1, 4'd7}; // Key 'C' = 0x3D\n            8'h3e : {valid, out} = {1'b1, 4'd8}; // Key 'D' = 0x3E\n            8'h46 : {valid, out} = {1'b1, 4'd9}; // Key 'F' = 0x46\n            default: {valid, out} = {1'b0, 4'd0}; // Invalid key\n        endcase\n    end\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n\n\talways @(*) begin\n\t\tcasex (code) \n\t\t\t8'h45: {out, valid} = 16'b0001_0000; //1\n\t\t\t8'h16: {out, valid} = 16'b0010_0000; //2\n\t\t\t8'h1E: {out, valid} = 16'b0011_0000; //3\n\t\t\t8'h26: {out, valid} = 16'b0100_0000; //4\n\t\t\t8'h25: {out, valid} = 16'b0101_0000; //5\n\t\t\t8'h2E: {out, valid} = 16'b0110_0000; //6\n\t\t\t8'h36: {out, valid} = 16'b0111_0000; //7\n\t\t\t8'h3D: {out, valid} = 16'b1000_0000; //8\n\t\t\t8'h3E: {out, valid} = 16'b1001_0000; //9\n\t\t\t8'h46: {out, valid} = 16'b1010_0000; //0\t\n\t\t\tdefault : {out, valid} = 16'b0000_0000; \n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n\t\tcase (code)\n\t\t\t8'h45 : {out,valid} = {4'd1 ,1'b1}; // 2nd case\n      8'h16 : {out,valid} = {4'd2 ,1'b1}; // 3rd case\n      8'h1E : {out,valid} = {4'd3 ,1'b1}; // 4th case\n      8'h26 : {out,valid} = {4'd4 ,1'b1}; // 5th case\n\t\t\t8'h25 : {out,valid} = {4'd5 ,1'b1}; // 6th case\n      8'h2E : {out,valid} = {4'd6 ,1'b1}; // 7th case\n\t\t\t8'h36 : {out,valid} = {4'd7 ,1'b1}; // 8th case\n\t\t\t8'h3D : {out,valid} = {4'd8 ,1'b1}; // 9th case\n      8'h3E : {out,valid} = {4'd9 ,1'b1}; // 10th case\n      default: {out,valid} = 2'b0;             // default case (all bits set to zero)\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\nalways @* begin\n\tcase(code)\n\t\t8'h45: {out, valid} = {4'd0, 1'b1}; // 'E'\n\t\t8'h16: {out, valid} = {4'd1, 1'b1}; // 'Q'\n\t\t8'h1E: {out, valid} = {4'd2, 1'b1}; // 'W'\n\t\t8'h26: {out, valid} = {4'd3, 1'b1}; // 'A'\n\t\t8'h25: {out, valid} = {4'd4, 1'b1}; // 'S'\n\t\t8'h2E: {out, valid} = {4'd5, 1'b1}; // 'D'\n\t\t8'h36: {out, valid} = {4'd6, 1'b1}; // 'Z'\n\t\t8'h3C: {out, valid} = {4'd7, 1'b1}; // 'X'\n\t\t8'h3D: {out, valid} = {4'd8, 1'b1}; // 'C'\n\t\t8'h46: {out, valid} = {4'd9, 1'b1}; // 'F'\n\t\tdefault:{out, valid}= {4'b0000, 1'b0};\n\tendcase\nend\n"}
{"task_id": "bugs_case", "completion": "\nalways @(*) begin\n\tcase (code)\n\t\t8'h45: {out, valid} = {4'd1, 1'b1}; // e\n\t\t8'h16: {out, valid} = {4'd2, 1'b1}; // q\n\t\t8'h1e: {out, valid} = {4'd3, 1'b1}; // w\n\t\t8'h26: {out, valid} = {4'd4, 1'b1}; // t\n\t\t8'h25: {out, valid} = {4'd5, 1'b1}; // z\n\t\t8'h2e: {out, valid} = {4'd6, 1'b1}; // u\n\t\t8'h36: {out, valid} = {4'd7, 1'b1}; // y\n\t\t8'h3d: {out, valid} = {4'd8, 1'b1}; // x\n\t\t8'h3e: {out, valid} = {4'd9, 1'b1}; // c\n\t\t8'h46: {out, valid} = {4'd0, 1'b1}; // r\n\t\tdefault :{out, valid} = {4'd0, 1'b0};\n\tendcase\nend\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n\t\t\tcasexz (code)\n\t\t\t\t8'h45: {valid, out} = {1'b1, 4'd0}; // 'E' key\n\t\t\t\t8'h16: {valid, out} = {1'b1, 4'd1}; // '2' key\n\t\t\t\t8'h1e: {valid, out} = {1'b1, 4'd3}; // '4' key\n\t\t\t\t8'h26: {valid, out} = {1'b1, 4'd4}; // '6' key\n\t\t\t\t8'h25: {valid, out} = {1'b1, 4'd5}; // '7' key\n\t\t\t\t8'h2e: {valid, out} = {1'b1, 4'd6}; // '9' key\n\t\t\t\t8'h36: {valid, out} = {1'b1, 4'd7}; // '-' key\n\t\t\t\t8'h3d: {valid, out} = {1'b1, 4'd8}; // '0' key\n\t\t\t\t8'h3e: {valid, out} = {1'b1, 4'd9}; // '=' key\n\t\t\t\t8'h46: {valid, out} = {1'b1, 4'd2}; // 'F' key\n\t\t\t\tdefault: {valid, out} = {1'b0, 4'd0}; // default to 0 if no match\n\t\t\tendcase\n\t\tend\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n\t    casez({code[7:5], code[4:0]}) // breaks the 8 bit input into 2 parts to compare\n            8'b1zzzzzz : {valid, out} <= 4'd9;    // 9 for key F (0x3A)\n\t    8'b0000_0zz : {valid, out} <= 4'd8;    // 8 for key R (0x27)\n            8'b1001_z0z : {valid, out} <= 4'd7;    // 7 for key E (0x1C)\n\t    8'b1zzz_zzz : {valid, out} <= 4'd6;    // 6 for any number or letter key (0-9 and A-F)\n            8'b1000_1zz : {valid, out} <= 4'd5;    // 5 for key T (0x2B)\n\t    8'b0100_z00 : {valid, out} <= 4'd4;    // 4 for key Y (0x36)\n            8'b1001_zz0 : {valid, out} <= 4'd3;    // 3 for key D (0x25)\n\t    8'b0011_zxx : {valid, out} <= 4'd2;    // 2 for any number or letter key (0-9 and A-F)\n            8'b0000_zz0 : {valid, out} <= 4'd1;    // 1 for key A (0x1E)\n\t    8'b0000_xxxx : {valid, out} <= 4'd0;    // 0 for any number or letter key (0-9 and A-F)\n            default : {valid, out} <= 4'd0;         // Default to not valid if code does not match any case\n        endcase\n\tend\n"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n\t\tif ((code == 8'h45) || (code == 8'h16) || \n\t\t   (code == 8'h1E) || (code == 8'h26) ||\n\t\t   (code == 8'h25) || (code == 8'h2E) || \n\t\t   (code == 8'h36) || (code == 8'h3D) || \n\t\t   (code == 8'h3E) || (code == 8'h46))  begin\n\t\t\tout = code[7:4] - 8'h10;\n\t\t\tvalid = 1'b1;\n\t\tend else begin\n\t\t\tout = 4'd0;\n\t\t\tvalid = 1'b0;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n\n\talways @(code) begin\n\tcasex (code) \n\t\t8'h45 : {valid, out} = 'b10_01; // 0\n\t\t8'h16 : {valid, out} = 'b10_00; // 1\n\t\t8'h1E : {valid, out} = 'b10_01; // 2\n\t\t8'h26 : {valid, out} = 'b10_10; // 3\n\t\t8'h25 : {valid, out} = 'b10_11; // 4\n\t\t8'h2E : {valid, out} = 'b10_01; // 5\n\t\t8'h36 : {valid, out} = 'b10_10; // 6\n\t\t8'h3D : {valid, out} = 'b10_11; // 7\n\t\t8'h3E : {valid, out} = 'b10_00; // 8\n\t\t8'h46 : {valid, out} = 'b10_11; // 9\n\t\tdefault: {valid, out} = 'b00_00; // Invalid\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n\t\t\tcase (code) \n\t\t\t\t8'h45 : {valid,out} = {1,4'b0};   // Key 0\n\t\t\t\t8'h16 : {valid,out} = {1,4'b1};   // Key 1\n\t\t\t\t8'h1E : {valid,out} = {1,4'b2};   // Key 2\n\t\t\t\t8'h26 : {valid,out} = {1,4'b3};   // Key 3\n\t\t\t\t8'h25 : {valid,out} = {1,4'b4};   // Key 4\n\t\t\t\t8'h2E : {valid,out} = {1,4'b5};   // Key 5\n\t\t\t\t8'h36 : {valid,out} = {1,4'b6};   // Key 6\n\t\t\t\t8'h3D : {valid,out} = {1,4'b7};   // Key 7\n\t\t\t\t8'h3E : {valid,out} = {1,4'b8};   // Key 8\n\t\t\t\t8'h46 : {valid,out} = {1,4'b9};   // Key 9\n\t\t\t\tdefault: {valid,out} = 0;          // Default case\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n\t// Array of all possible keyboard scancodes for keys 0 through 9\n\tparameter [7:0] codes[10] = '{8'h45, 8'h16, 8'h1E, 8'h26, 8'h25, 8'h2E, 8'h36, 8'h3D, 8'h3E, 8'h46};\n\talways @(*) begin\n\t\tfor (integer i = 0; i < 10; i = i + 1) begin\n\t\t\tif (code == codes[i]) begin\n\t\t\t\t{valid, out} <= {1'b1, 4'(i)};\n\t\t\t\tbreak;\n\t\t end\n\t     else if(i == 9)begin\n\t\t\t\t {valid,out}<={1'b0,4'd0}; // if code doesn't match any in the list set valid to 0 and output to zero\n             end\n\t    end\n    end\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n\talways @* begin\n\t\t\tcase(code)\n\t\t\t\t8'h45 : {valid,out} = {1'b1, 4'd0}; // Key 0\n\t\t\t\t8'h16 : {valid,out} = {1'b1, 4'd1}; // Key 1\n\t\t\t\t8'h1e : {valid,out} = {1'b1, 4'd2}; // Key 2\n\t\t\t\t8'h26 : {valid,out} = {1'b1, 4'd3}; // Key 3\n\t\t\t\t8'h25 : {valid,out} = {1'b1, 4'd4}; // Key 4\n\t\t\t\t8'h2e : {valid,out} = {1'b1, 4'd5}; // Key 5\n\t\t\t\t8'h36 : {valid,out} = {1'b1, 4'd6}; // Key 6\n\t\t\t\t8'h3d : {valid,out} = {1'b1, 4'd7}; // Key 7\n\t\t\t\t8'h3e : {valid,out} = {1'b1, 4'd8}; // Key 8\n\t\t\t\t8'h46 : {valid,out} = {1'b1, 4'd9}; // Key 9\n\t\t\t\tdefault:{valid, out} = 2'b0;\t\t    // default case\n\t\t\tendcase\n\tend\n\n"}
{"task_id": "bugs_case", "completion": "\n\talways @(*) begin\n\t\tcase (code)\n\t\t\t8'h45: {out,valid} = {4'd0,1'b1}; // 0\n\t\t\t8'h16: {out,valid} = {4'd1,1'b1}; // 1\n\t\t\t8'h1E: {out,valid} = {4'd2,1'b1}; // 2\n\t\t\t8'h26: {out,valid} = {4'd3,1'b1}; // 3\n\t\t\t8'h25: {out,valid} = {4'd4,1'b1}; // 4\n\t\t\t8'h2E: {out,valid} = {4'd5,1'b1}; // 5\n\t\t\t8'h36: {out,valid} = {4'd6,1'b1}; // 6\n\t\t\t8'h3D: {out,valid} = {4'd7,1'b1}; // 7\n\t\t\t8'h3E: {out,valid} = {4'd8,1'b1}; // 8\n\t\t\t8'h46: {out,valid} = {4'd9,1'b1}; // 9\n\t\t\tdefault : {out,valid} = {4'd0,1'b0}; // Default value when no match found, set out to 0 and valid to 0\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\n    always @(code) begin\n        casex({{2'b0},code[7:5],1'b0})\n            8'h45 : {out,valid} = 4'd0; // 'E'\n            8'h16 : {out,valid} = 4'd1; // 'Q'\n            8'h1e : {out,valid} = 4'd2; // 'W'\n            8'h26 : {out,valid} = 4'd3; // 'T'\n            8'h25 : {out,valid} = 4'd4; // 'O'\n            8'h2e : {out,valid} = 4'd5; // 'P'\n            8'h36 : {out,valid} = 4'd6; // 'Y'\n            8'h3d : {out,valid} = 4'd7; // 'F'\n            8'h3e : {out,valid} = 4'd8; // 'G'\n            8'h46 : {out,valid} = 4'd9; // 'H'\n            default: {out,valid} = 0; \n        endcase\n    end\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\nalways @* begin\n\tcase(code)\n\t\t8'h45: {out, valid} = {4'd0, 1'b1}; //0\n\t\t8'h16: {out, valid} = {4'd1, 1'b1}; //1\n\t\t8'h1E: {out, valid} = {4'd2, 1'b1}; //2\n\t\t8'h26: {out, valid} = {4'd3, 1'b1}; //3\n\t\t8'h25: {out, valid} = {4'd4, 1'b1}; //4\n\t\t8'h2E: {out, valid} = {4'd5, 1'b1}; //5\n\t\t8'h36: {out, valid} = {4'd6, 1'b1}; //6\n\t\t8'h3D: {out, valid} = {4'd7, 1'b1}; //7\n\t\t8'h3E: {out, valid} = {4'd8, 1'b1}; //8\n\t\t8'h46: {out, valid} = {4'd9, 1'b1}; //9\n\t\tdefault: {out, valid} = 10'd0;       //Invalid\n\tendcase\nend\nendmodule\n"}
{"task_id": "bugs_case", "completion": "\nalways @(*) begin\n\tcasexz (code) \n\t\t8'h45: {out, valid} = {4'd0, 1'b1}; // 'E' key\n\t\t8'h16: {out, valid} = {4'd1, 1'b1}; // 'Q' key\n\t\t8'h1E: {out, valid} = {4'd2, 1'b1}; // 'W' key\n\t\t8'h26: {out, valid} = {4'd3, 1'b1}; // 'A' key\n\t\t8'h25: {out, valid} = {4'd4, 1'b1}; // 'S' key\n\t\t8'h2E: {out, valid} = {4'd5, 1'b1}; // 'Z' key\n\t\t8'h36: {out, valid} = {4'd6, 1'b1}; // 'X' key\n\t\t8'h3D: {out, valid} = {4'd7, 1'b1}; // 'C' key\n\t\t8'h3E: {out, valid} = {4'd8, 1'b1}; // 'V' key\n\t\t8'h46: {out, valid} = {4'd9, 1'b1}; // 'F' key\n\t\tdefault: {out, valid} = {4'd0, 1'b0}; // No matching case found\n\tendcase\nend\n"}
{"task_id": "bugs_case", "completion": "\n\nalways @* begin\n\tif(code == 8'h45) begin //1\n\t\tout = 4'b0001;\n\t\tvalid = 1'b1;\n\tend \n\telse if(code == 8'h16) begin //2\n\t\tout = 4'b0010;\n\t\tvalid = 1'b1;\n\tend \n\telse if(code == 8'h1e) begin //3\n\t\tout = 4'b0011;\n\t\tvalid = 1'b1;\n\tend\n\telse if(code == 8'h26) begin //4\n\t\tout = 4'b0100;\n\t\tvalid = 1'b1;\n\tend \n\telse if(code == 8'h25) begin //5\n\t\tout = 4'b0101;\n\t\tvalid = 1'b1;\n\tend \n\telse if(code == 8'h2e) begin //6\n\t\tout = 4'b0110;\n\t\tvalid = 1'b1;\n\tend  \n\telse if(code == 8'h36) begin //7\n\t\tout = 4'b0111;\n\t\tvalid = 1'b1;\n\tend \n\telse if(code == 8'h3d) begin //8\n\t\tout = 4'b1000;\n\t\tvalid = 1'b1;\n\tend  \n\telse if(code == 8'h3e) begin //9\n\t\tout = 4'b1001;\n\t\tvalid = 1'b1;\n\tend \n\telse if(code == 8'h46) begin //0\n\t\tout = 4'b0000;\n\t\tvalid = 1'b1;\n\tend  \n\telse begin\n\t\tout = 4'b0000;\n\t\tvalid = 1'b0;\n\tend \nend\n\nendmodule\n\n"}
{"task_id": "bugs_case", "completion": "\nalways @(*) begin\n\tcasexz (code)\n\t\t8'h45 : {valid, out} = {1'b1, 4'd0}; // '0' key code\n\t\t8'h16 : {valid, out} = {1'b1, 4'd1}; // '1' key code\n\t\t8'h1E : {valid, out} = {1'b1, 4'd2}; // '2' key code\n\t\t8'h26 : {valid, out} = {1'b1, 4'd3}; // '3' key code\n\t\t8'h25 : {valid, out} = {1'b1, 4'd4}; // '4' key code\n\t\t8'h2E : {valid, out} = {1'b1, 4'd5}; // '5' key code\n\t\t8'h36 : {valid, out} = {1'b1, 4'd6}; // '6' key code\n\t\t8'h3D : {valid, out} = {1'b1, 4'd7}; // '7' key code\n\t\t8'h3E : {valid, out} = {1'b1, 4'd8}; // '8' key code\n\t\t8'h46 : {valid, out} = {1'b1, 4'd9}; // '9' key code\n\t\tdefault: {valid, out} = {1'b0, 4'd0}; // default to 'invalid' (both valid and out set to 0)\n\tendcase\nend\n"}
{"task_id": "bugs_case", "completion": "\n\n\talways @(*) begin\n\t\tcase (code) \n\t\t\t8'h45 : {out,valid} = {4'b0001, 1'b1}; //1\n\t\t\t8'h16 : {out,valid} = {4'b0010, 1'b1}; //2\n\t\t\t8'h1e : {out,valid} = {4'b0011, 1'b1}; //3\n\t\t\t8'h26 : {out,valid} = {4'b0100, 1'b1}; //4\n\t\t\t8'h25 : {out,valid} = {4'b0101, 1'b1}; //5\n\t\t\t8'h2e : {out,valid} = {4'b0110, 1'b1}; //6\n\t\t\t8'h36 : {out,valid} = {4'b0111, 1'b1}; //7\n\t\t\t8'h3d : {out,valid} = {4'b1000, 1'b1}; //8\n\t\t\t8'h3e : {out,valid} = {4'b1001, 1'b1}; //9\n\t\t\t8'h46 : {out,valid} = {4'b1010, 1'b1}; //A (10 in decimal)\n\t\t\tdefault:{out,valid} = {4'b0000, 1'b0};   //invalid input\n\t\tendcase\n\tend\n\nendmodule\n\n"}
{"task_id": "dff16e", "completion": "\n\t// D flip flops with byte enable\n\talways @(posedge clk or negedge resetn) begin \n\t    if(!resetn) // synchronous active low reset\n\t        q <= 16'b0;\n\t    else \n\t\t\tif (byteena[1]) // for upper byte \n\t\t\t    q[15:8] <= d[15:8];  \n            if (byteena[0]) // for lower byte\n                q[7:0]  <= d[7:0];    \n\tend\n\n"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn)\n\t\t\tq <= 16'h0;\n\t\telse if (byteena[0]) \n\t\t\tq <= {d[7:0], q[7:8]};\n\t\telse if (byteena[1])  \n\t\t\tq <= {q[3:0], d[15:8]};\n\tend\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\tif (!resetn)\n\t\tq <= 16'b0;\n\telse if (byteena[1])\n\t\tq <= {q[15:8], d[7:0]};\n\telse if (byteena[0])\n\t\tq <= {d[15:8], q[7:0]};\n\telse\n\t\tq <= d;  //No modification of any byte.\n\tend\nendmodule\n\n"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (~resetn) \n\t\t\tq <= 0;\n\t\telse if(byteena[1]) \n\t\t\tq <= {d[15:8], q[7:0]};\n\t\telse if(byteena[0]) \n\t\t\tq <= {q[15:8], d[7:0]};\n\tend\nendmodule\n\n"}
{"task_id": "dff16e", "completion": "\n    \n    always @ (posedge clk or negedge resetn) begin\n        if (!resetn) \n            q <= 16'b0;\n        else\n            case(byteena) \n                2'b00 : q <= d[7:0];      // lower byte only \n                2'b01 : q <= {q[15:8],d[7:0]};   // upper byte + lower byte\n                2'b10 : q <= {d[15:8],q[7:0]};   // lower byte + upper byte \n                2'b11 : q <= d;            // all bytes\n            endcase \n    end    \nendmodule \n"}
{"task_id": "dff16e", "completion": "\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif(!resetn)\n\t\t\tq <= 16'b0;\n\t\telse if (byteena[1])\n\t\t\tq[15:8] <= d[15:8];\n\t\telse if (byteena[0])\n\t\t\tq[7:0] <= d[7:0];\n\tend\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (resetn == 1'b0) \n\t\t\tq <= 16'h0;\n\t\telse if (byteena[1] == 1'b1 && byteena[0] == 1'b1)   // both bytes are enabled for write\n\t\t\tq <= d;\n\t\telse if (byteena[1] == 1'b1)  // only upper byte is enabled for write\n\t\t\tq <= {q[7:0],d[15:8]};\n\t\telse if (byteena[0] == 1'b1)  // only lower byte is enabled for write\n\t\t\tq <= {d[7:0],q[15:8]};\n\tend\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n\talways @ (posedge clk or negedge resetn) begin  // Synchronous reset \n        if (!resetn)   // Async active low reset\n            q <= 16'h0;  \n        else  \n           case(byteena)\n                2'b01:  q[7:0] <= d[7:0];  // Lower byte only\n                2'b10:  q[15:8] <= d[15:8]; // Upper byte only\n                2'b11:  q <= d;    // Both bytes\n                default: ;  // No change\n           endcase      \n\tend  \nendmodule\n"}
{"task_id": "dff16e", "completion": "\nalways @ (posedge clk or negedge resetn) begin\n\tif (!resetn)\n\t\tq <= 16'b0;\n\telse if(byteena ==2'h3) //If both bytes are enabled\n\t\tq <= d; \n\telse if(byteena == 2'h1) //Only upper byte is enabled\n\t\tq[15:8] <= d[15:8];\n\telse if(byteena == 2'h2) // Only lower byte is enabled\n\t\tq[7:0] <= d[7:0];\nend\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n \n\talways @ (posedge clk or negedge resetn) begin\n\t  if (!resetn)\n\t    q <= 16'h0;   // Synchronous active-low reset\n\t  else\n\t\t\tif(byteena[1])\n\t\t\t    q[15:8] <= d[15:8]; \n\t\t\telse if (byteena[0])\n\t\t\t    q[7:0] <= d[7:0];\n\tend\n\t\nendmodule\n\n"}
{"task_id": "dff16e", "completion": "\n \n   always @(posedge clk or negedge resetn) begin\n       if (!resetn)\n           q <= 16'b0;\n       else begin\n       \tif (byteena[1])\n               q[15:8] <= d[15:8];\n \t   \n\t   if (byteena[0])\n               q[7:0] <= d[7:0];\n       end\n   end\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) \n\t\t\tq <= 16'h0;\n\t\telse if (byteena[1]) \n\t\t\tq[15:8] <= d[15:8];\n\t\telse if (byteena[0])  \n\t\t\tq[7:0] <= d[7:0];\n\tend\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn)\n\t\t\tq <= 16'b0;\n\t\telse if (byteena[1])\n\t\t\tq <= {q[7:0], d[15:8]};\n\t\telse if (byteena[0])\n\t\t\tq <= {d[7:0], q[15:8]};\n\tend\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn)\n\t\t\tq <= 16'h0;\n\t\telse if (byteena[1])\n\t\t\tq <= {q[15:8], d[15:8]};\n\t\telse if (byteena[0]) \n\t\t\tq <= {d[7:0], q[15:8]};\n\tend\n\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn)\n\t\t\tq <= 0;\n\t\telse if (byteena[0]) \n\t\t\tq <= {8'b0, d[7:0]};\n\t\telse if (byteena[1])\n\t\t\tq <= {d[15:8], 8'b0};\n\tend\n\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n   always @(posedge clk or negedge resetn) begin \n       if (!resetn)\n           q <= 16'b0;\n       else\n           case (byteena)\n                2'h3 : q <= d;      // Write all bytes at the same time.\n                2'h2 : q[7:0] <= d; // Write only lower byte\n                2'h1 : q[15:8]<= d; // Write only upper byte\n                2'h0 :            ;  // No change in values of q, so no write to the flip-flops.\n           endcase   \n   end\t\nendmodule \n\n"}
{"task_id": "dff16e", "completion": "\nalways @(posedge clk or negedge resetn) begin\n\tif (~resetn)\n\t\tq <= 16'b0;\n\telse \n\tcase (byteena[1:0]) \n\t\t2'b00: q <= d[7:0]; //lower byte\n\t\t2'b01, 2'b10: q <= {d[7:0], q[15:8]}; //upper or lower part of the first byte and all previous bytes\n\t\t2'b11: q <= d; //full word\n\tendcase\nend\nendmodule\n"}
{"task_id": "dff16e", "completion": "\n    \n    always @(posedge clk or negedge resetn) begin\n        if(!resetn)\n            q <= 16'b0;\n        else \n\t        case (byteena)\n                2'b11: q <= d[15:8];\n\t            2'b10: q <= {q[7:0], d[7:0]};\n\t            2'b01: q <= {d[15:8], q[7:0]};\n                default:  q <= d; //if byteena = 00, write d to all bytes of Q.\n            endcase    \n    end\nendmodule\n"}
{"task_id": "dff16e", "completion": "\nalways @(posedge clk or negedge resetn) begin\n\tif (!resetn) \n\t\tq <= 16'h0;\n\telse if (byteena[1])  \n\t\tq <= {q[15:8], d[15:8]};\n    else if (byteena[0]) \n        q <= {d[7:0], q[7:0]};\n    else \n        q <= q;  // No change.\nend\t\nendmodule\n\n"}
{"task_id": "dff16e", "completion": "\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) \n\t\t\tq <= 16'b0;\n\t\telse if (byteena[1])\n\t\t\tq <= {d[15:8], q[7:0]};\n\t\telse if(byteena[0])\n\t\t\tq <= {q[15:8], d[7:0]}; \n   end\nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\n\n\tassign out1 = (state[7]) ? 1'b1 : 1'b0; // For S5 and S6 outputs are always set to '1', otherwise they are '0'.\n\tassign out2 = state[8]; // Outputs 'in' for states S8. For other cases it is '0'.\n\n\t// State transition logic:\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t10'b0000_0000_01: next_state = 10'b0000_0000_10; // S0 --0--> S1\n            10'b0000_0000_10: if (in) \n next_state = 10'b0000_0001_00; // S1 --1--> S2\n                              else \n next_state = state; \t\t\t   // S1 --0--> S1\n            10'b0000_0001_00: if (in) \n next_state = 10'b0000_0010_00; // S2 --1--> S3\n                              else  \n next_state = state;\t\t\t   \t   // S2 --0--> S2\n            10'b0000_0010_00: if (in) \n next_state = 10'b0000_0100_00; // S3 --1--> S4\n                              else  \n next_state = state;\t\t\t   \t   // S3 --0--> S3\n            10'b0000_0100_00: if (in) \n next_state = 10'b0000_1000_00; // S4 --1--> S5\n                              else  \n next_state = state;\t\t\t   \t   // S4 --0--> S4\n            10'b0000_1000_00: if (in) \n next_state = 10'b0001_0000_00; // S5 --1--> S6\n                              else  \n next_state = state;\t\t\t   \t   // S5 --0--> S5\n            10'b0001_0000_00: if (in) \n next_state = 10'b0010_0000_00; // S6 --1--> S7\n                              else  \n next_state = state;\t\t\t   \t   // S6 --0--> S6\n            10'b0010_0000_00: if (in) \n next_state = 10'b0100_0000_00; // S7 --1--> S8\n                              else  \n next_state = state;\t\t\t   \t   // S7 --0--> S7\n            10'b0100_0000_00: if (in) \n next_state = 10'b1000_0000_01; // S8 --1--> S9\n                              else  \n next_state = state;\t\t\t   \t   // S8 --0--> S8\n            10'b1000_0000_01: if (in) \n next_state = 10'b0000_0000_10; // S9 --1--> S1\n                              else  \n next_state = state;\t\t\t   \t   // S9 --0--> S9\n            default:           next_state = 10'b0000_0000_00; \t\t   // Default to S0 if no other condition met.\n        endcase\n\tend\nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\n\t\n    assign out1 = ~(|state[7:6]); //out1 is only 1 if the state machine is in S5 or S8\n    assign out2 = (state[9] & ~state[3]) | (state[8] & ~state[4]) ;//out2 is only 1 when current state is either S7, and the next state will be in S0.\n\talways @(*) begin // State transition logic based on input\n    \tcasez ({in, state}) \n        \t5'b0_???????: next_state = {state[8:0], 1'b0};// For all states except for S9, the next state is just to rotate left by one bit.\n         \t5'b1_{2'b00, 4'b???}: next_state = {state[7:0], 2'b00}; //For input 1 and states S0,S1,S2,S3, the next state is just to shift left two bits.\n         \t5'b1_{2'b01, 4'b???}: next_state = {state[7], ~state[9:1]}; //For input 1 and states S4,S5,S6,S7 the next state is to rotate right by one bit.\n         \tdefault: next_state = 10'hXXX;//if any other combinations are met, set next state as undefined (as per Verilog coding standard).\n        endcase\n    end \nendmodule\n\n"}
{"task_id": "fsm_onehot", "completion": "\n\n    assign next_state[0] = ~(in | state[1]);\n    assign next_state[1] =  (in ^ state[2]);\n    assign next_state[2] = ~(in | state[3]);\n    assign next_state[3] =  (in ^ state[4]);\n    assign next_state[4] = ~(in | state[5]);\n    assign next_state[5] =  (in ^ state[6]);\n    assign next_state[6] = ~(in | state[7]);\n    assign next_state[7] =  (in ^ state[8]);\n    assign next_state[8] =           state[9];\n    assign next_state[9] =     ~in &  state[0];\t\n    \n    // Outputs are determined by current state\n    assign out1 = |{state[6], state[5], state[3:2], state[1:0]};\n    assign out2 = ~(|(state[7:4]) ^ state[8]);\n\nendmodule\n\n"}
{"task_id": "fsm_onehot", "completion": "\n\n\tassign out1 = state[7]; // From S7 we always output 1.\n\tassign out2 = state[8]; // From S8 we always output 0.\n\t \n\t// Combinational logic for next_state derived from the given transitions.\n    assign next_state[0] = ~state[3]&~state[5]&in | (state[7])& ~in;\n\tassign next_state[1] = state[1]&(~state[2]&~state[6]& in| (state[4]^state[7]) & ~in);\n    assign next_state[2] = ~state[0]&state[5]& ~in | state[3] & ~state[4];\n\tassign next_state[3] = state[1]&( state[6]& in| (state[7]) & in);\n    assign next_state[4] = ~state[2]&~state[5]&in | (state[8]^state[9]) & ~in;\n\tassign next_state[5] = (state[0]| state[1])& ~state[7];\n\tassign next_state[6] = in ? state[4]: (~state[2]&~state[3]&in | state[5] & ~state[8]);\n\tassign next_state[7] = in ? state[3] : (state[0]|(state[1]^in)); \n\tassign next_state[8] = ~state[4]&~state[6]&~in | state[9] & ~in;\n    assign next_state[9] = state[5]& in |  (state[7]^state[9]) & in ;    \nendmodule \n"}
{"task_id": "fsm_onehot", "completion": "\n    assign out1 = state[7]; // From State S7 to State S0 and back depends on input in.\n  \tassign out2 = state[8]; // From State S8 to State S0 and back also depends on the input in.\n  \t\n  \t// One-hot encoding:\n  \t// (1) 10'b0000000001 corresponds to State S1,\n  \t// (2) 10'b0000000010 corresponds to State S2,\n  \t// (3) and so on...\n  \t\n  \talways @* begin\n    \tcase(state[9:0]) //Current state\n      \t\t10'b0000000001: next_state = in ? 10'b0000000010 : 10'b0000000001; \n      \t\t//State S1 transitions to State S2 when input is '1', otherwise stays in State S1.\n       \t\t10'b0000000010: next_state = in ? 10'b0000000100 : 10'b0000000010;\n        \t//State S2 transitions to State S3 when input is '1', otherwise stays in State S2.\n       \t\t10'b0000000100: next_state = in ? 10'b0000001000 : 10'b0000000100;\n        \t//And so on...\n      \t\tdefault: next_state = 10'b0000000000; //Default state for invalid/unknown states.\n    \tendcase\n  \tend \nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\n\t// Output Logic\n    assign out1 = |(state[7:5]); // S6 or S9 outputs 1 if current state is from S6 or S9 respectively.\n\tassign out2 = state[4]; // S5 output 2nd bit of the state (bit 3).\n    \n\t// State Transition Logic\n    assign next_state[0] = state[8] ^ in; // S0 transitions to S1 if input is 1, stays at S0 otherwise.\n\tassign next_state[9:1] = ~(state[7:0]) & ((state[8:0]^{in,1'b0}) | (state[8:0]^{1'b1, ~in})); // For other states except S0 and S9.\n\tassign next_state[9] = state[4] & in; // State S9 transitions to S1 if current state is from S5 and input is 1, stays at S0 otherwise.\n    \nendmodule\n\n"}
{"task_id": "fsm_onehot", "completion": "\n  always @(*) begin\n    casez({in,state[9:0]}) // One-hot decoding with a case statement.\n      4'b0???: next_state = {state[8:0],1'b0};\n      4'b1000: next_state = 10'h02; \n      4'b1001: next_state = 10'h03;\n      4'b101?: next_state = {state[8], state[9], state[7:0]};\n      4'b1100: next_state = 10'h05; \n      4'b1101: next_state = 10'h06;  \n      4'b1110: next_state = state[9] ? 10'h03 : 10'h07; // Output out2 set.\n      4'b1111: begin \n                 if (in) \n                   next_state = 10'h08; // No change in state, output out1 set.\n                 else\n                   next_state = state[9] ? 10'h05 : 10'h07; // Output out2 set.\n                end\n      default: next_state = 10'bxxxxxxx; // Invalid state (x).\n    endcase  \n    \n    casez(state)\n      10'b???0000000: out1 = 1'b0; // No output.\n      10'b??0?000000: out1 = 1'b0; // Output 2 set.\n      10'b??00?00000: out1 = 1'b0; // Output 2 and 3 set.\n      default:        out1 = in ? (state[4] ^ state[5]) : ~(state[6]); // Derived from above transitions.\n    endcase  \n    \n    casez({in,state}) // Another way to derive output 2 using one-hot decoding.\n      10'b0???: out2 = 1'b0; // No output.\n      10'b1?00: out2 = state[3];\n      default:  out2 = ~state[9] & state[8] | ~state[5] & state[4]; // Derived from transitions.\n    endcase  \nend\n"}
{"task_id": "fsm_onehot", "completion": "\n\tassign next_state[0] = ((~state[8]&state[4])|(state[7]^state[6]))^state[5];\n    assign next_state[1] = ~((in^state[3])&(state[2]^state[9]))|state[1];\n    assign next_state[2] = ((state[8]|state[4])&in)|state[0];\n\tassign out1= state[6] & (state[7] | in); \n    assign out2 = ~(state[9] | in ) ; \n    \n    genvar i; \n\tgenerate\n\t    for (i= 2 ; i< 8 ; i = i +1) begin : loop \n\t\t\tassign next_state[i+2]  = ((in^ state[(i-2)%7])&(~state[(i-1)%7]))|((state[(i-2)%7]&~in)&state[(i-1)%7]);  \n        end \n\tendgenerate\n       assign next_state[9] = (state[5]^(~in)) & state[8];   \n        \nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\n\n\tassign out1 = state[7]; // Out for S5 and S6 states.\n\tassign out2 = |(state & 10'b1111000000); // Out for all except S3, S4, and S5 states (when in == 1).\n\t \n\t// State Transition Logic:\n\talways @(*) begin\n\t\t\tcasez({in, state}) \n\t\t\t\t2'b00: next_state = state;\n                2'b01: next_state = 10'h5480; // From S0 to S1.\n                2'b10: next_state = ~(state[7] ? 10'h3C : 10'h600); // From S1 to S2 or S0 depending on the value of state[4].\n                2'b11: next_state = (state[7]) ? 10'h5D80 : 10'h2A8; // From S2 and S3 respectively to S4. If in == 1, else from S4 to S5.\n\t\t\tendcase\n\tend\n  \nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\n    \n\t// State transition logic \n    assign next_state[0] = (~in & ~state[4]) | (state[8]);\n    assign next_state[1] = in & state[3];\n    assign next_state[2] = state[5] ^ in;\n    assign next_state[3] = (~in & state[6]) | (state[0] & ~state[4]);\n    assign next_state[4] = ~(state[1] ^ in);\n    assign next_state[5] = (in & state[7]) | (state[8] & ~in);\n    assign next_state[6] = (~state[2] & in) | (state[9] & ~in);\n    assign next_state[7] = ~(state[3] ^ in);\n    assign next_state[8] = state[4];\n    assign next_state[9] = state[5];\n\t\n\t// Output logic \n    assign out1 = state[0] | state[2] | (state[6] & ~in) | (~state[7] & in);\n    assign out2 = (state[8] ^ in) | (state[9]);\n    \nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\nalways @* begin\n\tcasez( {state[9], state[8:5], in} ) \n\t\t4'b0??0 : next_state = 10'b0_0000_0001; // S0 to S0\n\t\t//... and so on, continue for all transitions\n\t\t4'b1111 : next_state = 10'b1_0000_0000; // S9 to S0\n\t\tdefault:  next_state=10'bx;  \n\tendcase\n\tcasez({state[9], state[8:5], in}) \n\t\t4'b0??0 : {out1, out2} = 2'b00; // S0 to S0\n\t\t//... and so on, continue for all states\n\t\t4'b1111 : {out1, out2} = 2'b10; // S9 to (0, 1)\n\t\tdefault:  {out1, out2}=2'bx;  \n\tendcase\nend\n"}
{"task_id": "fsm_onehot", "completion": "\n\tassign next_state = {\n\t  // S0 (0, 0) --0--> S0\n\t  ~state[8],\n\t  \n\t  // S0 (0, 0) --1--> S1\n\t  state[9] & ~in,\n\t  \n\t  // S1 (0, 0) --0--> S0\n\t  ~state[7],\n\t  \n\t  // S1 (0, 0) --1--> S2\n\t  state[8] & ~in,\n\t  \n\t  // S2 (0, 0) --0--> S0\n\t  ~state[6],\n\t  \n\t  // S2 (0, 0) --1--> S3\n\t  state[7] & ~in,\n\t  \n\t  // S3 (0, 0) --0--> S0\n\t  ~state[5],\n\t  \n\t  // S3 (0, 0) --1--> S4\n\t  state[6] & ~in,\n\t  \n\t  // S4 (0, 0) --0--> S0\n\t  ~state[4],\n\t  \n\t  // S4 (0, 0) --1--> S5\n\t  state[5] & ~in,\n\t  \n\t  // S5 (0, 0) --0--> S8\n\t  ~state[3],\n\t  \n\t  // S5 (0, 0) --1--> S6\n\t  state[4] & ~in,\n\t  \n\t  // S6 (0, 0) --0--> S9\n\t  ~state[2],\n\t  \n\t  // S6 (0, 0) --1--> S7\n\t  state[3] & ~in,\n\t  \n\t  // S7 (0, 1) --0--> S0\n\t  ~state[1],\n\t  \n\t  // S7 (0, 1) --1--> S7\n\t  state[2] & in,\n\t  \n\t  // S8 (1, 0) --0--> S0\n\t  ~state[0],\n\t  \n\t  // S8 (1, 0) --1--> S1\n\t  state[3] & in,\n\t  \n\t  // S9 (1, 1) --0--> S0\n\t  ~in,\n\t  \n\t  // S9 (1, 1) --1--> S1\n\t  state[1] & in};\n\n\t// Outputs\n\tassign out1 = |{state[2],state[5]};\n\tassign out2 = ~|{state[0:7],state[9]};\n"}
{"task_id": "fsm_onehot", "completion": "\n\tassign next_state = \n\t\t(state[5] && !in) ? 10'b0000010000 :\t// S5 to S8 when in == 0\n\t\t(state[6] && in) ? 10'b0000000010 :\t// S6 to S9 when in == 1\n\t\t(state[7]) ? 10'b0000000000 :\t\t\t// S7 remains as is on every state\n\t\t(state[3] && !in) ? 10'b0000000001 :\t// S3 to S4 when in == 0\n\t\t(state[4] && in ) ? 10'b0000001000 :\t// S4 to S5 when in == 1\n\t\t(state[0]) ? 10'b0000000001 :\t\t\t// S0 to S1 on every state\n\t\t(state[8] && !in) ? 10'b0000100000 :\t// S8 to S0 when in == 0\n\t\t(state[9]) ? 10'b0000010000 :\t\t\t// S9 to S5 on every state\n\t\t(state[2] && !in) ? 10'b0000000100 :\t// S2 to S3 when in == 0\n\t\t(state[1]) ? 10'b0000000010 :\t\t\t// S1 to S2 on every state\n\t\t\t      state;\t\t\t\t\t\t// No change for all other states\n    \n\tassign out1 = (state==7) & in | (state==8);   // For states 7 and 8, if input is '1', output '1' else '0'.\n\tassign out2 = ~state[9];                       // Output '0' when current state is S5 or S6, otherwise '1'.\n"}
{"task_id": "fsm_onehot", "completion": "\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t10'b0000000001: next_state = in ? 10'b0000000010 : state; // S0 -> S1 if in = 1, else stay at S0\n\t\t\t10'b0000000010: next_state = in ? 10'b0000000100 : state; // S1 -> S2 if in = 1, else stay at S1\n\t\t\t10'b0000000100: next_state = in ? 10'b0000001000 : state; // S2 -> S3 if in = 1, else stay at S2\n\t\t\t10'b0000001000: next_state = in ? 10'b0000010000 : state; // S3 -> S4 if in = 1, else stay at S3\n\t\t\t10'b0000010000: next_state = in ? 10'b0000100000 : state; // S4 -> S5 if in = 1, else stay at S4\n\t\t\t10'b0000100000: next_state = in ? 10'b0001000000 : 10'b0000000001; // S5 -> S6 if in = 0, else stay at S8\n\t\t\t10'b0001000000: next_state = in ? 10'b0010000000 : state; // S6 -> S7 if in = 1, else stay at S9\n\t\t\t10'b0010000000: next_state = in ? state : 10'b0000000001; // S7 -> S8 if in = 0, else stay at S0\n\t\t\t10'b0100000000: next_state = in ? 10'b0000000001 : state; // S8 -> S9 if in = 1, else stay at S1\n\t\t\t10'b0000000001: next_state = in ? state : 10'b0100000000; // S9 -> S10 if in = 0, else stay at S0\n\t\t\tdefault: next_state = 10'b0000000001; // default to start state if no matching condition\n\t\tendcase \n\tend\n    \n\t// Output logic\n\tassign out1 = (next_state == 10'b0000000001 || next_state == 10'b0100000000) ? 0 : 1; //out1 is zero when in S0 or S9, one otherwise\n\tassign out2 = (next_state[8] == 1) ? 1 : 0; //output 2 corresponds to the third bit from right of the next state\n"}
{"task_id": "fsm_onehot", "completion": "\n    assign next_state[0] = (~in & ~state[5]) | (~in & state[4]) | (in & state[3]);\n\tassign next_state[1] = ~in & state[8];\n\tassign next_state[2] = in & ~state[7];\n\tassign next_state[3] = in & state[6];\n\tassign next_state[4] = (~in & state[2]) | (in & state[1]);\n\tassign next_state[5] = (~in & state[9]) | (in & ~state[0]);\n\tassign next_state[6] = ~in & state[7];\n\tassign next_state[7] = in & ~state[6];\n\tassign next_state[8] = in & state[1];\n\tassign next_state[9] = (~in & state[0]) | (in & state[5]);\n\t\n\tassign out1 = ~(state[3] | state[4] | state[6] | (state[7] & ~state[8]));\n\tassign out2 = ~((state[0] & in) | state[9]);\n"}
{"task_id": "fsm_onehot", "completion": "\n   // Derive the logic equations by inspection assuming a one-hot encoding.\n    always @(*) begin\n        if (state[5]) begin  // S6 and S7 have outputs that are constant -> 0\n            next_state = 10'b0; out1 = in; out2 = ~in;\n        end else if (state[4] || state[9]) begin // S5 to S8 and S0 have the same next states -> S1\n            next_state = {state[3:0], 4'b0, ~state[7:4]}; out1 = ~in; out2 = in;\n        end else if (state[3]) begin // S4 is a special state that changes to S8 with input 0 -> S0\n            next_state = {4'b0, ~state[6], 5'b0}; out1 = ~in; out2 = ~in;\n        end else if (state[2:1] == 2'b10 || state[8]) begin // S3 to S9 and S0 have the same next states -> S0\n            next_state = {5'b0, ~state[7], 4'b0}; out1 = ~in; out2 = ~in;\n        end else if (state[2:1] == 2'b01) begin // S2 is a special state that changes to S6 with input 1 -> S8\n            next_state = {3'b0, ~state[5], 6'b0}; out1 = ~in; out2 = in;\n        end else if (state[1]) begin // Special case: S1 is a final state that doesn't transition with input -> stays at S1\n            next_state = state; out1 = ~in; out2 = ~in;\n        end else begin // The initial and the only other possibility, all states 0 to 4 are valid start points. Outputs for those states remain 0 as they aren't described in transitions above.\n            next_state = {8'b0, ~state[9], 1'b0}; out1 = ~in; out2 = ~in; // S0 and others to S0 with input 0\n        end\n    end\nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\n\talways @(*) begin\n\t\t//default outputs\n\t\tout1 = 0;  //initialize to zero\n\t\tout2 = 0;  //initialize to zero\n\t\t\n        case (state)\n            10'b_0000000001: next_state = in ? 10'b_0000000011 : 10'b_0000000001; // S0 ->  (if in==0)S0 else S1\n            10'b_0000000010: next_state = in ? 10'b_0000000100 : 10'b_0000000010; // S1 ->  (if in==0)S2 else S1\n            10'b_0000000100: next_state = in ? 10'b_0000001000 : 10'b_0000000100; // S2 ->  (if in==0)S3 else S2\n            10'b_0000001000: next_state = in ? 10'b_0000010000 : 10'b_0000001000; // S3 ->  (if in==0)S4 else S3\n            10'b_0000010000: next_state = in ? 10'b_0000100000 : 10'b_0000010000; // S4 ->  (if in==0)S5 else S4\n            10'b_0000100000: next_state = in ? 10'b_0001000000 : 10'b_0000100000; // S5 ->  (if in==0)S6 else S5\n            10'b_0001000000: next_state = in ? 10'b_0010000000 : 10'b_0001000000; // S6 ->  (if in==0)S7 else S6\n            10'b_0010000000: next_state = in ? 10'b_0100000000 : 10'b_0010000000; // S7 ->  (if in==0)S8 else S7, and set out2 to 1\n            10'b_0100000000: next_state = in ? 10'b_0000000001 : 10'b_0100000000; // S8 ->  (if in==1)S9 else reset to S0\n            10'b_0100000001: next_state = in ? 10'b_0100000001 : 10'b_0100000000; // S9 ->  (if in==0)S9 else reset to S1\n            default         : next_state = 10'b_0000000000;                           // Catch-all, so that if an undefined state is encountered the machine will reset\n        endcase\n\t\t\n\t\t//determine output states from current one-hot encoded state\n\t\tcase (state)\n            10'b_0000000001: out2 = 0; // S0 -> Out2 = 0\n\t\t\t10'b_0000000010, 10'b_0000000100, 10'b_0000001000, 10'b_0000010000, // S1 -> S2 -> S3 -> S4 -> Out2 = 0\n            10'b_0000010001: out2 = 1; // S5 -> Out2 = 1"}
{"task_id": "fsm_onehot", "completion": "\n\tassign out1 = (state[5]) ? 1'b1 : 1'b0; // For states S7 only.\n\tassign out2 = state[8]; // Always for any state other than S0, S4 and S9.\n\t\n\t// The following are the transition logic:\n\tassign next_state[0] = ~(state[3]) & in | (state[5] & ~in); \n\tassign next_state[1] = state[2] & in;\n\tassign next_state[2] = (state[4] ^ in) & ~state[5];\n\tassign next_state[3] = ~(state[7]) & in | (state[0] & ~in);\n\tassign next_state[4] = state[1] & in;\n\tassign next_state[5] = (state[6] ^ in) & state[8];\n\tassign next_state[6] = ~(state[9]) & in | (state[3] & ~in); \n\tassign next_state[7] = state[4] & in;\n\tassign next_state[8] = (state[5] ^ in) & ~state[0];\n\tassign next_state[9] = ~(state[2]) & in | (state[6] & ~in); \nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\n\talways @(*) begin\n    \tcasexz ({in, state})  // Using one-hot encoding for state and input.\n        \t10'b0_???????: next_state = 7'b1_______; out1=0;out2=0;//S0 to S0\n            10'b1_?0????: next_state = 7'b?1______; out1=0;out2=0;//S0 to S1\n            10'b1_?0??1?: next_state = 7'b?1_____;  out1=0;out2=0; //S0 to S3\n            // Complete the remaining cases...\n        endcase\n\tend\n"}
{"task_id": "fsm_onehot", "completion": "\n\t// State transition logic\n\tassign next_state = state == 10'b00_0000_0000 ? 10'b00_0000_0001 :\n\t\t\t\t\t\t\t\t\t   state == 10'b00_0000_0001 ? 10'b00_0000_0010 :\n\t\t\t\t\t\t\t\t\t\tstate == 10'b00_0000_0010 ? (in ? 10'b00_0000_0000 : 10'b00_0000_0100) :\n\t\t\t\t\t\t\t\t\t   state == 10'b00_0000_0100 ? 10'b00_0000_1000 :\n\t\t\t\t\t\t\t\t\t\tstate == 10'b00_0000_1000 ? (in ? 10'b00_0000_0001 : 10'b00_0001_0000) :\n\t\t\t\t\t\t\t\t\t   state == 10'b00_0001_0000 ? 10'b00_0010_0000 :\n\t\t\t\t\t\t\t\t\t\tstate == 10'b00_0010_0000 ? (in ? 10'b00_0000_0010 : 10'b00_0100_0000) :\n\t\t\t\t\t\t\t\t\t   state == 10'b00_0100_0000 ? 10'b00_1000_0000 :\n\t\t\t\t\t\t\t\t\t\tstate == 10'b00_1000_0000 ? (in ? 10'b00_0000_0100 : 10'b10_0000_0000) :\n\t\t\t\t\t\t\t\t\t   state == 10'b10_0000_0000 ? 10'b00_0000_0000 :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  10'b10_0000_0000; // Stay in S9 for input 1\n\t// Output logic\n\tassign out1 = state[8]; // Out1 is set to the value of State[8] (the eighth bit)\n\tassign out2 = state[9]; // Out2 is set to the value of State[9] (the ninth bit)\nendmodule\n"}
{"task_id": "conditional", "completion": "\n\t// Comparisons are made in order. As soon as a smaller number is found, it is assigned to the 'min' variable and no more comparisons are done with that number due to its being already smaller than any other numbers present later in sequence of comparison. \n\talways @* begin\n\t\tif (a < b && a < c && a < d) min = a;\n\t\telse if(b < a && b < c && b < d) min = b;\n\t\telse if(c < a && c < b && c < d) min = c;\n\t\telse min = d;\n\tend\nendmodule\n\n"}
{"task_id": "conditional", "completion": "\n    \n    always @* begin \n        if((a<b) && (a<c) && (a<d))\n            min = a;\n        else if((b<a) && (b<c) && (b<d))\n            min = b;\n        else if((c<a) && (c<b) && (c<d))\n            min = c;\n        else \n            min = d;\n    end  \nendmodule\n\n"}
{"task_id": "conditional", "completion": "\n\n\talways @* begin\n\t\t\tif(a<b && a<c && a<d) \n\t\t\t\tmin = a;\n\t\t\telse if(b<a && b<c && b<d) \n\t\t\t\tmin = b;\n\t\t\telse if(c<a && c<b && c<d)\n\t\t\t\tmin = c;\n\t\t\telse min = d;\n    end\nendmodule\n"}
{"task_id": "conditional", "completion": "\nbegin\n    if(a < b && a < c && a < d) \n    \tmin = a;\n    else if (b < a && b < c && b < d)\n        min = b;\n\telse if (c < a && c < b && c < d)\n\t    min = c;\n    else\n\t    min = d;\nend\n"}
{"task_id": "conditional", "completion": "\nalways @* begin\n\tif (a < b && a < c && a < d) \n\t\tmin = a;\n\telse if (b < a && b < c && b < d)\n\t\tmin = b;\n\telse if (c < a && c < b && c < d)\n\t\tmin = c;\n\telse min = d;\nend\n\n"}
{"task_id": "conditional", "completion": "\n  \n\t//Comparing numbers using less than or equal to operator. \n\talways @* begin\n\t  if ((a <= b) && (a <= c) && (a <= d)) \n\t\t    min = a;\n\t\telse if ((b <= a) && (b <= c) && (b <= d)) \n\t\t\t min = b;\n\t\telse if ((c <= a) && (c <= b) && (c <= d))\n        min = c;\n\t  else \n\t\t    min = d;   //d is guaranteed to be the smallest.\n\tend \nendmodule\n"}
{"task_id": "conditional", "completion": "\n    always @* begin\n        if(a < b && a < c && a < d)\n            min = a;\n        else if(b < a && b < c && b < d) \n            min = b;\n        else if(c < a && c < b && c < d) \n            min = c;\n        else \n            min = d;    // d is the minimum.\n    end\nendmodule\n"}
{"task_id": "conditional", "completion": "\n\talways @* begin\n\t\t\tif((a < b) && (a < c) && (a < d)) \n\t\t\t\tmin = a;\n\t\t\telse if ((b < a) && (b < c) && (b < d)) \n\t\t\t\tmin = b;\n\t\t\telse if ((c < a) && (c < b) && (c < d)) \n\t\t\t\tmin = c;\n\t\t\telse min = d;\n    end\nendmodule\n"}
{"task_id": "conditional", "completion": "\nalways @* begin\n\tif (a < b && a < c && a < d) \n\t\tmin = a;\n\telse if (b < a && b < c && b < d) \n\t\tmin = b;\n\telse if (c < a && c < b && c < d) \n\t\tmin = c;\n\telse min = d; // D is the smallest.\nend\nendmodule\n"}
{"task_id": "conditional", "completion": "\n   always @* begin\n       if (a < b && a < c && a < d) \n           min = a;\n        else if(b < c && b < d) \n            min = b;\n        else if (c < d) \n            min = c;\n        else \n            min = d;\n   end   \nendmodule\n"}
{"task_id": "conditional", "completion": "\nalways @* begin\n\tif(a < b && a < c && a < d) \n\t\tmin = a;\n\telse if (b < c && b < d)\n\t\tmin = b;\n\telse if (c < d)\n\t\tmin = c;\n\telse \n\t\tmin = d;\nend\n"}
{"task_id": "conditional", "completion": "\n\talways @* begin\n\t\tif((a<b)&&(a<c)&&(a<d)) \n\t\t\tmin = a;\n\t\telse if ((b<a)&&(b<c)&&(b<d))  \n\t\t\tmin = b;\n\t\telse if ((c<a)&&(c<b)&&(c<d)) \n\t\t\tmin = c;\n\t\telse min = d;\n\tend\n\nendmodule\n"}
{"task_id": "conditional", "completion": "\n\t// Comparing each value with others.\n\talways @(*) begin\n\t\t\tif ((a < b) && (a < c) && (a < d)) \n\t\t\t\tmin = a;\n\t\t\telse if ((b < a) && (b < c) && (b < d))  \n\t\t\t\tmin = b;\n\t\t\telse if ((c < a) && (c < b) && (c < d))  \n\t\t\t\tmin = c;\n\t\t\telse \n\t\t\t\tmin = d;    // If none of them are minimum.\n\tend\n\nendmodule\n"}
{"task_id": "conditional", "completion": "\nalways @* begin\n\tif (a < b && a < c && a < d)\n\t\tmin = a;\n\telse if (b < a && b < c && b < d)\n\t\tmin = b;\n\telse if (c < a && c < b && c < d)\n\t\tmin = c;\n\telse \n\t\tmin = d;\nend\n\t\nendmodule\n"}
{"task_id": "conditional", "completion": "\n\n\talways @* begin\n\t\tif (a < b && a < c && a < d) \n\t\t\tmin = a;\n\t\telse if (b < c && b < d) \n\t\t\tmin = b;\n\t\telse if (c < d) \n\t\t\tmin = c;\n\t\telse \n\t\t\tmin = d;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "conditional", "completion": "\nalways @* begin\n\tif((a < b) && (a < c) && (a < d))\n\t\tmin = a;\n\telse if ((b < c) && (b < d))\n\t\tmin = b;\n\telse if(c < d)\n\t\tmin = c;\n\telse \n\t\tmin = d;\nend\n\n"}
{"task_id": "conditional", "completion": "\nalways @* begin\n\tif (a < b && a < c && a < d) \n\t\tmin = a;\n\telse if (b < a && b < c && b < d) \n\t\tmin = b;\n\telse if (c < a && c < b && c < d) \n\t\tmin = c;\n\telse \n\t\tmin = d;\nend\n"}
{"task_id": "conditional", "completion": "\n\talways @* begin\n\t    if ((a < b) && (a < c) && (a < d)) \n            min = a;\n        else if ((b < a) && (b < c) && (b < d))\n            min = b;\n        else if ((c < a) && (c < b) && (c < d))\n            min = c;\n        else\n            min = d;        \t\n    end \nendmodule\n"}
{"task_id": "conditional", "completion": "\n\talways @* begin\n\t\tif(a<b && a<c && a<d)\n\t\t\tmin = a;\n\t\telse if(b<a && b<c && b<d)\n\t\t\tmin = b;\n\t\telse if (c<a && c<b && c<d)\n\t\t\tmin = c;\n\t\telse \n\t\t\tmin = d;\n\tend\nendmodule\n"}
{"task_id": "conditional", "completion": "\nbegin\n\tmin = a;\n\tif (b < min)\n\t\tmin = b;\n\tif (c < min)\n\t\tmin = c;\n\tif (d < min)\n\t\tmin = d;\nend\nendmodule \n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in;\n\tassign out_or  = |in;\n\tassign out_xor = ^in;\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n     assign out_and = &in; \n     assign out_or  = |in;  \n     assign out_xor = ^in;   \nendmodule\n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in; // Logical AND operation with all inputs.\n\tassign out_or  = |in; // Logical OR operation with all inputs.\n\tassign out_xor = ^in; // Exclusive OR operation with all inputs.\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n     assign out_and = &in; \n     assign out_or  = |in;  \n     assign out_xor = ^in;   \nendmodule\n"}
{"task_id": "gates4", "completion": "\n    \n    assign out_and = &in; //AND Gate\n    assign out_or  = |in;  //OR Gate\n    assign out_xor = ^in; //XOR Gate\n    \nendmodule\n"}
{"task_id": "gates4", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n"}
{"task_id": "gates4", "completion": "\n    \n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\n  \nendmodule \n\n"}
{"task_id": "gates4", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n"}
{"task_id": "gates4", "completion": "\n    \n    assign out_and = &in; // AND gate. If all inputs are 1, outputs a high signal.\n    assign out_or = ~^in;// OR gate. If any of the input is high(1), output is high.\n\tassign out_xor = ^in; // XOR gate. Number of high signals in the inputs must be even or odd to get a high output signal.\nendmodule \n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in;\n\tassign out_or  = |in;\n\tassign out_xor = ^in;\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or  = |in;\n\tassign out_xor = ^in;\n  \nendmodule \n\n"}
{"task_id": "gates4", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or  = |in;\n\tassign out_xor = ^in; \nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in;\n\tassign out_or = ^in;\n\tassign out_xor = ~(out_and ^ out_or); // XOR of AND and OR operation.\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n   assign out_and = &in;  // '&' is AND gate for n-bits.\n\tassign out_or  = |in;\t// '|' is OR gate for n-bits.\n\tassign out_xor = ^in;\t// '^' is XOR gate for n-bits.\n\t\nendmodule\n\n"}
{"task_id": "gates4", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule \n\n"}
{"task_id": "gates4", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = ~out_and; //since out_and is equivalent to the 4-input AND gate. The complement of a logic variable (equivalent to logical NOT) can be used for the OR operation in this case since OR(A,B) = !(!A && !B).\n\tassign out_xor = ~(out_and ^ out_or); //since XOR(A,B) is equivalent to AND(!A || !B), so taking complement of it would be equivalent to AND(A&&B). Again since these are boolean operations, the final result will also have a boolean interpretation.\n\t\nendmodule \n\n"}
{"task_id": "gates4", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n\n"}
{"task_id": "review2015_fancytimer", "completion": "\nreg[11:0] pattern;  // store the incoming bits\nreg[3:0] delay;     // to hold the delay value\nreg start_timer;   // flag indicating if timer starts\nwire [3:0] count_next,count_curr;    // for counter\n\t\n\t//detecting '1101' pattern \n\talways @(posedge clk or posedge reset) begin\n    \tif (reset)\n        \tpattern <= 12'b0;\n    \telse if ((~start_timer) & data & (~pattern[3]))  \n        \tpattern <= {data, pattern[11:1]};  // shift in the bit and drop oldest one\n       else if(start_timer && ack )\n\t\t    start_timer <= 0;     // reset after ack is received\n     \telse if((~counting)&& (pattern==12'hE))  \n         \tstart_timer <= 1;  //start timer when '1101' pattern found\n\tend\n\n\t//extracting delay value from the last four bits of incoming data after detecting '1101'\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset)\n        \tdelay <= 4'b0;\n    \telse if ((~start_timer)&data & pattern[3])  \n       \t\tdelay <= {data, delay[3:1]};  //shift in the bit and drop oldest one\n       else if(start_timer && ack )\n\t\t    start_timer <= 0;      //reset after ack is received\n\tend\n    \n\t//counter implementation  \n\talways @(posedge clk or posedge reset) begin\n       \tif (reset) begin \n            count <= 4'b0;\n            counting <= 1'b0;\n         end\n      \telse if(start_timer==1 )begin\n          \tcount <= delay+1;    //load counter with delay + 1  \n             counting <= 1'b1;     // start counting\n       \tend \n       else if (counting) begin \n            count <= count - 4'd1;  // decrement the count value by 1 every clock cycle \n           \tif(count==0 )begin      // if counter is zero, then stop counting\n                 counting <= 1'b0;    // stop counting\n                 done<=1;              // notify user that timer has timed out\n         \tend  \n       end  \n     end\nendmodule \n"}
{"task_id": "review2015_fancytimer", "completion": "\nreg [15:0] shift_register;\nwire start = (shift_register[12:8] == 5'b11010); // 11010 because we are shifting in one more bit at the time.\nwire [3:0] delay;\nassign delay = {shift_register[7], shift_register[6], shift_register[5], shift_register[4]};\nreg [3:0] counter = 4'b0;\nreg counting_enable;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        done <= 1'b0;\n        counting <= 1'b0;\n        shift_register <= 16'b0;\n        counter <= 4'b0;\n        counting_enable <= 1'b0;\n    end\n    else begin\n        shift_register <= {shift_register[14:0], data}; // Shift in new bit.\n        if (start && !counting) begin  // Start the timer when we find the start pattern.\n            done <= 1'b0;\n            counting <= 1'b1;\n            counter <= delay;           // Set countdown to delay + 1 as per requirement.\n            counting_enable <= 1'b1;    // Enable the counter.\n        end else if (ack && counting) begin  // If acknowledgement is given before timer completes, stop it and wait for next start sequence.\n            done <= 1'b0;               \n            counting <= 1'b0;\n            counter <= delay;           // Set countdown to delay as per requirement once again after ack.\n        end else if (counting && counting_enable) begin  // If we have not received an acknowledgement yet, decrement the counter and when it reaches zero, notify completion.\n            counter <= counter - 4'b0001;\n            if (counter == 4'b0) begin\n                done <= 1'b1;\n                counting <= 1'b0;\n                counting_enable <= 1'b0; // Disable the counter so that it doesn't count while waiting for acknowledgement. \n            end\n        end \n    end\nend\nassign count = (counting) ? counter : {4{1'bx}}; // If not counting, don't care value is assigned to count.\nendmodule\n"}
{"task_id": "review2015_fancytimer", "completion": "\n    reg [3:0] delay;\n    reg [1599:0] shift_reg; // 2^16-1 = 16 bit\n    \n\talways @(posedge clk or posedge reset) begin\n\t    if (reset == 1'b1) begin\n\t        counting <= 1'b0;\n            done     <= 1'b0;\n            delay    <= 4'h0;  // Initialize to zero.\n        end else begin\n\t\t    shift_reg <= {shift_reg[1598:0], data}; // Shift in serial input bit.\n\t        \n\t        if (~counting) begin\n    \t        if ((shift_reg[16-1:4] == 12'hD0) && (data==1'b1)) begin  // Detect '11010', the start sequence.\n\t\t            delay   <= shift_reg[3:0];   // Load delay bits from serial input into timer register.\n    \t        \tcounting <= 1'b1;  // Set counting flag.\n                end\n\t        end else begin\n\t\t        if (&{4{delay}}) begin\n\t\t\t        counting <= 1'b0;    // Reset the count after delay is done\n                    done     <= 1'b1;    \n\t        \t    if (ack) \n                        done <= 1'b0;       // Wait for ACK to be high before resuming searching.\n\t\t        end else begin  \n\t\t\t        delay <= delay - 1'd1;\n\t\t        end   \n\t        end\n        end\n    end\n    \n\tassign count = (counting) ? delay : 4'h0; // if counting is active then display the remaining delay otherwise don\u2019t care.\nendmodule\n"}
{"task_id": "review2015_fancytimer", "completion": "\n   // define states of the FSM\n    localparam START = 4'b1101;  // Start sequence\n\tlocalparam COUNTING = 4'hX;  // Counting state\n\t\n\treg [3:0] delay, next_delay;\n\treg [2:0] count_clk;   // clock counter for one cycle of counting\n    reg [1:0] currState,nextState;\n    \n    parameter START_STATE = 2'b00, COUNT_STATE = 2'b01, WAIT_STATE = 2'b10, DONE_STATE = 2'b11;\n\t\n\t// state transition logic\n\talways @(posedge clk or posedge reset)  begin\n        if (reset == 1'h1)   // reset synchronously active high\n            currState <= START_STATE;\n        else \n            currState <= nextState;\n    end\n    \n    always @(*) begin\n        case(currState)\n           START_STATE: if (data == 1'b1)   // start counting when input is '1'\n                             nextState = COUNT_STATE;\n                         else \n                             nextState = START_STATE;\n                         \n           COUNT_STATE: if (count_clk == delay[2:0]) // if count clock matches delay, move to done state\n                            nextState = DONE_STATE;\n                        else \n                            nextState = COUNT_STATE;  \n                      \n           DONE_STATE: if(ack == 1'b1)   // wait for ack before transitioning back to start state\n                          nextState = START_STATE;\n                      else \n                          nextState = WAIT_STATE;     \n                            \n           WAIT_STATE: nextState = COUNT_STATE;     // return to counting state after acknowledgement\n                      \n         endcase\n    end\n\t\n\t// delay input logic\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'h1) \n            delay <= 4'b0;\n       else if (currState == COUNT_STATE || currState== START_STATE ) // latch delay on start state and counting state\n           delay <= {data,delay[3:1]}; \n    end\n\t\n\t// count output logic\n\talways @(posedge clk or posedge reset) begin\n        if (reset == 1'h1)  \n            count_clk <= 3'b0; // clock counter for one cycle of counting\n         else if (currState == COUNT_STATE ) \n             count_clk <= count_clk + 1;\n    end\n\t\n\t// other output logic\n\tassign count = (count_clk >= delay[2:0]) ? (delay[3:0] - count_clk) : {4{1'bz}}; // remaining time to display \n\tassign counting =  (currState== COUNT_STATE)? 1'h1:1'h0 ; // output if timer is counting or not\n    assign done = ((currState == DONE_STATE )||(currState == WAIT_STATE))? 1'h1 : 1'h0;   // output when countdown complete and waiting for ack\n\t\nendmodule\n"}
{"task_id": "review2015_fancytimer", "completion": "\nlocalparam IDLE = 2'b01; // State for idle\nlocalparam SEARCH_START = 2'b10; // State for searching the start pattern 1101\nlocalparam COUNTING = 2'b11; // State for counting cycles\nwire [3:0] delay;\nreg [3:0] counter;\nreg [1:0] state = IDLE;\nreg [179:0] shift_register; // Used to store 8 bit of serial data from the input\n\n// Synchronous reset\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= IDLE;\n        counter <= 4'b0;\n        done <= 1'b0;\n\tcounting <= 1'b0;\n    end else begin\n\tcase (state) \n\t    IDLE: begin // Wait for the start sequence 1101\n\t        if(shift_register[7:0] == 8'hD3) begin\n\t\t    delay <= shift_register[15:12];\n\t\t    state <= COUNTING;\n\t\t    done <= 1'b0;\n\t\t    counting <= 1'b1;\n\t\tend \n\t    end\n    \t    COUNTING: begin // Count for the number of cycles determined by the delay\n\t        if(counter == 4'(delay) + 1 )begin \n\t\t    counter <= 4'b0;\n\t\t    state <= IDLE;\n\t\t    done <= 1'b1;\n\t\t    counting <= 1'b0;\n\t\tend else begin\n\t\t    counter <= counter + 1;\n\t        end  \n\t    end\n        default : ; // Do nothing, keep the current state \n       endcase\n    end \nend\n// Shift register for incoming serial data\nalways @(posedge clk) shift_register <= {shift_register[178:0],data};\n\t  \nassign count = done ? delay - counter + 4'b1 : counter; // Count display \n"}
{"task_id": "review2015_fancytimer", "completion": " \n\treg [3:0] delay;\n\treg [13:0] counter = 0; // clock cycles are divided into 4 bits so we can count to 2^14-1\n\tlocalparam PATTERN=14'b11010000_0000; // 1101 followed by 4 zeroes\n\treg [13:0] currentState = 0;\n\twire patternFound = (currentState[13:0] == PATTERN[13:0]);\n\t\t\n    assign count = counter[13:10]; // 4 bits of counter output\n    \n\talways @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin // reset synchronous to avoid metastability problem\n            currentState <= 0;\n\t\t    counting <= 1'b0;\n\t\t    done <= 1'b0;\n\t        counter <= 0;\n\t    end else begin\n           currentState <= {data, currentState[13:1]}; // shift in new bit\n\t       if (patternFound && ~counting) begin  // start counting when pattern found\n               delay <= currentState[9:6];  \n\t\t       counter <= 0;    \n\t\t       counting <= 1'b1;   \n           end else if(~ack && done && counting ) begin // stop counting and signal done if ack is not asserted\n\t             counting<=1'b0;\n\t\t        done<=1'b1;\n            end  else if (counter[13]==1'b0 && counting) begin// increment counter every clock cycle as long as it doesn't overflow\n                counter <= counter+1'b1;\n\t           end   \n\t       if(ack && done )begin // reset when ack is asserted and timer has timed out \n\t\t         currentState <= 0;\n\t\t\t     counting<=1'b0;\n\t\t\t     done<=1'b0;\n                counter <= 0;       \n            end  \n\t       if(counter==({~delay[3:0],4'hf}+1))begin // reset everything when delay has been reached \n                 currentState <= 0;   \n\t\t         counting<=1'b0;\n\t\t         done<=1'b0;    \n                 counter <=0;  \n\t       end       \n        end\n    end\nendmodule\n"}
{"task_id": "review2015_fancytimer", "completion": "\nwire [3:0] delay;\nreg [12:0] counter;\nreg [1:0] state = 0;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) begin\n\t\tstate <= 0;\n        counting <= 0;\n        done <= 0;\n\tend else case (state) \n\t\t2'h0: if (data == 1'b1) state <= 2'h1;\n        2'h1: if (data == 1'b1) begin\n            delay[3] <= data; // MSB first\n            state <= 2'h2;\n        end else state <= 2'h0;\n        2'h2: begin\n\t\t\tdelay[2:0] <= {delay[3], data}; \n            state <= 2'h3;\n        end\n        2'h3: if (data == 1'b0) begin\n            counter <= 4'd1 * delay + 13'd1000; // +1 to take into account the clock cycle when reaching zero\n\t\t\tcounting <= 1'b1;\n            state <= 2'h4;\n        end else begin \n            state <= 2'h0;\n            done <= 0;\n        end  \n        2'h4: if (counter > 0) begin \n            count <= counter[12:9];\n\t\t\tcounter <= counter - 13'd1; // Decrement the counter\n        end else begin \n            counting <= 0;\n\t\t\tdone <= 1'b1;\n            state <= 2'h5;\n        end  \n        2'h5: if (ack == 1'b1) state <= 2'h0;  // wait for ack before resetting\n    endcase\nend\n"}
{"task_id": "review2015_fancytimer", "completion": "\n\treg [1599:0] pattern; // store the received bits \n\treg [3:0] delay;       // delay counter\n\treg [3:0] count_temp;  // count temporary variable\n\tparameter PATTERN = 16'b1101;\n\tparameter MAXDELAY = 4'd15; // maximum possible delay value\n\t\t\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) begin\n\t        pattern <= 0; \n            counting <= 0;   \n            count <= 0;       \n            done <= 0;         \n            delay <= 4'b0;     \n            count_temp <= 4'd15;  \n       end else if(data === 1 && pattern[1600] === 0) begin // start receiving bits \n\t        pattern <= {data, pattern[1599:0]};          \n\t    end else if (pattern === PATTERN) begin    // pattern detected\n            counting <= 1;                        \n            delay <= pattern[3:0];                \n      \tend else if(counting && ack === 1'b1) begin  // acknowledge received\n\t        done <= 0;                               \n    \t    counting <= 0;                            \n\t        delay <= 4'd0;                             \n         end else if (counting) begin                 \n            count_temp <= delay + 1;                   \n        end else if(done && ack === 1'b1) begin // timer timed out \n           done <= 0;                              \n\t\t     pattern[1600:4] <= 0;                  \n         end\n\tend\n\t\n\t// assign count = (counting) ? delay - count_temp + 1 : 'z;\n    always @(*) begin\n        if(counting && ack === 1'b0)\n            count <= count_temp;  // when counting is enable and acknowledge has not been received, show the current time left.\n        else if (done === 1'b1)\n        \tcount <= 4'd0;   // once timer timed out or done with its function, display '0'. \n\t   \telse \n\t\t    count <= 'z;      // idle state when nothing is happening\n\tend\n\nendmodule\n\n"}
{"task_id": "review2015_fancytimer", "completion": "\n\treg[1599:0] timer; // 1600 bit register to store the entire duration of the timer delay.\n\treg [3:0] delay;\n\tinteger i;\n\tparameter START_PATTERN = 16'h2D0; // Hex value for 1101 in binary\n\t\t\n\talways @(posedge clk or posedge reset) begin\n        if (reset == 1) begin\n            timer <= 1600'd0;\n            delay <= 4'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end \n\t\telse if(timer > 1600'd0 && ack) begin // If the timer is running and ack has been received, reset everything.\n\t\t\ttimer <= 1600'd0;\n\t\t    delay <= 4'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n\t\tend \n\t\telse if(timer == 1600'd0 && counting) begin // If we have reached the end of our timer and are still counting, set 'done'.\n\t\t\tdone <= 1'b1;\n\t\t\ttimer <= delay * 1000 - 1; // Set the timer to count for (delay + 1) * 1000 cycles.\n            count <= delay - 1;   // Update the count value\n\t\tend\t\t\t\n\t\telse if(timer > 0 && !counting) begin\t// If we are not counting and our timer is still running, decrement it each clock cycle.\n\t\t\ttimer <= timer - 1;\n            count <= timer / 1000 ; // Update the current remaining time\n        end   \t\n            \n         else if(timer == 1600'd0 && !counting) begin\t// If we are not counting and our timer has reached 0, stop decrementing.\n\t\t\ttimer <= 1600'd0;\n            count <= 4'd0 ; // Update the current remaining time to be zero\n        end  \t    \t      \t     \t \t   \n            \n        \n\t\t\t\tif(counting == 1'b0) begin \t//If we are not currently counting, check if the start pattern has been detected.\n\t\t\t\t\tfor (i = 1599; i >= 4; i = i - 1) begin // Shift in data bits most significant bit first.\n\t\t\t\t\t\ttimer[i] <= timer[i-1];\t\n\t\t\t\t\t\t\tif((timer[i+3:i-2] & {16{START_PATTERN}} )== START_PATTERN) begin\t// If the start pattern has been detected, set our delay to be the next 4 bits and start counting.\n\t\t\t\t\t\t\t\ttimer <= timer << i; // Shift away unwanted bits.\n\t\t\t\t\t\t\t\tdelay <= timer[3:0];   \n\t\t\t\t\t\t\t\tcounting <= 1'b1;  \n\t\t\t\t\t\t\tend\t\t\t\t\t    \t\t    \t\t\t     \n\t\t\t\t\tend\t     \t       \t \t   \t\t \n\t\t\tend              \t  \n        end      \t      \t      \t        \nendmodule\n"}
{"task_id": "review2015_fancytimer", "completion": "\nreg [1599:0] shift_register;\nwire [3:0] delay;\nreg start_counting = 0;\nreg [3:0] timer = 4'b0; // Initialize the counter to 0.\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        shift_register <= 1600'd0;\n        done <= 0;\n        counting <= 0;\n\t\ttimer <= 4'b0;\n\tend else begin\n    \tshift_register <= {data, shift_register[1599:1]};  // Shift in the new bit.\n\t\t\n     \tif (&shift_register[3:0] == 1) begin  \t\t\t\t// If a 4-bit pattern of 1101 is detected...\n        \tdone <= 1;\t\t\t\t\t\t\t\t\t\t// ...notify that we're done.\n            delay <= shift_register[7:4];         \t\t    // Extract the delay from the next four bits.\n        end else begin\n           counting <= 1 & start_counting;                 \t// If we've detected and started a count, continue counting... \n\t       if (ack == 1 && timer > 0) done <= 0;            \t// ...until acknowledgement is received. Reset the timer when acknowledged.\n        end\n\t\t  \n     \tif(timer <= delay + 1 & start_counting==1 & ack != 1 ) begin // Count for (delay+1)*1000 clock cycles and decrement the timer each cycle.\n            timer <= timer - 4'b0001;                     \t\n        end else if(timer > delay + 1 & start_counting==1 & ack != 1 ) begin\n\t\t\ttimer <=  delay;\n        end    \t\t\t      \n     \tif((ack == 1 && timer > 0) || (&shift_register[3:0] == 1)) begin // If acknowledgement is received or if we've detected and started a count, reset the start_counting flag.\t  \n\t\t  start_counting <= 0;   \n        end else if(&shift_register[7:4] != 4'b0 && &shift_register[3:0] == 1) begin // If we've detected an input pattern of 1101, set the start_counting flag.\n\t\t  start_counting <= 1;   \n        end\t  \t\t\t      \n    end\nend\nassign count = timer;\t\t\t\t\t\t\t\t\t\t// Assign the current value of the timer to the output wire 'count'.\n"}
{"task_id": "review2015_fancytimer", "completion": "\n\treg [1599:0] shift_register;   // Create a large enough register to store the delay bits plus 4 more clock cycles.\n\treg [3:0] delay;               // Delay variable for counting.\n    reg [2:0] state = 0;           // State machine for handling different states of the timer.\n\n\t// Synchronous reset logic\n\talways @(posedge clk or posedge reset) begin\n        if (reset) begin\n            shift_register <= 1600'b0;\n            delay <= 4'b0;\n\t\t    state <= 3'd0;  // Go back to waiting for the start sequence.\n        end\n\tend\n\n\t// State machine logic\n\talways @(posedge clk) begin\n\t    case (state)\n\t\t    3'd0: if (shift_register[1597:1594] == 4'b1101) state <= 3'd1;  // Found start sequence, go to next state.\n            3'd1: begin\n                shift_register <= {data, shift_register[1599:1]};    // Shift in the new data bit.\n                if (shift_register[1587:1584] == 4'b0) state <= 3'd2;  // If delay bits are all zero, go back to waiting for start sequence.\n            end\n\t\t    3'd2: begin\n\t\t\t    delay <= shift_register[1591:1588];                   // Load the new delay value.\n\t\t\t\tcounting <= 1'b1; // Start counting.\n\t\t\t    state <= 3'd3; // Go to counting state.\n\t\t    end \n            3'd3: if (delay == 4'b0) begin                          // Check if we have finished counting yet.\n                state <= 3'd4; // If yes, go to done state.\n\t\t\t\tcounting <= 1'b0;                                 // Stop the counter.\n\t\t    end else delay <= delay - 1;                             // Otherwise, decrement the delay and continue counting.\n            3'd4: begin \n                done <= 1'b1; // Notify user that timer is finished.\n\t\t\t\tstate <= 3'd5; // Go to waiting for ack state.\n\t\t    end  \n\t\t    3'd5: if (ack) begin                                 // Check if user has acknowledged the timeout.\n                done <= 1'b0;                                // If yes, go back to idle state.\n\t\t\t\tstate <= 3'd0; // Start looking for next start sequence.\n            end \n\t    endcase\n\tend\n\n\t// Output counting value\n    assign count = (state == 3'd2 || state == 3'd3) ? delay + 1 : 4'bzzzz;   // Don't care if we are not counting, and the current remaining time.\n"}
{"task_id": "review2015_fancytimer", "completion": "\nreg [15:0] pattern = 0; // 16-bit register to hold the received pattern.\nreg [3:0] delay;      // 4-bit register to hold the delay value.\nreg [279:0] cycle_count = 0; // 280-bit register to hold the cycle count.\nreg ack_prev = 0;     // Previous value of ack for edge detection.\n\nalways @(posedge clk or posedge reset) begin : TIMER\n    if (reset == 1'b1) begin  // Asynchronous reset\n        pattern <= 0;\n        delay <= 4'b0;\n        cycle_count <= 0;\n        counting <= 1'b0;\n        done <= 1'b0;\n        count <= 4'b0;\n    end else begin\n        ack_prev <= ack; // Update previous value of ack.\n        \n        if (pattern == 16'hE59A) begin  // Check for the start sequence.\n            counting <= 1'b1;\n            done <= 1'b0;\n            cycle_count <= 280'd1;   // Start counting from 1000 clock cycles.\n        end else if (cycle_count == 0) begin // Timer finished counting.\n            delay <= pattern[3:0];\n            cycle_count <= {4{delay}} + 280'd1; // Count for ((delay+1)*1000). \n            counting <= 1'b1;\n        end else if (cycle_count > 0) begin  // Timer is still counting.\n            cycle_count <= cycle_count - 1'b1;  // Decrement the counter.\n\t    count <= cycle_count[279:280];   // Update remaining time to display on output 'count'.\n        end else begin // Do nothing while timer is not counting and pattern sequence has not been received yet.\n            done <= 1'b1;\n        end\n        \n        if (ack == 1'b1 && ack_prev == 1'b0) begin // Check for positive edge of 'ack'.\n            done <= 1'b0;  // Notify the user and reset pattern.\n            pattern <= 0;\n\t    cycle_count <= 280'd1;\n        end\n        \n        if (data == 1'b1 && pattern != 16'hE59A) begin // Shift in data bits one at a time. \n           pattern <= {pattern[14:0], data};\n        end else if (data == 1'b0 && pattern != 16'hE59A) begin\n           pattern <= {pattern[14:0], data};\n        end\n    end\nend\t        \nendmodule \n"}
{"task_id": "review2015_fancytimer", "completion": "\n\t// Defining states for state machine\n\ttypedef enum {IDLE, SEARCHING, COUNTING} state_t; \n\tstate_t state;\n\treg [3:0] delay, cnt;\n\treg [15:0] pattern;\n\t\n\t// State Machine Transitions and Outputs\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin\n\t\t\tstate <= IDLE;\n            counting <= 0;\n            done <= 0;\n            delay <= 4'h0;\n            cnt <= 4'hF;  // Initialize count to maximum value for 4-bit binary counter.\n        end\n        \n\t\telse case (state) \n\t\t\tIDLE: begin\n\t\t\t\tif (pattern == 'b1101)\n\t\t\t\t\tstate <= SEARCHING;\n                else begin\n                    pattern[15:1] <= {pattern[14:0], data}; // Shift in serial data bits\n                    counting <= 0;\n                    done <= 0;  \n                end \n            end\n            \n\t\t\tSEARCHING: begin\n\t\t\t\tif (data == 1'b1) begin\n                    pattern <= 'b11010; \n                    state <= COUNTING;\n                    delay[3:0] <= {pattern[7], pattern[6], pattern[5], pattern[4]}; // Determine delay from the last four bits received\n\t\t\t\t\tcounting <= 1'b1;     \n                end                  \n            end            \n\t\t\t\n\t\t\tCOUNTING: begin \n\t\t\t\tif (cnt == 0) begin \n                    cnt <= delay + 1;  \n                    state <= IDLE;    // Return to idle state once count is finished.\n                    done <= 1'b1;    \n                end                 \n                 else if(ack==1'b1) begin\n\t\t\t\t\t\tdone<=0;//when acknowledged, reset the done signal \n\t\t\t\t        state<=IDLE;  \n\t\t\t\tend   \n            end                  \n        endcase                     \n        \n        count <= cnt; // Output current remaining time to user.\n        \n\t    if (cnt > 0) begin\n\t\t\tcnt <= cnt - 1'b1;     // Decrement counter until it reaches 0  \n\t\tend                \n    end                           \nendmodule                         \n"}
{"task_id": "review2015_fancytimer", "completion": "\n\n\treg [1599:0] buffer; // buffer to hold the received bits.\n    reg [3:0] delay_count = 4'd0; \n    integer counter = 2800; // clock cycles needed to count for the given delay (1 second * desired frequency)\n\twire pattern_detected = &buffer[1597:1596]; // 11 at beginning of buffer, rest don't care.\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            buffer <= 0;\n            counting <= 0;\n            done <= 0;\n            delay_count <= 4'd0;\n        end \n\t\telse begin\n\t\t\tbuffer <= {data, buffer[1599:1]}; // shift in new bit.\n\t\t\t\n            if(pattern_detected) begin\n                delay_count <= buffer[3:0]; // save the delay from data input.\n                counting <= 1; \n                done <= 0;\n                `ifdef SYNTHESIS\n                    #2800 counter = 2800 - (delay_count + 4'd1) * 1000; // count for given delay in clock cycles, reset after.\n\t\t\t\t    if (!(counter >= 0)) begin\n\t\t\t\t\t\tdone <= 1;\n                        counting <= 0;\n\t\t\t\t    end else begin\n                    `endif    \n                       counter <= (delay_count + 4'd1) * 1000 - 2800 + counter; // decrementing countdown, reset after.\n                     `ifdef SYNTHESIS  \n                       $display(\"%d\",counter/1000); // show the remaining time in seconds\n                    `endif    \n\t\t\t\t    end     \n            end else if (ack) begin \n                done <= 0;\n                counting <= 0;\n\t\t\tend\n        end\n    end\n    assign count = delay_count - counter/1000; // current remaining time to zero.\n\n"}
{"task_id": "review2015_fancytimer", "completion": "\nreg [1599:0] pattern;  // Stores the received bits.\nreg [3:0] delay;       // The duration of timer delay.\nreg start_counting;     // Indicates when to start counting.\ninteger i;             \n\t\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin  // Reset synchronously\n            pattern <= 0;\n            delay <= 4'hf;\n            done <= 1'b0;\n            counting <= 1'b0;\n            start_counting <= 1'b0;\n        end\n\t\telse begin\n\t\t\tif (~start_counting) begin  // If not yet started.\n                pattern <= {pattern[1598:0], data};  // Shift in new bit.\n\t\t\t\t// Check if the received bits match with start pattern 1101.\n                if ((pattern[15] == 1'b1) && (pattern[14:12] == 3'b110)) begin  \n                    delay <= pattern[11:8];   // Extract duration from received bits.\n                    start_counting <= 1'b1;  // Indicate that counting is about to start.\n                end\n            end else if (counting) begin   // If still counting...\n\t\t\t\tif(i > 0 )begin             // Decrease the counter for each clock cycle.\n\t\t\t\t\ti <= i - 1;\n                    count <= delay + 1'b1 - i/1000 ;    // Calculate and output remaining time.\n                end else begin               // When counting is done...\n                    done <= 1'b1;            // Notify the user.\n                    start_counting <= 1'b0;  // Wait for acknowledgment before restart searching.\n\t\t\t\t\ti <= delay + 1'b1 ;\n                     if (ack) begin         // If acknowledged, prepare for next sequence.\n                        counting <= 1'b0;   // Deassert the done signal and wait for new start signal.\n                    end \n                end\n\t\t\tend else begin                   // If not counting...\n\t\t\t\tif (start_counting && ack) begin  // And acknowledged, prepare to count.\n\t\t\t\t\tcounting <= 1'b1;   // Assert the counting output.\n\t\t\t\t\ti <= delay + 1'b1 ;        // Start counting for specified duration.\n                end else begin                    \n                    done <= 1'b0;           // Otherwise don't notify and stay in this state.\n\t\t\t\tend \n\t\t\tend\n\t\tend\n    end\nendmodule\n"}
{"task_id": "review2015_fancytimer", "completion": "\n// State machine variables\nreg [1599:0] delay_cycles; // Total number of cycles to count\nreg [127:0] state;          // Current state\nparameter PATTERN = 16'h2AF0, STOPPED = 16'h0003; // Start pattern and stop states\nlocalparam DELAY_WIDTH = 4;\n\n// State machine transitions\nalways @(posedge clk or posedge reset) begin \n\tif (reset == 1'b1) state <= STOPPED; // Asynchronous reset\n\telse case (state[3:0])\n\t\tSTOPPED : if (data == 1'b1 && delay_cycles != 0 ) state <= 4'h1; else state <= STOPPED;\n\t\t1       : if (delay_cycles >= 2**DELAY_WIDTH) state <= 5'h1F; // We are done counting, wait for ack\n\t\tdefault : state <= {1'b0, state[1598:4]}; \n\tendcase\nend\n\n// Set delay and start counting\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) delay_cycles <= 0; // Asynchronous reset\n\telse if (state == STOPPED && data == 1'b1 ) delay_cycles <= PATTERN[3:0]; // Load delay value from input bits\nend\n\n// Output assignments\nassign count = state[DELAY_WIDTH+2 : 4 ];\nassign done = (state[3]==1) ? ~(ack & counting): 1'b0;\nassign counting = ~(state == STOPPED);\n"}
{"task_id": "review2015_fancytimer", "completion": "\nreg [15:0] pattern;  // Pattern to search for\nwire start_found = (pattern[15:4] == 12'b1101);  // Has the correct sequence been found?\nreg [3:0] delay, next_count;  \n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        pattern <= 0;\n        counting <= 0;\n        done <= 0;\n    end \n\telse begin\n    \tpattern <= {data, pattern[15:1]}; // Shift in new bit\n     \tif (!counting && start_found) begin  // If not currently counting and the sequence was found\n         \tdelay <= pattern[3:0];  \n            counting <= 1;  // Start counting\n        end else if (ack && done) begin\n\t\t\tdone <= 0;\n        \tcounting <= 0;\n     \tend\n   \t\tif(counting) begin\n       \t\tif (next_count == 0 ) begin\n            \tdone <= 1;  \n             \tnext_count <= delay;  // reset counter\n            end else begin\n\t\t\t\tnext_count <= next_count - 1'b1; // Decrement counter\n            end\n     \tend\t\t\n    end\nend\nassign count = counting ? next_count : 4'hf ;  // If we are not currently counting, display all 1s because the user shouldn't be reading this value anyway.\n"}
{"task_id": "review2015_fancytimer", "completion": "\nlocalparam PATTERN = 4'b1101;\nwire pattern_detected = (data && shiftreg == PATTERN); \nreg [3:0] delay;\nreg [15:0] counter; // count in 1000s of clock cycles.\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        counting <= 0;\n        done <= 0;\n        shiftreg <= 0;\n        delay <= 0;\n        counter <= 0;\n    end else begin\n        shiftreg <= {shiftreg[2:0], data}; // Shift in new bit.\n        if (counting) begin \n            if(counter == delay * 1000 - 1) begin\n                done <= 1; \n                counting <= 0;\n            end else begin  \n                counter <= counter + 1'b1; \n\t\t\t\tdelay <= delay > 0 ? delay - 1 : 0; // Decrease the remaining time.\n\t\t\tend\n        end else if (pattern_detected) begin\n            counting <= 1;\n            delay <= shiftreg[3:0]; \n        end\n        if(ack && done)\n             done <= 0; \n    end\nend\nassign count = counter > delay * 1000 ? delay : counter/1000; // Remaining time.\n"}
{"task_id": "review2015_fancytimer", "completion": "\n\n    // Local parameters\n    localparam PATTERN = 4'b1101;\n    \n    // State machine signals\n    typedef enum logic [1:0] {WAITING, SEARCHING, COUNTING} state_t;\n    state_t state, next_state;\n \n    // Registers and wires\n    reg [3:0] delay;\n    reg [3:0] timer;\n    \n    wire data_synced = (state == SEARCHING) ? data : 'b0;\n        \t\n\t// State machine\n\talways @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= WAITING;\n        else \n            state <= next_state;\n    end\n    \t\n    // Next state logic\n    always @* begin\n        case (state) \n            WAITING:   next_state = data_synced ? SEARCHING : WAITING;\n            SEARCHING: next_state = ack ? WAITING : COUNTING;\n            COUNTING:  next_state = (timer == 0 && ~ack) ? DONE : COUNTING;\n            DONE:      next_state = data_synced ? SEARCHING : DONE;\n\t\t\tdefault:   next_state = state;\n        endcase\n    end    \n      \n\t// Output logic\n\tassign count = (state == COUNTING) ? delay-timer+1 : 'b0; \n\tassign counting = ~(next_state inside {DONE, WAITING});\n\tassign done = ~ack & ((state == DONE) | (next_state == DONE));  \n    \t\t\n\t// Timer logic\n    always @(posedge clk or posedge reset) begin\n        if (reset || state == COUNTING && ack) \n            timer <= 4'b0;\n       else if (counting && (timer==delay))\n        \ttimer <= 'b0;\n\telse  \n\t    \ttimer <= timer + 1;\n    end\n        \n\t// Shift register for delay and start pattern\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset || state == DONE && ack) \n\t        delay <= 4'b0;\n      \telse if ((state == SEARCHING || state == COUNTING) && ack)\n          \tdelay <= {data, delay[3:1]};        \n\tend    \t\t  \t\n    endmodule\n"}
{"task_id": "review2015_fancytimer", "completion": "\nreg [12:0] timer; // 13 bit counter to store the delay\nreg [3:0] delay; // 4 bit delay value from the serial data\nreg [1:0] state; // FSM State\nparameter IDLE = 2'h0, SEARCHING = 2'h1, COUNTING = 2'h2, DONE = 2'h3;\n\talways @(posedge clk or posedge reset) begin\n        if (reset == 1) begin\n            state <= IDLE;\n\t\t\ttimer <= 0;\n\t\t\tcounting <= 0;\n\t\t\tdone <= 0;\n        end else begin\n            case (state)\n                IDLE: \n                    if(data==1'b1)\n                        state <= SEARCHING;\n                \n                SEARCHING: begin\n                    if(~ack) begin // wait till acknowledge is low to start counting again\n\t\t            \tif({data, data} == 2'b11 ) begin\n\t\t\t    \tstate <= COUNTING;\n                            delay <= {data, data};\n                        end else \n\t\t            state <= IDLE;\n                    end\n                end\n                \n                COUNTING:begin\n                    timer <= timer + 1;\n                    count <= ~timer[3:0] +1'b1 ; // remaining time is calculated by the delay-timer. It starts decrementing from delay for every 1000 cycles\n\t\t    if (&timer) begin // check whether counter has reached its limit\n\t\t\t\tstate <= DONE;  \n                        done <= 1; // notify user that timer is complete\n                    end\n                end\n                \n                DONE:begin\n                 \tif(ack==1'b1)begin  // wait for acknowledge to be high before resetting the state machine and starting to search again\n\t\t\t\tstate <= IDLE;\n                        done <= 0;   // clear the done signal when acknowledgement is received \n                    end else \n\t\t\tstate <= DONE;\n                end\n            endcase\n        end\n    end    \nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [1:0] prev_state;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tprev_state <= 2'b00;\n\t\t\t{dfr, fr3, fr2, fr1} <= 4'b1111;\n\t\tend else begin\n\t\t\tcase ({s[3], s[2], s[1]})\n\t\t\t\t3'b111: {prev_state, dfr, fr3, fr2, fr1} <= 5'b01111; // Above s[3]\n\t\t\t\t3'b011: {prev_state, dfr, fr3, fr2, fr1} <= 5'b00110; // Between s[3] and s[2]\n\t\t\t\t3'b001: {prev_state, dfr, fr3, fr2, fr1} <= 5'b00010; // Between s[2] and s[1]\n\t\t\t\tdefault: begin \n\t\t\t\t\t{prev_state, dfr, fr3, fr2, fr1} <= (s[3:1] == prev_state) ? {prev_state, ~dfr, ~fr3 & fr3 | fr3 & ~fr3, ~fr2 & dfr | fr2 & ~fr2, ~fr1};\n\t\t\t\t\tend // Below s[1]\n\t\t\tendcase \n\t\tend \n\tend\nendmodule\n\n"}
{"task_id": "ece241_2013_q4", "completion": "\n    // Declare states as enum to make it more understandable.\n\ttypedef enum logic[1:0] {LOW = 2'b00, MEDIUM_UP = 2'b01, MEDIUM_DOWN = 2'b10, HIGH = 2'b11} state_t; \n\tstate_t state; // Current state\n\tstate_t next_state; // Next state\n    \n\talways @(posedge clk or posedge reset) begin : REGISTERS\n\t    if (reset) // Asynchronous active high reset\n\t        state <= LOW;\n\t    else \n\t\t    state <= next_state;  \n\tend        \n\t// State machine transition logic and output decoding\n\talways @(*) begin\n        case(state)\n            HIGH: begin\n                fr3 <= 1'b0; // None asserted since water level is above s[3] \n\t\t\t    fr2 <= (s[2]==1); // Asserted if at or below s[2], otherwise not asserted \n\t\t\t    fr1 <= (s[1]==1); // Asserted if at or below s[1], otherwise not asserted \n                dfr <= 1'b0; // Not changed, since no change in level between previous and current sensor\n            end                \n\t\t\tMEDIUM_DOWN: begin\n\t\t\t    fr3 <= (s[3]==1); // Asserted if at or above s[3], otherwise not asserted \n                fr2 <= ~(s[2]); // Not changed, since level is between two sensors\n\t\t\t    fr1 <= ~(s[1]); // Not changed, since level is between two sensors\n                dfr <= 1'b0; // Closed the flow rate to decrease\n\t\t\tend                \n\t\t\tMEDIUM_UP: begin\n\t\t\t    fr3 <= (s[3]==1); // Asserted if at or above s[3], otherwise not asserted \n                fr2 <= ~(s[2]); // Not changed, since level is between two sensors\n\t\t\t    fr1 <= ~(s[1]); // Open flow rate to increase\n                dfr <= 1'b0; // Not changed, since no change in level between previous and current sensor\n\t\t\tend                \n            LOW: begin\n                fr3 <= (s[3]==1); // Asserted if at or above s[3], otherwise not asserted \n\t\t\t    fr2 <= ~(s[2]); // Open flow rate to decrease\n\t\t\t    fr1 <= ~(s[1]); // Open flow rate to increase\n                dfr <= 1'b0; // Not changed, since no change in level between previous and current sensor\n\t\t\tend                \n            default: begin // Default state is LOW\n                fr3 <= (s[3]==1); \n\t\t\t    fr2 <= ~(s[2]); \n\t\t\t    fr1 <= ~(s[1]); \n                dfr <= 1'b0; \n\t\t\tend                \n        endcase    \n\tend         \n\t// Next state logic: Determines next_state based on sensor inputs.  \n\talways @(*) begin : NEXT_STATE_LOGIC\n\t    if (s[3]) // Above s[3] \n            next_state = HIGH;            \n        else if (s[2]) // Between s[3] and s[2] or below s[2]\n\t        next_state = MEDIUM_DOWN;  \n\t    else if (s[1]) // Between s[2] and s[1] or below s[1], so we need to check previous state \n            case(state)\n                HIGH: next_state = MEDIUM_UP; // Flow rate is decreasing, but now going downward. Need to open the flow rate.\n\t\t\t    MEDIUM_DOWN: next_state = LOW; // Flow rate is closed, and we are below s[1]. So, need to open the flow rate.\n                default: next_state = MEDIUM_UP;  // Otherwise just going downward. Need to open the flow rate.\n\t\t\tendcase          \n\t    else begin // Below s[1], so we need to check previous state\n            case(state)\n\t\t\t    HIGH,MEDIUM_DOWN: next_state = LOW; // Flow rates are closed or decreasing. Need to open the flow rate.\n                default: next_state = MEDIUM_DOWN; // Otherwise going upward. Close the flow"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [1:0] pre_state;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin  // Reset State\n\t\t\t{fr3, fr2, fr1, dfr} <= 4'b1111;\n\t\tend else begin     // State Transition\n\t\t\tcase({s[3], s[2], s[1]})\n\t\t\t\t3'b000: {fr3, fr2, fr1, dfr} <= 4'b0000;  // Above s[3]: no flow rate\n\t\t\t\t3'b001: {fr3, fr2, fr1, dfr} <= 4'b0010;  // Between s[3] and s[2] : fr1\n\t\t\t\t3'b010: {fr3, fr2, fr1, dfr} <= 4'b1011;  // Between s[2] and s[1]: fr1 & fr2\n\t\t\t\t3'b011: {fr3, fr2, fr1, dfr} <= 4'b1110;  // Below s[1]: fr1 & fr2 & fr3\n\t\t\t\tdefault: {fr3, fr2, fr1, dfr} <= {fr3, fr2, fr1, dfr}; // No Change State\n\t\t\tendcase\n\t\tend\n\t\tpre_state <= {s[3], s[2]};  // Previous State\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [1:0] prev_s;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tprev_s <= 2'b0;\n\t\t\t{fr3, fr2, fr1, dfr} <= 4'b1111;\n\t\tend\n\t\telse begin\n\t\t\tprev_s <= s[2:1];\n\t\t\tcase(s) \n\t\t\t\t3'b111: {fr3, fr2, fr1, dfr} <= 4'b0000; // above s[3]\n\t\t\t\t3'b110: {fr3, fr2, fr1, dfr} <= {1'b0, 1'b1, 2'b0}; // between s[3] and s[2]\n\t\t\t\t3'b100: {fr3, fr2, fr1, dfr} <= 4'b0110; // between s[2] and s[1]\n\t\t\t\tdefault:{fr3, fr2, fr1, dfr} <= 4'b1100; // below s[1]\n\t\t\tendcase \n\t\t\tif(prev_s == 2'b00 && s != 3'b111) dfr <=  1'b0; \n            if(prev_s == 2'b10 && s == 3'b110 ) dfr <= ~dfr; //supplemental flow valve state change\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n// Using combinatorial logic to implement the state transition diagram. \nalways @(*) begin\n\tif (reset) begin // reset condition\n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b1;\n\t\tdfr <= 1'b1;\n\tend else if (s[3]) begin  // above sensor s[3]\n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b0;\n\t\tdfr <= 1'b0;\n\tend else if ((~s[3]) && (s[2])) begin // between s[3] and s[2] \n\t\tfr3 <= fr3;  \n\t\tfr2 <= 1'b1; \n\t\tfr1 <= 1'b1; \n\t\tdfr <= 1'b0; \n\tend else if ((~s[3]) && (~s[2]) && s[1]) begin // between s[2] and s[1] \n\t\tfr3 <= fr3;  \n\t\tfr2 <= 1'b1; \n\t\tfr1 <= 1'b1; \n\t\tdfr <= 1'b1; \n\tend else if ((~s[3]) && (~s[2]) && (~s[1])) begin // below s[1]\n\t\tfr3 <= 1'b0;  \n\t\tfr2 <= 1'b0; \n\t\tfr1 <= 1'b1; \n\t\tdfr <= 1'b1; \n\tend else begin // default state\n\t\tfr3 <= fr3;  \n\t\tfr2 <= fr2; \n\t\tfr1 <= fr1; \n\t\tdfr <= dfr; \n\tend\nend\n// Using flip-flop for synchronous operation.\nalways @(posedge clk) begin\n\tif (reset) begin // reset condition\n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b1;\n\t\tdfr <= 1'b1;\n\tend else if(s[3]) begin  // above sensor s[3]\n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b0;\n\t\tdfr <= 1'b0;\n\tend else if ((~s[3]) && (s[2])) begin // between s[3] and s[2] \n\t\tfr3 <= fr3;  \n\t\tfr2 <= 1'b1; \n\t\tfr1 <= 1'b1; \n\t\tdfr <= 1'b0; \n\tend else if ((~s[3]) && (~s[2]) && s[1]) begin // between s[2] and s[1] \n\t\tfr3 <= fr3;  \n\t\tfr2 <= 1'b1; \n\t\tfr1 <= 1'b1; \n\t\tdfr <= 1'b1; \n\tend else if ((~s[3]) && (~s[2]) && (~s[1])) begin // below s[1]\n\t\tfr3 <= 1'b0;  \n\t\tfr2 <= 1'b0; \n\t\tfr1 <= 1'b1; \n\t\tdfr <= 1'b1; \n\tend else begin // default state\n\t\tfr3 <= fr3;  \n\t\tfr2 <= fr2; \n\t\tfr1 <= fr1; \n\t\tdfr <= dfr; \n\tend\nend\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b1;\n\t\tdfr  <= 1'b1;\n\tend \n\telse if (s == 4'b0001) begin\n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b1;\n\t\tdfr  <= 1'b0;\n\tend  \n\telse if (s == 4'b0010 || s == 4'b0011) begin \n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b0;\n\t\tdfr  <= 1'b1;\n\tend  \n\telse if (s == 4'b0101 || s == 4'b0110) begin \n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b0;\n\t\tdfr  <= 1'b1;\n\tend  \n\telse if (s == 4'b0111 || s == 4'b1000) begin \n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b1;\n\t\tdfr  <= 1'b1;\n\tend  \n\telse if (s == 4'b1001 || s == 4'b1010) begin \n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b0;\n\t\tdfr  <= 1'b1;\n\tend  \n\telse if (s == 4'b1011 || s == 4'b1100) begin \n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b0;\n\t\tdfr  <= 1'b1;\n\tend  \n\telse if (s == 4'b1101 || s == 4'b1110) begin \n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b1;\n\t\tdfr  <= 1'b1;\n\tend  \n\telse if (s == 4'b1111) begin \n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b0;\n\t\tdfr  <= 1'b1;\n\tend  \nend\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n     always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            fr3 <= 1'b0;\n            fr2 <= 1'b1;\n            fr1 <= 1'b1;\n            dfr <= 1'b1;\n        end \n\telse begin\n\t   case(s)\n\t\t3'b100: begin // water level is above s[3]\n                    fr3 <= 1'b1;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b0;\n                    dfr <= 1'b0;\t  \n                 end \n\t\t3'b011: begin // water level is between s[3] and s[2]\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b0;\t  \t\t       \n                 end \n\t\t3'b010: begin // water level is between s[2] and s[1]\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b1;\t  \t       \n                 end \n\t\t3'b001: begin // water level is between s[1] and no sensors asserted\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b0;\t  \t       \n                 end \t\t    \t   \n            default: begin // when the water level is below s[1], flow rate is at maximum (both Nominal and Supplemental flow valve opened)\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b0;\n                    dfr <= 1'b0;\t  \t       \n                 end \t\t       \t\t   \n            endcase\n         end\n     end\nendmodule\n\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg prev_reset;\n   wire level_above_s3 = s[3];\n   wire level_between_s3_and_s2 = (~level_above_s3) & s[2];\n   wire level_between_s2_and_s1 = (~level_above_s3) & (~level_between_s3_and_s2) & s[1];\n   wire level_below_s1 = (~level_above_s3) & (~level_between_s3_and_s2) & (~level_between_s2_and_s1);\n    \n\talways @(posedge clk, posedge reset) begin\n      if(reset | prev_reset) begin\n        fr3 <= 1'b1;\n        fr2 <= 1'b1;\n        fr1 <= 1'b1;\n        dfr <= 1'b1;\n\t\tend else begin  // rising clock edge   \n      \tif (level_above_s3) begin\n        \tfr3 <= 0;\n          fr2 <= 0;\n          fr1 <= 0;\n          dfr <= 0;          \n      \tend  \t\t\n       \telse if (level_between_s3_and_s2) begin\n          fr3 <= 0;\n          fr2 <= 1;\n          dfr <= level_above_s3;  // open/close Supplemental flow valve based on water level above or below last level   \t\t  \t\t    \t\t      \t\t\t     \n      \tend \n       \telse if (level_between_s2_and_s1) begin\n           fr3 <= 0;\n          fr2 <= 1;\n          fr1 <= 1;\n          dfr <= level_above_s3 | level_between_s3_and_s2; // open/close Supplemental flow valve based on water level above or below last level  \t\t  \t\n      \tend \t\t\t\n       \telse if (level_below_s1) begin\n           fr3 <= 1;\n          fr2 <= 1;\n          fr1 <= 1;\n          dfr <= level_above_s3 | level_between_s3_and_s2 | level_between_s2_and_s1; // open/close Supplemental flow valve based on water level above or below last level  \t\t \t\t\t     \t      \n       \tend    \t\t\t\t\t   \t   \t\t\t\t     \t \t\t\t\t\t\t \n         end\n     prev_reset <= reset;         \t     \t  \n  end\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n    \n    localparam SENSOR_LEVELS = 4'b0100; // Water level above this value will set flow rate to zero.\n    localparam FLOW_RATE_ZERO = 3'b000; // Flow rates are asserted high for these levels.\n    \n    reg [2:0] prev_flow_rate; \n\t\n\t// State machine that drives the outputs fr3, fr2, fr1 and dfr\n\talways @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Asynchronous reset.\n            fr3 <= 1'b0;\n            fr2 <= 1'b0;\n            fr1 <= 1'b1;\n            dfr <= 1'b1;\n            prev_flow_rate <= 3'b111; \n        end\n        \n\t\telse begin    \n\t\t    if (s == SENSOR_LEVELS) begin // Water level above s[3]\n\t\t\t    fr3 <= 1'b0;\n                dfr <= 1'b0;\n            end  \n            \n            else if ((s == 3'b011) || (s == 3'b010)) begin // Between s[2], s[3], and above s[3]\n\t\t\t    fr3 <= 1'b0;\n                dfr <= 1'b1;\n            end \n            \n            else if ((s == 3'b01) || (s == 3'b00)) begin // Between s[1], s[2], and above s[1]\n\t\t\t    fr3 <= 1'b1;\n                dfr <= |prev_flow_rate ? 1'b1 : 1'b0;\n            end  \n            \n            else begin // Below s[1]\n\t\t\t    fr3 <= 1'b1;\n                dfr <= 1'b1;\n            end  \n        \t\n\t\t\tprev_flow_rate <= {fr3, fr2, fr1}; \n        end  \n\tend      \n    \n\t// Fr1 and Fr2 flow rate are always asserted high for these levels.\n    assign fr1 = (s == 3'b000) || ((s == 3'b001) && !fr3); // Below s[1], or at level s[1] but not when the water is rising upwards after reaching above s[1]. \n\tassign fr2 = |{s[3], s[2]} ? (s[2] || s[3]) : 1'b0;   // If water is between sensors [2,3], or if it's at sensor 3. Otherwise, zero flow rate.\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n    reg [2:0] state;\n    \n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) begin \n\t        state <= 3'b111; //all outputs asserted for reset\n            {fr3, fr2, fr1, dfr} <= 4'hf; \n        end \n\t\telse case(s)\n\t\t\t3'b000: begin \n                {fr3, fr2, fr1, dfr} <= 4'h0; //None\n            state <= 3'b111; \n\t\t\tend\n            3'b001: begin \n                {fr3, fr2, fr1, dfr} <= 4'h5; //fr1\n                state <= 3'b110; \n\t\t\tend\n\t\t\t3'b011: begin \n                {fr3, fr2, fr1, dfr} <= 4'h6; //fr1, fr2\n                state <= 3'b100; \n            end\n            3'b111: begin \n                {fr3, fr2, fr1, dfr} <= 4'h7; //fr1, fr2, fr3\n                state <= 3'b000; \n\t\t\tend\n\t\tendcase\n    end \nendmodule  \n"}
{"task_id": "ece241_2013_q4", "completion": "\n\t// State encoding for water levels (0 - above s[3], 1 - between s[3] and s[2], ..., 3 - below s[1])\n\treg [1:0] state;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin // active-high synchronous reset\n\t\t\tstate <= 2'b11; // to the state equivalent to if water level had been low for a long time\n\t\t\t{fr3, fr2, fr1, dfr} <= 4'b1111; // all outputs are asserted\n\t\tend else begin \n\t\t\tcase (state)\n\t\t\t\t2'b00: {fr3, fr2, fr1, dfr} <= 4'b0000; // above s[3] -> None\n\t\t\t\t2'b01: if(s[1]) {fr3, fr2, fr1, dfr} <= 4'b1010; else {fr3, fr2, fr1, dfr} <= 4'b0010; // between s[3] and s[2] -> fr1\n\t\t\t\t2'b10: if(s[2]) {fr3, fr2, fr1, dfr} <= 4'b0011; else {fr3, fr2, fr1, dfr} <= 4'b0001; // between s[2] and s[1] -> fr1, fr2\n\t\t\t\t2'b11: {fr3, fr2, fr1, dfr} <= 4'b0001; // below s[1] -> None, fr1, fr2, fr3\n\t\t\tendcase\n\t\t\t\n\t\t\t// update state based on sensor inputs\n\t\t\tstate <= (s == 3'b0) ? 2'b00 : ((s == 3'b101 || s == 3'b110) ? 2'b01 : ((s == 3'b011 || s == 3'b111) ? 2'b10 : 2'b11));\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [2:0] state;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= 3'b111;\n\t\t\t{fr3, fr2, fr1, dfr} <= 4'b1111;\n\t\tend else begin\n\t\t\tcase (s) \n\t\t\t\t3'b000: state <= 3'b000; // Below s[1]\n\t\t\t\t3'b001: state <= 3'b001; // Between s[2] and s[1]\n\t\t\t\t3'b011: state <= 3'b010; // Between s[3] and s[2]\n\t\t\t\t3'b111: state <= 3'b011; // Above s[3]\n\t\t\t\tdefault: state <= state; \n\t\t\tendcase\n\t\t\t\n\t\t\tcase (state)\n\t\t\t\t3'b000: {fr3, fr2, fr1, dfr} <= 4'b1000; // Below s[1], no flow rate\n\t\t\t\t3'b001: {fr3, fr2, fr1, dfr} <= 4'b0100; // Between s[2] and s[1], fr1\n\t\t\t\t3'b010: {fr3, fr2, fr1, dfr} <= 4'b0110; // Between s[3] and s[2], fr1 & fr2\n\t\t\t\t3'b011: {fr3, fr2, fr1, dfr} <= 4'b0111; // Above s[3], fr1 & fr2 & fr3\n\t\t\t\tdefault:{fr3, fr2, fr1, dfr} <= {fr3, fr2, fr1, dfr}; \n\t\t\tendcase\n\tend\n\t\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\t// State definition\n\ttypedef enum {LOWER_THAN_SENSOR_1, BETWEEN_SENSOR_1_AND_2, BETWEEN_SENSOR_2_AND_3, HIGHER_THAN_SENSOR_3} state; \n\tstate curr_state = LOWER_THAN_SENSOR_1;\n\tstate next_state = LOWER_THAN_SENSOR_1;\n\t\t\n\t// State transition and output logic\n\talways @(*) begin\n\t\tcase (curr_state)\n\t\t\tLOWER_THAN_SENSOR_1: \tif (!s[3]) begin next_state = LOWER_THAN_SENSOR_1; {fr1, fr2, fr3} = 3'b0; dfr = 0; end\n\t\t\t\t\t\t\t\telse if (s[1]) begin next_state = BETWEEN_SENSOR_1_AND_2; {fr1, fr2, fr3} = 3'b01; dfr = 0; end\n\t\t\tBETWEEN_SENSOR_1_AND_2: \tif (!s[3]) begin next_state = BETWEEN_SENSOR_1_AND_2; {fr1, fr2, fr3} = 3'b01; dfr = 0; end\n\t\t\t\t\t\t\t\telse if (s[2]) begin next_state = BETWEEN_SENSOR_2_AND_3; {fr1, fr2, fr3} = 3'b10; dfr = 0; end\n\t\t\tBETWEEN_SENSOR_2_AND_3:\tif (!s[3]) begin next_state = BETWEEN_SENSOR_2_AND_3; {fr1, fr2, fr3} = 3'b11; dfr = 0; end\n\t\t\t\t\t\t\t\telse \t\t  begin next_state = HIGHER_THAN_SENSOR_3; {fr1, fr2, fr3} = 3'b11; dfr = 1; end\n\t\t\tHIGHER_THAN_SENSOR_3:\tif (s[1]) begin next_state = BETWEEN_SENSOR_1_AND_2; {fr1, fr2, fr3} = 3'b01; dfr = 1; end\n\t\t\t\t\t\t\t\telse \t\t  begin next_state = HIGHER_THAN_SENSOR_3; {fr1, fr2, fr3} = 3'b11; dfr = 1; end\t\n\t\tendcase\n\tend\n\n\t// State update\n\talways @(posedge clk) begin\n\t\tif (reset == 1) curr_state <= LOWER_THAN_SENSOR_1;  // asynchronous reset\n\t\telse if (curr_state != next_state) curr_state <= next_state; // synchronous update to new state\n\tend\t\t\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [2:0] state;\n\tparameter idle = 3'b000;\n\tparameter level1 = 3'b001;\n\tparameter level2 = 3'b010;\n\tparameter level3 = 3'b011;\n\tparameter level4 = 3'b100;\n  \n\talways @(posedge clk) begin\n\t\tif (reset == 1'b1) begin \n\t\t    state <= idle;\n\t\t    fr3 <= 1'b1;\n    \t    fr2 <= 1'b1;\n        \tfr1 <= 1'b1;\n       \t \tdfr <= 1'b0;\n\t\tend else case (state)\n\t\t\tidle: if (s[1] == 1'b1 && s[2]== 1'b0 && s[3] == 1'b0) begin // below level 1\n\t\t\t\tstate <= level4;\n\t\t\t    fr3 <= 1'b0;\n        \t\t    fr2 <= 1'b0;\n        \t\t    fr1 <= 1'b0;\n       \t\t\t dfr <= 1'b1;\n      \t\t     end else if (s[1] == 1'b0 && s[2]== 1'b1 && s[3] == 1'b0) begin // below level2\n\t\t\t\tstate <= level1;\n        \t\t    fr3 <= 1'b1;\n        \t\t    fr2 <= 1'b1;\n       \t\t\t dfr <= 1'b0;\n      \t\t     end else if (s[1] == 1'b0 && s[2]== 1'b0 && s[3] == 1'b1) begin // below level3\n\t\t\t\tstate <= level2;\n        \t\t    fr3 <= 1'b1;\n        \t\t    fr2 <= 1'b1;\n       \t\t\t dfr <= 1'b0;\n      \t\t     end \n\t\t\tlevel1: if (s[1] == 1'b1 && s[2]== 1'b1 && s[3] == 1'b0) begin // level 2 and above\n        \t\t\t    fr3 <= 1'b0;\n       \t\t\t     dfr <= 1'b1;\n      \t\t          end else if (s[1] == 1'b0 && s[2]== 1'b0 && s[3] == 1'b1) begin // below level3\n        \t\t\t    state <= level4;\n\t\t\t\t    fr3 <= 1'b0;\n       \t    \t\t    dfr <= 1'b1;\n      \t\t          end  \n\t\t\tlevel2: if (s[1] == 1'b1 && s[2]== 1'b1 && s[3] == 1'b0) begin // level 3 and above\n        \t\t\t    fr2 <= 1'b0;\n       \t\t\t     dfr <= 1'b1;\n      \t\t          end else if (s[1] == 1'b1 && s[2]== 1'b0 && s[3] == 1'b0) begin // below level1\n        \t\t\t    state <= level4;\n\t\t\t\t    fr2 <= 1'b0;\n       \t    \t\t    dfr <= 1'b1;\n      \t\t          end  \n\t\t\tlevel3: if (s[1] == 1'b1 && s[2]== 1'b0 && s[3] == 1'b0) begin // level 4 and above\n        \t\t\t    fr1 <= 1'b0;\n       \t\t\t     dfr <= 1'b1;\n      \t\t          end else if (s[1] == 1'b0 && s[2]== 1'b0 && s[3] == 1'b1) begin // below level3\n        \t\t\t    state <= level4;\n\t\t\t\t    fr1 <= 1'b0;\n       \t    \t\t    dfr <= 1'b1;\n      \t\t          end  \n\t\t\tlevel4: if (s[1] == 1'b0 && s[2]== 1'b0 && s[3] == 1'b0) begin // above level 4\n        \t\t\t     fr1 <= 1'b1;\n       \t\t\t      fr2 <= 1'b1;\n      \t\t               fr3 <= 1'b1;\n       \t    \t\t\t    dfr <= 1'b0;\n      \t\t          end  \n\t\tendcase\n\tend\nendmodule \n\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [1:0] previous_state;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset == 1'b1) begin  // Synchronous Reset\n\t\t    fr3 <= 1'b1;  \n\t\t    fr2 <= 1'b1;\n\t\t    fr1 <= 1'b1;\n\t\t    dfr <= 1'b0;\n            previous_state <= 2'b11; // No sensors asserted\n\t    end \n\t\telse begin\n             if(s[3] == 1)begin \n                fr3 <= 1'b0;  \n\t\t\t\tfr2 <= (previous_state == 2'b01 || previous_state==2'b10 ) ? 1'b1 : 1'b0 ;\n\t\t\t\tfr1 <= (previous_state != 2'b11) ? 1'b1 : 1'b0;  \n                dfr <= 1'b0;\n                previous_state <= 3; // Sensor s[3] asserted, others not\n            end\n\t\t\telse if(s[2] == 1)begin\n\t\t\t\tfr3 <= (previous_state != 3 ) ? 1'b1 : 1'b0 ;  \n\t\t\t\tfr2 <= 1'b0;  \n                fr1 <= (previous_state != 2'b11 && previous_state !=2'b01) ? 1'b1 : 1'b0 ;   \n                dfr <= (previous_state == 2'b01 ) ? 1'b1 : 1'b0;  \n\t\t\t\tprevious_state <= 2'b10; // Sensor s[2] asserted, others not\n            end\n\t\t\telse if(s[1]==1)begin\n                fr3 <= (previous_state != 3 && previous_state !=2 ) ? 1'b1 : 1'b0 ;  \n\t\t\t\tfr2 <= (previous_state == 2'b11 || previous_state ==2'b01 ) ? 1'b1 : 1'b0;  \n                fr1 <= 1'b0;   \n                dfr <= (previous_state != 2'b10) ? 1'b1 : 1'b0;  \n\t\t\t\tprevious_state <= 2'b01; // Sensor s[1] asserted, others not\n            end\n\t\t\telse begin\n                fr3 <= 1'b1 ;  \n\t\t\t\tfr2 <= 1'b1 ; \n\t\t\t    fr1 <= 1'b1;      \n                dfr <= (previous_state == 2'b10) ? 1'b1 : 1'b0; // No sensors asserted, open Supplemental flow valve if last level was lower\n\t\t\t\tprevious_state <= 2'b11;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [1:0] state;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 2'b11;\n\t\telse if (!s[3]) \n\t\t\tbegin // Above s[3], no flow\n\t\t\t\tfr1<=0; fr2<=0; fr3<=0; dfr<=0; state <=2'b01;\n\t\t\tend \n\t\telse if (s[3] && !s[2] && !s[1]) // Below s[2], but not below s[3]. Between levels s[3] and s[2].\n\t\t\t begin\n\t\t\t\t fr1<=1;fr2<=0;state <=2'b00; \n\t\t\tif (dfr) dfr <= state [1]; // If previous level was lower than current one, open Supplemental flow valve.\n\t  \t end \n\t\telse if (!s[3] && !s[2]) begin // Below s[1], between levels s[1] and s[2]. \n\t\t\t fr1<=1;fr2<=1;state <=2'b01;\n\t\t\tif (dfr) dfr <= ~state [1]; // If previous level was higher, close Supplemental flow valve.\n\t  \t end\n      else if (!s[3] && !s[2] && !s[1]) begin  // Below s[1]. All four outputs are asserted in this state.\n\t\t\t fr1<=1;fr2<=1;fr3<=1;dfr<=1;state <=2'b10;\n      end \n\tend \nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\n\treg last_s;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tfr3 <= 1'b1;\n\t\t\tfr2 <= 1'b1;\n\t\t\tfr1 <= 1'b1;\n\t\t\tdfr <= 1'b0;\n\t\t\tlast_s <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tif (s[3]) begin // Above s[3]\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b0;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b0;\n\t\t\t\tlast_s <= s[3];\n\t\t\tend \n\t\t\telse if (s[2]) begin // Between s[3] and s[2]\n\t\t\t\tfr3 <= last_s == s[2];\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= fr3 | ~last_s;\n\t\t\t\tdfr <= fr3 & (~last_s ^ s[2]);\n\t\t\t\tlast_s <= s[2];\n\t\t\tend \n\t\t\telse if (s[1]) begin // Between s[2] and s[1]\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= last_s == s[1];\n\t\t\t\tfr1 <= fr2 | ~last_s;\n\t\t\t\tdfr <= fr2 & (~last_s ^ s[1]);\n\t\t\t\tlast_s <= s[1];\n\t\t\tend \n\t\t\telse begin // Below s[1]\n\t\t\t\tfr3 <= 1'b0;\n\t\t\t\tfr2 <= 1'b0;\n\t\t\t\tfr1 <= 1'b1;\n\t\t\t\tdfr <= ~(fr1 | fr2);\n\t\t\t\tlast_s <= s[1];\n\t\t\tend \n\t\tend\n\tend\n\n"}
{"task_id": "ece241_2013_q4", "completion": "\n\treg [2:0] state;\n\tparameter idle = 3'b000;\n\tparameter fr1_state = 3'b001;\n\tparameter fr2_state = 3'b010;\n\tparameter fr3_state = 3'b011;\n\tparameter dfr_state = 3'b100;\n\t\n\t// State transition\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= idle; // equivalent to if the water level had been low for a long time\n\t\telse begin\n\t\t\tcase (s[3:1])\n\t\t\t\t3'b001 : state <= fr1_state;\n\t\t\t\t3'b011 : state <= dfr_state;\n\t\t\t\t3'b100, 3'b101 : state <= fr2_state;\n\t\t\t\t3'b111: state <= fr3_state;\n\t\t\t\tdefault : state <= idle;\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Output assignments\n\tassign {fr3, fr2, fr1, dfr} = state;\n\n"}
{"task_id": "ece241_2013_q4", "completion": "\n    //state variables are declared as wires \n  \twire state0,state1,state2,state3; \n\t \n\t//assigning the states for the water levels\n\tassign state0 = !s[1] && !s[2] && !s[3]; //below s1 \n\tassign state1 = !s[1] && !s[2] || (s[1] && !s[2] && !s[3]); //between s1 and fr2\n\tassign state2 = !s[1] || (s[1] && !s[2]) ;//between s2 and s1 \n\tassign state3 = s[1] && s[2] && s[3]; //above s3\n\t \n    //flow rate assignments for each state\n\talways @(*) begin \n\t\tif (state0)begin\n\t\t\t{fr3, fr2, fr1, dfr} = 4'b1111;//when water level is below lowest sensor\n        end\n\t\telse if (state1) begin\n\t\t\t{fr3, fr2, fr1, dfr} = 4'b0010; //between s[3] and s[2] \n\t\tend\n\t\telse if (state2) begin\n\t\t\t{fr3, fr2, fr1, dfr} = 4'b0011;//between s[2] and s[1]\n        end\n\t\telse if (state3)begin\n\t\t\t{fr3, fr2, fr1, dfr} = 4'b0000; //above s[3] \n         end\n    end\n\t \n\t//reset synchronous to clk\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\t{fr3, fr2, fr1, dfr} <= 4'b1111; //water level is low for a long time\n\tend\n\t \nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) begin\n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b1;\n\t\tdfr <= 1'b1;\n\tend else begin \n\t\tcase(s)\n\t\t\t3'b001: begin // Below s[1]\n\t\t\t\tfr3 <= 1'b0;\n\t\t\t\tfr2 <= 1'b0;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b1;\n\t\t\tend \n\t\t\t3'b011: begin // Between s[1] and s[2]\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b0;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b1;\n\t\t\tend \n\t\t\t3'b010: begin // Between s[2] and s[3]\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b1;\n\t\t\tend \n\t\t\t3'b110: begin // Between s[3] and nothing (Above)\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= 1'b1;\n\t\t\t\tdfr <= 1'b0;\n\t\t\tend \n\t\t\tdefault: begin // Other cases\n\t\t\t\tfr3 <= 1'bx;\n\t\t\t\tfr2 <= 1'bx;\n\t\t\t\tfr1 <= 1'bx;\n\t\t\t\tdfr <= 1'bx;\n\t\t\tend  \n\t\tendcase \n\tend \nend \nendmodule\n"}
{"task_id": "mux256to1v", "completion": "\nassign out = in[(sel+1)*4-1:sel*4];  // Multiplexer Implementation Using Slicing and Concatenation\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\n\t// Convert the 8-bit selector to a 4 bit value for addressing.\n\twire [3:0] sel_bits = {1'b0,sel[2],sel[1],sel[0]};\n\n\t// Create 16 copies of each byte in 'in' and then select from them based on the address given by the lower two bits of the selector.\n\tgenvar i;\n\tgenerate\n\t\tfor(i=0; i<4; ++i) begin : MUXES\n\t\t\tassign out[i] = in[(sel_bits+1'b1)*4-1 -: 1][3-i]; // Generating the muxes using bit slicing.\n\t\tend\n\tendgenerate\nendmodule\n"}
{"task_id": "mux256to1v", "completion": "\n\tassign out = in[(sel*4+3) : sel*4]; // for little endian \n\t// assign out = {in[((sel<<2) + 3)],in[((sel<<2) + 2)],in[((sel<<2) + 1)],in[(sel<<2)]}; // for big endian \nendmodule\n"}
{"task_id": "mux256to1v", "completion": "\n\t// Convert the selector to an index by multiplying it by 4 and adding a base index of 'b0001_0000 (which is decimal 16),\n    // then use that index to select 4 bits from in[].\n\tassign out = in[(sel << 2) +: 4];\nendmodule\n"}
{"task_id": "mux256to1v", "completion": "\n\tassign out = in[(sel+1)*4-1:(sel*4)];\nendmodule \n"}
{"task_id": "mux256to1v", "completion": "\n    assign out = in[((sel+1)*4)-1: sel*4]; \nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\n\tassign out = in[(sel+1)*4-1:(sel*4)];  // select bits from input based on selection.\n\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n   assign out = in[(sel+1)*4-1:sel*4];\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\tassign out = in[(sel*4)+3 : (sel*4)]; \nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\nassign out = in[((sel+1)*4)-1:sel*4];  // +1 is for converting from binary to base-10 indexing.\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\n\tassign out = in[(sel+1)*4-1:sel*4];\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\nassign out = in[((sel+1)*4)-1 : sel*4];\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\n\tassign out = in[(sel+1)*4-1 : sel*4]; \n\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\nassign out = in[((sel+1)*4)-1: sel*4];\nendmodule\n"}
{"task_id": "mux256to1v", "completion": "\n\tassign out = in[((sel+1)*4)-1 : sel*4];\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\t// Define the multiplexer using a case statement to determine which 4-bit slice of 'in' is selected based on 'sel'.\n\tassign out = sel[2:0] < 3 ? in[(sel+1)*4-1 : (sel*4) - 1 -: 4] : {4{1'bX}};\nendmodule\n"}
{"task_id": "mux256to1v", "completion": "\n\tassign out = in[(sel+1)*4-1:(sel*4)];\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\tassign out = in[(sel*4)+3 : sel*4];  //calculation of the start and end bit of a specific selection\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\n\tassign out = in[(sel+4'd1)*4-1 : sel*4];\nendmodule\n\n"}
{"task_id": "mux256to1v", "completion": "\n\n\tassign out = in[(sel+4) * 4 - 1 : sel*4];\n\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\tassign sum = a ^ b;  // Sum is XOR of two inputs\n\tassign cout = a & b;  // Carry out is AND of two inputs\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n    \n    assign sum = a ^ b;\n    assign cout = a & b; \nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n   assign sum = a^b;  // XOR gate for sum\n   assign cout = a&b;  // AND gate for carry out\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\n\tassign sum = a ^ b; // Sum is XOR of two bits\n\tassign cout = a & b; // Carry out is AND operation on two bits\n\t\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n    assign sum = a ^ b;\n\tassign cout = a & b;\nendmodule \n\n"}
{"task_id": "hadd", "completion": "\n    assign sum = a ^ b;\n    assign cout = a & b;\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n    assign sum = a ^ b;\n    assign cout = a & b; \nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\tassign sum = a ^ b;  // XOR gate to calculate sum\n\tassign cout = a & b;  // AND gate to calculate carry-out\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n   assign sum = a ^ b;\n   assign cout = a & b;\n   \nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\tassign sum = a ^ b;\n\tassign cout = a & b;\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\nassign sum = a ^ b;\nassign cout = a & b;\nendmodule\n"}
{"task_id": "hadd", "completion": "\n    \n    assign sum = a ^ b; // XOR Gate\n    assign cout = a & b; // AND Gate \n      \nendmodule\n  \n"}
{"task_id": "hadd", "completion": "\n\tassign sum = a ^ b;\n\tassign cout = a & b;\nendmodule\n"}
{"task_id": "hadd", "completion": "\n  \nassign sum = a ^ b;\nassign cout = a & b; \n\nendmodule \n\n"}
{"task_id": "hadd", "completion": "\n\n\tassign sum = a ^ b;\n\tassign cout = a & b;\n\t\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\tassign sum = a ^ b; \t// XOR for sum\n\tassign cout = a & b;\t// AND for carry out\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n  assign sum = a ^ b;\n  assign cout = a & b;\n  \nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n    \n    assign sum = a ^ b;  // XOR Gate for Sum\n    assign cout = a & b;  // AND Gate for Carry-out\n  \nendmodule\n"}
{"task_id": "hadd", "completion": "\n\n\tassign sum = a ^ b;\n    assign cout = a & b;\nendmodule\n\n"}
{"task_id": "hadd", "completion": "\n\tassign sum = a ^ b;  // XOR operator to compute the sum of inputs\n\tassign cout = a & b; // AND operator to compute carry out\nendmodule\n\n"}
{"task_id": "circuit9", "completion": "\n\talways @(posedge clk or posedge a) begin\n    \tif (a == 1'b1)\n        \tq <= 3'd7; // If a is high reset to 7\n    \telse if (clk == 1'b1)\n          q <= {q[2:0], q[2]}; // else rotate right on clock pulse\n    end\nendmodule\n\n"}
{"task_id": "circuit9", "completion": "\nwire c;\nassign c = a&~q[0];\nalways @(posedge clk) begin\n\tq <= {c, q[2:1]};\nend\n\n"}
{"task_id": "circuit9", "completion": "\ninteger i;\ninitial begin\n    i = 7'b0000011; // Initialize to some value other than zero.\nend\n\nalways @(posedge clk) \nbegin\n\tif (a == 1'b1) \n\t\ti <= {i[5:0], i[6]};    // Rotate right\n\telse if(a == 1'b0) \n        \ti <= {i[4:0], i[6]};   // Rotate left\nend\nassign q = i[2:0];\n\n"}
{"task_id": "circuit9", "completion": "\ninitial begin\n        q = 3'b0;\n    end\n\n    always @(posedge clk) begin\n        case({a,q}) // state transition\n            2'b10 : q <= 3'd4 ;  // from q=0 to q=4 when a=0\n            2'b11 : q <= 3'd7 ;  // from q=0 to q=7 when a=1\n            2'b00 : q <= 3'd0 ;  // hold at q=0 when a=0\n            default: q <= q;      // otherwise, keep the state.\n        endcase  \n    end\nendmodule\n"}
{"task_id": "circuit9", "completion": "\ninteger i;\n\talways @(posedge clk) begin\n\t\tif(!a) begin\n\t\t\tfor(i=0; i<7; i++)\n\t\t\t\tq[i] <= #1 ~q[i+1];\n\t\tend else\n\t\t\tq <= 3'b0;\n\tend\nendmodule\n"}
{"task_id": "circuit9", "completion": "\n    always @(posedge clk) begin\n        if(a==1'b1) begin\n            case (q)\n                3'd4:   q <= 3'd5;  // jumps to 5 on rising edge of clock when q=4\n                3'd6:   q <= 3'd0;  // wraps around to 0 on rising edge of clock when q=6\n                default : q <= q + 1;  // for all other values, increment by one on every rising edge\n            endcase\n        end\n    end\t\nendmodule\n"}
{"task_id": "circuit9", "completion": "\n\treg [2:0] temp;\n\n\talways @(posedge clk or posedge a) begin\n\t    if(a == 1'b1) begin\n\t        temp <= 3'd0;  \n\t\t  end \n\t\telse begin\n\t\t    temp <= {temp[1:0], temp[2]};      // Right rotate by one bit.\n        end\n\tend\n    \n\tassign q = temp;\nendmodule\n"}
{"task_id": "circuit9", "completion": "\n\t// Create a variable to store the current state of the counter. Initialize it to zero.\n\treg [1:0] cntr;\n\tinitial cntr = 2'b00;\n\t\n\talways @(posedge clk) begin\n\t\tif (a == 1'b1) \n\t\t\tcntr <= cntr + 2'b01; // Increment the counter by 1 when a is high.\n\t\t\t\n\t\tcase (cntr) \t// Depending on the current state of the counter, assign different outputs to q.\n\t\t\t2'b00: q <= 3'b000;\n\t\t\t2'b01: q <= 3'b001;\n\t\t\t2'b10: q <= 3'b010;\n\t\t\t2'b11: q <= 3'b100;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"task_id": "circuit9", "completion": "\n\treg [3:0] counter;\n  \n\talways @(posedge clk) begin\n\t\tif(!a)\n\t\t\tcounter <= 4'd0;\n\t\telse if (counter < 4'd7)\n\t\t\tcounter <= counter + 1;\n\tend\n\tassign q = counter[2:0];\nendmodule\n\n"}
{"task_id": "circuit9", "completion": "\n\treg [2:0] nextstate;\n\n\talways @(posedge clk) begin\n\t\tcase (q)\n\t\t\t3'b000: if (a == 1'b1) \n\t\t\t\t\t\tnextstate <= 3'b001;\n\t\t\t\t\telse \n\t\t\t\t\t\tnextstate <= q;\n\t\t\t3'b001: if (a == 1'b1) \n\t\t\t\t\t\tnextstate <= 3'b010;\n\t\t\t\t\telse \n\t\t\t\t\t\tnextstate <= 3'b000;\n\t\t\t3'b010: if (a == 1'b1) \n\t\t\t\t\t\tnextstate <= 3'b011;\n\t\t\t\t\telse \n\t\t\t\t\t\tnextstate <= q;\n\t\t\t3'b011: if (a == 1'b1) \n\t\t\t\t\t\tnextstate <= 3'b100;\n\t\t\t\t\telse \n\t\t\t\t\t\tnextstate <= 3'b000;\n\t\t\t3'b100: if (a == 1'b1) \n\t\t\t\t\t\tnextstate <= q;\n\t\t\t\t\telse \n\t\t\t\t\t\tnextstate <= 3'b001;\n\t\t\tdefault: nextstate <= 3'bx;\n\t\tendcase\n\tend\n\n\t// register the next state and output it to q\n\talways @(posedge clk) begin\n\t\tq <= nextstate;\n\tend\nendmodule \n\n"}
{"task_id": "circuit9", "completion": "\n\n\t// State encoding \n\t// 0 -> 4 -> 5 -> 6 -> \"0\" \n\t//     ^     |_____|\n\t//     |______________|\n\treg[1:0] state;\n\n\talways @(posedge clk) begin\n\t\tcase (state)\n\t\t\t2'h0 : if(a == 1) state <= 2'h1; // If a is 1, move to next state. Stay at state 0 otherwise.\n\t\t\t2'h1 : if(a == 1) state <= 2'h2; // If a is 1, move to next state. Stay at state 4 otherwise.\n\t\t\t2'h2 : if(a == 0) state <= 2'h3; // If a is 0, move to next state. Stay at state 5 otherwise.\n\t\t\tdefault: state <= 2'h0;           // Reset the state machine on all other cases. Go back to state 6.\n\tend\n\t\n\t// Output decoding\n\tassign q = (state == 2'h3) ? 3'b001 : // If we are in state \"0\", output 4\n\t            (state == 2'h2) ? 3'b010 : // If we are in state \"4\", output 5\n\t\t\t    (state == 2'h1) ? 3'b011 : // If we are in state \"5\", output 6\n\t\t\t\t3'b100;                      // In any other case, output \"0\"\nendmodule\n"}
{"task_id": "circuit9", "completion": "\n  \n    always @(posedge clk or posedge a) begin\n        if (!a)\n            q <= 3'b1;\n\t    else\n\t        case (q) \n\t\t      3'b111: q <= 3'b000;\n              \tdefault: q <= q + 1'b1;\n  \t\t    endcase\n     end\nendmodule\n"}
{"task_id": "circuit9", "completion": "\n\t// Implemented based on the table given in question description.\n\treg [1:0] state = 2'b00;\n\t\n\talways @(posedge clk) begin\n\t\tcase (state)\n\t\t    2'b00 : if (!a) \n\t\t\t        state <= 2'b00; // q=000\n\t\t           else  \n\t\t\t         state <= 2'b11; // q=111\n\t\t     2'b01 : if (!a) \n\t\t\t        state <= 2'b10; // q=100\n\t\t           else \n\t\t\t         state <= 2'b00; // q=000\n\t\t     2'b10 : if (!a) \n\t\t\t        state <= 2'b11; // q=111\n\t\t           else  \n\t\t\t         state <= 2'b01; // q=011\n\t\t     2'b11 : if (!a) \n\t\t\t        state <= 2'b00; // q=000\n\t\t           else  \n\t\t\t         state <= 2'b10; // q=100\n\t\tendcase\n\tend\n\t\n\t// Assign output based on the current state.\n\tassign q = (state == 2'b00) ? 3'b000 : \n\t\t   (state == 2'b01) ? 3'b100 : \n\t\t   (state == 2'b10) ? 3'b111 : 3'b011;\nendmodule\n"}
{"task_id": "circuit9", "completion": "\n\talways @(posedge clk) begin\n\t\tif(!a) begin\n\t\t\tcase (q)\n\t\t\t\t3'b001 : q <= 3'b010;\n\t\t\t\t3'b010 : q <= 3'b100;\n\t\t\t\t3'b100 : q <= 3'b001; \n\t\t\t\tdefault: q <= 3'b000;  // default value in case of any other value.\n\t\t\tendcase\n\t\tend else begin\n\t\t\tcase (q)\n\t\t\t\t3'b001 : q <= 3'b000;\n                3'b010 : q <= 3'b001;\n                3'b100 : q <= 3'b010; \n                default: q <= 3'b000; // default value in case of any other value.\n\t\t\tendcase\n\t\tend\n\tend\n\t\nendmodule\n"}
{"task_id": "circuit9", "completion": "\ninitial begin\n\tq = 3'b0;\nend\n\nalways @(posedge clk) begin\n\tcase({a , q}) \n\t\t4'b1000 : q <= 3'd0 ; // When a=0 and q is 8 (overflow) reset to 0.\n    \t4'b0111 : q <= 3'd7 ; // When a=1 and q is 7 increment by 1.\n\t\t4'b0110 : q <= 3'd6 ; // When a=1 and q is 6 increment by 1.\n\t\t4'b0101 : q <= 3'd5 ; // When a=1 and q is 5 increment by 1.\n\t\t4'b0100 : q <= 3'd4 ; // When a=1 and q is 4 increment by 1.\n    \t4'b0011 : q <= 3'd3 ; // When a=1 and q is 3 increment by 1.\n\t\t4'b0010 : q <= 3'd2 ; // When a=1 and q is 2 increment by 1.\n\t\t4'b0001 : q <= 3'd1 ; // When a=1 and q is 1 increment by 1.\n\tendcase\nend\n\n"}
{"task_id": "circuit9", "completion": "\ninteger i;\n    always @(posedge clk) begin\n        if (!a) begin\n            for (i=0; i<3; i++) begin\n                q[i] <= q[i+1];\n            end\n        end else begin\n            q <= 3'b001;\n        end \n    end\nendmodule\n"}
{"task_id": "circuit9", "completion": "\ninitial begin\n    q = 3'b0;\nend\nalways @(posedge clk) begin\n\tif(!a && q == 3'd7)\n        q <= 3'd0;\n\telse if (!a) \n\t     q <= q + 1;  \nend\nendmodule\n"}
{"task_id": "circuit9", "completion": "\ninteger i; // Declare an integer to use as counter\n    always @(posedge clk) begin     // Wait for positive clock edge\n        if (a == 1'b1)               // Check the input 'a'. If it is 1, then increase q by one.\n            q <= q + 1;             \n        else                        // If not, keep counting and outputting same value in q until a 1 appears again\n            for(i = 0; i < 3 ; i = i +1 ) begin  \n                if (q == i+1)\n                    q<=i;\n\tend\n    end\nendmodule\n"}
{"task_id": "circuit9", "completion": "\n\treg [2:0] nextState; // next state of the FSM\n\n\t// State transition\n\talways @(posedge clk) begin\n\t    case (q)\n\t\t    3'b000 : if (a == 1) nextState <= 3'b001; else nextState <= q;\n\t\t    3'b001 : if (a == 1) nextState <= 3'b010; else nextState <= q;\n\t\t    3'b010 : if (a == 1) nextState <= 3'b100; else nextState <= q;\n\t\t    3'b100 : if (a == 1) nextState <= 3'b000; else nextState <= q;  //back to zero\n\t\t    default: nextState <= 3'b000;\n\t    endcase\n\tend\n\t \n\t// Output Logic\n\tassign q = nextState;  \n\nendmodule \n"}
{"task_id": "circuit9", "completion": "\n\treg [2:0] state; //register to hold the current state\n\t\n\t//state transition table\n\talways @(posedge clk) begin  \n        case ({state, a}) \n            4'b0000 : state <= 3'b001;\n            4'b0001 : state <= 3'b011;\n            4'b0010 : state <= 3'b001;\n            4'b0011 : state <= 3'b000; //dead end here (sink state)\n            default : state <= 3'b000; \n        endcase\n    end  \n\tassign q = state;\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n\t\tif(!j && !k) // Case J = 0 and K = 0 \n\t\t\tQ <= Q;   // Hold the output.\n\t\telse if (!j && k) //Case J=0 and K=1\n\t\t\tQ <= 0;    // Reset Output to zero.\n\t\telse if (j && !k) // Case J=1 and K =0 \n\t\t\tQ <= 1;     // Set output to one.\n\t\telse if(j&& k)// Case J=1 and K=1\n\t\t\tQ <= ~Q;    // Toggle the output.\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\n    always @(posedge clk) begin\n        if (!j && !k) \n            Q <= Q;\n        else if(!j && k) \n            Q <= 0;\n        else if(j && !k)  \n            Q <= 1;\n        else  if(j && k)  \n            Q <= ~Q;\n    end\n\t\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\nalways @(posedge clk) begin\n\tif((j == 1'b0) && (k == 1'b0)) \n\t\tQ <= Q;\n\telse if ((j == 1'b0) && (k == 1'b1)) \n\t\tQ <= 1'b0;\n\telse if ((j == 1'b1) && (k == 1'b0)) \n\t\tQ <= 1'b1;\n\telse if ((j == 1'b1) && (k == 1'b1)) \n\t\tQ <= ~Q;\nend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n\t\tif(!j && !k) \n\t\t\tQ <= Q; // Do nothing as Q stays the same\n\t\telse if (!j && k)\n\t\t\tQ <= 0; // Set Q to zero\n\t\telse if (j && !k)\n\t\t\tQ <= 1; // Set Q to one\n\t\telse if (j && k) \n\t\t\tQ <= ~Q; // Toggle Q\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (!j && !k)\n\t\t\t// do nothing; keep the state as it is \n\t\t\tQ <= Q;\n\t\telse if (!j && k)\n\t\t\t// reset to zero\n\t\t\tQ <= 0;\n\t\telse if (j && !k)\n\t\t\t// set to one\n\t\t\tQ <= 1;\n\t\telse if (j && k)\n\t\t\t// invert the state\n\t\t\tQ <= ~Q;\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n    \tif ((j == 1'b0) && (k == 1'b0)) \n        \tQ <= Q;\n      \telse if ((j == 1'b0) && (k == 1'b1))  \n        \tQ <= 1'b0;\n      \telse if ((j == 1'b1) && (k == 1'b0))\n         \tQ <= 1'b1;\n        else \n        \tQ <= ~Q;\n    end\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n\t\tif(!j & !k)  // J = 0 and K = 0\n\t\t\tQ <= Q;  // No Change\n\t\telse if(!j & k) // J=0 and K =1\n\t\t\tQ <= 0; // Reset\n\t\telse if(j & !k )//J =1 and K =0\n\t\t\tQ <= 1; // Set\n\t\telse if(j & k)  //J =1 and K = 1\n\t\t\tQ <= ~Q;    // Toggle\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n\t    if (!j && !k) \n\t        Q <= Q; // same as JK Flip-flop truth table state 1\n\t    else if (!j && k)  \n\t        Q <= 0;  // same as JK Flip-flop truth table state 2\n        else if (j && !k) \n            Q <= 1;   // same as JK Flip-flop truth table state 3\n\t    else if (j && k)   \n\t        Q <= ~Q; // same as JK Flip-flop truth table state 4\t\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\nalways @(posedge clk) begin\n\tif (!j && !k) \n\t\tQ <= Q;\n\telse if(!j && k)  \n\t\tQ <= 0;\n\telse if(j && !k) \n\t\tQ <= 1;\n\telse if(j && k)  \n\t\tQ <= ~Q;\nend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n\t\tif (!j && !k) \n\t\t\tQ <= Q;\n\t\telse if (!j && k) \n\t\t\tQ <= 0;\n\t\telse if (j && !k) \n\t\t\tQ <= 1;\n\t\telse if (j && k) \n\t\t\tQ <= ~Q;\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n\t\tif(!j && !k)  // J=0 and K=0 => hold current state of flip flop (Qold).\n\t\t\tQ <= Q;\n\t\telse if (!j && k)  // J=0 and K=1 => 0.\n\t\t\tQ <= 0;\n\t\telse if (j && !k) // J=1 and K=0 => 1.\n\t\t\tQ <= 1;\n\t\telse if(j && k)   // J=1 and K=1 => invert current state of flip flop. \n\t\t\tQ <= ~Q;\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n    \tif (!j && !k) // Case 0, 0\n        \tQ <= Q;\n        else if (!j && k) // Case 0, 1\n        \tQ <= 0;\n        else if (j && !k) // Case 1, 0\n        \tQ <= 1;\n        else if (j && k) // Case 1, 1\n        \tQ <= !Q;\n    end\nendmodule\n\n"}
{"task_id": "ece241_2013_q7", "completion": "\n    always @(posedge clk) begin\n        if(!j && !k) \n            Q <= Q; //same as Qold\n        else if(!j && k) \n            Q <= 0;\n        else if(j && !k) \n            Q <= 1;\n        else if (j && k) \n            Q <= ~Q; //not Qold\n    end\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n\t\tif (~j & ~k) // J=0 and K=0\n\t\t\tQ <= Q;\n\t\telse if (~j & k) // J=0 and K=1\n\t\t\tQ <= 0;\n\t\telse if (j & ~k) // J=1 and K=0\n\t\t\tQ <= 1;\n\t\telse if (j & k) // J=1 and K=1\n\t\t\tQ <= ~Q;\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\talways @(posedge clk) begin\n    \tif(!j && !k) \n        \tQ <= Q;\n      \telse if (!j && k) \n\t\t\tQ <= 0;\n        else if (j && !k) \n        \tQ <= 1;\n      \telse if (j && k) \n          \tQ <= ~Q;\n    end\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\n    always @(posedge clk) begin\n        if(!j & !k)\n            Q <= Q; // maintains previous state\n        else if(!j & k) \n            Q <= 0; // sets output to 0\n        else if (j & !k)\n            Q <= 1; //sets output to 1\n        else if(j& k)\n           Q <= ~Q;//toggle the flip flop state\n    end\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n    \n\talways @(posedge clk) begin\n\t    if (!j && !k) \n\t        Q <= Q;\n\t    else if (!j && k) \n\t        Q <= 0;\n\t    else if (j && !k) \n\t        Q <= 1;\n\t    else if (j && k) \n\t        Q <= ~Q;\n\tend\n\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\n\t// JK Flip-Flop logic\n\talways @(posedge clk) begin\n\t    if (!j & !k) \n            Q <= Q; // hold the previous value of Q (Qold)\n        else if (!j & k) \n            Q <= 0; // set Q to 0 on a falling clock edge\n        else if (j & !k) \n            Q <= 1; // set Q to 1 on a rising clock edge\n        else if (j & k) \n            Q <= ~Q; // toggle Q at the rising clock edge\n\tend\n\t\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\nalways @(posedge clk) begin\n    if (!j && !k)\n        Q <= Q;\n    else if (!j && k)\n        Q <= 0;\n    else if (j && !k)\n        Q <= 1;\n    else if (j && k) \n        Q <= ~Q;\nend\n\t\n"}
{"task_id": "ece241_2013_q7", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif ((j==0)&(k==0)) // J=0 & K=0\n\t\t\tQ <= Q; // Do nothing\n\t\telse if((j==0)&(k==1))//J=0 & K=1\n\t\t\tQ <= 0;// Reset Q to 0\n\t\telse if ((j==1)&(k==0))// J=1 & K=0\n\t\t\tQ <= ~Q; // Invert Q value\n\t\telse if((j==1)&(k==1))//J=1 & K=1\n\t\t\tQ <= !Q;// Toggle Q value\n\tend\nendmodule\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = ~vibrate_mode & ring;\n\tassign motor = vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = !vibrate_mode && ring;\n\tassign motor = vibrate_mode || ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = ~vibrate_mode & ring; // when the phone is in incoming call and not in vibration mode\n\tassign motor = vibrate_mode | ring;   // when the phone is in vibration mode or an incoming call \nendmodule\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = ~vibrate_mode & ring;\n\tassign motor = vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\nassign ringer = ring & ~vibrate_mode;\nassign motor = (ring | vibrate_mode) & ~ring;\n\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\n\tassign ringer = ~vibrate_mode & ring;\n\tassign motor = vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n   assign motor = (ring | vibrate_mode);\n   assign ringer = ~((ring | vibrate_mode));\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n   assign ringer = ~vibrate_mode & ring;\n   assign motor = vibrate_mode | ring;\n   \nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n    assign ringer = ring && !vibrate_mode;\n    assign motor = ~ring || vibrate_mode;\n    \nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n   assign ringer = !vibrate_mode & ring;\n   assign motor = vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = ring & ~vibrate_mode;\n    assign motor = (ring | vibrate_mode) & ~ring;\nendmodule \n\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = ~vibrate_mode & ring;\n\tassign motor = vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = ~vibrate_mode & ring;\n\tassign motor = vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\tassign ringer = ring && !vibrate_mode;\n    assign motor = (ring || vibrate_mode) ;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\n\tassign ringer = !vibrate_mode && ring;\n\tassign motor = vibrate_mode || ring;\nendmodule\n"}
{"task_id": "ringer", "completion": "\n   assign ringer = !vibrate_mode & ring;\n   assign motor  = vibrate_mode | ring;\n   \nendmodule\n\n"}
{"task_id": "ringer", "completion": "\nassign ringer = ~vibrate_mode & ring;\nassign motor = vibrate_mode | ring;\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\nassign ringer = (vibrate_mode == 1'b0) ? ring : 1'b0;\nassign motor = (vibrate_mode == 1'b1) ? 1'b1 : ring;\t\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n    \n    assign ringer = ~vibrate_mode & ring;\n    assign motor = vibrate_mode | ring;\n\nendmodule\n\n"}
{"task_id": "ringer", "completion": "\n\t// ringer and motor should be active low since they are normally open (0 = on)\n\tassign ringer = ~(ring | vibrate_mode);  // if there's a ring or vibration mode is activated, turn off the ringer\n\tassign motor = ~(ring & vibrate_mode);   // if only there's no call and no vibration mode then it should be on, otherwise off.\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\t// state definitions \n\tlocalparam IDLE = 2'b01;\n\tlocalparam START_BIT = 2'b10;\n\tlocalparam DATA = 2'b11;\n\t\n\t//register definition\n\treg [1:0] current_state, next_state;\n\treg [3:0] bit_counter;  // to count from 0-9 (data bits + start + 8 data + 1 stop)\n\treg done_r;  \n\n\t// state transition and outputs\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) begin\n\t\t\tcurrent_state <= IDLE;\n\t\t\tbit_counter <= 4'b0;\n\t\t\tdone_r <= 1'b0; \n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tbit_counter <= bit_counter + 4'b1;\n\t\t\t\tif(next_state == IDLE) \n\t\t\t\t\tdone_r <= 1'b0; \n\t\t\t\telse if (bit_counter == 9 && current_state != START_BIT )   // check for stop bit when data is read completely.\n\t\t\t\t\tdone_r <= 1'b1; \t\t\n\t\tend\n\tend \n\n\t// next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tIDLE: if(!in)       // idle and start bit detected\n\t\t\t\tnext_state = START_BIT;  \n\t\t\telse             // not in IDLE, stay at the same state.\n\t\t\t\tnext_state = current_state; \n\t\t\t\t\n\t\t\tSTART_BIT: begin     // read all 8 data bits when start bit is found\n\t\t\t\tif(bit_counter == 9)  \n\t\t\t\t\tnext_state = DATA;\n\t\t\t\telse             \n\t\t\t\t\tnext_valid_state = START_BIT;    // stay at START_BIT until 7 more bits are received.\n\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\tDATA: begin         // wait for stop bit after reading data\n\t\t\t\tif(bit_counter == 9)  \n\t\t\t\t\tnext_state <= IDLE;     // start receiving next byte, go back to idle when stop bit is detected\n\t\t\t\telse \n\t\t\t\t\tnext_state = DATA;    // stay at DATA till all 8 bits are received\n\t\t\tend\n\t\t\t\t\t\n\t\t\tdefault: next_state = IDLE ;  \n\tendcase\n\tend\n\tassign done = done_r;\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\t// Define states\n\ttypedef enum logic [1:0] {IDLE=2'b00, START=2'b01, RECEIVE=2'b10} state_t; \n\tstate_t state, next_state;\n\tlogic [2:0] bit_counter; // Counter for the 8 data bits.\n\t\n\t// FSM State register\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\t// Next state logic and output decoder\n\talways_comb begin\n\t\tcase(state) \n\t\t\tIDLE: if (in == 1'b0) // Waiting for start bit\n\t\t\t\tnext_state = START;\n\t\t\telse \n\t\t\t\tnext_state = IDLE;\n\t\t\t\t\n\t\t\tSTART: if (bit_counter < 3'd8) \n\t\t\t\t// Still receiving data bits. Count them and stay in this state.\n\t\t\t\tnext_state = RECEIVE;\n\t\t\telse if(in == 1'b1) // If the start bit is found, move to next byte without waiting.\n\t\t\t\tnext_state = START;\n\t\t\t\t\n\t\t\tRECEIVE: if (bit_counter < 3'd9) \n\t\t\t\t// Still receiving more data bits. Count them and stay in this state.\n\t\t\t\tnext_state = RECEIVE;\n\t\t\telse // When all the 8+1 data bits have been received, wait for stop bit.\n\t\t\t\tnext_state = IDLE;\n\t\t\t\t\n\t\t\tdefault: next_state = IDLE; // Default to idle in case of error\n\t\tendcase\n\tend\n\t\n\t// Output decoder\n\tassign done = (state == RECEIVE) & (bit_counter == 3'd9); // If we are at the RECEIVE state and have received all 9 bits, signal that a byte has been completely transmitted.\n\t\t\n\talways @(posedge clk or posedge reset) begin\n\t  if(reset) \n\t    bit_counter <= 0; // Reset counter on synchronous reset\n\t  else if (state == RECEIVE & in == 1'b1)\n\t    bit_counter <= bit_counter + 3'd1; // Increment the data bit count.\n\tend\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\n\treg [3:0] state;\n   reg [2:0] count;\n\n\t// State definitions\n\tparameter S0 = 4'b0000;  // Idle\n\tparameter S1 = 4'b0001;  // Start bit detected, waiting for first data bit.\n\tparameter S2 = 4'b0010;  // Waiting for second data bit.\n   parameter S3 = 4'b0011;  // Waiting for third data bit.\n   parameter S4 = 4'b0100;  // Waiting for fourth data bit.\n\tparameter S5 = 4'b0101;\t// Waiting for fifth data bit.\n   parameter S6 = 4'b0110;  // Waiting for sixth data bit.\n\tparameter S7 = 4'b0111;  // Waiting for seventh data bit.\n\tparameter S8 = 4'b1000;  // Waiting for eighth data bit.\n\tparameter S9 = 4'b1001;\t// Stop bit detected, check if it is '1'. If not wait until the stop bit becomes '1'.\n\t\n   assign done = (state == S9) && in;\n   \n\talways @(posedge clk or posedge reset) begin\n\t\t\tif (reset == 1'b1) begin\n\t\t\t\tcount <= 3'h0;  // Reset count to 0.\n            state <= S0;   // Go back to idle state.\n         end else begin\n             case (state)\n                 S0: if(in==1'b0) state <= S1;\t// If start bit detected, move to next state.\n                 \n                 S1: if(count == 3'h7)begin count <= 3'h8;state<=S9;end else begin state <= S2; count <= count + 1; end  // If all bits are received then move to stop bit detection state and reset the counter. Else continue receiving data bits.\n                 \n                 S2: if(count == 3'h7)begin count <= 3'h8;state<=S9;end else begin state <= S3; count <= count + 1; end  // Repeat the same process as above for other states of data bits.\n                 \n                 S3: if(count == 3'h7)begin count <= 3'h8;state<=S9;end else begin state <= S4; count <= count + 1; end  \n                  \n                 S4: if(count == 3'h7)begin count <= 3'h8;state<=S9;end else begin state <= S5; count <= count + 1; end \n                 \n                 S5: if(count == 3'h7)begin count <= 3'h8;state<=S9;end else begin state <= S6; count <= count + 1; end  \n                  \n                 S6: if(count == 3'h7)begin count <= 3'h8;state<=S9;end else begin state <= S7; count <= count + 1; end \n                 \n                 S7: if(count == 3'h7)begin count <= 3'h8;state<=S9;end else begin state <= S8; count <= count + 1; end  \n                  \n                 S8: if(count == 3'h7)begin count <= 3'h8;state<=S9;end else begin state <= S2; count <= count + 1; end  // Repeat the same process as for start bit but now data bits are being counted from 0 to 7.\n                 \n                 default: state <= S0;   // If no valid states detected then go back to idle state.\n            \tendcase\n         end\n    end\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\nparameter START = 2'b01;\n\tparameter DATA  = 2'b10;\n\t\n\treg [1:0] state = START;\n\treg [7:0] counter = 8'd0;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'h1) begin\n\t\t\tstate <= START;\n\t\t\tcounter <= 8'd0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\t\tcase (state) \n\t\t\t\t\tSTART: \n\t\t\t\t\t\tif (in == 1'h0) begin\n\t\t\t\t\t\t\tstate <= DATA;\n\t\t\t\t\t\t\tcounter <= 8'd0;\n\t\t\t\t\t\tend\n\t\t\t\t\tDATA: \n\t\t\t\t\t\tif (in == 1'b1 && counter == 8'd7) begin\n\t\t\t\t\t\t\tdone <= 1'b1;\n\t\t\t\t\t\tend else if(in == 1'b1 && counter < 8'd7) begin\n\t\t\t\t\t\t\tcounter <= counter + 1'h1;\n\t\t\t\t\t\tend else if (in == 1'b0) begin \n\t\t\t\t\t\t\tstate <= START;\n\t\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\tend\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\treg [3:0] state; \n   parameter s_idle = 4'b0001, \n             s_startbit = 4'b0010, \n\t\t\t       s_data = 4'b0100, \n\t\t\t\t     s_stopbit = 4'b1000;\n\twire data_in = in; // To read the serial input bit from top module\n  \n   always @(posedge clk or posedge reset) begin\n      if (reset) state <= s_idle; \n\t  else begin\n        case (state)\n          s_idle:       if (data_in == 1'b0) state <= s_startbit; // Wait for start bit = 0\n          \n\t\t    s_startbit :     if (data_in == 1'b1) state <= s_data;   // If start bit is 0, wait for data bits\n          \n\t\t\t\ts_data:      \tif (&state[2:0]==1'b1) state <= s_stopbit;    // When all 8 data bits received, go to stop bit check\n\t\t\t\t\n\t\t    s_stopbit:   if (data_in == 1'b1 ) state <= s_idle;\t\t// If Stop bit is correct, reset state to idle for next byte\n          \n\t\t\t\tdefault :     state <= s_idle;  // To ensure that the FSM stays in one of these states.\n        endcase\n      end  \n   end\n\t  assign done = (state == s_stopbit) ? 1'b1: 1'b0; // If the last transition was to stop bit state, then byte received properly and set done high.\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n   reg [3:0] state;\n   \n   parameter IDLE = 4'b0001, START = 4'b0010, DATA = 4'b0100, STOP = 4'b1000; //State declarations \n\t\n\talways @(posedge clk or posedge reset) begin //synchronous block to handle synchronous and active-high reset condition\n\t  if (reset == 1) state <= IDLE; // resetting the state machine to idle upon receiving reset pulse\n\t  else begin\n\t\t\tcase (state) \n\t\t\t\tIDLE: \tif(in==0) state <= START;\t//Waiting for start bit\n\t\t\t\t\t\telse state <= IDLE; //If start bit not received, remain in idle\n\t\t\t\t\n\t\t\t\tSTART: if(in==1) state <= DATA; //Once start bit is received, move to data receiving stage \n\t\t\t\t\t\telse state <= IDLE; //If no start bit detected, return back to idle state\n\t\t\t\t\t\t\n\t\t\t\tDATA: \tif(in==0) state <= STOP;\t//Waiting for stop bit after all data bits are transmitted.\n\t\t\t\t\t\telse state <= DATA;//If not at the stop stage yet remain in data receiving stage\n\t\t\t\t\n\t\t\t\tSTOP: done <= 1; //When a valid stop bit is received, signal that byte has been successfully received\n\t\t\t\t\t  if(in==0) state <= IDLE;\t//Wait for start of another byte from host again. If no more bits detected return to idle state.\n\t\t\t endcase\n\t  end\n\tend\nendmodule\n\n"}
{"task_id": "fsm_serial", "completion": "\n\n    reg [3:0] counter;\n    reg shiftreg; // To store the received bits\n    \n    typedef enum {WAIT_START, DATA, WAIT_STOP} state_t;\n    state_t state, nextstate; \n\t\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n\t        state <= WAIT_START;   // Asynchronous reset\n\t    else\n    \t    state <= nextstate;      // Synchronous state transition \n    end\n\n    // Next-state and output logic\n    always @(*) begin\n        case(state)\n            WAIT_START: if (in == 0 )  nextstate = DATA ;else nextstate = WAIT_START;  \n            DATA :      if (!shiftreg[7] && counter==8) nextstate = WAIT_STOP; else nextstate = DATA ; // If we have received all bits, go to wait stop state. 0th bit of shift register checks if all data bits are received.\n            WAIT_STOP : if (in == 1 )  nextstate = WAIT_START;else nextstate = WAIT_STOP;  \n        endcase \n        \n      done = (state == WAIT_STOP && in == 1); // If we reached the wait stop state with a stop bit, then transmission is complete.   \n    end\n    \n\t// Shift register and counter logic\n\talways @(posedge clk) begin\n\t    if (!reset) begin  // Asynchronous reset\n            shiftreg <= {in , shiftreg[7:1]};  // Shift in the new bit at LSB, drop oldest bit from MSB end.\n    \t    if (state == DATA && counter < 8 )    counter <= counter+1; \n\t        else if(state == WAIT_STOP)          counter <= 0;  \n        end else begin\n            shiftreg <= 0 ;\n\t        counter  <= 4'b0;            \t      \t\t      // Reset values at start.\n\t    end    \t        \t\t   \t\t          \t\t \t\t\t\n\tend\n\t\nendmodule\n\n"}
{"task_id": "fsm_serial", "completion": "\nreg [3:0] counter;\nreg data_bit_received;\nparameter IDLE = 2'h0, START = 2'h1, DATA = 2'h2, STOP = 2'h3;\nreg [1:0] state = IDLE;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= IDLE;\n\tend else begin\n\t\tcase (state) \n\t\t\tIDLE: begin\n\t\t\t\tif (!in) begin // if start bit is received\n\t\t\t\t\tcounter <= 4'h8;\n\t\t\t\t\tdata_bit_received <= 0;\n\t\t\t\t\tstate <= START;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tif (in) begin // if the next bit is a stop bit, stay in start state and wait for the start bit again. \n\t\t\t\t\tstate <= IDLE;\n\t\t\t\tend else begin\n\t\t\t\t\tdata_bit_received <= 1'h0; // clear data_bit_received flag to indicate we are now receiving data bits.\n\t\t\t\t\tstate <= DATA;\n\t\t\t end\n\t\t\tDATA: begin\n\t\t\t\tif (counter == 4'h0) begin  // if all 8 data bits are received \n\t\t\t\t\tdata_bit_received <= 1;   // set data bit flag to indicate we have received a valid byte.\n\t\t\t\t\tstate <= STOP;\n\t\t\t\tend else begin    // decrement counter since we still need more data bits.\n\t\t\t\t\tcounter <= counter - 4'h1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP: begin  \n\t\t\t\tif (!in) begin  // if stop bit is received and it was correct, done = 1\n\t\t\t\t\tdone <= 1;\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\tend else begin  // else we have a wrong stop bit, stay in this state and wait for the right one.\n\t\t\t\t\tdata_bit_received <= 0;  \n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\nassign done = (state == STOP && in) ? 1'b1 : 1'b0; // assigning done value when a byte has been received correctly.\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\t// Define states\n\tparameter S0 = 3'b000;  // Idle state\n\tparameter S1 = 3'b001;  // Wait for start bit\n\tparameter S2 = 3'b010;  // Receive first data bit\n\tparameter S3 = 3'b011;  // Receive second data bit\n\t.\n\t.\n\t.\n\tparameter S8 = 3'b100;  // Receive last data bit\n\tparameter S9 = 3'b101;  // Wait for stop bit\n\t\n\t// State variables\n\treg [2:0] state, next_state;\n\t\n\t// Done output variable\n\tassign done = (state == S9);\n\n\t// Next state logic\n\talways @* begin\n\t\tcase(state)\n\t\t\tS0: if (!in) next_state = S1; else next_state = S0;\n\t\t\tS1: if (in)  next_state = S2; else next_state = S1;\n\t\t\tS2: if (!in) next_state = S3; else next_state = S2;\n\t\t\t   .\n\t\t\t   .\n\t\t\t   .\n\t\t\tS7: if (!in) next_state = S8; else next_state = S7;\n\t\t\tS8: if (in)  next_state = S9; else next_state = S8;\n\t\t\tS9: if (!in) next_state = S1; else next_state = S9;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\n\t// Synchronous state update\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= S0;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\n\t// State definitions for FSM\n\tlocalparam START  = 2'b00;\n\tlocalparam BITS   = 2'b01;\n\tlocalparam STOP   = 2'b10;\n\treg [1:0] state = START; // Initial state is start bit\n\treg done = 0;\n\n\t// FSM implementation using combinational logic\n\talways @(posedge clk) begin\n\t\t if (reset) begin\n\t\t\t  state <= START;\n\t\t\t  done <= 0;\n\t\t end else case (state)\n\t\t\t\t  START: if (in == 0 ) state <= BITS;\n\t\t\t\t  BITS : if (~| in ) state <= STOP;\n\t\t\t\t  STOP : if ( in  == 1) begin\n\t\t\t\t\t\tdone <= 1'b1;\n\t\t\t\t\t    state <= START;\n\t\t\t     end else state <= STOP; // Wait for stop bit to be seen.\n\t\t\tendcase\n\tend\n\t\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\treg [3:0] state;\n\tparameter S0=4'h0,S1=4'h1,S2=4'h2,S3=4'h3,S4=4'h4; // states of FSM\n  \n\t// State transitions & Output decoding \n\talways @(posedge clk or posedge reset) begin\n\tif (reset==1'b1) \n\t  state <= S0;\n\telse\n\tcase(state)\n\tS0: if(in == 1'b0) // start bit received\n\t    state <= S1; \n        else \n            state <= S0;\n        \n\tS1: if(in == 1'b1) // first data bit received\n\t    state <= S2;  \n        else \n            state <= S0;     \n            \n\t// continue with similar transitions and checks for other bits (upto S7).\n      \n        // after receiving all 8 bits\n\tS2: if(in == 1'b1) // data bit received\n\t    state <= S3;  \n        else \n            state <= S0;     \n            \n\t// continue with similar transitions and checks for other bits (upto S7).\n        \n\tS3: if(in == 1'b1) // second last data bit received\n\t    state <= S4;  \n        else \n            state <= S0;   \n         \n\t// continue with similar transitions and checks for other bits (upto S8).\n          \n\tS4: if(in == 1'b1) // stop bit received\n\t    state <= S0; // back to initial state after receiving data byte. \n        else\n            state <= S0;    \n\tdefault : state <= S0;      \n\tendcase\n\tend  \n        \n\t// Output decoding for done signal. When all states have been completed (S0), the \"done\" output is set to '1'\n\tassign done = (state == S0);  // done after byte received & verification\n\t\t\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n   reg [3:0] shift_reg;\n   reg [2:0] state; \n   \n   parameter IDLE = 3'b000, START = 3'b001, DATA = 3'b010, STOP = 3'b100;\n\t\n\t// State transition\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= IDLE;\n\t\telse \n\t\t\tcase (state) \n\t\t\t\tIDLE:   if (in == 0) state <= START; // If start bit = 0 go to start state\n\t\t\t\tSTART:  if (~in)     state <= DATA; // If still start bit = 0, go to data state\n\t\t\t\tDATA:   if (~in)     state <= STOP;  // If still start bit = 0, go to stop state\n\t\t\t\tSTOP:   if (in)      state <= IDLE;  // If stop bit = 1, go back to idle state\n\t\t\tendcase\n\tend\n   \n\t// Output\n\tassign done = (state == STOP);\n      \nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\t//State definition\n\tlocalparam [1:0] IDLE = 2'b00;\n\tlocalparam [1:0] START_RCV = 2'b01;\n\tlocalparam [1:0] DATA_RCV = 2'b10;\n\tlocalparam [1:0] STOP_WAIT = 2'b11;\n\n\t//FSM definition\n\treg [1:0] state = IDLE;\n\tassign done = (state == DATA_RCV && in == 1'b1); //We are done when we have received 8 data bits and the stop bit is 1.\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)begin\n\t\t    state <= IDLE;\n        end else begin\n            case (state)\n                IDLE: if(in == 1'b0) //If start bit '0' is received\n                      state <= START_RCV; \n                START_RCV: if(&state == 1'b1)   //Wait till we receive 8 data bits.\n                            state <= DATA_RCV;\n                DATA_RCV: if(in == 1'b1) //If stop bit '1' is received\n                          state <= STOP_WAIT;\n                STOP_WAIT: if(~&state== 1'b1 ) //Wait till stop bit not received.\n                           state <= IDLE;\t  \n            endcase\n        end     \n    end\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\t// Define states\n\tlocalparam [1:0] WAIT_START = 2'b00, DATA = 2'b01, WAIT_STOP = 2'b10;\n\treg [1:0] state = WAIT_START;  // Initialize to wait start state.\n\n\t// FSM transition and actions are defined here:\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin   // active high reset\n\t\t\tstate <= WAIT_START;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tcase(state)\n\t\t\t\tWAIT_START:  if (in==0) state <= DATA; // wait for start bit\n\t\t\t\tDATA:        if (&{8{in}} == 1'b1) state <= WAIT_STOP; // wait for all 8 data bits\n\t\t\t\t\t\t\t else state <= DATA;   // keep in data state till 8 bits are received.\n\t\t\t\tWAIT_STOP:   if (in==1) done <= 1;   // once stop bit is received, mark as 'done'.\n\t\t\t\t             else state <= WAIT_START;// wait for next start bit.\n\t\t\tendcase\n\t\tend\n\tend \nendmodule\n\n"}
{"task_id": "fsm_serial", "completion": "\n   reg [3:0] state;\n   \tparameter IDLE = 4'b0001, DATA = 4'b0010, STOP_WAIT = 4'b0100, ERROR = 4'b1000;  // Define states.\n   \t\t\n   always @(posedge clk or posedge reset) begin\t\t// Reset synchronous with clock\n\tif (reset == 1)\n\t\tstate <= IDLE;\n\telse\n\tcase (state)\n    \tIDLE: if (in == 0) state <= DATA;  // Wait for start bit, then move to DATA state\n   \t    DATA: begin\n        \tif(in==1 && done == 1'b0) state <= STOP_WAIT;  \t// If the byte of data is transmitted and stop bit not yet detected, go to STOP_WAIT. \n            else if (done != 1'b0) state <= ERROR;    \t //If stop bit was already detected or there was an error while receiving data, go to ERROR state.\n      \t    end\n   \t \tSTOP_WAIT: begin\n       \t\t\tif(in==1) begin done <= 1; state <= IDLE; end \t// If a stop bit is received, move to IDLE and set the done signal.\n        \t\telse if (done == 0) state <= ERROR;   //If no stop bit has been detected yet, go to error state.\n      \t\t    end\n    \t    ERROR: begin \n          \t\tif(in==1 || in ==0) state <= IDLE;  \t// If an error is encountered and reset signal occurs or start bit is detected, move back to IDLE.\n       \t\t    end\n     \tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n    reg [2:0] state;\n    \n    parameter START = 3'b001;\n    parameter DATA  = 3'b010;\n    parameter STOP  = 3'b100;\n\tparameter IDLE  = 3'b000;\n     \n    always @(posedge clk or posedge reset) begin \n        if (reset) state <= IDLE;\n        else begin\n            case (state)\n                IDLE: if (!in) state <= START; // waiting for start bit\n                    \n                START: begin \n                    if (in) state <= DATA;   // if start bit is not zero, go back to idle\n                    else state <= START;     // if start bit was zero, stay in this state and wait\n                end\n                \n                DATA: begin\n                    if (!in) state <= STOP;  // data bits have been counted, next should be stop bit\n                    else state <= DATA;       // keep counting data bits\n                end\n                    \n                STOP: begin                  \n                    if (in) state <= IDLE;    // If stop bit is not one, go back to idle\n                    else state <= STOP;      // If stop bit was one stay in this state and wait \n                End\n                \n            default : state <= IDLE ;         \n            endcase    \n        end\n        \n   assign done = (state == STOP);           // When the FSM is in the STOP state, all bytes are correctly received.\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\n\t// state encoding scheme: 00-idle, 01-start bit detected, 1x-data bits received\n\treg [1:0] current_state = 2'b00;\n\treg [7:0] data = 8'd0; // to store the received data\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= 2'b00;\n\t\t\tdata <= 8'd0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tcase(current_state) \n\t\t\t\t// wait for start bit, then transition to the next state\n\t\t\t\t2'b00: if (in == 1'b0) current_state <= 2'b01;\n\t\t\t\t\t\telse current_state <= 2'b00;\n\t\t\t\t// receive data bits, decrement a counter each clock cycle and when it hits 0, transition to the next state\n\t\t\t\t2'b01: begin\n\t\t\t\t\t\t\tdata <= {in, data[7:1]};\n\t\t\t\t\t\t\tif (&data) current_state <= 2'b10;\n\t\t\t\t\t\tend\n\t\t\t\t// wait for stop bit and check if it is 1. If true, set done signal to 1 and go back to idle state\n\t\t\t\t2'b10: begin\n\t\t\t\t\t\t\tif(in == 1'b1) done <= 1'b1;\n\t\t\t\t\t\t\t\telse done <= 1'b0;\n\t\t\t\t\t\t\tcurrent_state <= 2'b00;\n\t\t\t\t\t\tend\n\t\t\t\tdefault: current_state <= 2'b00; \n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "fsm_serial", "completion": "\n// FSM definition\ntypedef enum {IDLE, START, DATA, STOP} state_t;\nstate_t state, next_state;\n\nreg [3:0] count; // Counter for 8 data bits.\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) begin\n\t\tstate <= IDLE;\n        done <= 1'b0;\n\tend else\n\t\tstate <= next_state;\n    count <= 4'd8; // Reset counter for 8 data bits.\nend\n\n// FSM logic\nalways @(*) begin\n\tcase (state)\n\t\tIDLE: if (in == 1'b0) \n\t\t\t\tnext_state = START;\n              else\n                next_state = IDLE;\n\t\t\t\t  \n        START: if (count > 4'd0)begin\n                 next_state = DATA;\n                 count = count - 4'd1; // Decrease counter.\n               end\n               else if(in == 1'b1) begin\n                 next_state = IDLE;  \n             \tend           \t\t\n        DATA: if (count > 4'd0)begin\n                next_state = DATA;\n                count = count - 4'd1; // Decrease counter.\n               end\n               else if(in == 1'b1) begin\n                 next_state = STOP;  \n             \tend    \t\t\n        STOP: if (in == 1'b1)begin\n                next_state = IDLE;\n\t\t\t      done <= 1'b1;  // Assert done.\n             end   \n               else\n                  next_state = STOP;                  \n       default : next_state = IDLE;  \t\n\tendcase\nend\t\nendmodule\n\n"}
{"task_id": "fsm_serial", "completion": "\nreg [3:0] state = 4'b1111; //Idle State\nwire start = &state[2:0]; //Start bit check\nwire stop  = state[3];   //Stop bit check \n\nalways @(posedge clk, posedge reset) begin\n\tif(reset)\n\t\tstate <= 4'b1111;\n\telse\n\t\tcase (state)\n\t\t\t4'b0000 : if(~in) state <= 4'b0001; // start bit found, move to next state\n\t\t\t4'b0001 : if( in) state <= 4'b0011; // 1st data bit received, move to next state\n\t\t\t4'b0011 : if(~in) state <= 4'b0111; // 2nd data bit received, move to next state\n\t\t\t4'b0111 : if( in) state <= 4'b0110; // 3rd data bit received, move to next state\n\t\t\t4'b0110 : if(~in) state <= 4'b1110; // 4th data bit received, move to next state\n\t\t\t4'b1110 : if( in) state <= 4'b1100; // 5th data bit received, move to next state\n\t\t\t4'b1100 : if(~in) state <= 4'b1000; // 6th data bit received, move to next state\n\t\t\t4'b1000 : if( in) state <= 4'b1001; // 7th data bit received, move to next state\n\t\t\t4'b1001 : if(~in) state <= 4'b1011; // 8th data bit received, move to next state\n\t\t\t4'b1011 : if( in) state <= 4'b1010; // 9th data bit received, move to next state\n\t\t\t4'b1010 : if(~in & stop) state <=4'b1111; else state<=4'b1110; //Wait for the expected stop bit or keep moving in case of an error.\n\t\t\tdefault:   state <= 4'b1111;          // Idle State\n\t\tendcase \nend \nassign done = ~start & stop ; //Done signal is asserted when all data bits have been received (start bit, 8 data bits and a stop bit)\n\n"}
{"task_id": "fsm_serial", "completion": "\n\nenum {IDLE = 2'b00, START = 2'b01, DATA = 2'b10} state;\nreg [5:0] count;\nalways @(posedge clk or posedge reset) begin \n    if (reset == 1'b1) begin\n        done <= 1'b0;\n\tstate <= IDLE;\n\tcount <= 6'd0;\n    end else begin\n\tcase (state) \n\t    IDLE:   if(in == 1'b0) state <= START;\n\t    START:\tif(in == 1'b0 && count < 8) begin state <= DATA; count <= count + 2'd1; end else state <= IDLE;\n\t    DATA:\tbegin \n\t\t\tif (count >= 7 && in == 1'b1) state <= IDLE;\n            else if(in == 1'b0 && count < 8) begin state <= START; count <= 6'd0; end \n                done <= 1'b0;\n\t    end\t    \n\tendcase\n\tif (state == DATA && in == 1'b1 && count == 7) done <= 1'b1;  else done <= 1'b0;\t  \n    end\nend\nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count;\n\twire isZero;\n\n\tassign isZero = (count == 10'd0);\n\tassign tc = isZero;\n  \n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tcount <= data;\n\t\telse if (!isZero)\n\t\t\tcount <= count - 1;\n\tend\nendmodule\n"}
{"task_id": "timer", "completion": "\n   reg [9:0] count;\n   \n   always @ (posedge clk) begin\n      if(load)\n         count <= data;\n\t  else if(!tc && count > 0 )\n        count <= count - 1'b1;\n\t    \n      if(count == 10'd0)\n\t\t tc <= 1;\n      else \n\t\t tc <= 0;\n   end\nendmodule\n"}
{"task_id": "timer", "completion": "\n\n    reg [9:0] count;\n    \n    assign tc = !count;\n\n    always @(posedge clk) begin\n        if (load)\n            count <= data;\n        else if (!tc) \n            count <= count - 1'b1;        \t\n    end\nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count;\n\tassign tc = (count == 10'b0);\n\talways @(posedge clk) begin\n\t\tif(load)\n\t\t\tcount <= data;\n\t\telse if(!tc) \n\t\t\tcount <= count - 10'd1;\n\tend\nendmodule\n"}
{"task_id": "timer", "completion": "\n\t// Internal signal to hold the counter value.\n\treg [9:0] count;\n\n\t// Timer state machine.\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tcount <= data; // Load counter with input data.\n\t\telse if (!tc && count > 0 ) \n\t\t\tcount <= count - 1'b1; // Decrement the counter.\n\t\t\t\n\t\t// Check whether count has reached zero.\n\t\tif(count == 10'd0)\n\t\t\ttc <= 1'b1;\n\t\telse\n\t\t\ttc <= 1'b0;\n\tend\nendmodule\n"}
{"task_id": "timer", "completion": "\n\n\treg [9:0] count;\n\tassign tc = !count;\n\t\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tcount <= data;\n\t\telse if(!tc) // Only decrement counter when it is not in terminal state.\n\t\t\tcount <= count - 1'b1;\n\tend\nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count; //10 bit counter\n\tassign tc = (count == 10'b0);\n\t\t\n\talways @(posedge clk) begin\n\t\tif(load)\n\t\t\tcount <= data; \n\t\telse if(!tc)\n\t\t\t\tcount <= count - 1;\n\tend\n\nendmodule\n"}
{"task_id": "timer", "completion": "\n\n\treg [9:0] count;\n\tassign tc = !count;\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tcount <= data;\n\t\telse if (!tc)\n\t\t\tcount <= count - 1'b1;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count;\n\tassign tc = (count == 10'b0);\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tcount <= data;\n\t\telse if (!tc)\n\t\t\tcount <= count - 10'b1;\n\tend\nendmodule\n\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count;\n\tassign tc = (count == 10'b0);\n\n\talways @(posedge clk) begin\n\t\tif(load)\n\t\t\tcount <= data;\n\t\telse if(!tc)\n\t\t\tcount <= count - 1;\n\tend\n\nendmodule\n"}
{"task_id": "timer", "completion": "\n    \n    reg [9:0] count;   // declare a 10-bit register called 'count'\n    wire zero_flag;      // define a wire to represent the zero flag\n\n    assign zero_flag = (count == 10'b0);      \n    assign tc = zero_flag;     // output signal 'tc' is same as the zero flag \n\t\n    always @(posedge clk) begin \n        if(load) \n            count <= data; \n        else if (!zero_flag) \n            count <= count - 10'b1;   // decrement counter only when it is not zero \n    end\nendmodule\n"}
{"task_id": "timer", "completion": "\nreg [9:0] count;\nwire ctc; //ctc stands for Count Terminal Condition\nassign ctc = (count==10'b0)?1'b1:1'b0;\n    \nalways @(posedge clk or posedge load) begin\n    if(load) \n\t\tcount <= data;\n\telse if(!ctc)\n\t    count <= count - 10'd1;\nend\n        \nassign tc = ctc;\n\t\nendmodule\n"}
{"task_id": "timer", "completion": "\n    \n    reg [9:0] count;\n\n    always @ (posedge clk) begin\n        if(load)\n            count <= data;\n        else if (!tc & count > 0) // Only decrement when timer is not yet at terminal count\n            count <= count - 1;\n\tend\n        \n    assign tc = (count==0);  \n    \nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] counter;\n\tassign tc = (counter == 10'b0) ? 1'b1 : 1'b0;\n\n\talways @(posedge clk) begin\n\t\tif(load) \n\t\t\tcounter <= data;\n\t\telse if(!tc)\n\t\t\tcounter <= counter - 1;\n\tend\nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count;\n\tassign tc = (count == 10'b0) ? 1'b1 : 1'b0; // If count is zero set terminal_count to high else keep it low.\n\t\t\n\talways @(posedge clk) begin\n\t\tif(load)  \n\t\t\tcount <= data;     // Load counter with the given data if load = 1\n\t\telse if (count != 0) \n\t\t\tcount <= count - 1;  // Decrease counter by one at every positive clock edge if not zero and load is low.\n\tend\n\t\nendmodule \n"}
{"task_id": "timer", "completion": "\n    reg [9:0] counter;\n\tassign tc = (counter == 10'h000) ? 1 : 0;\n\t\t\n\talways @(posedge clk) begin\n\t\tif(load)\n\t\t\tcounter <= data;\n\t\telse if(!tc)\n\t\t\tcounter <= counter - 1;\n\tend\t\nendmodule\n"}
{"task_id": "timer", "completion": "\n    reg [9:0] count;\n    \n    always @(posedge clk) begin\n        if (load == 1'b1)\n            count <= data;\n        else if(count != 0) \n            count <= count - 1;\n            \n    assign tc = (count == 0);  \nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count;\n\tassign tc = !count;\n\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tcount <= data;\n\t\telse if (!tc) \n\t\t\tcount <= count - 1'b1;\n\tend\nendmodule\n"}
{"task_id": "timer", "completion": "\n\treg [9:0] count;\n\tassign tc = (count == 10'b0);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tcount <= data;\n\t\telse if (!tc) \n\t\t\tcount <= count - 10'b1;\n\tend\nendmodule\n"}
{"task_id": "timer", "completion": "\n    reg [9:0] counter;\n    always @(posedge clk) begin\n        if (load)\n            counter <= data;\n        else if (!tc)\n            counter <= counter - 1;\n        \n        if (counter == 0)\n            tc <= 1'b1;\n        else\n            tc <= 1'b0;\n    end\nendmodule\n"}
{"task_id": "circuit7", "completion": "\n\n\t// D flip-flop\n\talways @(posedge clk) begin\n\t\tif(a)\n\t\t\tq <= 1'b0; // if a is high, set the output to low\n\t\telse \n\t\t\tq <= ~q;    // toggle the value of q with every clock cycle\n\tend\n\nendmodule\n"}
{"task_id": "circuit7", "completion": "\ninitial begin\n    q <= 1'bX;\nend\n    \nalways @(posedge clk) begin\n\tif(a == 0)\n\t\tq <= 1'b0;\n\telse if(a == 1 && q==1'bx)  // Handling the case where a is '1' and q is uninitialized (x)\n\t    q <= 1'b1;\nend\nendmodule\n"}
{"task_id": "circuit7", "completion": "\n\n    always @(posedge clk) begin\n        if (a == 1'b1 && q != 1'bx) // only flip when a is active and q is defined\n            q <= ~q; \n\tend  \nendmodule\n"}
{"task_id": "circuit7", "completion": "\nreg d;\n  \nalways @(posedge clk) begin\n    if (a == 1'b0) // D flip-flop with asynchronous reset.\n        d <= ~d;\nend\n\nassign q = d; \n\t\nendmodule\n\n"}
{"task_id": "circuit7", "completion": "\n\treg temp;\n\talways @(posedge clk) begin\n\t\t\tif(!a)\n\t\t\t\ttemp <= 0;\n\t\t\telse if(a && !temp)\n\t\t\t\ttemp <= 1;\n\t\t\telse \n\t\t\t\ttemp <= temp;\n\t\t\tq <= temp;\n\tend\nendmodule\n"}
{"task_id": "circuit7", "completion": "\nreg [3:0] state = 4'b0;\nalways @(posedge clk) begin\n\tcase(state)\n\t\t4'd8: state <= 4'd15;\n\t\tdefault: state <= a ? (state << 1) : ((state << 1) | a); \n\tendcase\nend\nassign q = state[3];\nendmodule\n"}
{"task_id": "circuit7", "completion": "\n\nalways @(posedge clk) begin\n\tif (a == 1'b0) \n\t\tq <= 1'b0;\n\telse if (a == 1'b1 && q == 1'b0) \n\t\tq <= 1'b1;\n\telse if (a == 1'b1 && q == 1'b1) \n\t\tq <= 1'b0;\nend\nendmodule\n"}
{"task_id": "circuit7", "completion": "\n\t// Using edge-triggered flip flop to synchronize the inputs with clock\n\talways @(posedge clk) begin\n\t\tif (a)\n\t\t\tq <= 1'b0;\n\t\telse\n\t\t\tq <= ~q;\n\tend\n\t\nendmodule \n"}
{"task_id": "circuit7", "completion": "\n\treg temp;\n\talways @(posedge clk) begin\n\tif (a==1'b0 && temp==1'b0)\n\t    q <= 1'b0;\n\telse if (a == 1'b1 && temp ==1'b0 ) \n\t    q <= 1'b1;\n\t else if ( a == 1'b0 && temp ==1'b1)\n           q<=1'b0 ;\n        else   \n            q <= !q;  \t\t    \t\n       temp <=a; \t\t\t\t\t\t\t\t\t        \nendmodule\n"}
{"task_id": "circuit7", "completion": "\nalways @(posedge clk or posedge a) begin\n\tif(a)\n\t    q <= 0;\n\telse if(~clk && ~q)\n\t    q <= 1;\nend\nendmodule\n\n"}
{"task_id": "circuit7", "completion": "\n\t// Create D Flip-Flop with asynchronous reset and set.\n\talways @(posedge clk or negedge clk) begin\n\t\tif (!clk & !a) // Async low to high transition, Set the output\n\t\t\tq <= 1'b0; \n\t\telse if (clk & a) // Async high to low transition, Reset the output\n\t\t\tq <= 1'b1;  \n\tend\nendmodule\n"}
{"task_id": "circuit7", "completion": "\n    \n\treg state;\n  \n    always @(posedge clk) begin\n        if(a == 1'b1)\n            state <= !state;\n        q <= state;\n    end\nendmodule \n\n"}
{"task_id": "circuit7", "completion": "\n\nalways @(posedge clk) begin\n\tif (a == 1'b1)\n\t\tq <= ~q;\nend\n\t\nendmodule\n\n"}
{"task_id": "circuit7", "completion": "\n\talways @(posedge clk) begin\n\t\tif(a == 0)\n\t\t\tq <= 1'b0;\n\t\telse\n\t\t\tq <= ~q;\n\tend\nendmodule\n\n"}
{"task_id": "circuit7", "completion": "\ninitial begin\n    q = 1'bX; //initialize the output to X\nend\nalways @(posedge clk or posedge a) begin\n\tif (a == 1'b1) \n        q <= ~q; //toggle on positive edge of clock and if input 'a' is high\n    else \n\t   q <= q; //hold the value on the negedge of clock or when input 'a' is low\nend\nendmodule\n\n"}
{"task_id": "circuit7", "completion": "\n\treg nextState;\n\talways @(posedge clk) begin\n\t    if (a == 1'b0) begin\n\t        nextState <= ~q;\n    \t    end else begin\n        \t    nextState <= a;\n    \t    end  \n\t    q <= nextState;\n\tend \nendmodule\n"}
{"task_id": "circuit7", "completion": "\n\treg d; // intermediary signal to store the value of 'a'\n\n\t// flip flop sequence\n\talways @(posedge clk) begin\n\t    if (~d & a)\n\t        q <= 1'b0;\n\t    else if (~q & ~d | q & d)\n            q <= 1'b1;\n        end\n    d <= a;  // update 'd' with 'a'\n\tend\nendmodule\n"}
{"task_id": "circuit7", "completion": "\nalways @(posedge clk) begin\n\tcase({a,q}) \n\t\t2'b01, 2'b10 : q <= ~q;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "circuit7", "completion": "\n    \n    always @(posedge clk) begin\n        if (a == 1'b1)\n            q <= ~q;\n    end\nendmodule\n\n"}
{"task_id": "circuit7", "completion": "\n\treg tmp;\n    \n    always @(posedge clk) begin\n        if(!a) \n            tmp <= 0;\n        else if(tmp==1'b0)\n            tmp <= ~q & a;\n        else\n            tmp <= q & ~a;        \n\tend\n\t\t  \n    assign q = (tmp == 0)? a : !(a&q); \n\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = {in[98:0] & in[99]};\n\tassign out_any = {in[98:1] | in[99]};\n\tassign out_different = {in^{in[0], in[99:1]}};\n\t\nendmodule \n\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = in[98:0] & in[99:1];\n\tassign out_any = in[98:0] | in[99:1];\n\tassign out_different = in^{in[0], in[99:1]};\n\t\nendmodule\n\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = in[98:0] & {in[99], in[99:1]};\n\tassign out_any = in[98:0] | {in[99], in[99:1]};\n\tassign out_different = in^{1'b0, in[99:1], 1'b0};\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = {in[98:0] & in[99]};\n\tassign out_any = {(in[98:0] | in[99]) ^ 1'b1}; // XOR with '1' to invert the result since we are dealing with an output of size (99->1) and not (99->0), which is opposite.\n\tassign out_different = {in[98:1]^{in[0], in[99]}}; \n\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = {in[98:1], 1'b0} & in;\n\tassign out_any = {in[98:0], 1'b0} | in;\n\tassign out_different = {in[98:1], 1'b0} ^ in;\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = {in[98:0] & in[99:1]};\n\tassign out_any = {~(~in[98:0] | ~in[99:1]) };\n\tassign out_different = ~((in^{in[0], in[99:1]})|({1'b0, in[99:1]} ^ in));\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = (in[99:1] & in[98:0]); \n\tassign out_any = (in[99:1] | in[98:0]); \n\tassign out_different = ({in[0], in[99]} ^ {in[98:0], 2'b0}); //Treating it as a circular array, so left neighbour of the first element is last one and right neighbour of the last element is the first.\n\t\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = {in[98], (&{in[97:0], in[99]})};\n\tassign out_any = ~|(~in & {1'b0, in[98:0]});\n\tassign out_different = ~({1'b0, in} ^ {{2'b0}, (&{in[97:0], in[99]} ? in : {1'b0})}); // Using wrap-around XOR as given in the question.\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = {in[98:0] & in[99:1]};\n\tassign out_any = {in[98:0] | in[99:1]};\n\tassign out_different = {in ^ {in[99], in[98:0]}};\n\t\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = (in[98:0] & in[99]);\n\tassign out_any = (in[98:0] | in[99]) ;\n\tassign out_different = (~(in ^ {1'b0, in[99:1]}));  // The '~' operator is used to invert the bits.\n\t\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = {in[98:0], in[99]} & {in[99], in};\n\tassign out_any = {in[98:0], in[99]} | {in[99], in};\n\tassign out_different = {in[98:1], ~^{in[99], in}};\n\t\nendmodule \n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = {in[98], (in[98:1] & in[99:2]) , 1'b0};\n\tassign out_any =  {1'b0, (in[98:0] | in[99:1]) };\n\tassign out_different = {in^{in[0], in[98:1]}, in[0]};\n\t\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = {in[98:1], in[0]} & {in[99], in};  //treat the vector as wrapping around so that in[99]'s neighbour to left is in[0].\n\tassign out_any = {in[98:1], in[0]} | {in[99], in};   //treat the vector as wrapping around so that in[99]'s neighbour to right is in[0].\n\tassign out_different = {in[98:1], in[0]} ^{in[99], in}; \n\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = in[98:0] & {in[99], in[99:1]};\n\tassign out_any = in[98:0] | {in[99], in[99:1]};\n\tassign out_different = in^{in[0], in[99:1]};\n\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = {in[98:1], 1'b0} & in;\n\tassign out_any = {in[98:0], 1'b0} | in;\n\tassign out_different = ~(in^{1'b0, in[98:0]});\nendmodule\n\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = in[98:0] & in[99];\n\tassign out_any = in[98:0] | in[99];\n\tassign out_different = in ^ {in[0], in[98:1]};\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = {in[98:0], in[99]} & {in[99], in};\n\tassign out_any = ~{in[98:0], ~in[99]} | {in[99], in};\n\tassign out_different = (({in[98:0], 1'bz} ^ {in[0], in[98:0]}) | ({1'bz, in[99]} ^ {in[99], 1'bz})) & {in[98:0], in};\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = in[98:0] & {in[99], in[99:1]};\n\tassign out_any = in[98:0] | {in[99], in[99:1]};\n\tassign out_different = in^{in[0], in[99:1]};\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\tassign out_both = {in[99], in[98:0] & in[99:1]};\n\tassign out_any = {in[99], in[98:0] | in[99:1]};\n\tassign out_different = {in[99], (~(in^{in[0], in[99:1]}))};  // XOR operation treats the input as circular and makes each bit different from its neighbour.\n\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\n\n\tassign out_both = {in[98:0], in[99]} & {{2{in[99]}}, in[99:1]}; // shifting left by one and comparing with neighbouring bits of in.\n\tassign out_any = {in[98:0], in[99]} | {{2{in[99]}}, in[99:1]};  // same as above but using OR operation instead of AND.\n\tassign out_different = ({{2{~in[99]}}, ~in[99:1] ^ {in[0], in}} << <80) | {{2{in[99]}}, in[99:1]} ;  // comparing with neighbours to the left.\n\t\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n    always @(*) begin \n        out = {<<{in[99:0]}}; \n    end\nendmodule\n\n"}
{"task_id": "vector100r", "completion": "\n\t\n\t// Method 1 using array concatenation\n\tgenvar i;\n\tgenerate\n\tfor (i = 0; i < 50; ++i) begin : gen_loop\n\t    assign out[i] = in[99-2*i];\n\t    assign out[99-i] = in[2*i];\n\tend\n\tendgenerate\n\t\t  \n\t// Method 2 using bitwise operators (not recommended for synthesis as it might be too complex to map)\n\tassign out = 0; //initialize output\n\tfor(genvar j=0;j<50;++j) begin : gen_loop1\n\t    assign out |= in[99-2*j] << (2*j); \n\t    if(2*j+1 < 100)\n\t    \tassign out |= in[2*j] >> (2*j+1);\n\tend   \n"}
{"task_id": "vector100r", "completion": "\nbegin\n\t//reversing the bits by concatenating them with reverse order.\n\tassign out = {in[99],in[98],in[97],......,in[1],in[0]}; // complete this line\nend\nendmodule \n\n"}
{"task_id": "vector100r", "completion": "\n\talways @(*) begin\n\t\tfor(integer i = 0; i<=49; i++) begin  // half of the length because we are swapping pairs of bits\n\t\t\tout[i] <= in[99-i];   // swap each bit with its mirror image\n\t\t\tout[99-i] <= in[i];   \n\t\tend\n\tend\n\n"}
{"task_id": "vector100r", "completion": "\n\talways @* begin  // combinational logic with input driven by in\n\t\t        // and output driven by reversed version of 'in'\n\t    out = { <<{in[99:0]}};  // reverse order of bits using left shift operator (<<)\n\tend\n"}
{"task_id": "vector100r", "completion": "\n\n\talways @(*) begin\n\t\tfor (integer i = 0; i < 50; i++) begin  //half of the size because we are reversing the bits\n\t\t\tout[i] = in[99-i];\n\t\t\tout[99-i] = in[i];\n\t end\n    end\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\talways @(*) begin \n\t\tfor (integer i = 0; i < 50; ++i) begin\n\t\t\tout[i] = in[99-i];\n\t\t\tout[99-i] = in[i];\n\tend\nend\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\n\tassign out = {<<{in}};\n\nendmodule \n\n"}
{"task_id": "vector100r", "completion": "\n\talways @(*) begin\n\t\tfor (integer i=0; i<50; i++) begin\n\t\t\tout[i] = in[99-i];\n\t\t\tout[99-i] = in[i];\n\tend\n  end\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\tint i; // Declare a temporary variable for loop indexing \n\talways @* begin // Use an always block to describe combinational logic\n\t\tfor (i = 0; i < 50; i = i + 1) begin : each_bit // Loop over half of the input bits\n\t\t\tout[i] <= in[99-i]; // Reverse order by selecting corresponding bit from end of input\n\t\t\tout[99-i] <= in[i];  // Place reversed bit at corresponding place in output\n\tend\n\tend\nendmodule\n"}
{"task_id": "vector100r", "completion": "\nbegin\ninteger i;\nalways@* begin\n\tfor(i=0; i<50; i++) begin\n\tout[i] = in[99-i];\n\tout[99-i] = in[i];\n\tend\nend\nendmodule \n"}
{"task_id": "vector100r", "completion": "\n\n\t// This is the reversing of a 100-bit input vector.\n\tassign out = in[99:0];\n\nendmodule\n\n"}
{"task_id": "vector100r", "completion": "\n\talways @(*) begin\n    \tout = {<<{in[99:0]}};\n  \tend\nendmodule \n"}
{"task_id": "vector100r", "completion": "\n\n\t// As a range of bits is reversed using concatenation\n\tfunction automatic [99:0] reverse(input [99:0] in);\n\t  integer i;\n      begin\n        for (i = 0; i < 100; i = i + 1)\n\t\t  // Reverses the order of the bits\n          out[i] = in[99-i];\n      end\n\tendfunction\n    \n    always @(*) begin  \n       out = reverse(in);  \n    end\n\t\nendmodule\n\n"}
{"task_id": "vector100r", "completion": "\n\tassign out = {<<{in}};\nendmodule\n\n"}
{"task_id": "vector100r", "completion": "\n\talways @(*) begin\n\t\tfor (int i=0; i<50; ++i) begin \n\t\t\tout[i] = in[99-i];\n\t\t\tout[99-i] = in[i];\n\tend\n\tend\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\tassign out = {<<{in}};  // reversing the input vector.\nendmodule\n\n"}
{"task_id": "vector100r", "completion": "\n\n\talways @* begin\n\t\tfor(integer i=0;i<100;i++)begin\n\t\t\tout[i] = in[99-i];\n\tend\nend\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\talways @* begin\n\t\tfor(int i = 0; i < 50; ++i) begin  // only need to loop through half the length of the vector\n\t\t\tout[i] <= in[99-i];            // mirror the bit from the opposite end of 'in' into 'out'\n\t\t\tout[99-i] <= in[i];            \n\t\tend\n\tend\nendmodule\n"}
{"task_id": "vector100r", "completion": "\n\n\tfor(genvar i = 0; i <= 50 ; ++i) begin // loop to swap halves of the input vector\n      assign out[i] = in[99-i]; \n\tend  \n\nendmodule\n\n"}
{"task_id": "countslow", "completion": "\n\talways @ (posedge clk) begin\n\t\t if (reset)\n\t\t\t  q <= 4'b0;\n\t\t else if (slowena)\n\t\t\t  if(q == 4'd9 ) \n\t\t\t\t   q <= 4'b0;\n\t\t\t  else\n\t\t\t\t   q <= q + 1 ;\t\n\tend\nendmodule\n"}
{"task_id": "countslow", "completion": "\nalways @(posedge clk) begin\n\tif (reset == 1'b1) \n\t\tq <= 4'd0;\n\telse if (slowena == 1'b1)\n\t\tcase(q)\n\t\t\t4'd9: q <= 4'd0; // if we reach the maximum value, reset to 0\n\t\t\tdefault: q <= q + 4'd1; // increment the counter otherwise\n\t\tendcase\nend\n\n"}
{"task_id": "countslow", "completion": "\n\t// Internal signal to keep track of whether we're at the end of a count\n\treg end_of_count;\n  \n  // State variables for our state machine. We need one for each possible output value.\n\tparameter [3:0] ZERO = 4'b0000, ONE = 4'b0001, TWO = 4'b0010, THREE =4'b0011, FOUR = 4'b0100, FIVE = 4'b0101, SIX=4'b0110, SEVEN = 4'b0111, EIGHT = 4'b1000, NINE= 4'b1001;\n\treg [3:0] state = ZERO;\n  \n  // The always block that describes the behavior of our counter. We use a case statement to describe transitions between states based on slowena and reset inputs.\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= ZERO;\n      end else if (slowena) begin \n        case (state)\n          ZERO : state <= ONE;\n          ONE : state <= TWO;\n          TWO: state <= THREE;\n          THREE: state <= FOUR;\n          FOUR: state <= FIVE;\n          FIVE: state <= SIX;\n          SIX: state <= SEVEN; \n          SEVEN: state <= EIGHT;\n\t\t\tEIGHT: state <= NINE;\n          NINE : state <= ZERO;\n        endcase // state\n      end     // if reset\n    end       // always @ (posedge clk or posedge reset)\n  \n  // Assign the output based on our internal state variable.\n\tassign q = state;\nendmodule\n"}
{"task_id": "countslow", "completion": "\n\n\talways @ (posedge clk) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0;\n\t\telse if (slowena) \n\t\t\tif(q == 4'd9)\n\t\t\t\tq <= 4'b0;\n\t\t\telse\n\t\t\t\tq <= q + 1;\n\tend\n\t\nendmodule\n"}
{"task_id": "countslow", "completion": "\n    always @ (posedge clk or posedge reset) begin \n        if (reset)\n            q <= 4'd0;\n        else if (slowena)\n            \tif(q == 4'd9) \n                \tq <= 4'd0;\n                else\n                    q <= q + 1;   \n    end\nendmodule\n"}
{"task_id": "countslow", "completion": "\n\talways @(posedge clk) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0;\n\t\telse if (slowena) \n\t\t\tbegin\n\t\t\t\tif (q == 4'd9) \n\t\t\t\t\tq <= 4'b0;\n\t\t\t\telse\n\t\t\t\t\tq <= q + 1'b1;\n\t\t\tend\n\tend\n\t\n"}
{"task_id": "countslow", "completion": "\n\treg[1:0] state; // Two bits of state to count from 0 through 4 then wraparound.\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= 2'b00;\n        else if (slowena) begin\n\t\t\tcase(state)\n\t\t\t\t2'b11: state <= 2'b00; // Wrap around from 3 to 0.\n\t\t\t\tdefault: state <= state + 1; // Increment.\n\t\t\tendcase\n\t\tend\n    end\n    \n    assign q = state[1:0]; // The least significant bits of the state are what we care about.\nendmodule\n"}
{"task_id": "countslow", "completion": "\n\n\t// Define states as binary numbers from 0 to 9 (inclusive)\n\tparameter S0 = 4'b0000;\n\tparameter S1 = 4'b0001;\n\tparameter S2 = 4'b0010;\n\tparameter S3 = 4'b0011;\n\tparameter S4 = 4'b0100;\n\tparameter S5 = 4'b0101;\n\tparameter S6 = 4'b0110;\n\tparameter S7 = 4'b0111;\n\tparameter S8 = 4'b1000;\n\tparameter S9 = 4'b1001;\n\t\n\t// Define next state as a function of current state and inputs\n\tfunction [3:0] NextState(input [3:0] curr_state, slowena, reset);\n\t\t\tcase (curr_state) \n\t\t\t\tS9 : if (reset) NextState = S0; else NextState = slowena ? S0 : curr_state;\n\t\t\t\tdefault : if (reset) NextState = S0; else NextState = slowena ? curr_state + 1 : curr_state;\n\t\t\tendcase\n\tendfunction \n\t\n\t// Define current state and next state registers\n\treg [3:0] curr_state, next_state;\n\t\n\t// Synchronous update of the current state register based on the clock input\n\talways @(posedge clk) begin\n\t\t\tif (reset)\n\t\t\t\t\tcurr_state <= S0; \n\t\t\telse \n\t\t\t      \tcurr_state <= next_state; \n  \tend\n\t\n\t// Next state logic\n\tassign next_state = NextState(curr_state, slowena, reset);\n\t\n\t// Output logic\n\tassign q = curr_state;\n\t\nendmodule\n"}
{"task_id": "countslow", "completion": "\n\treg [3:0] cnt; // Counter\n\talways @(posedge clk) begin\n\t\tif (reset == 1'b1) // Synchronous reset\n\t\t\tcnt <= 4'd0; \n\t\telse if (slowena == 1'b1)  \n\t\t\t      if (cnt != 4'd9)   \n\t\t\t\t cnt <= cnt + 1;\n\t\t\t      else\n\t\t\t\t cnt <= 4'd0; // Wraps at 9, goes back to 0\n\tend\n\t\t\n\t// Assign q output\n\tassign q = cnt;\n\nendmodule\n"}
{"task_id": "countslow", "completion": "\n\n\talways @ (posedge clk) begin\n\t\tif(reset == 1'b1)\n\t\t  q <= 4'h0;\n\t\telse if(slowena == 1'b1)\n\t\t  if(q < 4'd9)\n\t\t\t  q <= q + 1;\n\t\t  else\n\t\t\t  q <= 4'h0;\n\tend\nendmodule\n\n"}
{"task_id": "countslow", "completion": "\n\talways @(posedge clk) begin\n        if (reset) \n            q <= 4'b0;\n        else if (slowena)   // slow down the counting process by checking 'slowena' on each clock cycle\n            q <= q + 1'd1;   \n        \n\t\tif(q == 4'b1010)\t// once the counter reaches 10, reset it back to 0\n\t\t\tq <= 4'b0;\n     end\nendmodule\n\n"}
{"task_id": "countslow", "completion": "\nalways @(posedge clk) begin\n\tif (reset==1'b1)  // Asynchronous active high reset\n\t\tq <= 4'h0;  \n\telse if (slowena == 1'b1) // Pausable counter\n\t\tcase (q)\n\t\t\t4'h9: q <= 4'h0;\n\t\t\tdefault: q <= q + 2'd1; \n\t\tendcase\nend\n\n"}
{"task_id": "countslow", "completion": "\n\t// The function to get the next state of counter\n\tfunction [3:0] NextState; \n        input [3:0] current_state;\n        begin  \n            NextState = (current_state == 4'd9)? 4'd0 : current_state + 1;\n        end \n    endfunction\n\n\talways @(posedge clk or posedge reset) begin\n\t    if(reset)\n\t        q <= 4'b0;   // Asynchronous active high reset\n\t    else if (slowena == 1'b1)\n            q <= NextState(q); \t// Synchronous counting\n    end\nendmodule\n\n"}
{"task_id": "countslow", "completion": "\n\treg [1:0] temp; //using two bits for binary counter to detect carry out\n    wire carryout;\n    \n\t//binary counter with synchronous reset and asynchronous load\n   always @(posedge clk or posedge reset) begin \n        if (reset == 1'b1) begin\n            q <= 4'd0;\n\t\t\ttemp <= 2'b00;\n        end else if (slowena == 1'b1) begin\n            {carryout, temp} <= temp + 2'd1; //adding 1 to binary counter\n\t\t\t\tif(carryout)\n\t\t\t\t\tq <= q + 4'd1;   //if carry out is detected then increment the counter by one \n        end\n    end\nendmodule\n"}
{"task_id": "countslow", "completion": "\n\treg [3:0] tmp;\n\talways @ (posedge clk or posedge reset) begin\n\t\tif(reset) \n\t\t\tq <= 4'b0;\n\t\telse if (slowena == 1'b1)\n\t\t\tq <= q + 1;\n\t\t\t\n\t\tif (q == 4'd9)\n\t\t\ttmp <= q;\n\t\tif (q == tmp && slowena == 1'b0 ) // slowena is 0 means counter paused, so we should reset to initial state.\n\t\t\tbegin\n\t\t\tq <= 4'b0;\n\t\t\tend\n\t\t\t\n\tend\nendmodule\n"}
{"task_id": "countslow", "completion": "\n\treg [3:0] nextq;\n    always @(posedge clk) begin\n        if (reset == 1'b1)  //reset is synchronous and high active\n            q <= 4'd0;\n        else if (slowena == 1'b1)  \n            q <= nextq;\n     end\n\talways@(*)\n    begin\n       case (q)\n          4'd0: nextq = 4'd1;\n          4'd1: nextq = 4'd2;\n          // Continue the same way until 9\n          4'd8: nextq = 4'd9;\n          4'd9: nextq = 4'd0;    //back to zero after 9\n          default: nextq = q + 1 ;// keep counting if slowena is not asserted\n       endcase  \n\tend\n"}
{"task_id": "countslow", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'b0;\n        else if (slowena) \n            q <= q == 4'd9 ? 4'b0 : q + 1;\n    end\nendmodule\n\n"}
{"task_id": "countslow", "completion": "\n\treg[3:0] counter; // internal state of the counter.\n\talways @(posedge clk) begin \n\tif (reset) begin\t// asynchronous active high reset\n\t\tcounter <= 4'b0000; // set counter to 0\n\tend else if (slowena) begin\t// increment counter when slowena is active\n\t\tcounter <= counter + 1;\n\t\tif(counter == 4'd9 ) begin // when the counter reaches 9, reset it.\n\t\t\tcounter <= 4'b0000;  \n\t\tend\n\tend \n\tq <= counter;\n\tend\nendmodule\n"}
{"task_id": "countslow", "completion": "\n    always @ (posedge clk or posedge reset) begin\n        if(reset == 1'b1)\n            q <= 4'd0;\n        else if (slowena == 1'b1) begin\n           if(q== 4'd9)\n               q<= 4'd0;\n           else \n             q <= q + 1;     \n        end\t\n    end\nendmodule  \n"}
{"task_id": "countslow", "completion": "\n\treg [3:0] temp;\n\talways @(posedge clk) begin\n\t\tif (reset) \n\t\t\ttemp <= 4'b0000; // equivalent to q = 0;\n\t\telse if (slowena) begin\n\t\t\tcase (temp)\n\t\t\t\t4'd9: temp <= 4'd0;\t// equivalent to if(q == 9) q = 0;\n\t\t\t\tdefault: temp <= temp + 1'b1;  // increment by one\n\t\tendcase\n\t\tend\n\tend\n\tassign q = temp;\nendmodule\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~(A ^ B);\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\n\tassign z = ~(A ^ B);\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\nassign z = ~(A ^ B);\nendmodule\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~|(A^B); // if the two bits are same then ^ will produce 2'b00 and ~|(...) is true else it will be false.\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\n\tassign z = (A == B) ? 1'b1 : 1'b0;\n\t\t  \nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\t//using equality operator to compare the inputs A and B\n\tassign z = (A == B) ? 1'b1 : 1'b0; \nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\n\tassign z = ~(A^B); // XNOR gate will give output 1 when A=B otherwise it will give zero.\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~|(A ^ B);\nendmodule\n"}
{"task_id": "mt2015_eq2", "completion": "\n\nassign z = ~(A ^ B);\n\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\n\tassign z = ~|(A ^ B);\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\nassign z = ~|(A ^ B); // Bitwise XOR and negation of OR will be 1 when both bits are the same (A equals to B)\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~((A ^ B) |  ((A ^ B) << 2));  //The expression checks if both inputs are the same and gives an output of 1 in this case. If not, it will give an output of 0.\nendmodule\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~|(A^B); // XOR operation and ~| is equivalent to NAND. It will be 1 if A = B because it means the inputs are not different and hence there's no 1 in (A^B) which gives us 0 so we get 1 when applying ~ operator on this result.\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~(A ^ B);\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~|((A ^ B) & {2{~A[0]}} & {2{B[1]} 1'b0} | (A ^ B) & {2{B[0]}} & {2{A[1]} 1'b0});\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n    assign z = ~|(A^B);\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = (A == B) ? 1'b1 : 1'b0; // Using a conditional operator to check if the two bits are equal and assigning the output accordingly.\nendmodule\n"}
{"task_id": "mt2015_eq2", "completion": "\n\n\tassign z = ~|(A^B);\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\tassign z = ~|((A^B) & {2{~&(A^B)}});\nendmodule\n\n"}
{"task_id": "mt2015_eq2", "completion": "\n\nassign z = ~|(A^B);\n  \nendmodule\n\n"}
{"task_id": "always_case", "completion": "\n\talways @(*) begin\n\t\tcase (sel) \n\t\t\t3'd0: out <= data0;\n\t\t\t3'd1: out <= data1;\n\t\t\t3'd2: out <= data2;\n\t\t\t3'd3: out <= data3;\n\t\t\t3'd4: out <= data4;\n\t\t\t3'd5: out <= data5;\n\t\t\tdefault: out <= 4'b0;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_case", "completion": "\nalways @(*) begin\n\tcase (sel) \n\t\t3'b000: out = data0;\n\t\t3'b001: out = data1;\n\t\t3'b010: out = data2;\n\t\t3'b011: out = data3;\n\t\t3'b100: out = data4;\n\t\t3'b101: out = data5;\n\t\tdefault : out = 4'd0;\n\tendcase \nend\nendmodule\n"}
{"task_id": "always_case", "completion": "\n\talways @* begin\n\t    case (sel)\n            0 : out <= data0;\n\t        1 : out <= data1;\n\t        2 : out <= data2;\n\t        3 : out <= data3;\n\t        4 : out <= data4;\n\t        5 : out <= data5;\n\t        default: out <= 4'b0;\n\t    endcase\n    end\nendmodule\n"}
{"task_id": "always_case", "completion": "\n    always @* begin\n        case (sel) \n            3'b000 : out = data0;\n            3'b001 : out = data1;\n            3'b010 : out = data2;\n            3'b011 : out = data3;\n            3'b100 : out = data4;\n            3'b101 : out = data5;\n            default: out = 4'd0;  //default case if sel not between 0 and 5.\n        endcase\n    end\nendmodule\n"}
{"task_id": "always_case", "completion": "\n\talways @* begin\n    case(sel) \n      3'd0 : out <= data0;\n      3'd1 : out <= data1;\n      3'd2 : out <= data2;\n      3'd3 : out <= data3;\n      3'd4 : out <= data4;\n      3'd5 : out <= data5;\n      default: out <= 4'b0;  // Default output to zero when sel is not between 0 and 5.\n    endcase \n\tend\nendmodule\n"}
{"task_id": "always_case", "completion": "\n\n\talways @(*) begin\n    \tcase (sel) \n        \t3'b000 : out = data0;\n         \t3'b001 : out = data1;\n          \t3'b010 : out = data2;\n           \t3'b011 : out = data3;\n            \t3'b100 : out = data4;\n             \t3'b101 : out = data5;\n              \tdefault: out = 4'd0; \n        endcase\n    end\nendmodule\n"}
{"task_id": "always_case", "completion": "\n\talways @* begin\n\t\tcase (sel) \n\t\t\t3'b000 : out = data0;\n\t\t\t3'b001 : out = data1;\n\t\t\t3'b010 : out = data2;\n\t\t\t3'b011 : out = data3;\n\t\t\t3'b100 : out = data4;\n\t\t\t3'b101 : out = data5;\n\t\t\tdefault: out = 4'd0;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_case", "completion": "\nalways @(*) begin\n\tcase (sel) \n\t\t3'd0 : out = data0;\n\t\t3'd1 : out = data1;\n\t\t3'd2 : out = data2;\n\t\t3'd3 : out = data3;\n\t\t3'd4 : out = data4;\n\t\t3'd5 : out = data5;\n\t\tdefault: out = 4'b0;\n\tendcase \nend\nendmodule\n"}
{"task_id": "always_case", "completion": "\n\talways @(*) begin\n\t    case (sel)\n            3'b000 : out = data0;\n            3'b001 : out = data1;\n            3'b010 : out = data2;\n            3'b011 : out = data3;\n            3'b100 : out = data4;\n            3'b101 : out = data5;\n            default: out = 4'd0;\n\t    endcase \n\tend  \nendmodule\n"}
{"task_id": "always_case", "completion": "\nalways @(*) begin\n\tcase(sel) \n\t\t3'd0: out = data0;\n\t\t3'd1: out = data1;\n\t\t3'd2: out = data2;\n\t\t3'd3: out = data3;\n\t\t3'd4: out = data4;\n\t\t3'd5: out = data5;\n\t\tdefault: out = 4'b0; \n\tendcase\nend\nendmodule\n"}
{"task_id": "always_case", "completion": "\n    always @(*) begin\n        case (sel) \n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0;\n        endcase \n    end  \nendmodule\n"}
{"task_id": "always_case", "completion": "\n     always @(*) begin \n         case (sel) \n            3'b000 : out = data0;\n            3'b001 : out = data1;\n            3'b010 : out = data2;\n            3'b011 : out = data3;\n            3'b100 : out = data4;\n            3'b101 : out = data5;\n            default : out = 4'h0;\n         endcase \n     end   \nendmodule \n"}
{"task_id": "always_case", "completion": "\n\talways @(*) begin\n\t\tcase (sel) \n\t\t\t3'd0 : out = data0;\n\t\t\t3'd1 : out = data1;\n\t\t\t3'd2 : out = data2;\n\t\t\t3'd3 : out = data3;\n\t\t\t3'd4 : out = data4;\n\t\t\t3'd5 : out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_case", "completion": "\n\n\talways @(*) begin\n\t\tcase (sel) \n\t\t\t3'd0: out <= data0;\n            3'd1: out <= data1;\n            3'd2: out <= data2;\n            3'd3: out <= data3;\n            3'd4: out <= data4;\n            3'd5: out <= data5;\n\t\t\tdefault: out <= 4'b0;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_case", "completion": "\n\talways @* begin\n\t\tcase(sel) \n\t\t\t3'd0: out = data0;\n\t\t\t3'd1: out = data1;\n\t\t\t3'd2: out = data2;\n\t\t\t3'd3: out = data3;\n\t\t\t3'd4: out = data4;\n\t\t\t3'd5: out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_case", "completion": "\n\talways @(*) begin\n\t\tcase (sel) \n\t\t\t3'b000 : out = data0;\n\t\t\t3'b001 : out = data1;\n\t\t\t3'b010 : out = data2;\n\t\t\t3'b011 : out = data3;\n\t\t\t3'b100 : out = data4;\n\t\t\t3'b101 : out = data5;\n\t\t\tdefault: out = 4'b0000;\n\tend\nend\n"}
{"task_id": "always_case", "completion": "\n\n\t// 6-to-1 multiplexer\n\talways @(*) begin\n\t    case (sel)\n\t\t    3'b000: out <= data0;\n\t\t    3'b001: out <= data1;\n\t\t    3'b010: out <= data2;\n\t\t    3'b011: out <= data3;\n\t\t    3'b100: out <= data4;\n\t\t    3'b101: out <= data5;\n\t\t    default: out <= 4'b0000;  // Default output to zero if sel is not between 0 and 5.\n\t    endcase\n\tend\n\n"}
{"task_id": "always_case", "completion": "\n     always @* begin \n         case(sel)  \n            3'b000 : out <= data0;  \n            3'b001 : out <= data1;  \n            3'b010 : out <= data2;  \n            3'b011 : out <= data3; \n\t\t\t3'b100 : out <= data4;\n\t\t\t3'b101 : out <= data5;\n            default: out <= 4'b0000; \n        endcase  \n     end   \nendmodule\n"}
{"task_id": "always_case", "completion": "\n    \n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'd0 : out = data0;\n            3'd1 : out = data1;\n            3'd2 : out = data2;\n            3'd3 : out = data3;\n            3'd4 : out = data4;\n            3'd5 : out = data5;\n            default : out = 4'b0; \n\t\tendcase\n\tend\n    \nendmodule\n"}
{"task_id": "always_case", "completion": "\n\n\talways @(*) begin\n\t\tcase (sel) \n\t\t\t3'd0 : out = data0;\n\t\t\t3'd1 : out = data1;\n\t\t\t3'd2 : out = data2;\n\t\t\t3'd3 : out = data3;\n\t\t\t3'd4 : out = data4;\n\t\t\t3'd5 : out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase \n\tend\n\n"}
{"task_id": "circuit3", "completion": "\n    wire ab;\n    wire bc;\n    wire cd;\n    \n    assign ab = a&b;\n    assign bc = b&c;\n    assign cd = c&d;\n    \n    assign q = ab | (bc & ~cd); \nendmodule\n"}
{"task_id": "circuit3", "completion": "\n\treg q;\n\talways @(*) begin\n\t\tcase ({a,b,c,d})\n\t\t\t4'h0 : q <= 1'b0;\n\t\t\t4'h1 : q <= d;\n\t\t\t4'h2 : q <= a ^ c;\n\t\t\t4'h3 : q <= b || d;\n\t\t\tdefault: q <= 1'bx; // undefined case.\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit3", "completion": "\n\tassign q = ((~a & ~b & c) | (a & b & d)) ;\nendmodule\n  \n"}
{"task_id": "circuit3", "completion": "\n    assign q = ((a & ~b & ~c) | (~d)) ;\nendmodule\n\n"}
{"task_id": "circuit3", "completion": "\nwire w0;\n\tassign w0 = ((~a&b)&c)|(d&((~a&b)&c));\n\tassign q = ~(w0 | (~a & b & c & d)); \nendmodule\n\n"}
{"task_id": "circuit3", "completion": "\nreg q;\n    \n    always @(*) begin\n        if (!a && !b && !c) \n            q = d;\n        else if (c) \n            q = ~q;\n    end\nendmodule\n\n"}
{"task_id": "circuit3", "completion": "\n\treg q; // Declare register q as output type 'reg' which is always driven by the last assignment.\n   \n   always @(*) begin  // This block defines combinational behavior of the circuit\n       if (!a & !b & !c & !d) \n          q = 0;\n        else if (!a & !b & !c & d)\n\t\t\tq = 1;\n        else if(!a & b & c & !d) \n            q=0;\n      \telse if (a & b & !c & d )\n           q= 1 ;\n     \telse if( a & b&c & d)\n          q =0;\n\t\telse if (a & !b & c & d)\n\t\t\tq = 0;\n\t    else \n            q=1;\n   end\nendmodule\n"}
{"task_id": "circuit3", "completion": "\nwire temp1 = (~a & ~b) | (c & d);\n\twire temp2 = ~(temp1 ^ c);\n\tassign q = temp2;\nendmodule\n"}
{"task_id": "circuit3", "completion": "\n\twire w0 = !a && !b && !c;\n\twire w1 = !w0 || d;\n\twire w2 = (d ? a : b) || w1;\n\twire w3 = c || w2;\n\n\tassign q = w3;\nendmodule\n"}
{"task_id": "circuit3", "completion": "\n\tassign #1 q = (~a & ~b & ~c & d) | (a & ~b & ~c & ~d) | (~a & b & ~c & ~d) | (a & b & c & ~d);\nendmodule \n"}
{"task_id": "circuit3", "completion": "\nassign #5ns q = ((~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & ~d)) ; \nendmodule   // This is a TTL NAND gate logic, where 'q' is output and others are inputs.\n"}
{"task_id": "circuit3", "completion": "\n    reg q;\n\talways @(*) begin\n\t    case({a,b,c,d})\n\t\t    4'h0 : q = 1'b0;\n\t\t\t4'h1 : q = a;\n\t\t\t4'h2 : q = b;\n\t\t\t4'h3 : q = c;\n\t\t\t4'h4 : q = d;\n\t\t\t4'h5 : q = a | b;\n\t\t\t4'h6 : q = a | c;\n\t\t\t4'h7 : q = a | d;\n\t\t\t4'h8 : q = b | c;\n\t\t\t4'h9 : q = b | d;\n\t\t\t4'ha : q = c | d;\n\t\t\t4'hb : q = 1'b0;\n\t\t\t4'hc : q = 1'b0;\n\t\t\t4'hd : q = 1'b0;\n\t\t\t4'he : q = 1'b1;\n\t\t\tdefault: q = 'x; // undefined state, don't know how to interpret input.\n\t    endcase\n    end\nendmodule\n"}
{"task_id": "circuit3", "completion": "\n\n    assign q = ((~b & ~c & d) | (a & ~c & ~d)) | (b & ~a & ~d) | (b & ~a & c & ~d) | (a & b & ~c);\n\t  \nendmodule\n\n"}
{"task_id": "circuit3", "completion": "\n\n\tassign q = ((a & ~b) | (~c & b)) ^ d;\nendmodule\n\n"}
{"task_id": "circuit3", "completion": "\n// 4-bit sequential D flip flop with synchronous clear\n\treg [3:0] q_internal;   // define 4 bit register to hold the output value of this flipflop\n    always @(posedge a or posedge b or posedge c or posedge d) begin  // sensitivity list, for each input change we will go into action\n        if (a==1'b1 && b==1'b0 && c==1'b0 && d==1'b0)       // If inputs are a=1 and b=0 and c=0 and d=0 then the output is 1\n            q_internal <= 4'd1;                               // So assigning 1 to the internal register\n        else if(a==1'b0 && b==1'b1 && c==1'b0 && d==1'b0)    // If inputs are a=0 and b=1 and c=0 and d=0 then the output is 2\n            q_internal <= 4'd2;                               // So assigning 2 to the internal register\n        else if(a==1'b0 && b==1'b0 && c==1'b1 && d==1'b0)    // If inputs are a=0 and b=0 and c=1 and d=0 then the output is 3\n            q_internal <= 4'd3;                               // So assigning 3 to the internal register\n        else if(a==1'b0 && b==1'b0 && c==1'b0 && d==1'b1)    // If inputs are a=0 and b=0 and c=0 and d=1 then the output is 4\n            q_internal <= 4'd4;                               // So assigning 4 to the internal register\n\tend  \n\t// The output 'q' would be the least significant bit of our internal register as required by your diagram\n    assign q = q_internal[0];\n"}
{"task_id": "circuit3", "completion": "\n    // combinational logic as per the simulation waveforms provided.\n\tassign q = ((~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (~a & b & ~c & d)) ;  \nendmodule\n"}
{"task_id": "circuit3", "completion": "\n\t// Combination of D flip-flops to create shift register.\n    reg q1;\n    reg q2;\n    \n    always @(*) begin\n        // D Flip-Flop 1\n        if (a == 0 && b == 0) begin\n            q1 = c & ~d;\n        end else if (c == 0 && d == 1) begin\n            q1 = ~b & a;\n        end else begin\n            q1 = c | d;\n        end\n        \n\t\t// D Flip-Flop 2\n        if (a == 1 && b == 0) begin\n            q2 = c & ~d;\n        end else if (c == 1 && d == 0) begin\n            q2 = ~b & a;\n        end else begin\n            q2 = c | d;\n        end\n    end\n    \n\t// Output is the OR of both flip-flops\n    assign q = q1 | q2;\nendmodule\n"}
{"task_id": "circuit3", "completion": "\n\twire ab, bc, cd;\n\tassign ab = a & b;\n\tassign bc = b & c;\n\tassign cd = c & d;\n\tassign q = ~(ab | bc | cd);\nendmodule\n\n"}
{"task_id": "circuit3", "completion": "\n\t// Define the q signal as an intermediate wire to store the value of the next state.\n\twire temp;\n\n\t// Implement the combinational logic using a series of if-else statements.\n\tassign q = (a ? d : c) | (b ? ~d & c : b & a); \n\nendmodule\n"}
{"task_id": "circuit3", "completion": "\nreg [3:0] state;\n\nalways @(*) begin\n\tcase ({d,c,b,a}) \n\t\t4'b0000 : state = 4'b0001; // State 0\n\t\t4'b0001 : state = 4'b0011; // State 1\n\t\t4'b0010 : state = 4'b0010; // State 2\n        4'b0011 : state = 4'b0110; // State 3\n\t\t4'b0100 : state = 4'b0100; // State 4\n        4'b0101 : state = 4'b0101; // State 5\n        4'b0110 : state = 4'b0111; // State 6\n        4'b0111 : state = 4'b0000; // State 7 - Back to state 0\n\t\t4'b1000 : state = 4'b1001; // State 8\n\t\tdefault : state = 4'b0000; // Default back to state 0\n\tendcase\nend\n\nassign q = (state == 4'b0001); // If the current state is state 1, output 'q' will be true. Otherwise it will be false.\n\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n    \n    reg a1_out;\n    reg b1_out;\n    reg a2_out;\n    reg b2_out;\n  \n    // Module A1 (x ^ y) & x\n    always @(*) begin\n        a1_out = (x^y)&x; \n    end\n    \n    // Module B1 \n    initial begin\n    $dumpvars(0, top_module);\n       #5  $dumpvars(0, top_module);\n       #10 $dumpvars(0, top_module);\n       #15 $dumpvars(0, top_module);\n       #20 $dumpvars(0, top_module);\n       #25 z = 1; // x=1,y=0\n       #30 z = 0; // x=0,y=0\n       #35 z = 0; // x=0,y=1\n       #40 z = 0; // x=0,y=1\n       #45 z = 1; // x=1,y=1\n       #50 z = 1; \n       #55 z = 1; \n       #60 $dumpvars(0, top_module);\n       #65 $dumpvars(0, top_module);\n       #70 $dumpvars(0, top_module);\n    end \n    \n    // Module A2 (x ^ y) & x\n    always @(*) begin\n        a2_out = (x^y)&x; \n    end\n    \n    // Module B2 \n    initial begin\n       #75 z = 0; // x=1,y=1\n       #80 z = 0; \n       #85 z = 0; \n       #90 $dumpvars(0, top_module);  \n    end  \n    \n    // OR of A1 and B1 output and AND of A2 and B2 outputs\n    assign z = (a1_out | b1_out) & (a2_out | b2_out); \nendmodule \n"}
{"task_id": "mt2015_q4", "completion": "\n\t// A submodules\n\twire a1, a2;\n\tA u1 (.x(x), .y(y), .z(a1));\n\tA u2 (.x(x), .y(y), .z(a2));\n\t \n\t// B submodules \n\twire b1, b2;\n\tB u3 (.x(x), .y(y), .z(b1));\n\tB u4 (.x(x), .y(y), .z(b2));\n\t\t\n\t// Output of the top_module\n\tassign z = (a1 | b1) & (a2 & b2);\nendmodule\n\n// Define module A and B \nmodule A (\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x ^ y) & x;\n\t  \nendmodule //A\n\nmodule B (\n\tinput x,\n\tinput y,\n\toutput reg z);\n    \n    always @(*) begin \n        if(y === 1'b0 && x === 1'b0 )z<=1 ; \n        else if(y===1'b0 && x ===1'b1) z<= 0;  \n        else if (y ==1'b1 &&x==1'b0)z<=0; \n      \telse z <=0;      // for y==1 and x==1, z remains unmodified as its value is assigned by default in synthesis tool i.e., X or Z (Don't care state). So the if else conditions cover all possible values of input and their combinations are handled correctly with this structure.)\n    end \nendmodule //B\n"}
{"task_id": "mt2015_q4", "completion": "\n\t// Declaration of A and B submodules\n\twire a1o, b1o, ano, bno; \n\tA A1 (.x (x), .y(y), .z(a1o));\n\tB B1 (.x (x), .y(y), .z(b1o));\n\tA AN (.x (ano), .y(y), .z(a2o));\n\tB BN (.x (bno), .y(y), .z(b2o));\n\t// Declaration of the AND and OR gates\n\tand A1ANO (ano, a1o, b1o);\n\tor B1OR (bno, a1o, b1o);\n\t// Implementation of XOR gate for Z output.\n\txor XOR_Z (.a(a2o), .b(b2o), .c(z));\nendmodule\n\n// Definition of submodules A and B\nmodule A (input x, y, output reg z);\nalways @* begin \n\tif((x^y) & x) \n\t\tz = 1; \n\telse \n\t\tz = 0; \nend \nendmodule\n\nmodule B( input x, y, output reg z);\ninitial begin \n\tif (~x&y) \n\t\tz=1 ; \n\telse \n\t\tz =0 ; \nend\nalways @* begin \n\tif (~x&y) \n\t\tz = 1; \n\telse \n\t\tz= 0;\nend  \nendmodule\n\n"}
{"task_id": "mt2015_q4", "completion": "\nmodule A(\n\tinput x,\n\tinput y,\n\toutput reg z1);\n\t\t\n\tassign z1 = (x ^ y) & x; // implemented by module A \nendmodule\n\nmodule B(\n\tinput x,\n\tinput y,\n\toutput reg z2);\n\t\n\t// Waveform provided in the question. So we can directly assign outputs here.\n\talways @(*) begin\n\t    if(!x & !y) z2 = 1;\n        else if (x & !y) z2 = 0; \n        else if (!x & y) z2 = 0;\n        else z2=1; // x & y\n\tend\nendmodule\n\nmodule top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\nwire outAorB;\nwire outAndB; \n\t\t\nA a1(.x(x), .y(y), .z1(outAorB)); // use of first A module\nA a2(.x(x), .y(y), .z1(outAndB)); // use of second A module\n\t\nB b1(.x(x), .y(y), .z2(outOrB));  // use of first B module\nB b2(.x(x), .y(y), .z2(outAndB)); // use of second B module\n\t\t\nassign z = outAorB | outAndB;  // XOR gate to combine outputs of A and B modules. \n\t\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\t// Submodules A and B\n\twire a1, b1; // outputs from the first pair of submodules\n\twire a2, b2; // outputs from the second pair of submodules\n\n\t// Module A (x ^ y) & x\n\tassign a1 = x^y & x; \n\tassign a2 = x^y & x;\n\n\t// Module B: see table above\n\tassign b1 = ~x & ~y | x & y; // using Verilog's NOT, OR and AND operators to mimic the given waveform\n\tassign b2 = ~x & ~y | x & y; \n\n\t// Output z is XOR of outputs a and b\n\tassign z = a1^b1 | a2^b2; // Using an XOR gate with OR gate as per circuit description.\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\t// Define module A and B\n\twire a1, b1, a2, b2;  // Temporary wires to store outputs of A and B submodules\n  \n    // First pair of A and B modules\n\tmodule_A u1 (.x(x), .y(y), .z(a1));\n\tmodule_B u2 (.x(x), .y(y), .z(b1));\n    // Second pair of A and B modules\n\tmodule_A u3 (.x(x), .y(y), .z(a2));\n\tmodule_B u4 (.x(x), .y(y), .z(b2));\n  \n\t// OR gate\n\tor or_gate (\n      // Connect the outputs of A modules to an OR gate\n\t  .in1(a1), \n      .in2(b1),\n      // Output of the OR gate\n      .out(z)\n    );\n    \nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\twire or_out, and_out;\n\tA first_a (.x (x), .y (y), .z (or_out));\n\tB first_b (.x (x), .y (y), .z (and_out));\n\tA second_a (.x (x), .y (y), .z (or2_out));\n\tB second_b (.x (x), .y (y), .z (and2_out));\n\tor #5 or_gate(or_out, or_out, and_out);\n\tand #5 and_gate(and_out, or2_out, and2_out);\n\txor #5 xor_gate(z, or_out, and_out);\nendmodule\n\n// A module that implements the function z = (x^y) & x\nmodule A(\n\tinput x, \n\tinput y, \n\toutput reg z);\n\tassign z = (~x&y) | (x&~y);\nendmodule\n\n// B module that simulates the boolean function provided in the problem.\nmodule B(\n\tinput x, \n\tinput y, \n\toutput reg z);\n\tinitial begin\n         #5; z = 1'b1;\n         #5; z = 1'b0;\n        end\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n    wire or_out1;\n\twire and_out2;\n\t\n\t// A Submodules (A) for OR Gate\n\tassign or_out1 = x | y;\n\t\n\t// B Submodules (B) for AND gate\n\tassign and_out2 = ~x & ~y;\n\t\n    // Output z\n\tassign z = ~(or_out1 & and_out2);\n\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\n\twire a1; // from A module 1 and B module 1\n\twire a2; // from A module 2 and B module 2\n\n\tA a_mod1(x, y, a1);\n\tB b_mod1(x, y, open);\n\tA a_mod2(x, y, a2);\n\tB b_mod2(x, y, open);\n\t\n\t// OR gate for A modules' outputs and AND gate for B modules' outputs\n\tassign z = ~(a1 | a2) & ~(b_mod1.z | b_mod2.z); \nendmodule\n\n"}
{"task_id": "mt2015_q4", "completion": "\n\twire a1;  // Output of the first A submodule\n\twire b1;  // Output of the first B submodule\n\twire a2;  // Output of the second A submodule\n\twire b2;  // Output of the second B submodule\n\t\n\t// Implementing A submodules\n\tassign a1 = ~(x^y) & x;   \n\tassign a2 = ~(x^y) & x;  \n\t\n\t// Implementing B submodules (simulation waveform provided)\n\talways @* begin\n        if($time >= 0 && $time < 5 ) b1 <= 1'b1;\n        else if($time >= 5 && $time < 10 ) b1 <= 1'b1;\n        else if($time >= 10 && $time < 15 ) b1 <= 1'b1;\n        else if($time >= 15 && $time < 20 ) b1 <= 1'b1;\n        else if($time >= 20 && $time < 25 ) b1 <= 1'b0;\n        else if($time >= 25 && $time < 30 ) b1 <= 1'b0;\n        else if($time >= 30 && $time < 35 ) b1 <= 1'b1;\n        else if($time >= 35 && $time < 40 ) b1 <= 1'b1;\n        else if($time >= 40 && $time < 45 ) b1 <= 1'b1;\n        else if($time >= 45 && $time < 50 ) b1 <= 1'b1;\n        else if($time >= 50 && $time < 55 ) b1 <= 1'b0;\n        else if($time >= 55 && $time < 60 ) b1 <= 1'b0;\n        else if($time >= 60 && $time < 65 ) b1 <= 1'b0;\n        else if($time >= 65 && $time < 70 ) b1 <= 1'b1;\n        else if($time >= 70 && $time < 75 ) b1 <= 1'b0;\n        else if($time >= 75 && $time < 80 ) b1 <= 1'b0;\n        else if($time >= 80 && $time < 85 ) b1 <= 1'b0;\n        else if($time >= 85 && $time < 90 ) b1 <= 1'b1;\t\n    end\n\t\n\talways @* begin\n        if($time >= 0 && $time < 5) b2 <= 1'b1;\n        else if($time >= 5 && $time < 10) b2 <= 1'b1;\n        else if($time >= 10 && $time < 15) b2 <= 1'b1;\n        else if($time >= 15 && $time < 20) b2 <= 1'b1;\n        else if($time >= 20 && $time < 25) b2 <= 1'b0;\n        else if($time >= 25 && $time < 30) b2 <= 1'b0;\n        else if($time >= 30 && $time < 35) b2 <= 1'b1;\n        else if($time >= 35 && $time < 40) b2 <= 1'b1;\n        else if($time >= 40 && $time < 45) b2 <= 1'b1;\n        else if($time >= 45 && $time < 50) b2 <= 1'b1;\n        else if($time >= 50 && $time < 55) b2 <= 1'b0;\n        else if($time >= 55 && $time < 60) b2 <= 1'b0;\n        else if($time >= 60 && $time < 65) b2 <= 1'b0;\n        else if($time >= 65 && $time < 70) b2 <= 1'b1;\n        else if($time >= 70 && $time < 75) b2 <= 1'b0;\n        else if($time >= 75 && $time < 80) b2 <= 1'b0;\n        else if($time >= 80 && $time < 85) b2 <= 1'b0;\n        else if($time >= 85 && $time < 90) b2 <= "}
{"task_id": "mt2015_q4", "completion": "\n\t// Module A for (x^y) & x \n\twire a1;\n\twire b1;\n\tassign {a1,b1} = x ^ y ? 2'b01 : 2'b10 ; // x^y=0 -> {a1,b1} = 2'b10; x^y=1 ->  {a1,b1} = 2'b01\n\tassign a = b1 & x;\n  \n\t// Module A for (~x^y) | ~x \n\twire a2;\n\twire b2;\n\tassign {a2,b2} = ~x ^ y ? 2'b01 : 2'b10 ; // ~x^y=0 -> {a2,b2} = 2'b10; ~x^y=1 ->  {a2,b2} = 2'b01\n\tassign b = b2 | ~x;\n  \n\t// OR gate \n\twire c;\n\tassign c = a || b;\n\t\n\t// AND gate \n\twire d;\n\tassign d = a && b;\n    \n    // XOR gate \n\tassign z = ~c ^ d;\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\twire a1; // Output of the first A submodule\n\twire b1; // Output of the first B submodule\n\twire a2; // Output of the second A submodule\n\twire b2; // Output of the second B submodule\n        \n    // Instantiate two A submodules and two B submodules\n    module_A u1 (.x(x), .y(y), .z(a1));\n    module_B u2 (.x(x), .y(y), .z(b1));\n    module_A u3 (.x(x), .y(y), .z(a2));\n    module_B u4 (.x(x), .y(y), .z(b2));\n    \n    // Connect the outputs to an XOR gate\n    assign z = a1 | b1 & a2 & b2;\n        \t\nendmodule\n\n"}
{"task_id": "mt2015_q4", "completion": "\n\twire a1, a2, b1, b2;  // intermediary wires to hold the outputs of A submodules and B submodules respectively.\n\t\n\t// Instantiate four A modules and two B modules\n\tA module_a1(x, y, a1);\n\tA module_a2(x, y, a2);\n\tB module_b1(x, y, b1);\n\tB module_b2(x, y, b2);\n\t\n\t// Output z is the XOR of the outputs from the two pairs of A and B submodules.\n\tassign z = (a1 | b1) & (a2 & b2);  // Implemented with boolean logic\nendmodule\n\n// A module implementation\nmodule A(input x, y, output reg out);\nalways @* begin\n\tif(x != y) \n\t\tout = 0; \n\telse \n\t\tout = 1; \nend\nendmodule\n\n// B module implementation\nmodule B(input x, y, output reg out);\nalways @* begin\n\tif((x == 0 && y == 0) || (x == 0 && y ==1))\n\t\tout = 1;\n\telse  \n\t\tout = 0;\nend\nendmodule \n"}
{"task_id": "mt2015_q4", "completion": "\n\n\twire or_out;\n\twire and_out;\n\twire a1z, a2z, b1z, b2z;\n\t\n\t// A submodules \n\tA A1 (.x(x), .y(y), .z(a1z));\n\tA A2 (.x(x), .y(y), .z(a2z));\n\tB B1 (.x(x), .y(y), .z(b1z));\n\tB B2 (.x(x), .y(y), .z(b2z));\n\n\t// OR gate\n\tor (or_out, a1z, b1z);\n\n\t// AND gate \n\tand (and_out, a2z, b2z);\n\n\t// XOR gate\n\txor (z, and_out, or_out);\n\nendmodule\n\n// Module A\nmodule A(input x, y, output reg z);\n    always @(*) begin\n        z = (x^y) & x;\n    end\nendmodule\n\n// Module B\nmodule B(input x, y, output reg z);\n\treg [1:0] state = 2'b00; // initial state\n\talways @(*) begin \n\t    case (state) \n\t\t    2'b00: if (!x & !y) state <= 2'b00; else state <= 2'b01; \n\t\t\t  2'b01: if (!x & !y) state <= 2'b01; else state <= 2'b10; \n\t\t    \t2'b10: if ( x & !y) state <= 2'b10; else state <= 2'b11; \n\t\t\t  2'b11: if (!x &  y) state <= 2'b11; else state <= 2'b00; \t\t\n\t    endcase\n\tend\n    assign z = (state == 2'b11); // if state is 3, output z=1 otherwise z=0\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\t// Submodules A and B\n\twire submodA1_z;\n\twire submodB1_z;\n\twire submodA2_z;\n\twire submodB2_z;\n  \n\tA a1 (.x(x), .y(y), .z(submodA1_z));\n\tB b1 (.x(x), .y(y), .z(submodB1_z));\n\tA a2 (.x(x), .y(y), .z(submodA2_z));\n\tB b2 (.x(x), .y(y), .z(submodB2_z));\n  \n\t// OR gate\n\twire or_out;\n\tor (or_out, submodB1_z, submodA1_z);\n \n    // AND gate\n\twire and_out;\n\tand (and_out, submodB2_z, submodA2_z);\n  \n\t// XOR gate\n\txor (z, or_out, and_out);\nendmodule\n\n\t// Module A implements the boolean function z = (x^y) & x.\n\tmodule A(input x, y, output reg z);\n\t    always @* begin\n\t\t    z <= x ^ y;  // The XOR of inputs x and y is stored in z\n        end\n\tend  \n    \n\t// Module B implements the boolean function z = (x^y) & !x.\n\tmodule B(input x, y, output reg z);\n\t    always @* begin\n\t\t    z <= ((x ^ y) & ~x);  // The AND of XOR and NOT of x is stored in z\n        end\n\tend  \n"}
{"task_id": "mt2015_q4", "completion": "\n\t// Define submodules A and B \n\twire a1xoray, b1xoray; // wire for outputs of first A and B instances.\n\twire a2xoray, b2xoray; // wire for outputs of second A and B instances.\n    \n    A u1 (.x(x), .y(y), .z(a1xoray));  // First A submodule instance with inputs x and y.\n\tB u2 (.x(x), .y(y), .z(b1xoray));  // First B submodule instance with inputs x and y.\n    A u3 (.x(x), .y(y), .z(a2xoray));  // Second A submodule instance with inputs x and y.\n\tB u4 (.x(x), .y(y), .z(b2xoray));  // Second B submodule instance with inputs x and y.\n    \n    // Connecting the outputs of first pair of A and B modules to an OR gate, second pair to an AND gate.\n\tassign z = (a1xoray || b1xoray) && (a2xoray || b2xoray); \nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n    wire orOut;\n    wire andOut;\n    \n\t// Instantiate two A modules and two B modules \n\tA module1_a (.x(x), .y(y), .z(orOut));\n\tB module1_b (.x(x), .y(y), .z(andOut));\n    A module2_a (.x(x), .y(y), .z());\n    B module2_b (.x(x), .y(y), .z());\n    \n\t// Implement OR and AND using XOR gate\n\tassign z = orOut ^ andOut;  // Final output of the top module is xor of outputs from A modules (or) and B modules (and)\nendmodule\n\n// Module A implements the boolean function z = (x^y) & x.\nmodule A(input x, input y, output reg z);\n\talways @(*) begin\n\t    z <= (x ^ y) & x;  // Asynchronous behavior for A module\n    end\nendmodule\n\n// Module B implements the boolean function z = !x | (!y & x).\nmodule B(input x, input y, output reg z);\n\talways @(*) begin\n\t    z <= !x | (!y & x);  // Asynchronous behavior for B module\n    end\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n    wire a1,b1; // outputs of A submodules\n    wire a2,b2; // outputs of B submodules \n    \n    A iA1(.x(x), .y(y), .z(a1));\n    A iA2(.x(x), .y(y), .z(a2));\n  \tB iB1(.x(x), .y(y), .z(b1));\n  \tB iB2(.x(x), .y(y), .z(b2));\n    \n    assign z = (a1 || b1) && (a2 && b2);\nendmodule\n\nmodule A(input x, y, output reg z);\n\tassign z = (x^y)&x;\nendmodule\n\nmodule B(input x, y, output reg z);\n\tinitial begin\n    \t#5ns  z = 0; // initialize to zero for the first 5 ns.\n        #20ns repeat(7) {z<=~z; #10ns} // Toggle between 0 and 1 every 30 ns\n    end\nendmodule\n\n"}
{"task_id": "mt2015_q4", "completion": "\n\twire a1, b1, a2, b2;\n\n\t// Module A implementation\n\tA firstA(.x(x), .y(y), .z(a1));  // x^y & x\n\tA secondA(.x(y), .y(x), .z(b1));  // y^x & y\n\t \n\t// Module B implementation\n\tB firstB(.x(x), .y(y), .z(a2));   // x | (~x & y)\n\tB secondB(.x(y), .y(x), .z(b2));  // y | (y & ~x)\n\n\t// OR and AND gates for outputs a1, b1, a2, b2\n\tassign z = ~(a1 & a2 & b1 & b2);\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\n\twire a1, a2;  // wires to connect the outputs of the A submodules (A1 and A2)\n\twire b1, b2;  // wires to connect the outputs of the B submodules (B1 and B2)\n\twire or_out, and_out;\n\n\t// Instantiate two instances of module A\n\tA A1 (.x(x), .y(y), .z(a1));\n\tA A2 (.x(x), .y(y), .z(a2));\n  \n\t// Instantiate two instances of module B\n\tB B1 (.t(x), .s(y), .r(b1));\n\tB B2 (.t(x), .s(y), .r(b2));\n\n\t// OR gate connecting the outputs of A submodules\n\tor (or_out, a1, a2);\n  \n\t// AND gate connecting the outputs of B submodules\n\tand (and_out, b1, b2);\n  \n\t// XOR gate connected to the output of the OR and the AND gates\n\txor (z, or_out, and_out);\nendmodule\n\n// Define module A implementing (x^y) & x\nmodule A(input x, y, output z);\n\txor #1 (z, x, y);  // time delay of 1ns\n\tand #2 (z, z, x);  // time delay of 2ns\nendmodule\n\n// Define module B implementing the simulation waveform given in the description\nmodule B(input t, s, output r);\n\t// Initial values to be updated by always block\n\treg [1:0] state = 2'b0;\n  \n\talways @ (posedge t or posedge s) begin\n\t\tcase ({t,s})\n\t\t\t2'b00 : state <= 2'b0;\n      \t\t2'b01 : state <= 2'b1;\n       \t\t2'b10 : state <= 2'b0;  // r is not modified when y=1 in the given waveform, hence the same value as before\n        \t2'b11 : state <= 2'b0;  // r is not modified when both x and y = 1, hence the same value as when {x,y}={0,0}\n   \t\t endcase\n  \tend\n\t// Assign output based on current state\n\tassign r = state[0];\nendmodule\n\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// assign statement output\n\tassign out_assign = a ^ b;\n\n\t// combinational always block output (no flip-flop)\n\talways @(*) begin\n\t\tout_always_comb <= a ^ b;\n\tend\n\n\t// clocked always block output (with flip-flop)\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\n\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n    assign out_assign = a ^ b;\n    \n    always @(*) begin   // Combinational always block.\n       out_always_comb <= a ^ b;\n    end \n\t \n\talways @(posedge clk) begin  // Clocked always block.\n        out_always_ff <= a ^ b;\n     end\nendmodule \n"}
{"task_id": "alwaysblock2", "completion": "\n\t// assign statement XOR gate\n\tassign out_assign = a ^ b;\n\t\n\t// combinational always block XOR gate\n\talways @(*) begin\n\tout_always_comb <= a ^ b;\n\tend\n\t\n\t// clocked always block XOR gate with flip flop\n\talways @(posedge clk) begin \n\tout_always_ff <= a ^ b;\n\tend\nendmodule\n\n"}
{"task_id": "alwaysblock2", "completion": "\n\tassign out_assign = a ^ b;\n\t\n\talways @(*) begin\n\t\tout_always_comb <= a ^ b;\n\tend\n\t\t\n\talways @ (posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend \nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n    \n    assign out_assign = a ^ b;\n      \n    always @(a or b) begin \n        out_always_comb <= a ^ b; \n    end  \n      \n    always @(posedge clk) begin \n        out_always_ff <= a ^ b; \n    end \n\t\nendmodule \n\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// Using assign statement\n\tassign out_assign = a^b;\n\t\n\t// Using combinational always block\n\talways @(*) begin\n\t\tout_always_comb = a^b;\n\tend\n\t\t\n\t// Using clocked always block with flip-flop (delay)\n\talways @(posedge clk or negedge clk) begin\n\t\tif(!clk) begin\n\t\t   out_always_ff <= a ^ b;\n\t\tend\n\t\telse begin\n\t\t    out_always_ff <= 1'bz;\n\t\tend\n\tend\nendmodule \n"}
{"task_id": "alwaysblock2", "completion": "\n\t// Assign statement XOR gate\n\tassign out_assign = a ^ b;\n\n\t// Combinational always block XOR gate\n\talways @(*) begin  // The star (*) indicates combinational logic\n\t    if (a && !b || !a && b)  \n\t        out_always_comb = 1'b1;\n        else   \n            out_always_comb = 1'b0;\n\tend \n\t\t\n\t// Clocked always block XOR gate\n\talways @(posedge clk) begin //The posedge keyword indicates that the sensitivity list includes a clock signal\n\t    if (a && !b || !a && b)  \n            out_always_ff <= 1'b1;\n        else   \n            out_always_ff <= 1'b0;\n\tend \n\t\t\nendmodule \n"}
{"task_id": "alwaysblock2", "completion": "\n\n\tassign out_assign = a ^ b;\n\t\n\talways @* begin\n\t   out_always_comb <= a ^ b;\n\tend\n\n\talways @(posedge clk) begin\n\t   out_always_ff <= a ^ b;\n\tend\n\t\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// Using assign statement\n\tassign out_assign = a ^ b;\n\t\n\t// Using combinational always block\n\talways @(*) begin\n\t\tout_always_comb <= a ^ b;\n\tend\n\t\n\t// Using clocked always block with flip-flop to delay the output\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend \n\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// Using assign statement\n\tassign out_assign = a ^ b;\n\t\n\t// Using combinational always block\n\talways @(*) begin  //beginning of always block (no sensitivity list)\n\t\tout_always_comb <= a ^ b;   // xor operation\n\tend     //ending of always block\n\t\n\t// Using clocked always block\n\talways @(posedge clk) begin    // clock event at rising edge\n\t\tout_always_ff <= a ^ b;  // flip flopped output (delayed compared to input signals)\n\tend      // end of always block\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\t\n\tassign out_assign = a^b;\n\t\n\talways @(a or b) begin\n\t\tout_always_comb <= a ^ b;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// XOR gate using assign statement\n\tassign out_assign = a ^ b;\n    \n    // XOR gate using combinational always block (No Flip-Flop)\n\talways @(*) begin \n\t    if((a==1 && b==0) || (a==0 && b==1))  \n            out_always_comb = 1;  \n        else  \n            out_always_comb = 0;  \n    end    \n\t\t\n\t// XOR gate using clocked always block (with Flip-Flop)\t\n\talways @(posedge clk) begin \n\t    if((a==1 && b==0) || (a==0 && b==1))  \n            out_always_ff <= 1;  \n        else  \n            out_always_ff <= 0;  \n    end    \t\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\tassign out_assign = a ^ b;\n\t\n\talways @(*) begin\n\t\tout_always_comb <= a ^ b;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\tassign out_assign = a ^ b;\n\n\talways @(*) begin\n\t\tout_always_comb = a ^ b;\n\tend\n\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\n\t// Using assign statement\n\tassign out_assign = a ^ b;\n\t\n\t// Combinational always block\n\talways @(*) begin\n\t\tout_always_comb = a ^ b;\n\tend\n\n\t// Clocked always block\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend \nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// Assign statement XOR gate\n\tassign out_assign = a ^ b;\n\t\t\n\t// Combinational always block XOR gate\n\talways @(*) begin\n\t\tout_always_comb <= a ^ b;\n\tend\n\n\t// Clocked always block XOR gate with flip-flop\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend \n\t\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// Using assign statement (XOR Gate)\n\tassign out_assign = a ^ b;\n\n\t// Combinational always block\n\talways @(*) begin \n\t\tout_always_comb = a ^ b;\n\tend\n\n\t// Clocked always block, Flip Flop implementation\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "alwaysblock2", "completion": "\n\t// using assign statement\n    assign out_assign = a ^ b;\n\t\n\t// using combinational always block\n\talways @(a or b) begin\n\t    out_always_comb <= a ^ b;\n\tend\n\t\t\n\t//using clocked always block\n\talways @(posedge clk) begin\n\t    out_always_ff <= a ^ b;\n\tend \n\t\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\n\t\n\tassign out_assign = a ^ b;\n\n\t//Combinational always block\n\talways @(*) begin\n\t\tout_always_comb <= a ^ b;\n\tend \n\n\t//Clocked/Flip-flopped always block\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend \n\nendmodule\n\n"}
{"task_id": "alwaysblock2", "completion": "\n   assign out_assign = a ^ b;\n   \n\talways @* begin\n\t\tout_always_comb <= a ^ b;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\n\t\nendmodule \n"}
{"task_id": "mt2015_muxdff", "completion": "\n\n\t// Sub-Module for flip flop and 2-1 multiplexer\n\tmodule sub_module(\n\t\tinput clk,\n\t\tinput L,\n\t\tinput q_in,\n\t\tinput r_in,\n\t\toutput reg Q);\n\t\t\n\talways @(posedge clk) begin\n    \tif (L) begin\n        \tQ <= r_in;\n    \tend else begin\n        \tQ <= {q_in ^ Q[2], Q[0], Q[2]};\n    \tend\n\tend\n\t\t\n\tendmodule \n\t\n\t// Hierarchical Verilog design with sub-module instantiated three times\n\tsub_module instance1(clk, L, q[0], r[0], q[0]);\n\tsub_module instance2(clk, L, q[1], r[1], q[1]);\n\tsub_module instance3(clk, L, q[2], r[2], q[2]);\n"}
{"task_id": "mt2015_muxdff", "completion": "\nmodule full_module (\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        q <= r;\n    end else begin\n        q <= {q[1] ^ q[2], q[0], q[2]};\n    end\nend\n\nendmodule\n\n// Creating submodule for flip flop and 2-1 MUX\nmodule top_module(\n\tinput clk,\n\tinput L,\n\tinput r_in,\n\toutput Q);\n    \nwire [2:0] mux_out; // Intermediate wire to handle the multiplexer output\nfull_module fm (.clk(clk), .L(L), .r({~r_in, r_in, 1'b0}), .q(mux_out)); // Instance of full module with multiplexer input connected to intermediate wire\n\t    \nassign Q = mux_out[2]; // Assign the output from MUX to Q\n    \nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\nmodule top_module (\n    input clk, // clock\n    input L,   // load/shift line\n    input q_in,// serial data input\n    input r_in,// parallel load data\n    output reg Q  // serial data output\n);\n    \n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;   // load operation\n        end else begin\n            Q <= q_in;   // shift operation\n        end\n    end\nendmodule\n\n"}
{"task_id": "mt2015_muxdff", "completion": "\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            Q <= {Q[1] ^ q_in, Q[0], q_in};\n        end\n\tend\n    \nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\tassign Q = (~L & q_in) | (L & r_in); \nendmodule\n\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t    Q <= r_in;\n        end else begin\n            Q <= ~Q & q_in | Q & ~q_in ;  // this is a flop with inverted data and clock lines. It can be used to make an XOR gate by adding the above line instead of assigning the bitwise operator ^ between q and r; \n        end\n\tend\n\t\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\tQ <= r_in;\n\t\tend else begin\n\t\t\tQ <= q_in;\n\t\tend\n\tend\n\t\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n    \n    // flip-flop\n    always @ (posedge clk) begin \n        if(L==1'b0) \n            Q <= ~q_in;\n        else \n            Q <= q_in;\n    end  \t\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\treg [2:0] mux_out;\n\t\n\t// Flip-flop\n    always @(posedge clk) begin\n        if (L) \n            Q <= q_in;\n        else \n            Q <= ~Q;\n    end\n    \n    // 2 to 1 Multiplexer\n    assign mux_out = {r_in, r_in & Q, Q};\n\t\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\treg [1:0] q;  // Internal flipflop signal\n\tassign Q = q[0];  // Output only the first bit to simulate a single flip-flop\n\n\t// Submodule for flip flop and 2-1 multiplexer\n\talways @(posedge clk) begin\n\t    if (L) begin\n\t        q <= {r_in,q_in};\n        end else begin\n            q <= ~q;\n\t    end\n\tend\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\treg r;\n\tassign r = {r_in};\n\talways @(posedge clk) begin\n\t\tif (L) \n\t\t\tQ <= r;\n\t\telse \n\t\t\tQ <= ~Q;\n\tend\nendmodule\n\n// In the parent module 'full_module', instantiate 'top_module' three times as:\n\nmodule full_module(\n    input [2:0] R,\n    input L,\n    input clk,\n    output [2:0] Q);\n    \n    top_module t1(.clk(clk), .L(L), .r_in(R[0]), .q_in(), .Q(Q[0]));\n    top_module t2(.clk(clk), .L(L), .r_in(R[1]), .q_in(), .Q(Q[1]));\n    top_module t3(.clk(clk), .L(L), .r_in(R[2]), .q_in(), .Q(Q[2]));\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            Q <= {Q[1] ^ Q[2], q_in, Q[2]};\n        end\n    end\nendmodule\n\n"}
{"task_id": "mt2015_muxdff", "completion": "\nmodule top_module (clk, L, q_in, r_in, Q);\n    input clk;\n    input L;\n    input q_in;\n    input r_in;\n    output reg Q;\n    \n    always @(posedge clk) begin\n        if (L) \n            Q <= {Q[1] ^ Q[2], q_in, Q[2]};\n        else \n            Q <= {Q[1] ^ Q[2], ~(Q[0]^r_in), Q[2]};\n    end\n    \nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\tassign Q = (L) ? r_in : ~q_in;\nendmodule\n\n"}
{"task_id": "mt2015_muxdff", "completion": "\n    assign Q = L ? q_in : r_in;\n    \nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\treg q; // Internal flip flop\n    assign Q = (~L & q) | (L & r_in); \n    \n\talways @(posedge clk or negedge L) begin\n        if(~L)\n            q <= '0;  \n        else if (r_in)\n\t\t\tq <= 1'b1;\n\t\telse \n\t\t\tq <= 1'b0;\n    end\nendmodule\n\n"}
{"task_id": "mt2015_muxdff", "completion": "\nassign Q = (L)?r_in:q_in;\nendmodule\n\nmodule full_module(\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q);\n    \n    top_module t1(.clk(clk), .L(L), .q_in(q[0]), .r_in(r[0]), .Q(q[0]) );  // Instantiation for first flip-flop/MUX\n\ttop_module t2(.clk(clk), .L(L), .q_in(q[1]), .r_in(r[1]), .Q(q[1]) );\t// Second flip-flop/MUX instantiation\n    top_module t3(.clk(clk), .L(L), .q_in(q[2]), .r_in(r[2]), .Q(q[2]) );  // Third flip-flop/MUX instantiation\n    \nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\nmodule full_module (\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        q <= r;\n    end else begin\n        q <= {q[1] ^ q[2], q[0], q[2]};\n    end\nend\n\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n\n\t// Submodule \n\tmodule sub_module (\n\t    input clk,\n        input load,\n        input [1:0] ena,\n        input d,\n        output q\n\t);\n\n\t    // D flip flop\n\t\talways @(posedge clk) begin\n\t\t    if (load) \n                Q <= d;\n            else if (ena == 2'h1)  \n                Q <= ~Q;\n            else if (ena == 2'h2)   \n                Q <= d;\n        end\n\tendmodule\n\n\t// Top Module\n\tsub_module instance0(clk, L, r_in[0], q);\n\tsub_module instance1(clk, L, r_in[1], ~q);\n\tsub_module instance2(clk, L, r_in[2], q);\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\n// The submodule which consists of a D flip flop and 2-1 multiplexer.\nmodule top_module(\n    input clk,         //Clock Input\n    input L,           //Load/Shift Select Line\n    input q_in,        //Serial Data Input bit\n\tinput r_in,\t\t  //Parallel Data Load\n    output reg Q       //Q Bar Output\n);\n    \nalways @(posedge clk) begin\n\t//If load signal is high then shift the parallel data loaded into register\n\tif (L==1'b0)\n\t    Q <= {Q[0], q_in};     \t\t  // Shift Right on Clock Pulse\n\telse if (L==1'b1)  \n        Q <= r_in;                     // Load Parallel Data at high load signal level.\t\nend    \n    \nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\treg [3:0] co; // Carry out of each stage full adder.\n    \n\tassign sum[0] = x[0]^y[0]; \n\t// Sum-of-products for the first bit is XOR'ed with Y's same bit to get S1.\n    \n\tassign co[0] = x[0]&y[0]; // And gate produces carry into stage two.\n        \n\tassign sum[1] = x[1]^y[1]^co[0]; \n\t// Same as above but with XOR'ed by the previous carry to get S2.\n    \n\tassign co[1] = (x[1]&y[1])|(co[0]&(x[1]^y[1])); // Stage two full adder, using both previous carries and XOR of stage one's products for a/c calculation.\n        \n\t// This pattern continues to all four bits (S3, S4 and the overflow bit). \n\tassign sum[2] = x[2]^y[2]^co[1];\n    \n\tassign co[2]= ((x[2]&y[2])|(co[1]&(x[2]^y[2]))); // carry for S3 calculated using pattern of above lines.\n        \n\tassign sum[3] = x[3]^y[3]^co[2];\n    \n\tassign co[3]= ((x[3]&y[3])|(co[2]&(x[3]^y[3]))); // carry for S4 calculated using pattern of above lines.\n        \n\t// The overflow bit is the sum of all carries, ignoring the first bit (the sign) because full adder overflows only occur when two positive numbers are added and a negative number is expected or vice versa. \n\tassign sum[4] = co[3]; //overflow bit\n    \nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\t// Full adder module\n\tmodule fa(\n\t\tinput a, b, cin,\n\t\toutput sum, cout\n\t);\n\n\t\tassign sum = a ^ b ^ cin;\n\t\tassign cout = (a & b) | (cin & (a ^ b));\n\t\t\n\tendmodule\n\n\t// 4 bit adder module with overflow output\n\tmodule top_module(\n\t\tinput [3:0] x,\n\t\tinput [3:0] y,\n\t\toutput [4:0] sum\n\t);\n\t\t\n\t\twire c1,c2,c3; // carries\n\n\t\t// Full adders instantiations with carry-in set to 0 for the least significant bits and the carries of the full adders in between as the carry-ins for the next step up.\n\t\tfa fa0(.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n\t\tfa fa1(.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n\t\tfa fa2(.a(x[2]), .b(y[2]], .cin(c2), .sum(sum[2]), .cout(c3));\n\t\tfa fa3(.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));  // sum bit [4] is the overflow output.\n\t\t\n\tendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n    wire c1,c2,c3; //carry bits\n    assign sum[0] = x[0] ^ y[0]; \n    \n    ha ha1 (.a(x[0]), .b(y[0]), .s(sum[0]), .co(c1));\n\tfa fa2 (.a(x[1]), .b(y[1]), .cin(c1), .s(sum[1]), .co(c2)); \n    fa fa3 (.a(x[2]), .b(y[2]), .cin(c2), .s(sum[2]), .co(c3));  \n\tfa fa4 (.a(x[3]), .b(y[3]), .cin(c3), .s(sum[3]), .co(sum[4]));  //carry out is included in the sum bit 5.\nendmodule \n\n// Half Adder (ha) and Full Adders (fa) are used to construct the 4-bit adder with full adders.\n"}
{"task_id": "m2014_q4j", "completion": "\n    \n    wire c1, c2, c3; // Carry wires\n    \n    full_adder fa0 (.x(x[0]), .y(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    full_adder fa1 (.x(x[1]), .y(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa2 (.x(x[2]), .y(y[2]], .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa3 (.x(x[3]), .y(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n    \nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\twire c1, c2, c3; // Carry bits\n\n\t// Full Adders\n\tfa fa0 (.x(x[0]), .y(y[0]), .cin(1'b0), \t.sum(sum[0]), .cout(c1));\n\tfa fa1 (.x(x[1]), .y(y[1]), .cin(c1),  \t.sum(sum[1]), .cout(c2));\n\tfa fa2 (.x(x[2]), .y(y[2]), .cin(c2), \t.sum(sum[2]), .cout(c3));\n\tfa fa3 (.x(x[3]), .y(y[3]), .cin(c3),  \t.sum(sum[3]), .cout(sum[4])); // Cascading Full Adder for overflow bit\nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\n\t// Full Adder Module\n\tmodule fullAdder(\n\t\tinput a, \n\t\tinput b, \n\t\tinput cin,\n\t\toutput reg sum,\n\t\toutput reg cout);\n\t\t\n\t\tassign sum = a ^ b ^ cin;\n\t\tassign cout = (a&b) | (cin & (a^b));\n\tendmodule\n\t\n\t//4-bit Adder Module \n\tfullAdder FA0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(sum[1]));\n\tfullAdder FA1 (.a(x[1]), .b(y[1]), .cin(sum[1]), .sum(sum[1]), .cout(sum[2]));\n\tfullAdder FA2 (.a(x[2]), .b(y[2]), .cin(sum[2]), .sum(sum[2]), .cout(sum[3]));\n\tfullAdder FA3 (.a(x[3]], .b(y[3]), .cin(sum[3]), .sum(sum[3]), .cout(sum[4]));\nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\twire c1,c2,c3; //Carry bits \n\n\t//Full adders for 4 bit addition\n\tfa fa1 (.x(x[0]), .y(y[0]), .cin(1'b0),   .sum(sum[0]), .cout(c1));\n\tfa fa2 (.x(x[1]), .y(y[1]), .cin(c1),    .sum(sum[1]), .cout(c2));\n\tfa fa3 (.x(x[2]), .y(y[2]), .cin(c2),    .sum(sum[2]), .cout(c3));\n\tfa fa4 (.x(x[3]), .y(y[3]), .cin(c3),    .sum(sum[3]), .cout(sum[4]));\nendmodule \n\n\t// Full Adder Module\n\tmodule fa (input x, input y, input cin, output sum, output cout);\n\t  assign #1 sum = x ^ y ^ cin;\n\t  assign #1 cout = (x & y) | (cin & (x ^ y));\n\tendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\twire c1,c2,c3;\n\tfullAdder fa0 (.x(x[0]), .y(y[0]), .cin(1'b0), .s(sum[0]), .cout(c1));\n\tfullAdder fa1 (.x(x[1]), .y(y[1]), .cin(c1), .s(sum[1]), .cout(c2));\n\tfullAdder fa2 (.x(x[2]), .y(y[2]], .cin(c2), .s(sum[2]), .cout(c3));\n\tfullAdder fa3 (.x(x[3]), .y(y[3]), .cin(c3), .s(sum[3]), .cout(sum[4]));\nendmodule\n\n"}
{"task_id": "m2014_q4j", "completion": "\n\n\twire c1,c2,c3; // Carry bits from full adders.\n\tassign {sum[4], c1} = x[0] + y[0];\n\tassign {sum[3], c2} = x[1] + y[1] + c1;\n\tassign {sum[2], c3} = x[2] + y[2] + c2;\n\tassign {sum[1], sum[0]} = x[3] + y[3] + c3; // Least significant bits of sum go directly from adder. Most significant bit comes from the final carry. \nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n  \n  wire c1, c2, c3; //Carry bits\n\n  full_adder fa0 (.x(x[0]), .y(y[0]), .cin(1'b0), .s(sum[0]), .cout(c1));\n  full_adder fa1 (.x(x[1]), .y(y[1]), .cin(c1), .s(sum[1]), .cout(c2));\n  full_adder fa2 (.x(x[2]), .y(y[2]], .cin(c2), .s(sum[2]), .cout(c3));\n  full_adder fa3 (.x(x[3]), .y(y[3]), .cin(c3), .s(sum[3]), .cout(sum[4]));\n  \nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\t// full adder module\n\tmodule FA(\n\t  input a, b, cin,\n\t  output s, cout\n\t);\n\t  assign #10 s = a ^ b ^ cin;  //sum\n\t  assign #10 cout = (a&b) | (cin & (a^b));   //carry out\n\tendmodule\n\t\t\n\t//4 bit adder with overflow logic\n\tFA fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .s(sum[0]), .cout(sum[4]));\n\tFA fa1 (.a(x[1]), .b(y[1]), .cin(sum[4]), .s(sum[1]), .cout(sum[5]));\n\tFA fa2 (.a(x[2]), .b(y[2]), .cin(sum[5]), .s(sum[2]), .cout(sum[6]));\n\tFA fa3 (.a(x[3]), .b(y[3]), .cin(sum[6]), .s(sum[3]), .cout());   // no need for cout as it's the last full adder and we don't use its output in overflow calculation\n\tassign sum[4] = sum[6]; \t// overflow bit is same as carry out of last addition operation.\nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\twire [2:0] c; //carry bits from the full adders \n\tassign sum[0] = x[0] ^ y[0];\n\tc[0] = x[0] & y[0];\n\n\tfa fa1 (.x(x[1]), .y(y[1]), .cin(c[0]), .s(sum[1]), .cout(c[1]));  //full adder instantiation for bit 1,2\n\tfa fa2 (.x(x[2]), .y(y[2]), .cin(c[1]), .s(sum[2]), .cout(c[2]));  \n\tfa fa3 (.x(x[3]), .y(y[3]), .cin(c[2]), .s(sum[3]), .cout(c[3]));  //full adder instantiation for bit 3,4\n\t\t\n\tassign sum[4] = c[3];    //assigning the output of last carry to overflow bit\n\t\nendmodule\n\t\n\t// Full Adder Module:\n\tmodule fa (input x, y, cin,\n\t\t\t\t\toutput s, cout);\n\t\t\t\tassign s = x ^ y ^ cin; \n\t\t\t\tassign cout = (x & y) | (cin & (x ^ y));   // Full adder logic for sum and carry\n\t\t\tendmodule\n"}
{"task_id": "m2014_q4j", "completion": " \n   reg c1,c2,c3;\n   \n   full_adder fa0 (.x(x[0]), .y(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n   full_adder fa1 (.x(x[1]), .y(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n   full_adder fa2 (.x(x[2]), .y(y[2]], .cin(c2), .sum(sum[2]), .cout(c3));\n   full_adder fa3 (.x(x[3]), .y(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n   \nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n   wire c1,c2,c3;\n   \n\tassign sum[0] = x[0] ^ y[0];\n\tassign c1= (x[0]) & (y[0]);\n\tfull_adder f1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n\tfull_adder f2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n\tfull_adder f3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\t\nendmodule\n\n"}
{"task_id": "m2014_q4j", "completion": " \n\twire C1,C2,C3; // carries from full adders to the next one\n\tfull_adder FA1 (.x(x[0]), .y(y[0]), .cin(1'b0), .sum(sum[0]), .cout(C1));\n\tfull_adder FA2 (.x(x[1]), .y(y[1]), .cin(C1), .sum(sum[1]), .cout(C2));\n\tfull_adder FA3 (.x(x[2]), .y(y[2]], .cin(C2), .sum(sum[2]), .cout(C3));\n\tfull_adder FA4 (.x(x[3]), .y(y[3]), .cin(C3), .sum(sum[3]), .cout(sum[4])); // The last full adder has both sum and cout, but we only take the most significant bit into account as overflow in this example. \n\t\nendmodule\n\n"}
{"task_id": "m2014_q4j", "completion": "\n\t// Full adder definition\n\tfunction [5:0] fullAdder;\n\t\tinput a, b, cin;\n\t\tbegin\n\t\t\tfullAdder = {cin ^ (a ^ b), ((~x[i]) & y[i]) | (y[i] & x[i]) };\n\t\tend\n\tendfunction\n        \n\t// 4 bit adder implementation using full adders  \n\tassign sum[0] = fullAdder(x[0], y[0], 1'b0); // Adding the least significant bits with cin = 0\n\tfor (i=1; i<4; i++) begin : ADDER_LOOP // Loop to add the remaining bits\n\t\tassign sum[i] = fullAdder(x[i], y[i], sum[i-1][4]);\n\tend\n        \n\tassign sum[4] = sum[3][4];  // Setting the overflow bit as carry out of fourth bit addition\nendmodule \n"}
{"task_id": "m2014_q4j", "completion": "\n\t// Full Adder implementation\n\tfunction automatic [2:0] fullAdder(input a, b, cin);\n    \treturn {cin ^ (a ^ b), ((a & b) | (cin & (a ^ b))) };\t\n\tendfunction\n\n\twire [3:0] c; // Carry bits\n    assign sum[4], c[0] = fullAdder(x[0], y[0], 1'b0); // Least significant bit full adder with Cin=0\n    \n    genvar i;\n\tgenerate\n        for (i = 1; i < 4; i = i + 1) begin : FA_loop\n            assign {c[i], sum[i]} = fullAdder(x[i], y[i], c[i-1]); // Full adders with Cin as the carry from previous bit adder. \n        end\n    endgenerate  \n\tassign sum[0] = ~|{c[3:0]}; // Overflow flag will be set if any of MSBs in Sum are different.\nendmodule \n"}
{"task_id": "m2014_q4j", "completion": "\n   reg c1, c2, c3; // Carry bits for the 3 full adders.\n\n   full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n   full_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n   full_adder fa2 (.a(x[2]), .b(y[2]], .cin(c2), .sum(sum[2]), .cout(c3));\n   full_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4])); // Overflow bit. \n   \t\t//The overflow bit is simply the carry out of the last full adder.\nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\n\t// Full Adder module \n\tmodule full_adder(\n    \tinput a,\n      \tinput b,\n     \tinput cin,\n        output reg sum,\n      \toutput reg cout);\n   \tassign sum = a ^ b ^ cin;\n  \tassign cout = (a & b) | (cin & (a ^ b));\n\tendmodule \n\n\t//4-bit Adder with full adders\n\tfull_adder adder0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry0));\n\tfull_adder adder1 (.a(x[1]), .b(y[1]), .cin(carry0), .sum(sum[1]), .cout(carry1));\n\tfull_adder adder2 (.a(x[2]), .b(y[2]), .cin(carry1), .sum(sum[2]), .cout(carry2));\n\tfull_adder adder3 (.a(x[3]), .b(y[3]), .cin(carry2), .sum(sum[3]), .cout(sum[4])); //carries to MSB is captured in sum[4]\nendmodule \n"}
{"task_id": "m2014_q4j", "completion": "\n   reg c1,c2,c3;  //carries\n   \n   FullAdder FA0 (.x(x[0]), .y(y[0]), .cin(0),     .sum(sum[0]), .cout(c1));\n   FullAdder FA1 (.x(x[1]), .y(y[1]), .cin(c1),    .sum(sum[1]), .cout(c2));\n   FullAdder FA2 (.x(x[2]), .y(y[2]), .cin(c2),    .sum(sum[2]), .cout(c3));\n   FullAdder FA3 (.x(x[3]), .y(y[3]), .cin(c3),    .sum(sum[3]), .cout(sum[4]));  //sum bit 4 is the overflow bit\n    \nendmodule\n\n// Definition of FullAdder module\nmodule FullAdder (\n\tinput x,\n\tinput y,\n\tinput cin,\n\toutput sum,\n\toutput cout);\n   \n   assign sum = x^y^cin;\n   assign cout = (x&y)|(cin&(x^y));\n    \nendmodule\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n"}
{"task_id": "norgate", "completion": "\n\n\tassign out = ~(a | b);\nendmodule\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n    assign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n"}
{"task_id": "norgate", "completion": "\n\n    assign out = ~(a | b);\n    \nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\n\tassign out = ~(a | b);\n\t\nendmodule\n"}
{"task_id": "norgate", "completion": "\nassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n   assign out = ~(a | b);\nendmodule\n"}
{"task_id": "norgate", "completion": "\nassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\t// Using built-in logical operators\n    assign out = ~(a | b);\n    \nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\n\tassign out = ~(a | b);\n\t\nendmodule\n\n"}
{"task_id": "norgate", "completion": "\n\tassign out = ~(a | b);\nendmodule\n\n"}
{"task_id": "fsm3comb", "completion": "\n\n\talways @* begin\n\t\tcase(state) \n\t\t\t2'b00 : begin  \n\t\t\t\t     if (in==1'b0)\n\t\t\t\t\t      begin\n\t\t\t\t\t\t       next_state = 2'b00; // stay at state A\n\t\t\t\t\t\t\t    out = 1'b0;\n\t\t\t\t\t      end\n\t\t\t\t\t else \n\t\t\t\t\t      begin\n\t\t\t\t\t\t       next_state = 2'b01; // go to state B\n\t\t\t\t\t\t\t    out = 1'b0;\n\t\t\t\t\t      end\t\n\t\t\t\t     end\n\t\t\t2'b01 : begin\n\t\t\t\t     if (in==1'b0)\n\t\t\t\t\t      begin\n\t\t\t\t\t\t       next_state = 2'b01; // stay at state B\n\t\t\t\t\t\t\t    out = 1'b0;\n\t\t\t\t\t      end \n\t\t\t\t\t else\n\t\t\t\t\t      begin\n\t\t\t\t\t\t       next_state = 2'b10; // go to state C\n\t\t\t\t\t\t\t    out = 1'b0;\n\t\t\t\t\t      end\n\t\t\t\t     end\t  \n\t\t\t2'b10 : begin\n\t\t\t\t     if (in==1'b0) \n\t\t\t\t\t      begin\n\t\t\t\t\t\t       next_state = 2'b10; // stay at state C\n\t\t\t\t\t\t\t    out = 1'b0;\n\t\t\t\t\t      end\n\t\t\t\t\t else \n\t\t\t\t\t      begin\n\t\t\t\t\t\t       next_state = 2'b11; // go to state D\n\t\t\t\t\t\t\t    out = 1'b0;\n\t\t\t\t\t      end\t  \n\t\t\t\t     end\t\t\t\n\t\t   2'b11 : begin\n\t\t\t\t     if (in==1'b0) \n\t\t\t\t\t      begin\n\t\t\t\t\t\t       next_state = 2'b11; // stay at state D\n\t\t\t\t\t\t\t    out = 1'b1;\n\t\t\t\t\t      end\n\t\t\t\t\t else \n\t\t\t\t\t      begin\n\t\t\t\t\t\t       next_state = 2'b00; // go back to state A\n\t\t\t\t\t\t\t    out = 1'b0;\n\t\t\t\t\t      end\t  \n\t\t\t\t     end\t\n\t\tendcase\n\tend\t\t\t       \nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n\talways @* begin\n\tcase(state) \n\t\t2'b00: begin next_state = in ? 2'b01 : 2'b00; out = 1'b0; end\n\t\t2'b01: begin next_state = in ? 2'b10 : 2'b01; out = 1'b0; end\n\t\t2'b10: begin next_state = in ? 2'b00 : 2'b10; out = 1'b0; end\n\t\t2'b11: begin next_state = in ? 2'b11 : 2'b01; out = 1'b1; end\n\tendcase\n    end  \n"}
{"task_id": "fsm3comb", "completion": "\n   always @* begin\n        case(state) \n            2'b00 : begin\n                if (in == 0 ) begin\n                    next_state = 2'b00;\n                    out = 1'b0;\n                end else begin\n                    next_state = 2'b01;\n                    out = 1'b0;\n                end\n            end\n            \n            2'b01 : begin \n                if (in == 0 ) begin\n                    next_state = 2'b01;\n                    out = 1'b0;\n                end else begin\n                    next_state = 2'b10;\n                    out = 1'b0;\n                end\n            end\n            \n            2'b10 : begin\n                if (in == 0 ) begin\n                    next_state = 2'b00;\n                    out = 1'b0;\n                end else begin\n                    next_state = 2'b11;\n                    out = 1'b0;\n                end\n            end\n            \n            2'b11 : begin \n                if (in == 0 ) begin\n                    next_state = 2'b10;\n                    out = 1'b1;\n                end else begin\n                    next_state = 2'b01;\n                    out = 1'b0;\n                end\n            end\n        endcase    \n    end \nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n\t// State Transition Logic\n\talways @(*) begin \n    \tcase(state)\n        \t\t2'b00 : next_state = in ? 2'b01 : 2'b00; // A to B on input '0', stay A on input '1'\n        \t\t2'b01 : next_state = in ? 2'b10 : 2'b01; // B to C on input '0', stay B on input '1'\n        \t\t2'b10 : next_state = in ? 2'b11 : 2'b00; // C to D on input '0', back to A on input '1'\n       \t\t\t2'b11 : next_state = in ? 2'b01 : 2'b10; // D to B on input '0', back to C on input '1'\n    \tendcase\n  \tend\n   \n\t// Output Logic\n\tassign out = (state == 2'b10) & ~in; // On state C, output '1' when not getting an input '1'\n"}
{"task_id": "fsm3comb", "completion": "\n\nalways @(*) begin\n\tcase(state) \n\t\t2'b00 : if (in) begin next_state = 2'b10; out=0; end else begin next_state=2'b00; out=0; end\n\t\t2'b01 : if (in) begin next_state = 2'b01; out=0; end else begin next_state=2'b11; out=0; end\n\t\t2'b10 : if (in) begin next_state = 2'b00; out=1;  end else begin next_state=2'b10; out=0; end\n\t\t2'b11 : if (in) begin next_state = 2'b01; out=0; end else begin next_state=2'b00; out=0; end\t\n\tendcase\nend\n\nendmodule\n\n"}
{"task_id": "fsm3comb", "completion": "\n\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t2'b00: begin //State A\n\t\t\t\tif (in==0) begin \n\t\t\t\t\tnext_state <= 2'b00; //Next state remains in State A\n\t\t\t\tend else begin \n\t\t\t\t\tnext_state <= 2'b01; //Transition to State B when input is high\n\t\t\t\tend\n\t\t\t\tout <= 1'b0; //Output for State A and low input=0, i.e., State A\n\t\t\tend\n\n\t\t\t2'b01: begin //State B\n\t\t\t\tif (in==0) begin \n\t\t\t\t\tnext_state <= 2'b01; //Next state remains in State B\n\t\t\t\tend else begin \n\t\t\t\t\tnext_state <= 2'b10; //Transition to State C when input is high\n\t\t\t\tend\n\t\t\t\tout <= 1'b0; //Output for State B and low input=0, i.e., State B\n\t\t\tend\n\n\t\t\t2'b10: begin //State C\n\t\t\t\tif (in==0) begin \n\t\t\t\t\tnext_state <= 2'b00; //Transition to State A when input is low\n\t\t\t\tend else begin \n\t\t\t\t\tnext_state <= 2'b11; //Transition to State D when input is high\n\t\t\t\tend\n\t\t\t\tout <= 1'b0; //Output for State C and low input=0, i.e., State C\n\t\t\tend\n\n\t\t\t2'b11: begin //State D\n\t\t\t\tif (in==0) begin \n\t\t\t\t\tnext_state <= 2'b10; //Transition to State C when input is high\n\t\t\t\tend else begin \n\t\t\t\t\tnext_state <= 2'b01; //Transition to State B when input is low\n\t\t\t\tend\n\t\t\t\tout <= 1'b1; //Output for State D and low input=0, i.e., State D\n\t\t\tend\n\t\tendcase\n\tend \nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n\n\t// Combinational logic portion of the Moore machine\n\talways @(*) begin  // State transition and output logic\n\tcase (state)\n\t\t2'b00 : begin // A state\n\t\t\t\tif (!in) begin\n\t\t\t\t\tnext_state <= 2'b00; // stay in state A\n\t\t\t\t\tout = 1'b0; // output is 0 for state A\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state <= 2'b01; // go to B state\n\t\t\t\t\tout = 1'b0; // output remains at 0\n\t\t\t\t\tend\n\t\t\tend\n\t\t2'b01 : begin // B state\n\t\t\t\tif (!in) begin\n\t\t\t\t\tnext_state <= 2'b01; // stay in state B\n\t\t\t\t\tout = 1'b0; // output is 0 for state B\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state <= 2'b10; // go to C state\n\t\t\t\t\tout = 1'b0; // output remains at 0\n\t\t\t\tend\n\t\t\tend\n\t\t2'b10 : begin // C state\n\t\t\t\tif (!in) begin\n\t\t\t\t\tnext_state <= 2'b00; // go to A state\n\t\t\t\t\tout = 1'b0; // output is still 0 for all states except D in which it goes high.\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state <= 2'b11; // go to D state\n\t\t\t\t\tout = 1'b0; // output remains at 0\n\t\t\t\tend\n\t\t\tend\n\t\t2'b11 : begin // D state\n\t\t\t\tif (!in) begin\n\t\t\t\t\tnext_state <= 2'b10; // go to C state\n\t\t\t\t\tout = 1'b1; // for the in=0 case, output goes high at transition into state D.\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state <= 2'b01; // stay in B state\n\t\t\t\t\tout = 1'b0; // and outputs stays low.\n\t\t\t\tend\n\t\t\tend\n\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "fsm3comb", "completion": "\n\t// Combinational Logic\n\talways @(*) begin  // this is the always block that defines your combinational logic for Moore machine\n        case (state)\n            2'b00 : begin\n                next_state = in ? 2'b01 : 2'b00;  // if input is 0 then stay at state A, if input is 1 move to B\n                out = 1'b0;                       // always output 0 in this state\n            end\n            2'b01 : begin\n                next_state = in ? 2'b10 : 2'b01;  \n                out = 1'b0;\n            end\n            2'b10 : begin\n                next_state = in ? 2'b00 : 2'b10;  \n                out = 1'b0;\n            end\n            2'b11 : begin\n                next_state = in ? 2'b11 : 2'b01;  \n                out = 1'b1;                         // output 1 when in state D and input is 1\n            end\n        endcase\n\tend   \n"}
{"task_id": "fsm3comb", "completion": "\nalways @(*) begin\n\tcase(state)\n\t\t2'b00: if(!in) {next_state = 2'b00; out=1'b0;} else {next_state = 2'b01; out=1'b0;}\n\t\t2'b01: if(!in) {next_state = 2'b00; out=1'b0;} else {next_state = 2'b10; out=1'b0;}\n\t\t2'b10: if(!in) {next_state = 2'b11; out=1'b0;} else {next_state = 2'b00; out=1'b0;}\n\t\t2'b11: if(!in) {next_state = 2'b10; out=1'b1;} else {next_state = 2'b01; out=1'b0;}\n\tendcase\nend\n\n"}
{"task_id": "fsm3comb", "completion": "\n\t\n\t// State Transition Logic\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t2'b00 : next_state = in ? 2'b01 : 2'b00; // A -> B when in=0, stay in A when in=1\n\t\t\t2'b01 : next_state = in ? 2'b10 : 2'b01; // B -> C when in=0, stay in B when in=1\n\t\t\t2'b10 : next_state = in ? 2'b00 : 2'b10; // C -> A when in=0, stay in D when in=1\n\t\t\t2'b11 : next_state = in ? 2'b01 : 2'b10; // D -> B when in=0, stay in C when in=1\n\t\tendcase\n\tend\n  \n\t// Output Logic\n\tassign out = (state == 2'b10) && (next_state == 2'b00);  // Out is 1 only when state is D and next state is A, else it is 0.\n\t\t\nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n   \n\talways @(*) begin\n    \tcase (state) \n        \t2'b00 : begin next_state = in ? 2'b01 : 2'b00; out = 1'b0; end   //State A\n        \t2'b01 : begin next_state = in ? 2'b10 : 2'b01; out = 1'b0; end   //State B\n        \t2'b10 : begin next_state = in ? 2'b00 : 2'b10; out = 1'b0; end   //State C\n        \tdefault: begin next_state = in ? 2'b11 : 2'b01; out = 1'b1; end   //State D\n    \tendcase\n   \tend\nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n\talways @(*) begin\n    case(state)\n        2'b00:begin \n            if (in==0) begin \n                next_state = 2'b00;   // A to A\n\t\t\t\tout=0;\n            end else begin \n                next_state = 2'b01;   // A to B\n\t\t\t\tout=0;\n            end\n        end\n        2'b01:begin\n            if (in==0) begin\n                next_state = 2'b01;   // B to C\n\t\t\t\tout=0;\n            end else begin \n                next_state = 2'b00;   // B to A\n\t\t\t\tout=0;\n            end\n        end\n        2'b10:begin \n            if (in==0) begin\n                next_state = 2'b10;   // C to D\n\t\t\t\tout=0;\n            end else begin \n                next_state = 2'b01;   // C to B\n\t\t\t\tout=0;\n            end\n        end\n        2'b11:begin \n            if (in==0) begin\n                next_state = 2'b00;   // D to A\n\t\t\t\tout=1;\n            end else begin \n                next_state = 2'b10;   // D to C\n\t\t\t\tout=0;\n            end\n        end\n    endcase\nend\nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n    \n    always @(*) begin\n        case(state) \n            2'b00 : if(!in) begin next_state <= 2'b00; out = 1'b0; end else begin next_state <= 2'b01; out=1'b0; end\n            2'b01 : if(!in) begin next_state <= 2'b01; out = 1'b0; end else begin next_state <= 2'b10; out=1'b0; end\n            2'b10 : if(!in) begin next_state <= 2'b00; out = 1'b0; end else begin next_state <= 2'b11; out=1'b0; end \n            2'b11 : if(!in) begin next_state <= 2'b10; out = 1'b1; end else begin next_state <= 2'b01; out=1'b0; end   \n        endcase\n     end\nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t2'b00 : begin next_state = in ? 2'b01 : 2'b00; out = 1'b0; end // A state\n\t\t\t2'b01 : begin next_state = in ? 2'b10 : 2'b01; out = 1'b0; end // B state\n\t\t\t2'b10 : begin next_state = in ? 2'b00 : 2'b10; out = 1'b0; end // C state\n\t\t\t2'b11 : begin next_state = in ? 2'b01 : 2'b10; out = 1'b1; end // D state\n\t\t\tdefault: begin next_state = 2'b00; out = 1'b0; end  \t// Default state is A\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n\n\talways @(*) begin\n\t\tcase(state) \n\t\t\t2'b00: begin\n\t\t\t\tif (in == 0) begin \n\t\t\t\t\tnext_state = 2'b00;   // A,A\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = 2'b01;   // B,B\n\t\t\t\tend \n\t\t\tout = in;\n\t\t\tend\n\t\t\t\n\t\t\t2'b01: begin\n\t\t\t\tif (in == 0) begin\n\t\t\t\t\tnext_state = 2'b00;   // A,C\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = 2'b01;  // B,B\n\t\t\t\tend \n\t\t\tout = in;\n\t\t\tend\n\t\t\t\n\t\t\t2'b10: begin\n\t\t\t\tif (in == 0) begin\n\t\t\t\t\tnext_state = 2'b10;   // C,A\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = 2'b11;  // D,B\n\t\t\t\tend \n\t\t\tout = in;\n\t\t\tend\n\t\t\t\n\t\t\t2'b11: begin\n\t\t\t\tif (in == 0) begin\n\t\t\t\t\tnext_state = 2'b00;   // A,D\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = 2'b01;  // B,B\n\t\t\t\tend \n\t\t\tout = ~in;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "fsm3comb", "completion": "\n\talways @* begin\n\t\tcase (state) \n\t\t\t2'b00 : begin\n\t\t\t\t\tif(in == 0 )begin\n\t\t\t\t\t\tnext_state <= 2'b00; // staying at A state for in=0\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= 2'b01; // moving to B state for in=1\n\t\t\t\t end \n\t\t\t\tout = 0; // always zero output when not in D state.\n\t\t\tend\n      \n      2'b01 : begin\n          if(in == 0 )begin\n\t\t\t\t\t\tnext_state <= 2'b00; // moving to A for in=0\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= 2'b01; // staying at B state for in=1\n\t\t      end \n\t\t\t\tout = 0;// always zero output when not in D state.\n      end\n      \n      2'b10 : begin\n          if(in == 0 )begin\n\t\t\t\t\t\tnext_state <= 2'b10; // staying at C for in=0\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= 2'b11; // moving to D state for in=1\n\t\t      end \n\t\t\t\tout = 0;// always zero output when not in D state.\n      end\n      \n      2'b11 : begin\n          if(in == 0 )begin\n\t\t\t\t\t\tnext_state <= 2'b10; // moving to C for in=0\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= 2'b01;// moving to B state for in=1\n\t\t      end \n\t\t\t\tout = 1; // on transitioning to D, output is switched ON.\n      end\n    endcase\n\tend\nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n   always @(*) begin\n    case (state) \n        2'b00 : begin\n            if (in == 0 )begin\n                next_state <= 2'b00;\n                out = 0;\n            end\n            else if (in == 1) begin\n                next_state <= 2'b01;\n                out = 0;\n            end\n        end\n        2'b01 : begin\n            if (in == 0 )begin\n                next_state <= 2'b00;\n                out = 0;\n            end \n            else if (in == 1) begin\n                next_state <= 2'b10;\n                out = 0;\n            end\n        end\n        2'b10 : begin\n            if(in==0)begin\n               next_state <= 2'b10;\n\t       out=0;\n\t    end \n\t    else if ( in == 1 )begin\n               next_state <= 2'b11;\n               out = 0 ;\n            end\n         end\n         2'b11 : begin\n              if(in==0)begin\n                 next_state <= 2'b01;\n\t\t out=1;\n\t       end \n\t       else if ( in == 1 )begin\n                  next_state <= 2'b10;\n\t\t  out = 0 ;\n               end\n        end  \n    endcase\nend\n"}
{"task_id": "fsm3comb", "completion": "\n\n\talways @(*) begin\n\t    case (state) \n\t\t    2'b00 : begin \n\t\t\t    if (!in) begin\n\t\t\t\t   next_state = 2'b00;\n\t\t\t\t   out = 1'b0;\n\t\t\t    end else begin\n\t\t\t\t   next_state = 2'b01;\n\t\t\t\t   out = 1'b0;\n\t\t\t    end\n\t\t      end\t    \n\t\t    2'b01 : begin \n\t\t\t    if (!in) begin\n\t\t\t\t   next_state = 2'b01;\n\t\t\t\t   out = 1'b0;\n\t\t\t    end else begin\n\t\t\t\t   next_state = 2'b10;\n\t\t\t\t   out = 1'b0;\n\t\t\t    end\n\t\t      end \n\t\t    2'b10 : begin\n\t\t\t    if (!in) begin\n\t\t\t\t   next_state = 2'b00;\n\t\t\t\t   out = 1'b0;\n\t\t\t    end else begin\n\t\t\t\t   next_state = 2'b11;\n\t\t\t\t   out = 1'b0;\n\t\t\t    end \n\t\t      end \n\t\t    2'b11 : begin \n\t\t\t    if (!in) begin\n\t\t\t\t   next_state = 2'b10;\n\t\t\t\t   out = 1'b1;\n\t\t\t    end else begin\n\t\t\t\t   next_state = 2'b01;\n\t\t\t\t   out = 1'b0;\n\t\t\t    end \n\t\t      end\n\t    endcase\t    \n        end\nendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n\n\talways @(*) begin  // Combinational logic\n\tcase ({in, state})\n\t\t2'b00_0 : begin\n\t\t    next_state = state;\n\t\t    out = 1'b0;\n                end\n                2'b00_1: begin\n                    next_state = 2'b10;  // to D from A or B\n                    out = 1'b0;\n\t\tend\n\t\t2'b10_0 : begin\n\t\t    next_state = state;\n\t\t    out = 1'b0;\n                end\n                2'b10_1: begin \n                    next_state = 2'b11; // to B from C\n                    out = 1'b0;\n\t\tend\n\t\t2'b01_0 : begin\n\t\t    next_state = state;  \n\t\t    out = 1'b0;\n                end \n                2'b01_1: begin \n                    next_state = 2'b10; // to D from A or B \n                    out = 1'b0;\n\t\tend\n\t\t2'b11_0 : begin \n\t\t    next_state = state;  \n\t\t    out = 1'b1;\n                end \n                2'b11_1: begin \n                    next_state = 2'b01; // to B from C\n                    out = 1'b1;\n\t\tend\n\t\tdefault : begin\n\t\t    next_state = state;  \n\t\t    out = 1'b0;\n                end\n\t    endcase\n    \tend \n\tendmodule\n"}
{"task_id": "fsm3comb", "completion": "\n\t\n\t// State transition logic\n\talways @* begin\n\t\tcase(state)\n\t\t\t2'b00 : if (in == 0) {next_state <= 2'b00; next_state <= 2'b01;} else {next_state <= 2'b00; next_state <= 2'b10;}\n\t\t\t2'b01 : if (in == 0) {next_state <= 2'b01; next_state <= 2'b01;} else {next_state <= 2'b10; next_state <= 2'b00;}\n\t\t\t2'b10 : if (in == 0) {next_state <= 2'b10; next_state <= 2'b10;} else {next_state <= 2'b10; next_state <= 2'b01;}\n\t\t\t2'b11 : if (in == 0) {next_state <= 2'b10; next_state <= 2'b11;} else {next_state <= 2'b01; next_state <= 2'b11;}\n\t\tendcase\n\tend\n\t\n\t// Output logic\n\tassign out = (state == 2'b11) ? 1 : 0;\n\nendmodule\n\n"}
{"task_id": "fsm_serialdata", "completion": "\n\t// Define the states of the state machine\n\tlocalparam IDLE = 2'b00;\n\tlocalparam DATA = 2'b01;\n\tlocalparam STOP = 2'b10;\n\n\treg [1:0] cur_state, next_state;\n\treg [7:0] byte_counter;\n\twire shift;\n\n\t// Output assignments based on current state\n\tassign done = (cur_state == STOP);\n\tassign out_byte = (cur_state == STOP) ? byte_counter : 8'bz;\n  \n\t// Shift register to capture the 8 bits of data\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tbyte_counter <= 8'h00;\n\t\telse if (shift)\n\t\t\tbyte_counter <= {in, byte_counter[7:1]};\n\tend\n  \n\t// State transition logic and next state calculation\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tcur_state <= IDLE;\n\t\telse \n\t\t\tcur_state <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase(cur_state)\n\t\t\tIDLE: if (in == 0)\n\t\t\t\t      next_state = DATA;\n\t\t\t    else\n\t\t\t\t      next_state = IDLE; \n\t\t\tDATA: if (byte_counter[7] == 1 && in == 1)\n\t\t\t\t\t   next_state = STOP;\n\t\t\t\t  else if (in == 0)\n\t\t\t\t\t   next_state = DATA;\n\t\t\t\t  else\n\t\t\t\t\t   next_state = IDLE; // Reset\n\t\t\tSTOP : if(in == 1)\n\t\t\t\t      next_state = IDLE;\n\t\t\t\telse \n\t\t\t\t      next_state = STOP;\n\t\t\tdefault: next_state = cur_endstate;\n\t\tendcase\n\tend\n\n\t// Shift register control based on current state\n\tassign shift = (cur_state == DATA);\n  \nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n     reg[31:0] shift; // To store the 8 data bits + start bit\n     integer i;\n     \n    typedef enum {WAITING_FOR_START, RECEIVING} state_type;\n       state_type state;\n       \n\talways @(posedge clk or posedge reset) begin\n         if (reset) begin\n             shift <= 32'b0;\n             out_byte <= 8'b0;\n             done <= 1'b0; \n             state <= WAITING_FOR_START;  \n          end   \n        else case(state)\n            // Waiting for the start bit\n            WAITING_FOR_START : begin\n                if (!in) begin // Start bit detected\n                  shift <= 32'b0; \n                  state <= RECEIVING;     \n                 end\n             end   \n             \n           // Receiving data bits and stop bit \n            RECEIVING: begin  \n               shift <= {shift[23:0], in}; // Shift in the next bit \n                if(in) begin // Stop bit detected \n                  out_byte <= {shift[7:0]}; // Output data byte\n                  done <= 1'b1;   \n                  state <= WAITING_FOR_START;  \n                 end     \n             end   \n          endcase  \n     end      \nendmodule\n\n"}
{"task_id": "fsm_serialdata", "completion": "\ntypedef enum {IDLE, START_BIT, DATA_BITS, STOP_BIT} state;\nstate present_state, next_state;\nreg [2:0] bit_counter; // 8 data bits + 1 start bit = 9 total\nreg [7:0] shift_register;\n\n// State Transition Logic\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) present_state <= IDLE;\n\telse present_state <= next_state;\nend\n\n// Next State Logic & Output Decoding\nalways @(*) begin\n\tcase(present_state)\n\t\tIDLE: if(in == 1'b0) begin \n\t\t\tnext_state = START_BIT; \n\t\tend else begin \n\t\t\tnext_state = IDLE; \n\t\tend\n\t\tSTART_BIT: if(bit_counter < 8) begin\n\t\t\tnext_state = DATA_BITS;\n\t\tend else begin\n\t\t\tnext_state = START_BIT; // Keep in start bit state till counter gets reset\n\t\tend \n\t\tDATA_BITS: if (bit_counter == 8) begin // data bits are received, so wait for stop bit\n\t\t\tnext_state = STOP_BIT;\n\t\tend else begin next_state = DATA_BITS; end\n\t\tSTOP_BIT: if(in == 1'b1) begin \n\t\t\tnext_state = IDLE; // Stop bit was correct so go to idle state\n\t\tend else begin \n\t\t\tnext_state = STOP_BIT; // Keep in stop bit until stop bit is found again\n\t\tend\n\t\tdefault: next_state = IDLE;\n\tendcase\n\tcase(present_state)\n\t\tDATA_BITS: out_byte = shift_register[7:0]; \n\t\tdefault: out_byte = 8'bZ; // dont care value\n\tendcase\n\tdone = (present_state == STOP_BIT && in == 1'b1); // If we found a stop bit and it is logic '1', done is asserted\nend\n\n// Shift Register & Bit Counter Logic\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) begin \n\t\tshift_register <= 8'b0; // reset the shift register to zero\n\t\tbit_counter <= 3'b0; // and bit counter\n\tend else if((present_state == DATA_BITS || present_state == START_BIT) && in == 1'b0) begin \n\t\t// Start bits are detected at falling edge, so we need to check for rising edge of clk\n\t\tif (bit_counter < 9) // Don't increment counter if it is a start bit since start bit will be received first time after reset or when idle state occurs and detects the next start bit.\n\t\t  bit_counter <= bit_counter + 1; \n\tend else if(present_state == DATA_BITS && in == 1'b0) begin // Data bits are detected at falling edge, so we need to check for rising edge of clk\n\t\t// When detecting data bits and a start bit is detected simultaneously. The start bit must have been received before the next 8 data bits. So count only after one clock cycle.\n\t\t\tshift_register <= {in, shift_register[7:1]}; // Shift in new bit at MSB position\n\tend else if(present_state == START_BIT && in == 1'b0) begin \n        // Only count start bits on falling edges because we have the condition that we only increment counter when detecting data bits and a start bit is detected simultaneously. So, no need to check for rising edge of clk here.\n\t\tbit_counter <= 3'b0; // Reset bit counter so that 9th bit (which represents the start bit) is counted first in next byte.\n\tend\nend\n"}
{"task_id": "fsm_serialdata", "completion": "\nlocalparam S_IDLE = 2'b00; // Waiting for start bit \nlocalparam S_DATA = 2'b01; // Waiting for data bits\nlocalparam S_STOP = 2'b10; // Waiting for stop bit\n\t\nreg [7:0] out_byte_reg = 8'h0;  \nreg done_reg = 0; \nreg [1:0] state = S_IDLE;\nreg [3:0] bit_counter = 4'h0; // counter for data bits \n\t\nalways @(posedge clk, posedge reset) begin\n\tif (reset == 1'b1) begin\n\t\tstate <= S_IDLE;\n\t\tbit_counter <= 4'h0;\n\t\tdone_reg <= 0;\n\tend else begin\n\t\tcase (state) \n\t\t\tS_IDLE : begin // Waiting for start bit\n\t\t\t\tif(in == 1'b0) begin\n\t\t\t\t\tstate <= S_DATA;\n\t\t\t\t\tbit_counter <= 4'h8; // Start counting data bits from 7 to 0\n\t\t\t\tend else begin\n\t\t\t\t\tdone_reg <= 0;\n\t\t\t\tend\t\t\n\t\t\tend\n\t\t\t\t\t\n\t\t\tS_DATA : begin // Waiting for the remaining data bits and one stop bit\n\t\t\t\tif(bit_counter != 4'h0) begin\n\t\t\t\t\tout_byte_reg <= {in, out_byte_reg[7:1]}; \n\t\t\t\t\tbit_counter <= bit_counter - 4'h1; // Decrease the counter until it becomes zero\n\t\t\t\tend else if(in == 1'b1) begin\n\t\t\t\t\tstate <= S_STOP;  \n\t\t\t\tend\t\t\n\t\t\tend\n\t\t\t\t\t\n\t\t\tS_STOP : begin // Waiting for a stop bit, once received set done to 1 and go back to idle state.\n\t\t\t\tif(in == 1'b1) begin\n\t\t\t\t\tstate <= S_IDLE;  \n\t\t\t\t\tdone_reg <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tdone_reg <= 0;\n\t\t\t\tend\t\t\n\t\t\tend\t\t\n\t\tendcase\n\tend \nend\nassign out_byte = out_byte_reg;\nassign done = done_reg;\n\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n// Finite State Machine Definition \ntypedef enum logic[2:0]{STATE_IDLE = 3'b001, STATE_START = 3'b010, STATE_DATA = 3'b100} state_t;\n\tstate_t state, next_state;\n\tlogic [7:0] byte_reg; // register to hold the byte being received\n\tlogic done_reg; // register to hold the output signal\n \n\t// Synchronous Process\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset) begin\n        \tstate <= STATE_IDLE;\n        \tbyte_reg <= 8'b0;\n        \tdone_reg <= 1'b0;\n    \tend\n    \telse begin\n        \tstate <= next_state;\n        \tbyte_reg <= byte_reg << 1 | in; // shift the register left and add the new bit at MSB\n        \tdone_reg <= (next_state == STATE_IDLE); \n    \tend\n  \tend\n\t// Next State Logic Process\n\talways @(*) begin\n    \tcase (state)\n        \tSTATE_IDLE: next_state = in ? STATE_START : STATE_IDLE;\n        \tSTATE_START: next_state = in ? STATE_DATA : STATE_IDLE; // wait for 8 more transitions to finish receiving the byte, then go back to idle if another start bit is detected.\n       \t\tSTATE_DATA: next_state = in ? STATE_DATA : (in == 0) ? STATE_START : STATE_IDLE; // continue receiving until a stop bit is found after all 8 data bits have been received, then go back to idle if another start bit is detected.\n        \tdefault: next_state = STATE_IDLE;\n    \tendcase\n  \tend\n\t// Output Assignments\n\tassign out_byte = byte_reg; // output the register that holds the bytes being received\n \tassign done = done_reg; // assert high for one clock cycle when a stop bit is detected and has been handled. This will reset to low once the FSM returns to idle state (as indicated by in == 0)\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n\treg [9:0] shift; \t//register with start bit, data bits and stop bit.\n\twire start = !shift[0]; //start when first bit is not set i.e., its a start bit.\n\twire stop  = shift[9];  //stop when last bit is set i.e., its a stop bit.\n\treg [3:0] count;      \t//counter to keep track of number of bits received till now.\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tshift <= 10'b1111111111; //initialize with idle state 1s.\n\t\t\tcount <= 4'd8;          //count should be initialized to 8 for first cycle only.\n\t\t\tout_byte <= 8'd0;       //output byte is set to zero in reset case.\n\t\t\tdone <= 1'b0;           //reset done signal as well.\n\t\tend else begin\n\t\t\tshift <= {in, shift[9:1]}; \t//receive bits one by one from left i.e., MSB becomes next cycle LSB.\n\t\t\tif (start) begin        \t  \t  \t   \t   //when start bit is detected\n\t\t\t\tcount <= 4'd0;          \t\t\t\t  \t  //reset the counter to 0.\n\t\t\tend else if (count < 4'd9) begin     \t//if not a stop bit yet\n\t\t\t\tcount <= count + 1;              \t   //increment counter till 8.\n\t\t\tend\n\t\t\tif (stop && count==4'd9) begin      \t \t//when all bits received and it is stop bit\n\t\t\t\tout_byte <= shift[7:0];         \t    //then send data byte on output.\n\t\t\t\tdone <= 1'b1;              \t\t\t   //and assert done signal as well.\n\t\t\tend else if (stop) begin       \t\t\t//if not all bits received yet and it is stop bit\n\t\t\t\tout_byte <= 8'd0;             \t   \t  //then reset output byte to zero.\n\t\t\t\tdone <= 1'b0;               \t       \t   //and de-assert done signal.\n\t\t\tend\n\t\tend\n\tend\nendmodule \n\n"}
{"task_id": "fsm_serialdata", "completion": "\n\nreg [2:0] state;\nwire start = state[0]; //start bit detector\nwire stop  = state[1]; //stop bit detector\nreg  [3:0] bitcount;  \nreg [7:0] data_out;\nassign done = stop;\nassign out_byte = data_out;\n    \nalways @(posedge clk or posedge reset) begin\n    if (reset == 1'b1) begin\n        state <= 3'b0;\n        bitcount <= 4'd8;\n\tdata_out <= '0;\n    end else begin\n        case (state) \n            3'b000 : //wait for start bit\n                if(~in) begin\n                    state <= 3'b100;\n\t\t   bitcount <= 4'd8;\n\t\tend    \n            3'b100 : //reading data bits\n               if (bitcount != 4'd0) begin \n                   data_out <= {in,data_out[7:1]};\n                   state <= {~stop,start};\n\t\t   bitcount <= bitcount - 4'd1;\n\t       end    \n            3'b110 : //wait for stop bit\n                if(in) begin\n                    state <= 3'b000;\n\t        end     \n        endcase   \n    end          \nend  \nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n\treg [31:0] counter;\n\treg [7:0] data;\n\treg start, stop;\n\treg done;\n\tparameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;\n\treg [1:0] state = IDLE;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tcounter <= 0;\n\t\t\tdone <= 0;\n\t\t\tdata <= 8'b0;\n\t\tend else case (state) \n\t\tIDLE: if (!in) state <= START;\n\t\tSTART: if (in) begin \n\t\t\tstate <= DATA;\n\t\t\tcounter <= 7;\n\t\t\tend\n\t\tDATA: if (counter != 0) begin\n\t\t\tdata[counter] <= in;\n\t\t\tcounter <= counter - 1;\n\t\t\tend else state <= STOP;\n\t\tSTOP: if (!in) begin\n\t\t\tstate <= IDLE;\n\t\t\tdone <= 1;\n\t\t\tout_byte <= data;\n\t\t\tend\n\t\tdefault: state <= IDLE;\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "fsm_serialdata", "completion": "\nreg [31:0] shift;  \nparameter SHIFT = 24; // 8 bits of data + 1 start bit + 1 stop bit.\nparameter IDLE = 2'b01;\nparameter RECEIVE = 2'b10;\nparameter STOP_WAIT = 2'b11;\nreg [1:0] state = IDLE;\nwire start, stop;\nassign out_byte = shift[7:0];\nassign start = (state == RECEIVE && in == 0); \nassign stop = (state == STOP_WAIT && in == 1);  \nalways @(posedge clk or posedge reset) begin\n\tif(reset)begin\n\t\tshift <= 32'b1; // idle state\n\t\tdone <= 0;\n\t\tstate <= IDLE; \n\tend else begin\n\tcase (state)\n\tIDLE: if(!in)  begin \n\t\t   state <= RECEIVE; \n\t\t  end\n\tRECEIVE: if(start)begin \n\t\t    shift <= {shift[23:0],1'b0}; // Shift in start bit\n\t\t   end else begin\n\t\t     shift <= {shift[30:0],in};  // Continue receiving bits\n\t\t   end\n\tSTOP_WAIT: if(stop)begin\n\t\t\t state <= IDLE; //Go back to idle when stop is detected.\n\t\t\tdone <= 1;      //Set done flag\n\t\t       end else begin\n\t\t         shift <= {shift[29:0],in,1'b1};  //Wait for stop bit\n\t\t       end  \n\tdefault : state <= IDLE;\n\tendcase\n    end\nend\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n    reg [3:0] state;\n    reg [7:0] out_byte_internal;\n    \n    parameter IDLE = 4'd0, START1 = 4'd1, DATA =  4'd2, STOP1 = 4'd3;\n\t\n    assign done = (state == STOP1);\n\tassign out_byte = (state == STOP1) ? out_byte_internal : 8'bz;\n\n    always @(posedge clk or posedge reset) begin\n        if(reset) begin\n            state <= IDLE;\n            out_byte_internal <= 8'b0;\n        end else begin    \n           case (state) \n                IDLE:   if (!in) state <= START1; // Wait for start bit\n                START1: if (in ) begin state <= DATA ; out_byte_internal[7]<= in; end\n                DATA :  if (!in) begin out_byte_internal[6:0] <= {out_byte_internal[7],out_byte_internal[6:0]};end else state <= STOP1; // Shift in next bit and store\n               END\n        end\t    \n    end\t\t\nendmodule \n"}
{"task_id": "fsm_serialdata", "completion": "\n\n\t//State definition\n    typedef enum logic[1:0]{S0=2'b00, S1=2'b01, S2=2'b10} state_t;\n\tstate_t state, next_state;\n\treg [7:0] data; // Data register\n\treg [3:0] bit_cnt; // Bit counter\n\n\t//State transition and outputs logic\n\talways @(posedge clk or posedge reset) begin \n\t    if (reset) state <= S0; else state <= next_state;\n\t    case (state)\n\t\t    S1 : out_byte <= data;\n\t\t    default: done <= 1'b0;\n\t\tendcase\n\tend\n\n\t//State transition logic with Moore outputs\n\talways @(*) begin \n\t\tcase(state)\n\t\t\tS0 : if (in == 1'b0) next_state = S1; else next_state = state; // Wait for start bit\n\t\t\tS1 : if (bit_cnt < 4'd8) next_state = S1; else next_state = S2;   // Counting 8 data bits\n            default: next_state = S0; // Reset or when stop bit not found.\n        endcase\n\tend\n\n\t//State dependent logic \n\talways @(posedge clk) begin \n\t    if (reset == 1'b1) begin\n\t\t    data <= 8'h0;\n\t\t    bit_cnt <= 4'h0;\n\t\tend else begin\n            case (state)\n                S1 : begin\n\t\t\t\t\tif (bit_cnt < 4'd8) begin\n\t\t\t\t\t    data <= {in, data[7:1]}; // Shift in new bit \n                        bit_cnt <= bit_cnt + 1;   // Counting data bits\n                    end\n\t\t\t\tend\n                S2 : if(in == 1'b1) done <= 1'b1; else next_state = S0;    // Wait for valid stop bit \n            endcase\n        end\n\tend\n\t\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n     reg[3:0] state; //state 0 is idle and others are for data reception states.\n    reg[7:0] temp;\n    parameter IDLE=4'b0001, D0=4'b0010,D1=4'b0100,D2=4'b1000; //States for receiving data bits. \n   reg done_internal = 0;\n    always @(posedge clk or posedge reset) begin\n        if(reset == 1)begin\n            state <= 4'd0;\n\t    temp<= 8'd0;\n        end\n\t\telse begin\n\t\t\tcase (state) \n\t\t\t     IDLE: begin\n\t\t\t\t\tif(in==0) //If a start bit is detected move to the next state.\n\t\t\t\t\t    state <= D0;\n                         done_internal <= 0 ;\n\t\t\t\tend\n\t\t\t\tD0: begin   //Receiving first data bit.\n\t\t\t\t    temp[0]<= in; \n if(in)\n state <= D1;     \t\t        \t \t             \t      end\n                               \t   else \n state <= IDLE ;\n                          end            \n                             \n\t\t\t     D1: begin //Receiving second data bit.\n\t\t\t\t    temp[1]<= in; \n if(in)\n state <= D2;     \t\t        \t \t             \t      end\n                               \telse\n state <= IDLE ;\n                         end         \n                                                    \n\t\t\t     D2: begin //Receiving third data bit.\n\t\t\t\t    temp[2]<= in; \n if(in)\n state <= IDLE;     \t\t        \t \t             \t      end\n                               \telse \n state <= IDLE ;      \n                            enddefault:begin   //Return to Idle when no valid start bit is detected.\n                                 done_internal <= 0 ;   \n state <= IDLE;               \n                             end         \n                        endcase\t           \n                \tend     \t\t        \t    \n             end \t\t\t\n    assign out_byte = temp;\n   assign done = (state == IDLE)?done_internal:0;\n              //If byte is correctly received, done signal will asserted. \t\t\t\t\nendmodule \n"}
{"task_id": "fsm_serialdata", "completion": "\ntypedef enum logic[1:0] {IDLE=2'b00, START=2'b01, DATA=2'b10} state_t;\nstate_t state, next_state;\nlogic [3:0] bit_count;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= IDLE;\n    else \n        state <= next_state;\nend\n    \nalways @(*) begin\n    case (state)\n        IDLE:   if (in == 0)       next_state = START; else next_state = IDLE;\n        START:  if (bit_count==8)  next_state = DATA;  else next_state = START;\n        DATA:   if (bit_count==9)  next_state = IDLE;  else next_state = DATA;\n        default:                 next_state = IDLE;\n    endcase\nend\n    \nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        bit_count <= 4'b0000;\n    else \n        case (next_state)\n            START:  bit_count <= bit_count + 1;\n            DATA:   bit_count <= bit_count + 1;\n            default: bit_count <= 4'b0000;\n        endcase\nend\n    \nalways @(posedge clk or posedge reset) begin\n    if (reset) \n        out_byte <= 8'b0000_0000;\n    else if (state == DATA && bit_count == 9) \n        out_byte <= {out_byte[6:0], in};\nend\n    \nassign done = (state==DATA && bit_count==9);\n"}
{"task_id": "fsm_serialdata", "completion": "\n\t// State definitions\n\tparameter STATE_IDLE = 2'd0;\n\tparameter STATE_START = 2'd1;\n\tparameter STATE_DATA = 2'd2;\n\tparameter STATE_STOP = 2'd3;\n\n\treg [1:0] state, next_state;\n\treg [7:0] bit_cnt, byte;  // bit counter and byte buffer\n\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= STATE_IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic & data shift register\n\talways @* begin\n\t\tcase (state) \n\t\t\tSTATE_IDLE:\n\t\t\t\tif (in == 1'b0)  // Waiting for start bit to appear\n\t\t\t\t\tnext_state = STATE_START;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_IDLE;\n\n\t\t\tSTATE_START:\n\t\t\t\tif (bit_cnt < 8) begin  // While we're still in the data phase, keep shifting bits into our buffer and increasing bit counter\n\t\t\t\t\tbyte = {in, byte[7:1]};  \n\t\t\t\t\tbit_cnt = bit_cnt + 2'd1;    \n\t\t\t\t\tnext_state = STATE_DATA;      \n\t\t\t\tend else begin  // If we are in the start but already at state 8, we reset our buffer and bit counter and go to the data phase again\n\t\t\t\t\tbyte = 8'b0;               \n\t\t\t\t\tbit_cnt = 2'd0;           \n\t\t\t\t\tnext_state = STATE_DATA;  \n\t\t\t\t}); \n\n\t\t\tSTATE_DATA:\n\t\t\t\tif (bit_cnt < 8) begin // Waiting for next data bit to appear\n\t\t\t\t\tbyte = {in, byte[7:1]};    \n\t\t\t\t\tbit_cnt = bit_cnt + 2'd1;  \n\t\t\t\t\tnext_state = STATE_DATA;   \n\t\t\t\tend else if (bit_cnt == 8) begin // All 8 data bits received, now waiting for stop bit to appear\n\t\t\t\t\tbyte = {in, byte[7:1]};     \n\t\t\t\t\tbit_cnt = 2'd0;            \n\t\t\t\t\tnext_state = STATE_STOP;    \n\t\t\t\tend else begin // If we are in the data state but already at count of 8 bits and a stop bit is detected, we reset our buffer and go back to idle. This allows for multiple bytes to be read\n\t\t\t\t\tbyte = 8'b0;              \n\t\t\t\t\tbit_cnt = 2'd0;           \n\t\t\t\t\tnext_state = STATE_IDLE;   \n\t\t\t\t}); \n\t\t\n\t\t\tSTATE_STOP: // Stop bit found, wait for next start bit to appear\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tdone = 1'b1;    \n\t\t\t\t\tout_byte <= byte;  \n\t\t\t\t\tnext_state = STATE_IDLE; \n\t\t\t\tend else begin // If stop bit does not exist, remain in this state until it appears and transition back to IDLE state.\n\t\t\t\t\tdone = 1'b0;     \n\t\t\t\t\tout_byte <= 8'bz;  \n\t\t\t\t\tnext_state = STATE_STOP; \n\t\t\t\t};\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\nenum {IDLE, START_BIT, DATA, STOP_BIT} state;\nreg [2:0] bit_cnt;\nreg [7:0] data_buf;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    state <= IDLE;\n    done <= 1'b0;\n    out_byte <= 8'h00;\n  end else begin\n    case (state)\n      IDLE: begin\n        bit_cnt <= 3'b000;\n        if (!in) begin // Start Bit detected\n          state <= START_BIT;\n        end\n      end\n      \n      START_BIT: begin\n        bit_cnt <= bit_cnt + 1;\n        data_buf[7:1] <= {data_buf[6:0]};\n        \n        if (bit_cnt == 3'b011) begin // We have 8 Data bits\n          state <= DATA;\n        end\n      end\n      \n      DATA: begin\n        bit_cnt <= bit_cnt + 1;\n        data_buf[0] <= in;\n        \n        if (bit_cnt == 3'b100) begin // We have 8 Data bits and now we are waiting for Stop bit\n          state <= STOP_BIT;\n        end\n      end\n      \n      STOP_BIT: begin\n        if (!in) begin // If it is a stop bit, then we consider data received successfully\n          out_byte <= data_buf;\n          done <= 1'b1;\n          state <= IDLE;\n        end else begin // if there was not stop bit detected then we keep waiting for it\n          state <= STOP_BIT;\n        end\n      end\n      \n    endcase\n  end\nend\n\n"}
{"task_id": "fsm_serialdata", "completion": "\nreg [3:0] bit_counter;\nreg [7:0] data;\nwire start;\nassign start = (bit_counter == 4'hA) ? 1 : 0; // Start bit is '0'. Decimal 10 in ASCII.\n\t\n// State encoding: S0-IDLE, S1-WAITING FOR START BIT, S2-GETTING DATA, S3-WAITING FOR STOP BIT\nreg [1:0] state;  \nparameter IDLE = 2'b00;\nparameter WAIT_START = 2'b01; \nparameter GET_DATA = 2'b10;\nparameter WAIT_STOP = 2'b11;\n\t\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= IDLE;\n\tend else begin\n\t\tcase (state)\n\t\t\tIDLE:begin \n\t\t\t\tif (!in) state <= WAIT_START;   //waiting for start bit\n\t\t\tend\n\t\t\t\t\n\t\t\tWAIT_START:begin \n\t\t\t\tif(start)begin\n\t\t\t\t\tbit_counter <= 4'h1;       //reset bit counter and get the first data bit\n\t\t\t\t\tstate <= GET_DATA;         //go to state GET_DATA\n\t\t\t\tend\n\t\t\tend\n\t\t\t\t\t\n\t\t\tGET_DATA: begin \n\t\t\t\tif(start)begin\n\t\t\t\t\tdata[7:0]<= {in, data[7:1]};    //shifting in new bit and saving old bits to the register.\n\t\t\t\t\tif (bit_counter < 4'h8)   //if we haven't received all 8 bits yet..\n\t\t\t\t\t\tbit_counter <= bit_counter + 1;     //increase counter\n\t\t\t\t\telse                        //else we have received a full byte.\n\t\t\t\t\t\tstate <= WAIT_STOP;       //go to state wait stop\n\t\t\t\tend\n\t\t\tend  \n\t\t\t\t\t\t\n\t\t\tWAIT_STOP: begin \n\t\t\t\tif(in)begin                       //if we are still in the middle of the stop bit, go back to waiting for start bit\n\t\t\t\t\tstate <= IDLE;   \n\t\t\t\t\tout_byte<=data[7:0];\n\t\t\t\t\tdone <= 1'b1;            //assert done signal. \n\t\t\t\tend else begin                        \n\t\t\t\t\tstate <= WAIT_START;      //if we are still waiting for the stop bit, stay in this state..\n\t\t\t\t\tdone <= 1'b0;             //and keep resetting done signal..\n\t\t\t\t\tend  \n\t\t\tend   \n\t\tdefault:begin \n\t\t\tstate<=IDLE;       //Default case to IDLE.\n\t\t\tend \n\t\tendcase\n\tend\nend\n\t\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n//state defination \nlocalparam START  = 3'b001; //start bit received\nlocalparam DATA   = 3'b010; //8 data bits received\nlocalparam STOP   = 3'b100; //stop bit received\n\nreg [2:0] state = START;  //initial state set to start\nreg [7:0] shift_register = 8'h0;  //clear the register at start\nwire serial_in= in; //input bit from serial line\nreg done = 1'b0; //done signal\n\nalways @(posedge clk or posedge reset) begin//synchronous state machine\n\tif (reset == 1'b1) begin\n\t\tstate <= START;  //asynchronous reset\n\t\tshift_register <= 8'h0;  \n        done <= 1'b0;\n    end else begin\n         case(state)\n             START:begin  \n                 if (serial_in == 1'b0) state<= DATA ;//if start bit received move to data state\n\t\t     else state <= START; //else stay in the same state\t\n\t\t\t done <= 1'b0; //clear done signal \n              end \n             DATA: begin \n                  if (&shift_register[7:0]==1)begin  \n                     shift_register <= {serial_in,shift_register[7:1]};//shift in the received bit into register\t\n                     state <= STOP; //after 8 bits move to stop state\n\t\t\t\t\t done <= 1'b0;\t//clear done signal   \n                  end\n                  else begin  \n                      shift_register <= {serial_in,shift_register[7:1]};//shift in the received bit into register\t\n                      state <= DATA; //stay at the same data state\n\t\t\t\t\t  done <= 1'b0;\t//clear done signal   \n                 end   \n               end  \n             STOP: begin \n                  if(serial_in == 1'b1)begin \n                     out_byte<=shift_register ;//if stop bit is correct load the byte into output register\t\n                     state <= START; //move to start state \n\t\t\t\t\t done <= 1'b1;\t//set done signal   \n                  end  \n                  else begin \n                      shift_register<= {serial_in,shift_register[7:1]};//shift in the received bit into register\t\n                      state <= STOP ; //stay at the stop state\n\t\t\t\t\t  done <= 1'b0;\t//clear done signal   \n                 end    \n             default : begin\n\t\t\t      state<=START;\n\t\t\t\t  done <= 1'b0;  \n                  end \t \n          endcase\n\tend \t\t\nend      \nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n\treg [3:0] shift; \n\treg [8:0] temp; // extra bit for stop bit.\n\tparameter IDLE = 2'd0, STARTED=2'd1, RECEIVING =2'd2;\n\treg [1:0] state ;\n\t \n\talways @(posedge clk or posedge reset) begin \n\t    if (reset) begin\n\t        out_byte <= 8'b0;\n    \t\tdone <= 1'b0;\n        \tshift <= 4'd0;\n\t\tstate <= IDLE;\n             end \n\t      else begin \n       \tcase(state) \n\t\t    IDLE: if (in == 1'b0) state <= STARTED; // start bit detected.\n\t\t    \n\t\t   STARTED: begin\n\t\t\t\tif(shift < 4'd9)begin \n\t\t\t\t\ttemp[8-shift]<= in; // shift the received data bit to correct place.\n\t\t\t\t\tshift <= shift + 1'b1;// increment counter.\n                    \t\t\tend   \n                            \telse state <= RECEIVING ; // all bits received.\n                            end  \n                         \n                 RECEIVING: if (in == 1'b1 && shift == 4'd9) begin \n\t\t\t      out_byte<=temp[7:0];// store data byte when stop bit is detected.\n                              done <= 1'b1; // signal that a byte is correctly received .\n\t\t\t      state <= IDLE ; // move to idle state for new byte.\n                          end   else if (in == 1'b0) begin \n                             shift <= 4'd0;// reset counter in case stop bit was wrong.\n\t\t          done <= 1'b0; // signal that a byte is incorrectly received .\t\n\t\t\t     end   \n                endcase ;     \n              end  \n        end\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\nreg [23:0] shift;  // we use extra bit for parity check\nreg [3:0] state;\nparameter IDLE = 4'b0001, DATA = 4'b0010, PARITY = 4'b0100, STOP = 4'b1000;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= IDLE;\n\t\tshift <= 24'h0;\n\tend\n\telse case(state) \n\t\tIDLE: if (!in) state <= DATA;   // start bit\n\t\t      \n\t\tDATA: shift <= {in, shift[23:1]}; // capture data bits\n\t\t\t  if (shift[8]) state <= PARITY; // check for stop bit when we have 8 data bits\n\t\t    \n\t\tPARITY: if (!in) state <= STOP;  // parity bit  \n\t\t        \n\t\tSTOP: if (in) begin\n\t\t\t\tstate <= IDLE; // reset to idle once we receive the stop bit again\n\t\t\t\tout_byte <= shift[7:0]; // output data byte on done signal\n\t\t\t\tdone <= 1; \n\t\t\tend  \n    endcase\nend\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\n\nenum int unsigned {S1=2'b01, S2=2'b10} state;  //states for the FSM\n\treg [7:0] data;   //to store received byte\n\treg start_found = 0;  //flag to indicate if a start bit has been found.\n\treg stop_found = 0;    // flag to indicate if stop bit is encountered.\n\talways @(posedge clk or posedge reset) begin\n\t\t\n\t\tif (reset)begin  \n\t\t\tstate <= S1;  //reset the state machine on synchronous high reset\n\t\t\tdata <= 8'h00;    //clear data when reset happens\n\t\t\tstart_found <= 0;  //reset start found flag\n\t\t\tstop_found <= 0;  //reset stop found flag\n\t\tend else begin\n\t\t\t\tcase(state)  \n\t\t\t\t\tS1:begin\t//wait for a start bit\n\t\t\t\t\t\tif (in==1'b0) begin\n\t\t\t\t\t\t\tstart_found <= 1;    //if a start bit is detected, raise the flag and move to state S2\n\t\t\t\t\t\t\tdata <= {8{1'b0}};  //clear data byte\n\t\t\t\t\t\t\tstate<=S2;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tS2:begin   //wait for 8 data bits\n\t\t\t\t\t\tif (start_found) begin    //only when a start bit is found, we move to state S2 from S1. \n\t\t\t\t\t\t\t if(~stop_found & in==1'b1 ) begin //if stop bit has not been detected and next input is valid, store the data bits.\n\t\t\t\t\t\t\t\t data[0] <= in;    //the least significant bit will be received first\n\t\t\t\t\t\t\t\t for (int i = 1; i < 8; ++i)begin  //receive remaining bits\n\t\t\t\t\t\t\t\t\t @(posedge clk) begin  \n\t\t\t\t\t\t\t\t\t\tdata[i] <= data[i-1];    \n end\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tstate<=S1;    //finish receiving the byte. move to state S1 to look for start bit again.\n                            end else if (stop_found==1'b1)begin \n                                state <= S2;   //if stop bit is detected before all data bits, ignore this sequence and go back to wait for more start bit.\n                             end   \n\t\t\t\t\t\tend \t\t\t\t\t\t\n\t\t\t\tendcase\t\t\n\t\t\tif(start_found & ~stop_found ) begin \n                 if (in==1'b1)begin   //if the last input is a stop bit, assert done and raise flag to indicate byte has been correctly received.\n                      out_byte <= data;   \n\t\t\t\t\t  done <= 1'b1; \n\t\t\t\t  end else begin \n                      done <= 1'b0;\n                     end    \n\t\t\t\tend  \t\t\t\n\t\t\telse done<=1'b0;\n         end\n      end\nendmodule \n"}
{"task_id": "vector3", "completion": "\n\t// concat and split input vectors to output vectors\n\twire [29:0] all_inputs = {a, b, c, d, e, f};\n\tassign w = {all_inputs[16], all_inputs[23:17]};\n\tassign x = {all_inputs[8], all_inputs[15:9]};\n\tassign y = {1'b0, all_inputs[24], all_inputs[7:0]};\n\tassign z = {1'b1, 1'b0, all_inputs[31:25]};\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:2], w[1]} = {a, 1'b1}; // a concatenated with two 1-bits at the end becomes the first output vector w.\n\tassign {x[7:2], x[1]} = {b, 1'b1}; // Similarly, b concatenated with two 1-bits becomes the second output vector x.\n\tassign {y[7:2], y[1]} = {c, 1'b1}; // The same operation is performed for vectors c, d and e to create the third output vector y and fourth output vector z respectively.\n\tassign {z[7:2], z[1]} = {d, 1'b1};\nendmodule\n"}
{"task_id": "vector3", "completion": "\n    assign {w[7:2], w[1]} = {f, e, d, c, b, a, 2'b1}; // concat input vec with two bits as MSBs in w\n\tassign x = {5'h0, f};                            // place 'f' into LSB and pad others with zeros.\n\tassign y = {4'h0, e, d, c, b, a, 1'b1};          // place 'a' to 'e' in bits[7:2] of y and put '1' in bit[1]\n\tassign z = {f, e, d, c, b, a, 2'b1};             // concat input vec with two bits as LSBs in z\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\t//Concatenate the input vectors and add two 1s in LSB positions.\n\twire [29:0] concat_in = {a, b, c, d, e, f, 1'b1, 1'b1};\n\t\n\t//Split the concatenated vector into four output vectors.\n\tassign {w[7:6], w[5:0]} = concat_in[29:14];\n\tassign {x[7:3], x[2:0]} = concat_in[13: 8];\n\tassign {y[7:5], y[4:0]} = concat_in[ 7: 3];\n\tassign {z[7:6], z[5:0]} = concat_in[ 2: 0];\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:2], w[1]} = {f, e};\n\tassign {x[7:4], x[3:0]} = {d, c, b, a};\n\tassign y = {1'b1, f, e, d, c, 1'b1};\n\tassign z = 8'hFF; // setting all the bits to 1\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\t// Concatenating all inputs into a 30 bit wide signal\n\t// Adding two '1' bits in the LSB positions.\n\twire [29:0] combined_inputs = {f, e, d, c, b, a, 1'b1, 1'b1};\n\t\t\n\tassign w = combined_inputs[31:24];\t// Extracting the first byte from concatenated input.\n\tassign x = combined_inputs[23:16];\t// Extracting second byte.\n\tassign y = combined_inputs[15:8];\t\t// Extracting third byte.\n\tassign z = combined_inputs[7:0];\t\t// Extracting last byte.\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\t//concatenate all input vectors\n\twire [29:0] concatenated = {a,b,c,d,e,f}; \n\tassign {w[7:1], w[0]} = 5'b1; //w is the first 8-bit output with 1 in LSB position\n\tassign x = {concatenated[29:23], 4'b1}; //x is the next 8-bit output with 1 in LSB position\n\tassign y = {concatenated[22:16], 5'b10}; //y is the next 8-bit output, followed by two 1 bits (10) in LSB positions\n\tassign z =  {concatened[15:9], 4'b111};//z is the last 8-bit output with three 1s at LSB positions.\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:5], x[7:2]} = {a, b, c, d}; // w[4-1] <= a, w[8-3] <= b, x[6-1] <= c, x[9-3] <= d\n\tassign y = {e, f, 2'b0};    // y[4-1] <= e, y[6-5] <= 0 (two zeros)\n\tassign z = 8'd1;            // z is all ones. Here we assume that we have a 8 bit input data. You can replace it with your own value if you want to force Z output always be 1.\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\n\t// Concatenate input vectors and add two 1's at the end.\n\twire [29:0] concat = {a, b, c, d, e, f, 2'b10};\n\t\t   \n\tassign w = concat[31:24]; // Output the first byte of concatenation.\n\tassign x = concat[23:16]; // Output the second byte of concatenation.\n\tassign y = concat[15:8];  // Output the third byte of concatenation.\n\tassign z = {concat[7:0], 2'b10}; // Output the fourth byte of concatenation and two 1 bits at the beginning.\n\t\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:2], w[1], w[0]} = {f, e, d, c, b, a, 2'b1};\n\tassign x = {f, e, d, c, b, a, 2'b0};\n\tassign y = {a, b, c, d, e, f, 2'b0};\n\tassign z[7:2] = {f, e, d, c, b, a};\n\tassign z[1:0] = 2'b1;\nendmodule\n\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:6], w[5:0]} = {a, 2'b10}; // append two 1s in the LSB positions of w and take only lower six bits as output.\n\tassign {x[7:4], x[3:0]} = {b, 4'b1010}; // same but with four 1s at the MSBs.\n\tassign {y[7:2], y[1:0]} = {c, 6'b111111}; // six ones in middle and two bits on right for error detection\n\tassign {z[7:5], z[4:0]} = {d, 3'b111}; // three ones at MSBs and lower five as output\nendmodule\n\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:2], w[1]} = {f, e, d, c, b, a}; // assign concatenate input to the first 8-bit output vector.\n\tassign x = w;  // assign the same value of 8-bit output vector w to another 8-bit output vector x\n\tassign y = 2'b10; // directly give two 1 bits in the LSB positions to another 8-bit output vector y\n\tassign {z[5:0], z[7]} = {4'b1111, 3'b111};// assign a value of 6 bits and 2 bits to the last 8-bits output vector z.\nendmodule\n\n"}
{"task_id": "vector3", "completion": "\n\tassign {z,y,x,w} = {2'b1,f,e,d,c,b,a,2'b1};\nendmodule \n\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:2], w[1]} = {f, e, d, c, b, a};\n\tassign {x[7:5], x[4:0]} = {5'b11111, f, e, d, c, b};\n\tassign {y[7:6], y[5:0]} = {2'b11, f, e, d, c, b, a, 3'b111};\n\tassign {z[7:4], z[3:0]} = {f, e, d, c};\n\t\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:2], w[1], w[0]} = {e, d, c, b, a, 2'b0};\n\tassign {x[7:5], x[4:0]} = {f, e, d, c, b, a, 3'b0};\n\tassign {y[7:6], y[5:0]} = {e, d, c, b, a, f, 2'b0};\n\tassign {z[7:4], z[3:0]} = {f, e, d, c, b, a, 4'b0};\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\n\tassign {w[7:2], w[1]} = {e[4:0], 1'b1}; // concat e and 1 then assign to first two bits of w, third bit is set to 1\n    assign x =  {d[4:0], 1'b1};              // concat d and 1 directly assigning to x\n\tassign y = {c[4:0], b[4:0]};             // concat c and b then assigning to y\n\tassign z[7:2] =  f;                       // copy bits of f to last two bits of z, third bit is 1 (assume that f has an additional bit in MSB)\n    assign z[1:0]  = 2'b11 ;                  // set LSB and next LSbit of Z as 1's.\n\t\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:2], w[1]} = {f, e, d, c, b, a};\n    assign {z[7:4], z[3:0]} = 4'b11;\n\tassign x = {6'd0, w[1]};\n\tassign y = {5'd0, w[7:2]};\n\t\nendmodule\n"}
{"task_id": "vector3", "completion": "\n    reg [29:0] concat;   // intermediate concatenation of inputs\n\tassign {w,x,y,z} = {{2{1'b1}},concat[29:18],concat[17:8],concat[7:0],{2{1'b1}}}; \n\talways @(*) begin   // update concatenation on change of inputs\n\t    concat <= {a, b, c, d, e, f};\n    end\nendmodule\n"}
{"task_id": "vector3", "completion": "\nassign {w[5:0], x[3:0], y[3:0], z[1:0]} = {a, b, c, d, e, f};\nassign w[7:6] = 2'b1;\nassign x[7:4] = 4'b1;\nassign y[7:4] = 4'b1;\nassign z[7:0] = {2{1'b1}};\n\t\nendmodule\n"}
{"task_id": "vector3", "completion": "\n\tassign {w[7:5], w[4:0]} = {a[4:0], 2'b1}; // first two bits are ones for concatenation and rest of the data.\n\tassign {x[7:6], x[5:0]} = {b[4:0], 2'b1}; \n\tassign {y[7:3], y[2:0]} = {c[4:0], 2'b1};  \n\tassign z = {d[4:0], e[4:0], f[4:0], 2'b1};    // z is concatenation of d, e and f data.\nendmodule\n\n"}
{"task_id": "history_shift", "completion": " \n\n\talways @(posedge clk or posedge areset) begin\n        if (areset)\n            predict_history <= 32'b0;\n        else if (predict_valid) \n            predict_history <= {predict_taken, predict_history[31:1]}; // shift right by one bit and replace the MSB with predict_taken.\n        else if (train_mispredicted) \n            predict_history <= {train_history, train_taken}; // append train_history and then append train_taken to it.\n    end  \n\t\nendmodule\n"}
{"task_id": "history_shift", "completion": "\nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1)\n\t\tpredict_history <= 32'h0;  // reset branch history register to all zeros\n\telse if (predict_valid)\n\t\tpredict_history <= {predict_taken, predict_history[31:1]}; // shift in prediction on LSB side\n\t\t\n\tif(train_mispredicted)\n\t\tpredict_history <= {train_history, train_taken}; \t// load register with the history after a misprediction\nend\n"}
{"task_id": "history_shift", "completion": "\n\t\n\t// Reset\n\talways @(posedge areset) begin\n\t\tpredict_history <= 32'h0;\n\tend\n\t\n\t// Shift in prediction results\n\talways @(posedge clk) begin\n\t    if (predict_valid) begin\n\t        predict_history <= {predict_taken, predict_history[31:1]};\n        end\n    end\n    \n   // Load misprediction history \n   always @(posedge clk) begin\n       if (train_mispredicted) begin\n           predict_history <= {train_history, train_taken};\n       end\n   end\t\nendmodule\n\n"}
{"task_id": "history_shift", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'd0;\n        end else begin \n            if(predict_valid) begin\n                predict_history <= {predict_taken, predict_history[31:1]};\n            end else if(train_mispredicted) begin\n                predict_history <= {train_taken , train_history} ;\n            end     \n        end \n    end  \nendmodule \n"}
{"task_id": "history_shift", "completion": "\n\t\n\talways @(posedge clk or posedge areset) begin \n        if (areset) predict_history <= 0;\n         else begin\n             if (predict_valid) predict_history <= {predict_taken,predict_history[31:1]};\n             else if (train_mispredicted) predict_history <= {train_history, train_taken};\n         end \n    end \nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\t\n  always @(posedge clk or posedge areset) begin\n        if (areset) \n            predict_history <= 32'b0;\n\telse if (predict_valid) \n            predict_history <= {predict_history[30:0],predict_taken};\n    end\n\t\n   always @(posedge clk or posedge areset) begin\n        if (areset)\n            predict_history <= 32'b0;\n\telse if (train_mispredicted) \n            predict_history <= {train_history, train_taken};\n    end\nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\talways @(posedge clk or posedge areset) begin \n        if (areset) predict_history <= 32'b0;   // Reset the register to zero on reset.\n        else begin                             \n            if(predict_valid)                  \n                predict_history <= {predict_history[30:0], predict_taken};       // Shift in new prediction into history, dropping oldest bit \n            \n            if (train_mispredicted)             \n                predict_history <= {train_history, train_taken};     // Load the training history as per instructions.  \n        end\n    end\nendmodule\t\n"}
{"task_id": "history_shift", "completion": "\n\talways_ff @(posedge clk or posedge areset) begin\n\t    if (areset) predict_history <= 32'b0;  // reset to zero on positive edge of areset\n        else if (predict_valid) predict_history <= {predict_taken, predict_history[31:1]};  // shift in the prediction direction\n\t     else if (train_mispredicted) predict_history <= {train_history, train_taken};  // load the branch history register with the history after the completion of the mispredicted branch.\n    end\nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\talways @(posedge clk or posedge areset) begin\n        if (areset)\n            predict_history <= 32'b0;\n         else \n             if (predict_valid)\n                predict_history <= {predict_taken, predict_history[31:1]};\n\t\telse if(train_mispredicted)\n\t\t    predict_history <={train_history, train_taken};     \n\tend\n    \nendmodule \n"}
{"task_id": "history_shift", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t        predict_history <= 0;\n\t    else if (predict_valid) \n\t        predict_history <= {predict_taken, predict_history[31:1]}; // rotate right by one bit\n\tend\n\n\talways @(posedge clk) begin\n\t    if (train_mispredicted)\n\t        predict_history <= {train_history, train_taken}; \n\tend\n    endmodule\n"}
{"task_id": "history_shift", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n        if (areset) predict_history <= 32'b0;\n\t    else begin \n\t\t    if (predict_valid) \n                predict_history <= {predict_history[30:0], predict_taken};\n            else if(train_mispredicted) \n                predict_history <= {train_history, train_taken};\n        end  \n\tend\n    \nendmodule \n"}
{"task_id": "history_shift", "completion": "\n\t\n   always @(posedge clk or posedge areset) begin\n        if (areset) predict_history <= 32'b0;\n        else if (predict_valid) predict_history <= {predict_taken, predict_history[31:1]};\n        else if (train_mispredicted) predict_history <= {train_history, train_taken};\n    end\n    \nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\t\n\talways @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) \n            predict_history <= 32'd0;\n            \n        else if (predict_valid == 1'b1 )\n            predict_history <= {predict_taken, predict_history[31:1]};   //shift right by one bit to update branch history for the predicted branch.\n        \n        else if(train_mispredicted == 1'b1) \n            predict_history <= {train_history , train_taken};             //load branch history register with the value of the train_history concatenated with actual result of the branch (train_taken).\n\tend\n\n"}
{"task_id": "history_shift", "completion": "\n\talways_ff @(posedge clk or posedge areset) begin \n        if (areset) predict_history <= 32'h0;\n         else begin\n            if(predict_valid == 1) $display(\"Prediction Validated\");\n            if(train_mispredicted==1)$display(\"Misprediction Occured \");\n            \n\t\t\tpredict_history <= (predict_taken ? {predict_history[30:0], 1'b0} : {predict_history[30:0], 1'b1});\n\t\t\t\n            if(train_mispredicted == 1) begin\n                predict_history<={train_history, train_taken};\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\n\talways_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            predict_history <= 0;\n        else if(predict_valid)\n            predict_history[31] <= predict_taken & predict_history[30:0]; // shift right by one and put the predicted bit on LSB\n    end\n    \n\talways_ff @(posedge clk) begin\n      \tif (train_mispredicted) \n          \tpredict_history <= {train_history, train_taken}; // Load with actual branch result concatenated to history register \n  \tend\nendmodule\n\n"}
{"task_id": "history_shift", "completion": "\n\talways_ff @(posedge clk or posedge areset) begin \n        if (areset) begin \n            predict_history <= 32'b0;   // Resets the counter to zero.\n        end    \n       else if(predict_valid)begin \n            predict_history[31] <= predict_taken;    // Shifts in new branch direction into history register.\n            predict_history[30:0]<= predict_history[31:1];   // Rotate the rest of the history one bit to the right\n       end \n    end\n    \n    always_ff @(posedge clk) begin\n        if(train_mispredicted)begin // If a misprediction occurs, load in new history.\n            predict_history <= {train_history, train_taken}; \n         end  \n      end\nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\talways @(posedge clk or posedge areset) begin \n        if (areset) \n            predict_history <= 0; \n        else if (predict_valid) \n            predict_history <= {predict_taken, predict_history[31:1]}; \n    end \n\t\n    always @(posedge clk or posedge areset) begin \n        if (areset)  \n            predict_history <= 0; \n        else if (train_mispredicted) \n            predict_history <= {train_taken, train_history}; \n    end \nendmodule\n"}
{"task_id": "history_shift", "completion": "\n\tlogic reset;\n  \n\talways @(posedge clk or posedge areset) begin\n        if (areset) \n            predict_history <= 32'b0;\n        else if (predict_valid)\n            predict_history <= {predict_history[30:0], predict_taken};\n\telse if (train_mispredicted)\n\t    predict_history <= {train_history, train_taken}; \n\tend\nendmodule  \n"}
{"task_id": "history_shift", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'h0;\n        end \n\t\telse begin\n\t\t\tif(predict_valid) begin\n\t\t\t\tpredict_history <= {predict_taken, predict_history[31:1]};\n\t\t\tend\n             else if(train_mispredicted) begin\n                predict_history <= {train_history, train_taken}; \n            end\n        end\n    end\n    \nendmodule\n"}
{"task_id": "history_shift", "completion": " \n\talways @(posedge clk or posedge areset) begin\n\t    if (areset == 1'b1) begin\n\t        predict_history <= 32'd0;\n\t    end\n\t    else if(predict_valid == '1 )begin\n\t        predict_history <= {predict_history[30:0], predict_taken};\n\t    end\n\tend\n\t\t   \n\talways @(posedge clk) begin\n       \tif (train_mispredicted== 1'b1) begin\n           \tpredict_history <= {train_history, train_taken};\n        \tend\n    \tend\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n    always @(*) begin\n        case (do_sub)\n          0: begin \n\t\t      out = a + b;\n              result_is_zero = ~|out;\n\t\t  end\n          1: begin \n\t\t      out = a - b;\n              result_is_zero = ~|out;\n\t\t\t  end\n        endcase\n    end\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n     always @(*) begin\n         case (do_sub)\n           0: {result_is_zero, out} = a + b; // add and store results in two different registers.\n           \u20191': {result_is_zero, out} = a - b; // subract and store results in the same register pair.\n         endcase\n     end\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n\talways @(*) begin\n\t    case (do_sub)\n\t      0: out = a+b;\n\t      1: out = a-b;\n\t    endcase\n\n        if (&out) // Instead of ~, use & to check if all bits are zero. \n            result_is_zero = 1;\n    end\n\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t1'b0: out = a+b;\n\t\t\t1'b1: out = a-b;\n\t\tendcase\n\t\t\n\t\tif (!$signed(out)) //Use $signed to handle negative values\n\t\t\tresult_is_zero = 1;\n\t\telse \n\t\t\tresult_is_zero = 0;\n\tend\nendmodule\n\n"}
{"task_id": "bugs_addsubz", "completion": "\n\n    always @(*) begin\n        case (do_sub)\n          0: {result_is_zero, out} = a+b;\n          1: {out, result_is_zero} = a-b;\n        endcase\n    end\n\nendmodule \n"}
{"task_id": "bugs_addsubz", "completion": "\n    always @(*) begin\n        case (do_sub)\n          0: begin\n             out = a+b;\n          end\n          1: begin \n             out = a-b;\n          end\n        endcase\n        \n\tif (out == 8'd0)\n\t     result_is_zero = 1;\n\telse\n\t  result_is_zero = 0;\n    end\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n\tThe bug in the above code is that there's no assignment for `result_is_zero`. It needs to be reset or initialized every time a new operation occurs (i.e., it should not depend on `out`). Also, you have an extra comment at the end of your module which doesn't belong in the Verilog code and will cause errors when trying to compile it. Here is the corrected version:\n\t\n\t"}
{"task_id": "bugs_addsubz", "completion": "\n    always @(*) begin\n        case (do_sub)\n          0: begin\n              out = a+b;\n              result_is_zero = (out == 8'd0)? 1 : 0;\n          end\n          1: begin\n              out = a-b;\n              result_is_zero = (out == 8'd0)? 1 : 0;\n          end\n        endcase\n    end\n\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n// Corrected module as the subtraction operation was incorrect and to correctly determine if the output is zero we should use (out == 8'b0) instead of ~out.\nalways @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n    endcase\n    \n    if(out == 8'b0) \n        result_is_zero = 1'b1;\n    else\n        result_is_zero = 1'b0;\nend\n\nendmodule\n\n"}
{"task_id": "bugs_addsubz", "completion": "\n    always @(*) begin\n        case (do_sub)\n          0: out = a+b;\n          1: out = a-b;\n        endcase\n\t\t  \n       if (out == 8'h00)\n            result_is_zero = 1;\n        else \n            result_is_zero = 0;\n    end\n\nendmodule\n\n"}
{"task_id": "bugs_addsubz", "completion": "\n\talways @(*) begin\n        case (do_sub)\n          0: \n\t    begin\n              out = a+b;\n\t      if (out == 8'h00)\n\t\t  result_is_zero = 1;\n             end\n         \n          1: \n            begin\n              out = a-b;\n\t      if (out == 8'h00)\n\t         result_is_zero = 1;\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\nThe bug is that the logic in checking for zero doesn't take into account if we are subtracting. The case of do_sub being 1 means you are doing a subtraction. So you need to modify your statement to reflect this change as follows:\n\n\talways @(*) begin\n\t    case (do_sub)\n\t\t    0: out = a+b;\n\t     \t1: out = a-b;\n\t    endcase\n\n\t    if ((~|out) && do_sub == 1'b0) // when adding and result is zero\n            result_is_zero = 1; \n        else if (do_sub == 1'b1 )// when subtracting, check the sign bit\n             result_is_zero = out[7];\n\tend\n\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n\n    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\t\t  \n        if (out == 8'd0)\n            result_is_zero = 1;\n\t\telse \n\t\t    result_is_zro = 0;\n    end\n\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n\talways @(*) begin\n    \tcase (do_sub)\n        \t1'b0: out = a+b;\n       \t\t1'b1: out = a-b;\n    \tendcase\n \n    result_is_zero = ~|out; // change from ~out to ~|out because when there are no bits set (which is equal to zero), the expression will be true.\n\tend\n\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n\talways @(*) begin\n        case (do_sub)\n          0: begin \n              out = a + b;\n              result_is_zero = ~|out; // '~' is not, '|' is or operator, so this checks if all bits of out are zero.\n              end\n          1: begin \n              out = a - b;\n              result_is_zero = ~|out; // '~' is not, '|' is or operator, so this checks if all bits of out are zero.\n              end\n        endcase\n\tend\n\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\nThe bug is in the if statement. It's checking whether \"out\" isn't zero which can lead to incorrect results as well as false positives because of signal propagation delay. We should instead check if \"a + b == a - b\", i.e., we are adding and subtracting numbers that sum to 0, then setting the result_is_zero flag.\n\nHere is the correct version:\n\n\talways @(*) begin\n    \tcase (do_sub)\n        \t1'b0: begin\n            \tout = a + b;\n            \tif (a + b == out) \n                \tresult_is_zero = 1'b1;\n            \telse \n                \tresult_is_zero = 1'b0;\n        \tend\n        \t1'b1: begin\n            \tout = a - b;\n            \tif (a - b == out) \n                \tresult_is_zero = 1'b1;\n            \telse \n                \tresult_is_zero = 1'b0;\n        \tend\n    \tendcase\n\tend\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\n\tThe bug in this code is that it does not account for the overflow/underflow situation when doing subtraction. \n\n\t// You need to check if (out == {8{1'b0}}) instead of just ~out because signed numbers can be negative, so checking out against all zeros won't work for negatives. \n\t\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t    0: begin\n\t\t\t    out = a + b;\n\t\t\t    result_is_zero = ~|out; // ~|out checks if the output is all zeros, which indicates it's zero.\n\t\t        end\n\t\t    1: begin \n\t\t\t\tout = a - b;\n\t\t\t\t// For subtraction to wrap around correctly for negative numbers in signed representations like 2's complement, check out against '0'.\n\t\t\t    result_is_zero = (out == {8{1'b0}});  \n\t\t        end\n\t        endcase\n\t    end\n\tend\n\t\n"}
{"task_id": "bugs_addsubz", "completion": "\n    always @(*) begin\n        case (do_sub)\n          0: begin\n            out = a + b;\n          end\n          1: begin\n            out = a - b;\n          end\n        endcase\n    \n        result_is_zero = ~|out ? 1'b1 : 1'b0 ;\n    end\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\nalways @(*) begin\n\tcase (do_sub)\n\t\t1'b0: begin  // addition\n\t\t\tout = a+b;\n\t\tend\n\t\t1'b1: begin  // subtraction\n\t\t\tout = a-b;\n\t end\n    default : out = 8'h0;\n   endcase\n\n\tif (~|out)\n\t\tresult_is_zero = 1'b1;\n\telse\n\t\tresult_is_zero = 1'b0;\nend \nendmodule\n\n"}
{"task_id": "bugs_addsubz", "completion": "\n\tThe bug in the code is with line if (~out). The bitwise NOT operator ~ is not correctly used. It should be used to check if all bits of the output are zero. However it's checking only first bit because we are using 8-bit bus, so 'if(~out)' will always give false for other 7 bits.\n\tSo here, instead of using \"~out\" in if statement, you should use \"|out\" to check any of the output's bits is zero or not. \n\tThe correct code should be:\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = ((~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & x2 & x1));\nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n\n\t// 8 input combination gives the output.\n\tassign f = ((~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1 )|(~x3 & x2 & ~x1)|  (x3 & x2 & x1));\nendmodule\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & x2 & x1) \n\t\t| (x3 & ~x2 & ~x1) | (x3 & ~x2 & x1) | (x3 & x2 & ~x1);\nendmodule\n"}
{"task_id": "truthtable1", "completion": "\n\n\t// This module implements a combinational circuit following the truth table provided in the question.\n\tassign f = ((~x3)&(~x2)&(~x1)) | ((~x3)&(~x2)&(x1)) | ((~x3)&(x2)&(~x1)) | (x3&(~x2)&(x1)) | ((~x3)&(x2)&(x1)) | \n\t((x3)&(x2)&(~x1));\nendmodule\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = (!x3 & !x2) | (!x3 &  x1) | ( x3 & !x1) | ( x3 & x2 & x1 );\nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n\n\tassign f = ((x3&~x2&~x1) | (~x3&x2&~x1) | (~x3&~x2&x1) | (x3&x2&x1)); \nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n\t// Here is a combinational circuit that implements the given truth table.\n\tassign f = (x1 && (!x2 || x3)) || (!x1 && !x2 && x3) ;\nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n\t// Implementing the truth table using combinational logic.\n\tassign f = (x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & x2 & x1);\nendmodule\n"}
{"task_id": "truthtable1", "completion": "\n\n\t// F = X2'X1 + X1X3' + X3 \n\tassign f = (~x2 & x1) | (x1 & ~x3) | x3;\nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\nassign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1) | (x3 & x2 & x1);\nendmodule\n"}
{"task_id": "truthtable1", "completion": "\nassign f = (x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & x2 & ~x1) | (x3 & x2 & x1);\nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = (x1 & ~x2) | (~x1 & x2 & x3) | (x1 & x2 & ~x3) | (x1 & x2 & x3);\nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = ((~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1 ) | (~x3 & x2  & ~x1) |  (~x3 & x2 & x1));\nendmodule\n"}
{"task_id": "truthtable1", "completion": "\n\n\t//Using Karnaugh Maps, we get the function as follows:\n\tf = ((~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1)) & \n\t    ((~x3 | x2 | x1) | (x3 & ~x2 & ~x1));\n\t  \nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n    assign f = x3 ^ ((x2 & x1) | (!x2 & !x1));\nendmodule\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = ((~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & ~x2 & ~x1));\nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n    assign f = (!x3 && !x2 && !x1) || (!x3 && !x2 && x1) || (!x3 && x2 && !x1) ||  (!x3 && x2 && x1)|| (x3 && !x2 && !x1 )|| (x3 && !x2 && x1)  ||(x3 && x2 && !x1) || (x3 && x2 && x1);\nendmodule \n"}
{"task_id": "truthtable1", "completion": "\n    \n    assign f = (x2 & ~x1) ^ (~x3 | (x1&(x2^x3)) | (~x1 & ~x2)); \n\nendmodule\n\n"}
{"task_id": "truthtable1", "completion": "\n\tassign f = (!x3 & !x2 & !x1) | (!x3 & !x2 & x1) | (!x3 & x2 & !x1) | (!x3 & x2 & x1) | (x3 & !x2 & !x1) | (x3 & !x2 & x1) | (x3 & x2 & !x1);\nendmodule \n"}
{"task_id": "truthtable1", "completion": "\nassign f = !x3 || (!x2 && x1) || (x2 && !x1) || (!x2 && !x1); \nendmodule\n"}
{"task_id": "circuit5", "completion": "\n\t// Assuming that the waveform is a shift register (without the load line) and the inputs are shifted in from right to left. \n\talways @(*) begin\n\t\t\tcase({a,b,c,d,e}) //each case represents a step in time where inputs are shifting in\n\t\t\t\t4'h0: q <= 4'ha; //in first cycle when all inputs are x (unknown)\n\t\t\t\t4'h1: q <= 4'hb; \n\t\t\t\t4'h2: q <= 4'hd;\n\t\t\t\t4'h3: q <= 4'he;\n\t\t\t\t4'h4: q <= 4'hf; //in the end all inputs are known and there is no shifting anymore\n\t\t\t\tdefault: q <= 4'ha; //unknown state\n\t\t\tendcase\n\t\tend\nendmodule\n"}
{"task_id": "circuit5", "completion": "\nalways @(*) begin\n\tcase ({e,d,c,b,a})   // priority encoder\n\t\t5'h1f: q <= 4'he;  // f\n\t\t5'h1e: q <= 4'hd;  // e\n\t\t5'h1d: q <= 4'hc;  // d\n\t\t5'h1b: q <= 4'ha;  // b\n\t\tdefault: q <= 4'h0; // others\n\tendcase\nend\n"}
{"task_id": "circuit5", "completion": "\n\treg [3:0] tmp;\n\talways @(*) begin\n\t\tcase ({a[1],b[1],c[2],d[1],e[3]}) \n\t\t\t5'b00_001: q = a; // At time=40ns, if c[2]==1 and d[1]==0, then q = a\n\t\t\t5'b00_010: q = b; // At time=45ns, if e[3]==1 and a==x,   then q = b\n            5'b00_100: q = c; // At time=60ns, if d[1]==1 and e[3]==0, then q = c\n\t\t\t5'b01_000: q = d; // At time=75ns, if b[1]==1 and a==x,   then q = d\n            5'b10_000: q = e; // At time=90ns, if c[2]==0 and d[1]==x, then q = e\n\t\t\tdefault  : q = 4'bx; // all others are x\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "circuit5", "completion": "\nalways @(*) begin\n\tif (a == 4'b1010)\n\t\tq <= b;\n\telse if (c == 4'b1010)\n\t\tq <= d;\n\telse if (e == 4'b1010)\n\t\tq <= e;\nend\n"}
{"task_id": "circuit5", "completion": "\n\nalways @(*) begin\n\tcase ({c[1], b})\n\t\t4'b0???: q = a; // c2 and c1 are zero so output is a \n\t\t4'b1000: q = d; // c2 is one, c1 and c0 are zero, so output is d\n\t\t4'b1001: q = e; // c2 is one, c1 and c0 are zero, so output is e \n\t\t// similarly we can add more cases based on our requirement  \n\t\tdefault : q = 4'bx; // default case for unsupported inputs\n\tendcase\nend\n\nendmodule\n\n"}
{"task_id": "circuit5", "completion": "\n    always @(*) begin  \n       if (a == 4'hf)         // If a is all 1s then set q to all 1s.\n           q = 4'hF;\n        else if (b == 4'he)     // Else, If b equals e set q to f-1.  \n         \tq = 4'hE;   \n       else if(c==4'hd)         // Else, If c is d then q = a+d \n           q=a+d;               \n        else if (e == 4'ha)     // Else, If e equals a set q to b-1.\n         \tq = 4'hB;  \n       else                    // For all other cases, q is the input d.  \n        \t q=d; \n    end \nendmodule\n"}
{"task_id": "circuit5", "completion": "\n// Based on the simulation waveforms provided.\nalways @(*) begin\n\tcase({a[3],b,c[2:0],d[1:0],e[0]}) //the condition of inputs a[3], b and c[2:0], d[1:0] and e[0] is combined based on the simulation waveforms.\n\t\t4'h6 : q <= 4'b0001; \t// f in binary\n\t\t4'h5 : q <= 4'b0010; \t// e in binary\n\t    4'h3 : q <= 4'b0011; \t// d in binary\n        4'h2 : q <= 4'b0100; \t// c in binary\n\t\t4'h1 : q <= 4'b0101; \t// b in binary\n\t    4'h7, 4'h8, 4'ha, 4'he, default: q <= 4'b0110; // a (a or h), g (g or i or j) and x/z cases when no conditions matched.\n\tendcase\nend\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n// assuming the simulation waveform is a 4-bit ripple counter that loops from f to a when it overflows\n\t// based on the waveform, we will implement a 4-bit ripple counter with synchronous reset\n\talways @(*) begin\n\t\tcase ({a, b, c, d, e})\n\t\t\t5'b00000: q <= 4'hf; // f when no inputs are high\n\t\t\t5'b01000: q <= 4'ha; // a on input b\n            5'b00001: q <= 4'hb; // b on input c\n            5'b00010: q <= 4'hd; // d on input e\n            5'b00100: q <= 4'he; // e on input f, but there is no input f in this design\n\t\t\tdefault:  q <= q;   // hold the state if none of the inputs are high\n\t\tendcase\n    end\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n// We can see the output 'q' changes with respect to time and input signals 'a', 'b', 'c', 'd', and 'e'. \n// When c=\"0\", \"q = a xor b; when c=\"1\", q is inverting gate, q = not(a and b);\n\talways @(*) begin\n\t\tif (c[0])\n\t\t\tq = ~(a & b);\n\t\telse \n\t\t\tq = a ^ b;\n\tend\n// Adding another combinational logic for the other signals 'd' and 'e' in similar way.\n\talways @(*) begin\n\t\tif (c[1])\n\t\t\tq = ~(d & e);\n\t\telse \n\t\t\tq = d ^ e;\n\tend\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n    always @(*) begin\n\t    case ({a[1],b[2],c[2],d[1],e[0]}) \n\t\t    5'b11000: q = 4'b0001; //a and b, no c, d or e\n\t\t    5'b00101: q = 4'b0010; //no a, b and c but e\n\t\t    5'b01010: q = 4'b0100; // no a, no b, c and d \n\t\t    5'b10001: q = 4'b1000; //a only and not b,c or d\n\t\t    default : q = 4'b0000;  //all zero\n\t    endcase\n\tend  \nendmodule\n"}
{"task_id": "circuit5", "completion": "\n\talways @(a or b or c or d or e) begin\n\t    case ({e,d,c,b,a}) \n\t\t    5'h1F : q = 4'h1; // f \n\t\t    5'h1E : q = 4'h2; // e\n\t\t    5'h1D : q = 4'h3; // d \n\t\t    5'h1C : q = 4'h4; // c \n\t\t    5'h1B : q = 4'h5; // b  \n\t\t    5'h1A : q = 4'h6; // a\n\t\t    default: q = 4'h0; // 0\n\t    endcase\n\tend\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n\talways @(a or b or c or d or e) begin\n\t\tcase ({e,d,c,b,a}) \n\t\t\t5'h14: q <= 4'hf;\n\t\t\t5'h13: q <= 4'hd;\n\t\t\t5'h12: q <= 4'ha;\n\t\t\t5'h11: q <= 4'he;\n\t\t\t5'h10: q <= 4'hb;\n\t\t\t5'h0f: q <= 4'h7;\n\t\t\t5'h0e: q <= 4'h8;\n\t\t\t5'h0d: q <= 4'hc;\n\t\t\t5'h0c: q <= 4'h6;\n\t\t\t5'h0b: q <= 4'h2;\n\t\t\t5'h0a: q <= 4'h9;\n\t\t\t5'h09: q <= 4'h1;\n\t\t\t5'h08: q <= 4'h3;\n\t\t\t5'h07: q <= 4'h5;\n\t\t\t5'h06: q <= 4'h4;\n\t\t\t5'h05: q <= 4'hf;\n\t\t\tdefault : q <= q;\n\t\tendcase\n\tend\n\t\nendmodule \n"}
{"task_id": "circuit5", "completion": "\n\talways @(*) begin\n\t\tcase ({a,b,c,d,e})\n\t\t\t5'bxxxxx: q <= 4'b0000; // a = 0, b = 0, c = 0, d = 0, e = 0\n\t\t\t5'b01xxx: q <= 4'b0001; // a = 0, b = 1, others = 0\n\t\t\t5'b10xxx: q <= 4'b0010; // a = 1, b = 0, others = 0\n\t\t\t5'bx0xxx: q <= 4'b0100; // a = x, b = 0, others = 0\n\t\t\t5'bxx1xx: q <= 4'b1000; // a = x, b = x, c = 1, others = 0\n\t\t\t5'bxxx0x: q <= 4'b0000; // a = x, b = x, c = x, d = 0\n\t\t\tdefault : q <= 4'b0000; // any other combination\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n\n\talways @(*) begin\n\tif (a == 4'h9) \n\t    q <= b;\n\telse if (c == 4'ha) \n            q<=d;\n    else if (e==4'he) \n         q <=  e;\n   else \n        q <= f ;\t\n\tend\n\t\t\nendmodule\n"}
{"task_id": "circuit5", "completion": "\nreg [31:0] waveform;\n\nalways @(*) begin\n\t// Concatenate inputs in order of a, b, c, d, e\n\twaveform = {a, b, c, d, e};\n\tcase ($size(waveform)) \n\t\t4'd5 : q <= waveform[0];\n\t\t4'd6 : q <= waveform[1];\n\t\t4'd7 : q <= waveform[2];\n\t\t4'd8 : q <= waveform[3];\n\t\t// Add more cases as needed for the rest of the waveform\n\tendcase\nend\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n\talways @(*) begin\n\t\tif (c[2:0] == 3'b0) \n\t\t\tq <= a & b; // AND gate\n\t\telse if (c[2:0] == 3'b1)  \n\t\t\tq <= a | b; // OR gate\n\t\telse if (c[2:0] == 3'b100) \n\t\t\tq <= ~a;    // NOT gate for a\n\t\telse if(c[2:0]== 3'b101 )\n\t\t\t q <= d + e;// Addition of D and E\n        else if (c[2:0] == 3'b110) \n            q <= {a[0], b[1:0], c[2], d[3]}; // Circular left shift by one place. MSB of A goes to LSB of Q and rest remain same.\n        else if (c[2:0] == 3'b111) \n            q <= {d[0], a[3:1]};  //Circular right shift by one place. LSB of D goes to MSB of Q and rest remains the same.\n\tend\nendmodule\n\n"}
{"task_id": "circuit5", "completion": "\nwire [7:0] wire_a; // intermediate signal a to concatenate\nwire [4:0] wire_b; // intermediate signal b to concatenate \nassign wire_a = {8{a}};  \nassign wire_b = {1'b0, b}; \nalways @(*) begin      \n\tcase({c,d})          \n\t    2'h3 : q <= e ^ (wire_a | wire_b); // if c = 1 and d = 1 then perform XOR operation with a concatenated with the bitwise OR of b and '0', else output e \n\t    2'h2 : q <= ~(wire_a & wire_b[3:0]); // if c = 1 and d = 0 then perform NOT on AND of a concatenated with bitwise AND of b and '0', else output e \n\t    default : q <= e;   \n\tendcase      \nend\n"}
{"task_id": "circuit5", "completion": "\n\talways @(*) begin\n\t\tif (a == b)\n\t\t\tq <= a;\n\t\telse if (c == d)\n\t\t\tq <= c;\n\t\telse \n\t\t\tq <= e;\n\tend\nendmodule\n\n"}
{"task_id": "circuit5", "completion": "\n// a=b xor c[2:0], d = !e[1] and f, where f is the least significant bit of b.\n\twire f; \n    assign f = b[0];\n\talways @* begin\n\t\tcase({a,c,d,f}) //4-bit inputs to case statement\n\t\t\t4'b????: q = 4'bx;     //wildcard match for unknown values of a and c\n\t\t\t4'b110?: q = d[3:0];  //when a=2 and b=0 or b=1, d is output\n\t\t\t4'b10??: q = e[3:0];  //when a=2 and b>1, e is the output\n\t\t\tdefault: q = 4'bx;     //default case for all other cases\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit5", "completion": "\n\t// Define the truth table according to simulation waveforms\n\tfunction [3:0] f;\n\t\tbegin\n\t\t\tcase ({a,b,c,d,e}) \n\t\t\t\t5'b01011 : f = 4'hB; // b\n      \t\t\t5'b01101 : f = 4'hE; // e\n      \t\t\t5'b01110 : f = 4'hD; // d\n      \t\t\t5'b10001 : f = 4'h8; // h\n      \t\t\t5'b10010 : f = 4'h6; // f\n      \t\t\t5'b10011 : f = 4'h7; // g\n      \t\t\tdefault  : f = 4'hF;\n    \t\tendcase\n\t\tend\n\tendfunction\n  \n\talways @(*) begin\n        \tq = f({a, b, c, d, e}); // connect the function to output\n   \t end\nendmodule\n"}
{"task_id": "m2014_q3", "completion": "\n    assign f = (x[2] && x[3]) || (!x[2] && !x[3] && x[1]); \nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\nassign f = (x[3]) ? ((~x[2])?(x[1]:0):((~x[2])?(x[1]):1)); \nendmodule\n"}
{"task_id": "m2014_q3", "completion": "\n\t//Karnaugh map is used to implement the given function.\n   assign f = ((x[2] & ~x[1]) | (~x[3] & x[1])) ;\nendmodule \n\n"}
{"task_id": "m2014_q3", "completion": "\nalways @(*) begin\n\tcase({x[3],x[2]})\n\t\t2'b00, 2'b11 : f = 1'b0; //f=0 when x3=0 and x2=0 or x3=1 and x2=1.\n\t\t//When neither of them are set we don't need to consider it since d = convenient value.\n\t\t2'b10, 2'b01 : f = 1'b0; //f=1 when x3=1 and x2=0 or x3=0 and x2=1.\n\t\t//When neither of them are set we don't need to consider it since d = convenient value.\n\tendcase\nend \n"}
{"task_id": "m2014_q3", "completion": "\n    always @* begin\n        if(x[3])\n            f = x[2];\n        else if(~x[2] && ~x[1])  // (0,0)\n            f = 0;\n        else if(x[2])             // (1,0) or (0,1)\n            f = x[4] | x[1];     \n        else                      // (1,1)\n            f = x[4]; \n    end\nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\n\tassign f = (x[2] && !x[3]) || (!x[1] && !x[2]);\n  \nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\tassign f = (x[2] && (!x[3])) || ((x[2] || !x[1]) && x[3]);\nendmodule \n\n// This code is implementing the function from its Karnaugh map representation. It uses De Morgan's Law to simplify the expression, resulting in the desired truth table for f.\n\n"}
{"task_id": "m2014_q3", "completion": "\nassign f = ((x[2] ~^~ x[3]) ^ x[1]);  // the tilde-caret symbol ^ is XOR gate. The ~^~ symbol denotes exclusive OR operation with don't care values ignored on both sides of the operator. \nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\tf = (x[2] & ~x[3]) | (~x[2] & x[3]);\nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\tfunction integer fn(input [4:1] x);\n\t    return ((~x[3]) & x[2]);  // Returns the function value for given inputs\n   endfunction\n\tassign f = fn(x);\nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n    assign f = (x[3]) ? ((x[2]) ? ~(x[4]) : x[1]) : (~x[2] & x[4]);  // Using Karnaugh map simplification of given function.\nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\tassign f = ((x[3]==1'b0) && (x[4]==1'b1)) ? 1 :\n\t\t\t((x[2]==1'b0) && (x[4]==1'b0));\nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\nalways @(*) begin\n\tcase({x[3], x[2]})\n\t\t2'b00 : f = ~x[1];\n\t\t2'b01 : f = x[4];\n\t\t2'b11 : f = ~x[4];\n\t\tdefault: f = ~x[1];\n\tendcase\nend\nendmodule\n"}
{"task_id": "m2014_q3", "completion": "\n    // Implement function f as a combinational circuit.\n\tfunction logic [3:0] karnaugh(logic [4:1] x);\n    \treturn {~x[2] & ~x[1], x[2] & ~x[1], x[2] & x[1], ~x[2] & x[1]};\n\tendfunction : karnaugh\n  \n    // Assign f to the output of the function.\n\tassign f = karnaugh(x)[3];\n\nendmodule : top_module\n\n"}
{"task_id": "m2014_q3", "completion": "\n    always @(*) begin\n        case ({x[3], x[2]})\n            2'b00: \tf = x[4]; // if x[3], x[2] = 00, f = x[4]\n            2'b01: \tf = !x[4]; // if x[3], x[2] = 01, f = not(x[4])\n            2'b11: \tf = !x[4]; // if x[3], x[2] = 11, f = not(x[4])\n            2default :f= (x[3] || x[1]);\t// for other cases of {x[3], x[2]} the value of f is true when x[3] or x[1] are 1;\n        endcase\n    end\nendmodule\n"}
{"task_id": "m2014_q3", "completion": "\n\t// The function can be represented in a single line of code because it is defined by a Karnaugh map. \n\t// This could also have been implemented using case statements, but this more concise solution would work just as well and is easier to understand.\n\tassign f = ((x[3] && x[4]) || (!x[2] && !x[1]) || (x[2] && x[4]) || (x[1] && !x[3]));\nendmodule\n"}
{"task_id": "m2014_q3", "completion": "\n\tassign f = !x[3] & x[2] || x[1] & !x[2]; // Output function\nendmodule\n"}
{"task_id": "m2014_q3", "completion": "\n\t\n\tf = ~x[2] & ~x[1] | ~x[3] & x[2] & ~x[1]; \nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\t//Implementing Karnaugh map for the function f(x[3], x[2], x[4]) = x[1]'xor(x[2], not(x[4]))\n\tfunction automatic logic f_func;\n\t\tinput [4:1] x; \n\t\t\n\t\tf_func = (~x[1] & (x[2] ^ ~x[4])) ;\n\tendfunction\n\n\t// Driving the output using function implementation\n\tassign f = f_func(x);\n\nendmodule\n\n"}
{"task_id": "m2014_q3", "completion": "\n\talways @* begin\n\t\tif(x[2]) begin\n\t\t\tif(x[3]) \n\t\t\t\tf = 0;\n\t\t\telse if(!x[1])\n\t\t\t\tf = !x[4];\n\t\t\telse \n\t\t\t\tf = ~x[4] & x[2];\n\t\tend else begin\n\t\t\tif (x[1])\n\t\t\t\tf = x[3];\n\t\t\telse \n\t\t\t\tf = x[4];\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\nassign #10ps out = in1 & in2;  // Adding delay of 10 ps to simulate bubble\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\n  // Synchronous approach to model the delay\n  \n\t// Registers for storing inputs\n\treg rin1;\n\treg rin2;\n\t\n\talways @(posedge clk) begin\n\t  rin1 <= in1;\n      rin2 <= #delay_time in2; // Delayed input 2\n    end\n\n\t// And gate logic\n\tassign out = rin1 & rin2;\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\n\t// This is a simple AND operation with in2 delayed by one clock cycle.\n\t// We use $changed to detect changes on inputs. \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            out <= 0;  // Asynchronous reset active high\n        else if ($changed(in1, in2)) \n        \tout <= #1 in1 & in2_delayed;  \n    end\n    \n    always @(posedge clk or posedge reset) begin\n      if (reset)\n          in2_delayed <= 0 ; // Asynchronous reset active high\n       else\n           in2_delayed <= #1 in2 ; \n    end\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n\tassign out = in1 & in2;\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\nassign out = in1 & ~in2;\n\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n    always @(*) begin\n        out = in1 & in2;  // Bubble is added after '&' to represent the fact that there is a bubble on input 'in2'\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n\n\tassign #1 out = in1 & in2;\n\t\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n\n\talways @(*) begin\n\t\tif (!in1 || !in2) \n\t\t\tout = 0;\n\t\telse if (in1 && in2)\n\t\t\tout = 1;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n    \n\tassign out = in1 & in2;  // no bubble on in2 input.\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\n\n\tassign #5 out = in1 & in2; // Delay of 5ns is added to simulate the bubble effect.\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\n\tassign out = in1 & in2; // there's no bubble here because we are assigning to a real wire and not a variable. The delay between inputs is the propagation delay of the AND gate which should be negligible if your input signals have low skew/frequency drifts.\nendmodule \n"}
{"task_id": "m2014_q4f", "completion": "\n    // Two inputs go to an AND gate with bubble on in2\n    always @* begin\n        if(in1) begin\n            if(~in2) begin   // Bubble\n                out = 0; \n            end else begin    // No Bubble\n                out = in1 & in2; \n            end \n        end else begin     // Both inputs are zero (or bubble on in1)\n            out = 0;        \n        end\n    end\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\nassign #10 out = in1 & in2; // Adding 10 ps delay for bubble simulation\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n\tassign out = in1 & in2; //in2 has no bubble so it works directly.\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\n\n\tassign #10 out = in1 & in2; // The delay is 10 time units\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\n\t// Implementation with a continuous assignment statement\n\tassign out = in1 & ~in2; // '~in2' creates the bubble\nendmodule \n\n"}
{"task_id": "m2014_q4f", "completion": "\n   assign #30 in2 = 1'bz; //simulate bubble effect\n\tassign out = in1 & in2; \nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n\talways @(*) begin\n\t\tif(!in2) \n\t\t    out = in1 & in2;\n\t\telse \n\t\t    out = 0;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4f", "completion": "\n\t\n\t// Implementing circuit with a bubble on input 2\n\tassign out = #0.5 in1 & in2; // delay of 0.5 ns added to simulate the bubble\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\n\t// Bubble is implemented as a combinational circuit using an always block. \n\t// As long as 'in1' or 'in2' change state, the bubble will keep them apart by setting 'out' to zero\n\talways @(*) begin\n\t    if (!in1 || !in2) \n\t\t    out <= 0; // Bubble is created when inputs are 0\n        else \n            out <= in1 & in2; // Logical AND operation otherwise\n\tend\nendmodule\n"}
{"task_id": "gshare", "completion": "\n\t// Declare the counters and branch history register\n\treg [1:0] predict_counter[7'd128];\n\treg [6:0] global_history = 7'b0;\n\n\t// Index into the counters using XOR of pc and global history\n\twire [6:0] index = (train_pc ^ global_history);\n\n\t// Reset\n\talways @(posedge clk or posedge areset) begin\n\t\tif(areset == 1'b1) begin\n\t\t\tfor(int i=0; i < 7'd128; i++) predict_counter[i] <= 2'b00;\n\t\t\tglobal_history <= 7'b0;\n\t\tend \n\t\telse begin\n\t\t\tif (train_valid == 1'b1) begin\n\t\t\t\t// Update the counters and global history\n\t\t\t\tpredict_counter[index] <= train_taken ? {predict_counter[index][1], predict_counter[index][1] + 2'b01} : \n\t\t\t\t\t\t\t\t\t\t{predict_counter[index][1] - 2'b01, predict_counter[index][0]};\n\t\t\t\tglobal_history <= train_mispredicted ? (train_pc ^ {7{train_taken}}): global_history;\n\t\t\tend\n\t\t\t\n\t\t\tif(predict_valid == 1'b1) begin\n\t\t\t\t// Predict taken if the counter is > 1, not taken otherwise.\n\t\t\t\tpredict_taken <= predict_counter[index][0] | (|predict_counter[index][1]); //(2'b01 or 2'b10 -> 2'b10, else -> 2'b00)\n\t\t    end\n\t\tend\n\t\t// Output the global history for prediction/training use.\n\t\tif (train_valid == 1'b1 || predict_valid == 1'b1 ) \n\t\t\t predict_history <= global_history;\n\tend\nendmodule\n\n"}
{"task_id": "gshare", "completion": "\n    \n    reg [1:0] PHT [127:0]; //Pattern History Table\n    reg [6:0] globalHistory;  \n    \n    always @(posedge clk or posedge areset) begin \n        if (areset) begin \n            PHT <= '{default:'0}; \n            globalHistory <= 7'b0; \n        end else begin\n            //Predict stage\n            if (predict_valid) begin\n                predict_taken = PHT[predict_pc^globalHistory][1]; //return the most significant bit from the saturating counter as the branch prediction taken.\n                predict_history = globalHistory;\n            end \n            \n            //Train stage\n            if (train_valid) begin\n                PHT[train_pc^globalHistory] <= train_taken ? {PHT[train_pc^globalHistory][0], PHT[train_pc^global_history][1]} + 2'b01 : {PHT[train_pc^globalHistory][0], PHT[train_pc^global_history][1]} - 2'b01; //increment/decrement the saturating counter.\n                if (train_mispredicted) globalHistory <= train_history; //update global history\n            end \n        end\n    end\nendmodule \n"}
{"task_id": "gshare", "completion": "\nreg [1:0] predict_counter;\nreg [7:0] history_register;\nreg [63:0] pht[127:0]; // Pattern History Table.\n\nalways @(posedge clk or posedge areset) begin\n  if (areset) begin\n    for(int i = 0; i < 8; ++i) history_register[i] <= 1'b0;\n    pht <= '{default:'0}; // Initialize PHT to zeros.\n  end else begin\n  \tif(train_valid) begin\n      pht[train_pc ^ history_register][train_history] <= train_taken ? (pht[train_pc ^ history_register][train_history] < 2'b11 ? pht[train_pc ^ history_register][train_history] + 1'b1 : 2'b11)\n      \t: (pht[train_pc ^ history_register][train_history] > 2'b00 ? pht[train_pc ^ history_register][train_history] - 1'b1 : 2'b00); // Update the PHT entry.\n      if(train_mispredicted) history_register <= train_history; // Recover branch history register.\n  \tend else begin\n  \t  predict_counter = pht[predict_pc ^ history_register];\n    \tif(predict_valid) history_register <= {history_register[6:1], 1'b0}; // Update the global branch history register.\n    end\n  end\nend\nassign predict_taken = predict_counter > 2'b10;\nassign predict_history = history_register;\n\t\n"}
{"task_id": "gshare", "completion": "\nreg [127:0][1:0] pht; // pattern history table\nreg [6:0] ghr;       // global branch history register\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        ghr <= 7'b0;\n\t    pht <= 128'h0;\n\tend else begin\n    \tif (train_valid) begin // training logic\n        \tpht[ghr ^ train_pc][train_taken] <= pht[ghr ^ train_pc][train_taken] + 2'b01;\n\t        if(train_mispredicted)\n\t\t        ghr <= train_history;\n    \tend else begin // prediction logic\n        \t{predict_taken, predict_history} = pht[ghr ^ predict_pc]; \n\t    end\n    end\nend\nendmodule\n"}
{"task_id": "gshare", "completion": "\nreg [1:0] branch_predictor[0:127];\nreg [6:0] global_branch_history;\nwire [6:0] index = predict_pc ^ global_branch_history;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tfor (integer i=0;i<128;i++)\n\t\t\tbranch_predictor[i] <= 2'b00;\n\t\tglobal_branch_history <= 7'b0;\n\tend else begin\n\t\tif (train_valid) begin\n\t\t\tbranch_predictor[index] <= {train_taken, train_mispredicted}; \n\t\t\t if(train_mispredicted == 1)\n\t\t\t\tglobal_branch_history<= train_history;\n\t\t\t\t\n\t\tend else if (predict_valid) begin\n\t\t\t{predict_taken, predict_history} = branch_predictor[index];\n\t\t\tif (predict_taken==1'b1) \n\t\t\t    global_branch_history <= {global_branch_history[6:0],1'b1};\n\t\t\telse if(predict_taken==1'b0 && predict_pc [6:3] != 4'hF )   //check the condition to avoid overflow\n\t\t\t\t\tglobal_branch_history <= {global_branch_history[6:0], 1'b0};\n\t\t\t\t\t\n\t\t end \n\tend\nend\nendmodule \n"}
{"task_id": "gshare", "completion": "\n\n\treg [1:0] PHT [0:127]; //Pattern History Table\n\treg [6:0] ghr; //Global history register\n\twire [6:0] index = predict_pc ^ ghr; \n    \n    always @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) begin\n            PHT <= '{default:'0};\n            ghr <= 7'h0;\n\t\tend else begin\n\t\t\tif (train_valid == 1'b1)  // train the predictor\n\t\t\t    if(train_mispredicted == 1'b1)  \n\t\t\t\t    ghr <= train_history ;     \n                PHT[index] <= {PHT[index][0],((~train_taken & PHT[index][1]) | (train_taken  & ~PHT[index][1]))}; // saturating counter\n            if(predict_valid == 1'b1) begin   // predict the branch outcome and update GHR\n                ghr <= {ghr[5:0],predict_pc[6]};      \n\t\t\t\tpredict_taken <= (PHT[index][1] == predict_pc[6]); \n                predict_history <= ghr;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "gshare", "completion": "\nimport bp::*;\n\tbranchpredictor #(.PCSIZE(7), .HISTORYSIZE(7)) predictor (.*);\nendmodule\n\n"}
{"task_id": "gshare", "completion": "\n\n// The pattern history table is a 2D array of 4-bit counters. \nreg [3:0] PHT [127:0];  \nwire [6:0] index;    // The hashed index into the PHT.\nreg [6:0] ghr;       // Global branch history register. \n\nassign index = ghr ^ predict_pc ^ {ghr[5:0],predict_valid}; // Hash function\n\n// Asynchronous reset\nalways @(posedge areset) begin  \n\tghr <= 7'b0;\n\tfor (integer i = 0; i < 128; i++) \n        \tPHT [i] <= 4'b0;   \nend\n\n// Prediction logic.\nalways @(*) begin\n\tif (!predict_valid) begin // If prediction is not valid, clear the outputs.\n\t\tpredict_taken = 0;  \n\t\tpredict_history = ghr;\n\tend  else begin           // Else perform prediction based on PHT entries.\n\t\tpredict_taken = (PHT [index] > 2) ? 1'b1 : 1'b0;\n\t\tpredict_history = ghr;  \n\tend\nend\n\n// Training logic\nalways @(posedge clk) begin\n\tif (!areset) begin\n\t\tif (train_valid) begin // If training is valid, update the PHT.\n\t\t\tif ((PHT [index] < 3'b011) && train_taken) // Train towards a taken branch.\n\t\t\t\tPHT [index] <= PHT [index] + 1;   \n\t\t\telse if ((PHT [index] > 0) && !train_taken ) \n\t\t\t\tPHT [index] <= PHT [index] - 1;  \n      // Train towards a not taken branch. Update the global history register on misprediction and pipeline flush.\n\t\t\tif(train_mispredicted) ghr <= train_history;   \n\t\tend \n\tend else begin       // Asynchronous reset, clear all PHT entries and reset GHR to zero.\n\t\tfor (integer i = 0; i < 128; i++) \n            \t\tPHT [i] <= 4'b0;\n       \t\tghr <= 7'b0;\n     end   \nend  \nendmodule\n"}
{"task_id": "gshare", "completion": "\nlocalparam NUM_ENTRIES = 128; // 2^7\nlocalparam COUNTER_WIDTH = 2;\ntypedef enum {SATURATED_LOW, SATURATED_HIGH} sat_counter_t;\nsat_counter_t [COUNTER_WIDTH-1:0] saturating_counters[NUM_ENTRIES];\nreg [6:0] global_history = 7'b0;\n\t\ninitial begin \n\t// Initialize the counters to be in a low saturation state (i.e., not taken)\n\tfor(int i=0 ; i< NUM_ENTRIES ; ++i)\n\t\tsaturating_counters[i] = SATURATED_LOW;\nend\n\nalways @(posedge clk or posedge areset) begin \n\tif (areset) begin \n\t\t// Asynchronous reset, set global history and counters to initial state\n\t\tglobal_history <= 7'b0;\n\t\tfor(int i=0 ; i< NUM_ENTRIES ; ++i)\n\t\t\tsaturating_counters[i] <= SATURATED_LOW;\n\tend else begin \n\t\t// Update global history register at the end of cycle when a branch is taken\n\t\tif (train_valid && train_taken)\n\t\t\tglobal_history <= {global_history[5:0], train_mispredicted};\n\t\t\t\n\t\t// Saturating counters update\n\t\tif(predict_valid || train_valid) begin \n\t\t\tcase (saturating_counters[(train_pc^global_history) % NUM_ENTRIES]) //Hash PC with global history and wrap around to valid range of PHT indices\n\t\t\t\tSATURATED_LOW: // Predict not taken, update counter if taken or reset it if not \n\t\t\t\t\tif (train_taken && !train_mispredicted) \n\t\t\t\t\t\tsaturating_counters[(train_pc^global_history) % NUM_ENTRIES] <= SATURATED_HIGH; // Predict taken, update counter to high saturation state  if not already at max count\n\t\t\t\t\telse if (!train_taken && train_mispredicted)\n\t\t\t\t\t\tsaturating_counters[(train_pc^global_history) % NUM_ENTRIES] <= SATURATED_LOW; // Predict not taken, update counter to low saturation state  if not already at min count\n\t\t\t\tSATURATED_HIGH: //Predict taken, update counter if not taken or reset it if already at max count\n\t\t\t\t\tif (train_taken && train_mispredicted) \n\t\t\t\t\t\tsaturating_counters[(train_pc^global_history) % NUM_ENTRIES] <= SATURATED_LOW; // Predict taken, update counter to low saturation state  if not already at min count\n\t\t\t\t\telse if (!train_taken && !train_mispredicted)\n\t\t\t\t\t\tsaturating_counters[(train_pc^global_history) % NUM_ENTRIES] <= SATURATED_HIGH; // Predict not taken, update counter to high saturation state  if not already at max count\n\t\t\tendcase \n\t\tend\n\t\t// Output prediction\n\t\tif(predict_valid && (saturating_counters[(predict_pc^global_history) % NUM_ENTRIES] == SATURATED_HIGH)) begin //Hash PC with global history and wrap around to valid range of PHT indices, output taken if high saturation state\n\t\t\tpredict_taken <= 1'b1;\n\t\tend else \n\t\t\tpredict_taken <= 1'b0;\n\t\t\t\n\t\t// Output predict_history is the global_history at this point. \n\t\tpredict_history <= global_history; //Update it with prediction history in same clock cycle as branch prediction output\n\tend\nend\nendmodule \n"}
{"task_id": "gshare", "completion": "\n\t// Define parameters\n\tlocalparam NUM_ENTRIES = 128;\n\tlocalparam INDEX_BITS = 7;\n\tlocalparam COUNTER_BITS = 2;\n\n\t// Define counters and pattern history table (PHT)\n\treg [COUNTER_BITS-1:0] counter[NUM_ENTRIES];\n\treg [INDEX_BITS-1:0] pht[NUM_ENTRIES];\n\n\t// Register for global branch history\n\treg [INDEX_BITS-1:0] global_history;\n\n\t// Asynchronous reset\n\talways @(posedge areset) begin\n\t\tfor (int i = 0; i < NUM_ENTRIES; i++) begin\n\t\t\tpht[i] <= 0;\n\t\t\tcounter[i] <= 0;\n\t\tend\n\t\tglobal_history <= 0;\n\tend\n\n\t// Predict interface\n\talways @(posedge clk) begin\n\t\tif (predict_valid) begin\n\t\t\tint index = pht[predict_pc ^ global_history];\n\t\t\tpredict_taken <= counter[index][1] > counter[index][0];  // Saturating counter predicts taken if higher count is greater\n\t\t\tpredict_history <= global_history;\n\t\tend\n\tend\n\n\t// Train interface\n\talways @(posedge clk) begin\n\t\tif (train_valid) begin\n\t\t\tint index = pht[train_pc ^ train_history];  // Hash PC and branch history into PHT index\n\t\t\t\n\t\t\tcase ({train_taken, train_mispredicted})\n\t\t\t\t2'b01: counter[index] <= {counter[index][COUNTER_BITS-1], counter[index][COUNTER_BITS-1:1]};  // If taken and mispredicted, decrement high count\n\t\t\t\t2'b10: begin\n\t\t\t\t\tif (train_mispredicted) global_history <= train_pc;  // Recover branch history for non-taken branches after mispredicting instructions\n\t\t\t\t\tcounter[index] <= {~counter[index][COUNTER_BITS-1], counter[index][COUNTER_BITS-1:1]};  // If not taken and mispredicted, decrement low count\n\t\t\t\tend\n\t\t\t\t2'b11: begin\n\t\t\t\t\tif (train_taken) global_history <= {global_history[INDEX_BITS-2:0], train_pc ^ global_history[INDEX_BITS-1]};  // Update branch history for taken branches after mispredicting instructions\n\t\t\t\t\tcounter[index] <= {~counter[index][COUNTER_BITS-1], counter[index][COUNTER_BITS-1:1]};  // If not taken and mispredicted, decrement low count\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "gshare", "completion": "\n\n\n    reg [1:0] branchTable[0:127]; // the table of counters (saturating counters)\n    reg [6:0] globalHistory;   // the 7-bit global branch history register\n    \n    integer i;                 \n\t\n\t// hash function to map pc into a index of branchTable and hashing into a 7-bit index.\n\tfunction automatic [6:0] hash_func(input[6:0] pc, input [6:0] gh);\n\t    return (gh^pc)&7'b1111111;   // xor operation and bitwise and for wrap around 7 bits\n\tendfunction\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin              // asynchronous reset\n            globalHistory <= 7'b0;     \n            for (i = 0; i < 128; i++) \n                branchTable[i] <= 2'b11;    // initialize all counters to saturated max value.\n        end else if (train_valid) begin   // training phase\n            branchTable[hash_func(train_pc,globalHistory)] <= train_taken ? {branchTable[hash_func(train_pc,globalHistory)][0],branchTable[hash_func(train_pc,globalHistory)][1] + ~train_mispredicted} : \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{branchTable[hash_func(train_pc,globalHistory)][0] + ~train_taken . train_mispredicted, branchTable[hash_func(train_pc,globalHistory)][1]}; // update PHT based on training\n            globalHistory <= (globalHistory << 1) | train_taken;  // update global history\n        end else if (predict_valid) begin   // prediction phase\n            predict_history <= globalHistory; // output current state of the global branch history register\n            {predict_taken, ~predict_taken} = branchTable[hash_func(predict_pc,globalHistory)];  // fetch predictions from PHT based on PC and GHR\n        end  \n    end    \nendmodule\n\n"}
{"task_id": "gshare", "completion": "\n\nreg [1:0] predict_counter;\nwire [7:0] index;\nwire [5:0] pht_index;\nassign index = {train_history, predict_pc};\nassign pht_index = index[6:1];\n\n// 128-entry pattern history table (PHT) with two bit counters.\nreg [1:0] PHT [0:127];\n\nalways @(posedge clk or posedge areset) begin\n\tif(areset) begin\n\t\tfor (integer i = 0; i < 128; i++) begin\n\t\t\tPHT[i] <= 2'b00;  // reset to not taken.\n\t\tend\n        predict_counter <= 2'd0;  //reset counter\n\tend\n\telse begin\n\t\tif(train_valid && ~predict_valid) begin   //Only training when predict_valid is low\n\t\t\tPHT[pht_index] <= train_taken ? PHT[pht_index] + 1 : PHT[pht_index] - 2'b01;    // increase if taken, decrease otherwise.\n            predict_counter <= ~train_mispredicted ? (predict_counter >= 4 ? predict_counter + 2 : predict_counter) : train_history[5:0];   // update predict counter if not mispredicted and not at the end of pipeline or set to training history if it was a misprediction.\n\t\tend\n        else begin \n\t\t\tpredict_counter <= (predict_valid && ~train_valid) ? predict_counter + 2 : predict_counter; //only increment counter when predicting and no training in progress, reset otherwise\n\t end\n     end\nend\n\nalways @(*) begin\n\tif(predict_valid)begin   //Predict branch if valid\n\t    predict_taken = PHT[pht_index][1];    //Taken if most recently executed was taken. \n        predict_history = predict_counter;      //Current predict counter value\n\tend else begin           //If not valid, don't change values.\n\t    predict_taken = 0;    \n        predict_history = predict_counter;  \n    end\nend\n\n"}
{"task_id": "gshare", "completion": "\n    \n\treg [1:0][63:0] branchTable; // 2 sets of counters for each entry in the table\n\treg [6:0] globalHistory, historyReg; // Global and local branch history registers\n\n\twire [6:0] index = (predict_pc ^ globalHistory) % 128; // Calculate hash index\n    wire predictTaken = branchTable[historyReg[1]][index] > 1; // Determine if the prediction is taken\n    \n\t// Asynchronous reset\n\talways @(posedge areset) begin\n\t\tfor (integer i = 0; i < 2; ++i) \n\t\t\tbranchTable[i] <= 7'd0;\n\tend\n\n\t// Synchronous operations\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            globalHistory <= 7'b0;\n            historyReg <= 7'b0;\n        end else begin\n        \tif (train_valid) begin // Handle training operation\n            \tbranchTable[historyReg[1]][(train_pc ^ globalHistory) % 128] <= train_taken ? branchTable[historyReg[1]][(train_pc ^ globalHistory) % 128] + 1'b1 : branchTable[historyReg[1]][(train_pc ^ globalHistory) % 128] - 1'b1;\n            \tglobalHistory <= (globalHistory << 1 | train_taken) % 128; // Update global history register with actual result and wrap around if needed\n            end else if (predict_valid) begin // Handle prediction operation\n                predict_history <= historyReg; \n                predict_taken <= predictTaken;  \t\n            \t// Update local branch history register\n            \thistoryReg <= train_mispredicted ? ((train_pc ^ globalHistory) % 128 << 1 | 1'b0) : (historyReg << 1 | predictTaken); \n            end\n        end\n    end\nendmodule\n"}
{"task_id": "gshare", "completion": "\n\t// Define counters and patterns history table\n\tlocalparam ENTRIES = 128;\n\treg [1:0] pht [ENTRIES-1:0]; // 2-bit saturating counter for each entry of the PHT\n\twire [6:0] index = predict_pc ^ global_history; // hash function based on PC and GHR\n\n\t// Global history register (GHR)\n\treg [6:0] global_history = 7'd0; \n\n\talways @(posedge clk or posedge areset) begin\n\t\tif(areset) begin\n\t\t\tglobal_history <= 7'b0; // reset the GHR\n\t\t\tfor (int i=0; i<ENTRIES; i++) begin\n\t\t\t\tpht[i] <= 2'd0; // Reset all PHT entries to 0\n\t\t\tend\n\t\tend\n\t\telse if(train_valid) begin\n\t\t\t// Training stage: update the pattern history table (PHT) and GHR, based on inputs from processor.\n\t\t\t pht[train_pc ^ global_history] <= train_taken ? pht[train_pc ^ global_history] + 2'd1 : \n      pht[train_pc ^ global_history] - 2'd1; // Increment if branch is taken, otherwise decrement.\n\t\t\t if(train_mispredicted) begin\n\t\t\t\t global_history <= train_history; \n             end\t\n        end  \n       else if(predict_valid)begin\n           // Prediction stage: output the prediction from PHT and update GHR for prediction.\n\t\t   predict_taken <= pht[index][1]; // The most significant bit is taken or not, in order to determine whether it's branch or not.\n\t\t   predict_history <= global_history; // Output current GHR \n           if(predict_valid) begin\n               global_history <= {global_history[6:0], pht[index][1]}; // Update the GHR based on prediction result, add most significant bit of PHT to it.\n\t\t   end\t\n       end\t   \n    end \nendmodule\n\n"}
{"task_id": "gshare", "completion": "\n\t\n\treg [7:0][1:0] PHT; // Pattern History Table is a 2-bit saturating counter array of size 128.\n\treg [6:0] global_history; // Global Branch History Register\n\n\t// reset the predictor and the branch history register on a reset signal\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tglobal_history <= 7'h0;\n\t\t\tfor (int i = 0; i < 128; i++) begin\n\t\t\t\tPHT[i] <= 2'b0; // Initialize all counters to 0.\n\t\t\tend\n\t\tend \n\t\telse if(train_valid) begin  \n\t\t\tif(train_mispredicted) begin\n\t\t\t\tglobal_history <= global_history & ~train_history;// recover the branch history register in case of a mispredict\n\t\t\tend\n\t\t\t// update the PHT based on actual outcome and the predictor's prediction for this instruction \n\t\t\tPHT[{train_history, train_pc}] <=  train_taken ? (PHT[{train_history, train_pc}][1:0] + 2'b01) : (PHT[{train_history, train_pc}][1:0] - 2'b01);\n\t\tend\n\t\t else if(predict_valid) begin   // branch prediction logic \n\t\t\t{predict_taken, predict_history} = PHT[{global_history ,predict_pc }];   \n\t\tend\n\t    global_history <= {global_history [5:0], train_taken}; // update the global history register.\n\tend\nendmodule\n"}
{"task_id": "gshare", "completion": "\n\t// define constants and variables\n\tlocalparam ENTRIES = 128;\n\tlocalparam BHR_SIZE = 7;\n\ttypedef bit[1:0] PHT[ENTRIES-1:0];\n\tPHT pht;\n\treg [BHR_SIZE-1:0] bhr;\n\n\t// reset the predictor (asynchronous)\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tpht <= '{default:'0};\n\t\t\tbhr <= 7'b0;\n\t\tend\n\tend\n\n\t// branch prediction\n\talways_comb begin\n\t\tpredict_taken = pht[predict_pc ^ bhr];  // predict if the PHT entry for this PC is taken\n\t\tpredict_history = bhr;  // output the current value of the BHR\n\tend\n\n\t// branch training\n\talways @(posedge clk) begin\n\t\tif (train_valid && ((pht[train_pc ^ bhr] != train_taken) || train_mispredicted)) begin\n\t\t\tpht[train_pc ^ bhr] <= train_taken ? 2'b11 : 2'b00;  // if the prediction was wrong, update PHT entry accordingly\n\t\t\tbhr <= train_history;  // recover BHR to state immediately after the branch\n\t\tend else if (train_valid) begin\n\t\t\tpht[train_pc ^ bhr] <= pht[train_pc ^ bhr] + 1'b1;  // otherwise, only update PHT entry without changing BHR\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "gshare", "completion": "\n// Define the number of entries in the pattern history table and branch counters\n`define PHT_ENTRIES 128\n`define COUNTER_WIDTH 2\n\nreg [`PHT_ENTRIES-1:0][`COUNTER_WIDTH-1:0] pht;\nreg [6:0] global_history;\nwire [6:0] index = global_history ^ predict_pc;\n\n// Predictor logic\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tpht <= 128'd0;\n\t\tglobal_history <= 7'd0;\n\tend else if (predict_valid) begin\n\t\tpredict_taken <= pht[index][1]; // PHT output is used as branch prediction\n\t\tpredict_history <= global_history;\n\tend\nend\n\n// Trainer logic\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tpht <= 128'd0;\n\telse if (train_valid) begin\n\t\t// Update branch history register (global history)\n\t\tglobal_history <= train_mispredicted ? global_history : train_pc ^ global_history;\n\t\t\n\t\t// Train the pattern history table\n\t\tpht[index] <= train_taken ? {pht[index][`COUNTER_WIDTH-2:0], 1'b1} : // increment taken count\n\t\t\t\t{{`COUNTER_WIDTH{1'b0}}, 1'b0}; // reset to not taken count\n\tend\nend\n\nendmodule\n"}
{"task_id": "gshare", "completion": "\nimport mgp::*; // for the branch predictor's data structures and operations\n\n// Define a few types for clarity. These are used in several places, so define them once.\ntypedef bit [6:0] Pc;\ntypedef bit [6:0] History;\n\nmodule top_module(\n\tinput clk,\n\tinput aresetn, // Active low reset\n\n\t// Predict interface\n\tinput predict_valid,\n\tinput Pc predict_pc,\n\toutput reg predict_taken, \n\toutput reg [6:0] predict Counter;\n);\n    (* ramstyle=\"MLAB, no_rw_check\" *)\n\treg [1:0] BP[0:127]; // Branch Predictor Table (BPT)\n\tHistory HistoryReg; \n    \n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn) begin\n\t\t\t// Asynchronous reset\n\t\t\tfor (int i = 0; i < 128; i++) BP[i] <= 2'b11; // Initialize counters to \"strong not taken\"\n\t\t\tHistoryReg <= 7'h0; // Zero out the history register\n\t\tend else begin\n            if (predict_valid) begin\n                Counter <= BP[predict_pc ^ HistoryReg][1:0]; // XOR PC with global history to get index into predictor table. Pick two bits from table entry. \n\t\t        predict_taken <= |Counter[1:0]; // The higher bit is a strong hint, the lower bit indicates \"weak\" prediction (the other branch).\n                HistoryReg <= {HistoryReg[6:0], Counter[1]}; // Shift global history register and append the taken bit from our counter.\n            end \n            \n            if(train_valid) begin\n                BP[train_pc ^ train_history][1:0] <= {~train_taken,train_taken} ; // XOR PC with branch history to get index into predictor table and update the two bits of that entry.\n\t\t        HistoryReg <= {HistoryReg[6:0], Counter[1]}; // Shift global history register and append the taken bit from our counter.\n            end \n\t\tend\n\tend\nendmodule\n"}
{"task_id": "gshare", "completion": "\n    wire [6:0] index = predict_pc ^ predict_history;\n    \n    reg [7:0][1:0] PHT [0:127]; // Pattern History Table\n    reg [6:0] branch_history; \n\t\n\t// Reset\n\talways @(posedge areset) begin\n\t\tfor (integer i = 0 ; i < 128 ; i++ )begin\n\t\t\tPHT[i][0] <= 2'b00;\n\t\t\tPHT[i][1] <= 2'b00;\n\t\tend\n        branch_history <= 7'd0;\n    end\n    \n\t// Predict block \n\talways @(posedge clk) begin\n\t    if (predict_valid)begin\n\t        predict_taken <= PHT[index][1]; // Check if counter is saturating towards taken.\n\t\t\tpredict_history <= branch_history;\n        end\n    end\n    \n\t// Train block \n\talways @(posedge clk) begin\n\t    if (train_valid)begin\n\t        // If the prediction was correct, increment the predictive counter to favor predicting that again.\n\t\t\tif(!train_taken || PHT[index][1] < 2'b01 )  \n\t\t\t\tPHT[index][1] <= PHT[index][1] + 1;\n\t\t\t// If the prediction was wrong, decrement the predictive counter to avoid making that prediction again. \n\t\t\telse if(train_taken)  \n\t\t\t    begin\n\t\t\t\t\tif (train_mispredicted == 0 ) begin\n\t\t\t\t\t\tPHT[index][1] <= PHT[index][1] - 1;\n\t\t\t\t\tend else begin\n                        branch_history <=  train_history ; // Recover the branch history register to the state immediately after the mispredicting branch completes execution.\n                    end\n\t\t\t    end\n\t\t\t// If train for a different, younger instruction occurs in the same cycle as prediction of that PHT entry\n            PHT[index][0] <= train_pc ^ train_history; // Update the pattern history table (PHT) \n        end \n\tend \n    \nendmodule \n"}
{"task_id": "gshare", "completion": "\nreg [1:0] PHT [0:127]; // pattern history table\nreg [6:0] ghr; // global branch history register\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        for (int i = 0; i < 128; i++) PHT[i] <= 2'b00; \n        ghr <= 7'h00;   // reset global history register to zero\n    end else begin\n        if (train_valid) begin\n            PHT[ghr ^ train_pc][(train_history >> 1)] <= (train_taken && !train_mispredicted)? 2'b11 : 2'b00; // increase prediction counter if the branch was taken and not a misprediction, else decrease it\n            ghr <= {ghr[5:0], train_taken}; // update global history register with actual branch outcome\n        end  \n    end\nend\n\nalways @(*) begin \n\tif (predict_valid) begin\n\t    predict_taken = PHT[ghr ^ predict_pc][1];\n\t\tpredict_history = ghr;\n\tend else begin\n\t\tpredict_taken = 0;\n\t\tpredict_history = 7'hx;\n    end \nend\n\nendmodule\n"}
{"task_id": "vector5", "completion": "\n    \n    assign out = { ~a ^ a, \n                  ~a ^ b, \n                  ~a ^ c, \n                  ~a ^ d,\n                  ~a ^ e, \n                  ~b ^ b,\n                  ~b ^ c,\n                  ~b ^ d,\n                  ~b ^ e,\n                  ~c ^ c,\n                  ~c ^ d,\n                  ~c ^ e,\n                  ~d ^ d,\n                  ~d ^ e,\n                  ~e ^ e }; \nendmodule\n\n"}
{"task_id": "vector5", "completion": "\n\n\tassign out[24] = ~a ^ a;\n\tassign out[23] = ~a ^ b;\n\tassign out[22] = ~a ^ c;\n\tassign out[21] = ~a ^ d;\n\tassign out[20] = ~a ^ e;\n\tassign out[19] = ~b ^ a;\n\tassign out[18] = ~b ^ b;\n\tassign out[17] = ~b ^ c;\n\tassign out[16] = ~b ^ d;\n\tassign out[15] = ~b ^ e;\n\tassign out[14] = ~c ^ a;\n\tassign out[13] = ~c ^ b;\n\tassign out[12] = ~c ^ c;\n\tassign out[11] = ~c ^ d;\n\tassign out[10] = ~c ^ e;\n\tassign out[ 9] = ~d ^ a;\n\tassign out[ 8] = ~d ^ b;\n\tassign out[ 7] = ~d ^ c;\n\tassign out[ 6] = ~d ^ d;\n\tassign out[ 5] = ~d ^ e;\n\tassign out[ 4] = ~e ^ a;\n\tassign out[ 3] = ~e ^ b;\n\tassign out[ 2] = ~e ^ c;\n\tassign out[ 1] = ~e ^ d;\n\tassign out[ 0] = ~e ^ e;\n\t\nendmodule\n"}
{"task_id": "vector5", "completion": "\n\tgenvar i;\n\tgenerate \n\tfor(i = 0; i < 5; i++) begin : gen_loop\n         assign out[i*4+3:i*4] = {4{~a ^ a}} & {4{~b ^ b}} & {4{~c ^ c}} & {4{~d ^ d}} & {4{~e ^ e}}; \n\tend \n\tendgenerate\n  \n"}
{"task_id": "vector5", "completion": "\n\t// 25-bit output vector to store the results\n\treg [24:0] out;\n\n\talways @(*) begin\n\t\t// Compute pairwise one-bit comparisons for a\n\t\tout[24:17] = {16{~a ^ a}};  // ~a ^ a is equivalent to a xor a, which always equals zero (0) since it's logical xor gate.\n\t\t\n\t\t// Compute pairwise one-bit comparisons for b, c, d and e\n\t\tfor(integer i = 16; i >= 0; i--) begin: loop2\n\t\t    out[i] = a ^ b; // Repeat the result of bitwise xor operation between a and b for all 8 bits (from msb to lsb).\n\t\t\t// Rotate bits left by one position, similar as rotating left in a rotator.\n\t\t\ta = b; \n\t\t    {b} = c; // Repeat the result of bitwise xor operation between b and c for all 8 bits (from msb to lsb).\n\t\t\t// Rotate bits left by one position, similar as rotating left in a rotator.\n\t\t\tc = d; \n\t\t\td = e;\n\t    end\n\tend\n\t\nendmodule\n"}
{"task_id": "vector5", "completion": "\n\tassign out[24: 1] = {~a ^ b, ~b ^ c, ~c ^ d, ~d ^ e};\n\tassign out[ 0] = ~e ^ e; // always equal to zero (no comparison)\nendmodule\n\n"}
{"task_id": "vector5", "completion": "\n\tgenvar i;\n\tgenerate \n\tfor (i = 0; i < 5; i = i+1) begin : loop\n\t\tassign out[4*i + 3] = a ^ b ^ c ^ d ^ e; // xor of all inputs\n\t\tif(i != 0) assign out[4*i + 2] = ~b ^ (a >> i);   // right shift and xor with not b\n\t\tassign out[4*i + 1] = b ^ c;  // xor of bit b and the next one in sequence\n\t\tif(i != 4) assign out[4*i ] = ~e ^ (d << i);   // left shift and xor with not e\n\tend\n\tendgenerate\n\nendmodule\n\n"}
{"task_id": "vector5", "completion": "\n\tassign out = ~a ^ {b,c,d,e}; // For 5-bit inputs, this will generate a 10-bit output. We slice off the first bit to fit it into a 25-bit vector.\nendmodule\n\n"}
{"task_id": "vector5", "completion": "\n\n\tfor(genvar i = 0; i < 5; i++) begin : gen_loop\n\t\tfor(genvar j = i+1; j < 5; j++) begin : inner_gen\n\t\t\tassign out[(j-1)*5 + i] = ~a ^ b; // for the first pair comparison, just a placeholder\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "vector5", "completion": "\n    assign out[24] = ~a ^ a;\n    assign out[23] = ~b ^ a;\n    assign out[22] = ~c ^ a;\n    assign out[21] = ~d ^ a;\n    assign out[20] = ~e ^ a;\n    \n\tassign out[19] = ~a ^ b;\n    assign out[18] = ~b ^ b;\n    assign out[17] = ~c ^ b;\n    assign out[16] = ~d ^ b;\n    assign out[15] = ~e ^ b;\n    \n\tassign out[14] = ~a ^ c;\n    assign out[13] = ~b ^ c;\n    assign out[12] = ~c ^ c;\n    assign out[11] = ~d ^ c;\n    assign out[10] = ~e ^ c;\n    \n\tassign out[ 9] = ~a ^ d;\n    assign out[ 8] = ~b ^ d;\n    assign out[ 7] = ~c ^ d;\n    assign out[ 6] = ~d ^ d;\n    assign out[ 5] = ~e ^ d;\n    \n\tassign out[ 4] = ~a ^ e;\n    assign out[ 3] = ~b ^ e;\n    assign out[ 2] = ~c ^ e;\n    assign out[ 1] = ~d ^ e;\n    assign out[ 0] = ~e ^ e;\t\nendmodule\n"}
{"task_id": "vector5", "completion": "\n    assign out = {1'b0, ~a ^ a, ~a ^ b, ~a ^ c, ~a ^ d, ~a ^ e, \n                  ~b ^ a, ~b ^ b, ~b ^ c, ~b ^ d, ~b ^ e, \n                  ~c ^ a, ~c ^ b, ~c ^ c, ~c ^ d, ~c ^ e, \n                  ~d ^ a, ~d ^ b, ~d ^ c, ~d ^ d, ~d ^ e, \n                  ~e ^ a, ~e ^ b, ~e ^ c, ~e ^ d, ~e ^ e};\nendmodule\n"}
{"task_id": "vector5", "completion": "\n\tfor(i = 0; i < 5; i++) begin : generate_bits\n\t\tassign out[i] = a ^ b; // replace with your comparison operation\n\tend\n    endgenerate\n    \n\tfor (i=5, j=6; i<24; i+=1, j+=1) begin: bitwise_comparisons\n       assign out[i] = ~(d | e);  //replace with the correct expression for each pair. You should use a for loop or similar to iterate over all possible pairs.\n\tend  \n    endgenerate\n\n"}
{"task_id": "vector5", "completion": "\n\tassign out[24:1] = ~{a,b,c,d,e} ^ {a,b,c,d,e};  // equivalent to XNOR operation\n\tassign out[0]   = ~e ^ e; // because any bit XOR with itself gives 0, and ~(same) is 1 if the same input.\nendmodule\n"}
{"task_id": "vector5", "completion": "\nassign out[24:0] = {\n        ~a ^ a,  //out[24]\n        ~a ^ b,  //out[23]\n        ~a ^ c,  //out[22]\n        ... ,    \n        ~e ^ d,   //out[1]\n        ~e ^ e    //out[0]\n};\nendmodule\n"}
{"task_id": "vector5", "completion": "\n    assign out = {1'b0, \n        ~a ^ b, ~a ^ c, ~a ^ d, ~a ^ e,\n        ~b ^ a,                 ~b ^ d, ~b ^ e,\n                  ~c ^ a,         ~c ^ e,\n                         ~d ^ a,                    ~e ^ a}; \nendmodule\n"}
{"task_id": "vector5", "completion": "\n\tassign out[24:16] = ~{a,b,c,d,e} ^ {a,b,c,d,e};  // Compare a with all others\n\tassign out[15:8 ] = ~{a,b,c,d,e} ^ {b,c,d,e,a};   // Compare b with all others\n\tassign out[7 :0 ] = ~{a,b,c,d,e} ^ {c,d,e,a,b};   // Compare c with all others\n\tassign out[15:8 ] = ~{a,b,c,d,e} ^ {d,e,a,b,c};  // Compare d with all others\n\tassign out[24:16] = ~{a,b,c,d,e} ^ {e,a,b,c,d};  // Compare e with all others\nendmodule\n"}
{"task_id": "vector5", "completion": "\n\tassign out = {~a ^ a, ~b ^ a, ~c ^ a, ~d ^ a, ~e ^ a, \n\t\t\t      ~a ^ b, ~b ^ b, ~c ^ b, ~d ^ b, ~e ^ b,  \n\t\t              ~a ^ c, ~b ^ c, ~c ^ c, ~d ^ c, ~e ^ c,   \n\t\t              ~a ^ d, ~b ^ d, ~c ^ d, ~d ^ d, ~e ^ d,    \n\t                  ~a ^ e, ~b ^ e, ~c ^ e, ~d ^ e, ~e ^ e};  \nendmodule\n"}
{"task_id": "vector5", "completion": "\n\tassign out[24:16] = ~{a,b,c,d,e,f,g,h,i,j}; // (a ^ a) through (j ^ j)\n\tassign out[15: 8] = {a^a, b^b, c^c, d^d, e^e, f^f, g^g, h^h}; //(k ^ k), ... ,(h ^ h)\n\tassign out[7 :0 ] = ~{i,j} | {a,b,c,d,e,f,g,h} ;// (l ^ l), ... ,(g ^ g)\n\tassign out[24:17] = {i^i, j^i, i^h, j^h, i^g, j^g, i^f, j^f}; //(i ^ i), ...,(j ^ f)\n\tassign out[23:9 ] = ~{a,b} | {c,d,e,f,g,h,i};  //(k ^ e), ... , (l ^ a)\n\tassign out[8 :0 ] = ~{1'b0,j} | {b,c,d,e,f,g,h,i};// (m ^ k), ... ,(l ^ b)\n\tassign out[24:9]  = ~{a}   | {b,c,d,e,f,g,h,i,j}; //(n ^ m), ... ,(k ^ a)\n\tassign out[8:0  ] = ~{1'b0} | {c,d,e,f,g,h,i,j};   // (o ^ n), ... ,(m ^ c)\n\tassign out[24:3]  =  ~a    | ~{b,c,d,e,f,g,h,i,j} ;// p ^ o), ... ,(l ^ e)\n\tassign out[2:0 ]  = ~{1'b0,a,b}; // (p ^ p), ... ,(o ^ c)\nendmodule\n"}
{"task_id": "vector5", "completion": "\n\tassign out[24] = ~a ^ a;\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n    \n    assign out[19] = ~b ^ a;\n    assign out[18] = ~b ^ b;\n    assign out[17] = ~b ^ c;\n    //... continue this pattern up to bit 5 with remaining signals and assignments for the other outputs\n    \n\tassign out[0] = ~e ^ e;\n\nendmodule\n"}
{"task_id": "vector5", "completion": "\n    assign out[24] = ~a ^ a; \n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n    //and so on until\n    assign out [0] = ~e ^ e;  \nendmodule\n"}
{"task_id": "vector5", "completion": "\n\n\tassign out[24] = ~a ^ a; // comparing a and a\n\tassign out[23] = ~a ^ b; // comparing a and b\n\tassign out[22] = ~a ^ c; // comparing a and c\n\tassign out[21] = ~a ^ d; // comparing a and d\n\tassign out[20] = ~a ^ e; // comparing a and e\n\tassign out[19:16] = 4'b0; \n\tassign out[15] = ~b ^ b; // comparing b and b\n\tassign out[14] = ~b ^ c; // comparing b and c\n\tassign out[13] = ~b ^ d; // comparing b and d\n\tassign out[12] = ~b ^ e; // comparing b and e\n\tassign out[11:8 ] = 4'b0;\n\tassign out[7 ] = ~c ^ c; // comparing c and c\n\tassign out[6 ] = ~c ^ d; // comparing c and d\n\tassign out[5 ] = ~c ^ e; // comparing c and e\n\tassign out[4:1] = 4'b0;\n\tassign out[0] = ~e ^ e; // comparing e and e \n\nendmodule\n"}
{"task_id": "mt2015_q4a", "completion": "\nassign z = (x ^ y) & x;\nendmodule \n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n    assign z = (x ^ y) & x;\nendmodule\n"}
{"task_id": "mt2015_q4a", "completion": "\n     assign z = (x ^ y) & x;  // Assigning the boolean function to output 'z'\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n"}
{"task_id": "mt2015_q4a", "completion": "\n    assign z = (x ^ y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n    \n    assign z = (x^y) & x;\n     \nendmodule \n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule \n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x^y)&x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n    assign z = (x ^ y) & x; \nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x; \nendmodule \n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;  //The boolean function is implemented here\nendmodule\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x^y) & x; \nendmodule\n\n"}
{"task_id": "mt2015_q4a", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n"}
{"task_id": "dff8p", "completion": "\nreg[15:0] rst;\nassign rst = 8'h34; // reset value is 0x34\n\nalways @(negedge clk) begin\n\tif (reset) \n\t\tq <= rst;\n\telse\n\t\tq <= d;\nend\n\n"}
{"task_id": "dff8p", "completion": "\n  \n  localparam initial_value = 8'h34; //reset value\n\n  always @(negedge clk) begin\n    if (reset == 1)\n      q <= initial_value;\n    else\n      q <= d;\n  end\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\n\treg [7:0] resetVal = 8'h34; //reset value \n\n\talways @(negedge clk) begin  \n\t    if (reset == 1) \n\t\t    q <= resetVal;    \n        else              \n            q <= d;            \n\tend\n\nendmodule\n"}
{"task_id": "dff8p", "completion": "\ninitial begin  // reset to a default value on startup\n    q = 8'h34;\nend\n    \nalways @(negedge clk) begin  // flip flop logic\n\tif (reset == 1'b1) begin\n\t   q <= 8'h34;\n\telse \n\t   q <= d;\n\tend\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n\t// 8-bit D flip flop with synchronous active high reset\n\talways @(negedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 8'h34;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n\treg [7:0] temp;\n\t\t\n\tinitial begin \n\t\ttemp = 8'h34; // initializing to reset value.\n\tend \n\t\n\talways @(negedge clk) begin\n\t\tif (reset == 1'b1)\n\t\t\tq <= temp; // asynchronous reset\n\t\telse\n\t\t\tq <= d;    // normal operation\n\tend  \n\t\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\n\treg[7:0] temp; \n\n\talways @(negedge clk or posedge reset) begin\n\t    if(reset == 1'b1)\n\t\t    temp <= 8'h34; // Reset to any value you want, I have used '34'.\n        else \n            temp <= d;     // Normal operation.\n\tend\n\n\t// Output assignment \n\tassign q = temp;\n\t\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n\n\tparameter [7:0] RESET_VAL = 8'h34; \n\t\t\n\talways @(negedge clk) begin\n\t\tif (reset)\n\t\t\tq <= RESET_VAL;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n    \n    always @(negedge clk) begin\n        if (reset) \n            q <= 8'h34;\n        else \n            q <= d;\n    end\nendmodule\n  \n "}
{"task_id": "dff8p", "completion": "\n\t// D flip flops with synchronous reset\n\talways @(negedge clk or posedge reset) begin\n\t\t\tif (reset) \n\t\t\t\tq <= 8'h34;\n\t\t\telse \n\t\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\n    always @(negedge clk) begin\n        if (reset) \n            q <= 8'h34;\n        else \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\n\n\treg [7:0] reset_value = 8'h34;\n\n\talways @(negedge clk) begin \n\t    if (reset == 1'b1) \n\t\t    q <= reset_value;\n        else  \n\t\t    q <= d;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\n\treg [7:0] rst; \n    always @ (negedge clk) begin   // reset is active high and neg edge triggered \n        if(reset) \n            rst <= 8'h34;\n        else \n            q <= d;\n     end\n\tassign q = rst;\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n\t\n\treg[7:0] preset;\n\n\talways @(negedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 8'h34;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\nalways @(negedge clk or posedge reset) begin \n\tif (reset) // synchronous active high reset\n\t\tq <= 8'h34; \n\telse \n\t\tq <= d; \nend\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\n\talways @(negedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 8'h34;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8p", "completion": "\n\treg [7:0] q; \n\talways @(negedge clk or posedge reset) begin\n\tif (reset == 1'b1) begin\n\t\tq <= 8'h34;\n\tend else begin\n\t\t\tq <= d;\n\tend\n\tend\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n\n\treg [7:0] internal_q; // internal storage to hold data until output assignment happens\n    \n\talways @(negedge clk) begin //synchronous on the falling edge of clock\n\t    if (reset) \n\t\t    internal_q <= 8'h34; // reset to value 0x34 rather than zero.\n\t    else \n            internal_q <= d; // load data on DFF\n\tend\n    \n\tassign q = internal_q; // assign the stored value back to output\n\n"}
{"task_id": "dff8p", "completion": "\n   \n   localparam RESET_VAL = 8'h34;\n\n\talways @(negedge clk) begin\n\t\t  if (reset == 1) \n\t\t\t  q <= RESET_VAL;\n\t      else \n\t\t\t  q <= d;\n\tend\nendmodule\n"}
{"task_id": "dff8p", "completion": "\n\treg [7:0] resetVal;\n\talways @(negedge clk) begin\n\t\tif (reset) \n\t\t    q <= 8'h34;\n        else \n            q <= d;\n     end\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\n\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\n\tassign out = ~in;\n\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule\n"}
{"task_id": "notgate", "completion": "\n\n\tassign out = ~in;\n\t\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\n\tassign out = ~in;\n\t\nendmodule\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\t// Assignment using always block for synchronous assignment\n\talways @* begin \n\t   out = ~in;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n    assign out = ~in;  // The NOT Gate implementation is done here by using the NOT operator ~\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\n\tassign out = ~in;\n\nendmodule \n\n"}
{"task_id": "notgate", "completion": "\n    \n    assign out = ~in;\nendmodule \n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule \n\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule\n"}
{"task_id": "notgate", "completion": "\nassign out = ~in; \nendmodule\n"}
{"task_id": "notgate", "completion": "\n\n\tassign out = ~in;\n  \nendmodule \n\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\n    assign out = ~in;\n    \nendmodule\n\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\n\nendmodule\n"}
{"task_id": "notgate", "completion": "\n\tassign out = ~in;\nendmodule\n"}
{"task_id": "wire4", "completion": "\n\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\t\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n\n\tassign w = a; // a -> w\n\tassign x = b; // b -> x\n\tassign y = b; // b -> y\n\tassign z = c; // c -> z\nendmodule\n"}
{"task_id": "wire4", "completion": "\n\tassign w = a; //since the connection is direct from 'a' to 'w'\n\tassign x = b; //same for 'b' and 'x'\n\tassign y = b; // same as 'y' but with 'b' instead of 'c' \n\tassign z = c; // and 'z' with 'c', as specified in the problem statement\nendmodule \n"}
{"task_id": "wire4", "completion": "\n   assign w = a;\n   assign x = b;\n   assign y = b;\n   assign z = c;\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n    \nendmodule\n\n"}
{"task_id": "wire4", "completion": "\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n"}
{"task_id": "wire4", "completion": "\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n\n\t// A simple implementation could be done using multiple assignments. \n\t// Here we assign each output to the corresponding input or an intermediate wire.\n\twire b_x, c_y; // Intermediate wires for b and c going to x and y respectively.\n    \n\tassign w = a;               \n\tassign b_x = b;             \n\tassign c_y = c;            \n\tassign x = b_x;         \n\tassign y = c_y;        \n\tassign z = b & c;  \nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n     assign w = a;\n     assign x = b;\n     assign y = b;\n     assign z = c;\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n"}
{"task_id": "wire4", "completion": "\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule\n"}
{"task_id": "wire4", "completion": "\n     assign w = a;\n     assign x = b;\n     assign y = b;\n     assign z = c;\nendmodule  \n"}
{"task_id": "wire4", "completion": "\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n"}
{"task_id": "wire4", "completion": "\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n\n\tassign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\t\nendmodule\n\n"}
{"task_id": "wire4", "completion": "\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule\n"}
{"task_id": "wire4", "completion": "\n\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\t\nendmodule\n\n"}
{"task_id": "circuit6", "completion": "\n\tThe simulation waveforms indicate that this circuit is an n-bit left/right shifter. The inputs 'a' control the direction of shifting and magnitude of shift (i.e., each unit increase in 'a' shifts one bit to the right or left). \n\tTherefore, for every cycle, if a > 1, then the output q is shifted by 'a - 1' bits towards the most significant end; conversely if a < 4, then q is shifted by (4 - a) bits towards the least significant end. The state of q after each clock cycle is dependent on its previous state and the input signal 'a'.\n\t\n\t// This implementation will use an always block to handle synchronous updates to variable \"q\" asynchronously. \n\talways @(*) begin\n\t\tcase (a)\n\t\t\t3'b000: q <= 16'h2F19; // Initial state\n\t\t    3'b001: q <= {q[14:0], 1'b0}; // Shift right by one bit\n            3'b010: q <= {1'b0, q[15:1]}; // Shift left by one bit\n\t        3'b011: q <= {q[14:0], 1'b0}; // Shift right by two bits\n            3'b100: q <= {1'b0, q[15:2]}; // Shift left by two bits\n\t        3'b101: q <= {q[14:0], 2'b00}; // Shift right by three bits\n            3'b110: q <= {2'b00, q[15:3]}; // Shift left by three bits\n\t        3'b111: q <= {q[14:0], 3'b000}; // Shift right by four bits (No change in shifting direction)\n\t\t    default: q <= 16'h2F19; // If the input 'a' is out of range, then maintain state as initial \"2F19\".\n\t\tendcase\n\tend\nendmodule \n"}
{"task_id": "circuit6", "completion": "\n   always @(*) begin\n\t    case (a)\n\t\t    3'b000: q = 16'h1232;\n\t\t\t3'b001: q = 16'haee0;\n\t\t\t3'b010: q = 16'h27d4;\n\t\t\t3'b011: q = 16'h5a0e;\n\t\t\t3'b100: q = 16'h2066;\n\t\t\t3'b101: q = 16'h64ce;\n\t\t\t3'b110: q = 16'hc526;\n\t\t\t3'b111: q = 16'h2f19;\n\t\t\tdefault: q = 16'hxxxx;  // undefined input\n\t    endcase\n   end\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n    \n    always @(*) begin  \n       case (a)         \n            3'b000 : q <= 16'h1232;          \n            3'b001 : q <= 16'haee0; \n            3'b010 : q <= 16'h27d4;        \n            3'b011 : q <= 16'h5a0e;  \n            3'b100 : q <= 16'h2066;     \n            3'b101 : q <= 16'h64ce ;      \n            3'b110 : q <= 16'hc526; \n\t    3'b111 : q <= 16'h2f19;   \n           default : q <= 16'hz;         // 'z' stands for high-impedance or open.\n       endcase \n    end  \nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\talways @(*) begin\n\t    case(a)\n\t\t    3'b000 : q = 16'h1232;\n            3'b001 : q = 16'haee0;\n            3'b010 : q = 16'h27d4;\n            3'b011 : q = 16'h5a0e; \n            3'b100 : q = 16'h2066;\n\t\t    3'b101 : q = 16'h64ce;  \t  \n            3'b110 : q = 16'hc526;  \n            3'b111 : q = 16'h2f19;   \n            default: q = 16'hxxxx; \n        endcase\n\tend\n\t\nendmodule\n"}
{"task_id": "circuit6", "completion": "\nThe above given code is incomplete. Please provide the full combinational circuit that should be implemented here.\n\n"}
{"task_id": "circuit6", "completion": "\n\n\talways @(*) begin\n\tcase (a)\n\t\t3'h0: q <= 16'd1232;\n\t\t3'h1: q <= 16'haee0;\n\t\t3'h2: q <= 16'h27d4;\n\t\t3'h3: q <= 16'h5a0e;\n\t\t3'h4: q <= 16'h2066;\n\t\t3'h5: q <= 16'h64ce;\n\t\t3'h6: q <= 16'hc526;\n\t\t3'h7: q <= 16'h2f19;\n\t\tdefault: q <= 16'b0;\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit6", "completion": "\nThe simulation waveforms provide us with the following truth table for the circuit:\n\n| a[2:0] | q[15:8] | q[7:0] | \n| 0     | 1       | 1232   |  \n| 1     | 1       | 1232   | \n| 2     | 4       | 64ce   |\n| 3     | 3       | 5a0e   |\n| 4     | 4       | 2066   |\n| 5     | 5       | 64ce   |\n| 6     | 9       | 78d0   |\n| 7     | 1       | 1232   | \n\nBased on this table, we can implement the combinational logic of our circuit as follows: \n\n\talways @(*) begin\n\t\tcase (a)\n\t\t\t3'b000 : q <= 16'h1232; // a = 0\n      \t\t3'b001 : q <= 16'haee0; // a = 1\n      \t\t3'b010 : q <= 16'h27d4; // a = 2\n      \t\t3'b011 : q <= 16'h5a0e; // a = 3\n      \t\t3'b100 : q <= 16'h2066; // a = 4\n      \t\t3'b101 : q <= 16'h64ce; // a = 5\n      \t\t3'b110 : q <= 16'hc526; // a = 6\n      \t\t3'b111 : q <= 16'h2f19; // a = 7\n\t\tendcase \n   \tend\n\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\t// I've created a table for all possible inputs and outputs based on the simulation.\n\t// In the code below, there is an if-else statement that uses combinational logic to select one of three output values according to the input value.\n\talways @(*) begin  // <-- * means everything in the design\n\t    case (a)\n\t       3'd0 : q = 16'h2f19;   // a=0, q=2f19\n\t       3'd1 : q = 16'haee0;   // a=1, q=aee0\n\t       3'd2 : q = 16'h5a0e;   // a=2, q=5a0e\n\t       3'd3 : q = 16'hc526;   // a=3, q=c526\n\t       3'd4 : q = 16'h64ce;   // a=4, q=64ce\n\t       3'd5 : q = 16'h2066;   // a=5, q=2066\n\t       3'd6 : q = 16'h27d4;   // a=6, q=27d4\n\t       3'd7 : q = 16'h1232;   // a=7, q=1232\n\t       default: q = 16'hxxxx;  // invalid input case\n\t    endcase\n\tend\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\n\t// We can create a lookup table for the output values based on the input.\n\treg [15:0] lut[8];  \n    \n\tassign q = lut[a];  // Outputs are looked up in the LUT.\n\t\n\t// Initialize our Look-Up Table\n\tinitial begin\t\t\n\t    lut[0] = 16'h1232;\n        lut[1] = 16'haee0;\n        lut[2] = 16'h27d4; \n        lut[3] = 16'h5a0e;\n        lut[4] = 16'h2066;\n        lut[5] = 16'h64ce;\n\t    lut[6] = 16'hc526; \n        lut[7] = 16'h2f19;\t\n    end\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\talways @(*) begin\n\tcase(a)\n\t\t3'b000 : q <= 16'h1232;\n\t\t3'b001 : q <= 16'haee0;\n\t\t3'b010 : q <= 16'h27d4;\n\t\t3'b011 : q <= 16'h5a0e;\n\t\t3'b100 : q <= 16'h2066;\n\t\t3'b101 : q <= 16'h64ce;\n\t\t3'b110 : q <= 16'hc526;\n\t\t3'b111 : q <= 16'h2f19;\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n    always @(*) begin\n        case(a)\n            3'b000 : q = 16'h1232; // time 15ns\n            3'b001 : q = 16'haee0; // time 45ns\n            3'b010 : q = 16'h27d4; // time 30ns\n            3'b011 : q = 16'h5a0e; // time 85ns\n            3'b100 : q = 16'h2066; // time 60ns\n            3'b101 : q = 16'h64ce; // time 90ns\n            3'b110 : q = 16'hc526; // time 75ns\n            3'b111 : q = 16'h2f19; // time 80ns\n            default: q = 'x;     // Initial states are undefined, output is x.\n        endcase\n    end\nendmodule\n"}
{"task_id": "circuit6", "completion": "\nalways @(*) begin\n\tcase (a)\n\t\t3'b000: q = 16'h1232;\n\t\t3'b001: q = 16'haee0;\n\t\t3'b010: q = 16'h27d4;\n\t\t3'b011: q = 16'h5a0e;\n\t\t3'b100: q = 16'h2066;\n\t\t3'b101: q = 16'h64ce;\n\t\t3'b110: q = 16'hc526;\n\t\t3'b111: q = 16'h2f19;\n\t\tdefault: q = 16'bx;\n\tendcase\nend\nendmodule \n"}
{"task_id": "circuit6", "completion": "\nalways @(*) begin\n\tcase(a)\n\t\t3'd0: q = 16'h1232;\n\t\t3'd1: q = 16'haee0;\n\t\t3'd2: q = 16'h27d4;\n\t\t3'd3: q = 16'h5a0e;\n\t\t3'd4: q = 16'h2066;\n\t\t3'd5: q = 16'h64ce;\n\t\t3'd6: q = 16'hc526;\n\t\t3'd7: q = 16'h2f19;\n\t\tdefault: q = 'x;  // unknown state\n\tendcase\nend\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\tThe table indicates that the output of this combinational circuit depends on the input 'a'. For example, if a = 3'b010 ('decimal' value is 2), then q should be 16-bit binary number equal to hexadecimal '54d8', because in that moment a[2]=0, a[1]=1 and a[0]=0. If we create truth table for this circuit, it would look like:\n\t| a[2] | a[1] | a[0] |   q   |\n\t| 0   |  x   |  x   |  54d8 |\n\t| x   | 0    |  x   |  27d4 |\n\t| x   |  x   | 0    |  64ce |\n\t| x   |  x   | 1    |  aee0 |\n\t| 1   |  x   |  x   |  c526 |\n\t| 0   | 1    |  x   |  9a38 |\n\t| 1   | 0    |  x   |  4e70 |\n\n\tThe code in Verilog would then look like this:\n"}
{"task_id": "circuit6", "completion": "\n\n\talways @(*) begin\n        case(a)\n        3'b000 : q <= 16'd1232; // initial value for 0\n        3'b001 : q <= 16'haee0; // for input '1'\n        3'b010 : q <= 16'h27d4; // for input '2'\n        3'b011 : q <= 16'h5a0e; // for input '3'\n        3'b100 : q <= 16'h2066; // for input '4'\n        3'b101 : q <= 16'h64ce; // for input '5'\n        3'b110 : q <= 16'hc526; // for input '6'\n        3'b111 : q <= 16'h2f19; // for input '7'\n        default:   q <= 16'bx;  // undefined values\n    endcase\t\n\tend\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\talways @(*) begin\n\tcase(a)\n\t\t3'b000 : q = 16'h1232;\n\t\t3'b001 : q = 16'haee0;\n\t\t3'b010 : q = 16'h27d4;\n\t\t3'b011 : q = 16'h5a0e;\n\t\t3'b100 : q = 16'h2066;\n\t\t3'b101 : q = 16'h64ce;\n\t\t3'b110 : q = 16'hc526;\n\t\t3'b111 : q = 16'h2f19;\n\t\tdefault: q = 'x;  // default to undefined state when a is not in above cases\n\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "circuit6", "completion": "\n    always @(*) begin\n        case (a)\n            3'b000 : q = 16'h1232;\n            3'b001 : q = 16'haee0;\n            3'b010 : q = 16'h27d4;\n            3'b011 : q = 16'h5a0e;\n            3'b100 : q = 16'h2066;\n            3'b101 : q = 16'h64ce;\n            3'b110 : q = 16'hc526;\n            3'b111 : q = 16'h2f19;\n            default: q = 16'bx;\n        endcase\n    end \nendmodule \n"}
{"task_id": "circuit6", "completion": "\n\t// Create lookup table for the combinational logic.\n\treg [3:0] lut[8];\n\tinteger i;\n\tinitial begin\n\t\tfor (i=0; i<2**($size(a)); i++) \n\t\t\tcase(i)\n\t\t\t\t4'd1 : lut[i] <= 4'hA;\n\t\t\t\t4'd2 : lut[i] <= 4'h6;\n\t\t\t\t4'd3 : lut[i] <= 4'h9;\n\t\t\t\t4'd4 : lut[i] <= 4'h0;\n\t\t\t\tdefault : lut[i] <= 4'hF;\n\t\tendcase\n\tend\n\t// Implement combinational circuit with lookup table.\n\talways @(*) begin\n\t\tcase (a) \n\t\t\t3'b001: q <= {lut[7][3:0], lut[2][3:0], lut[6][3:0], lut[5][3:0]};\n      \t\t3'b010: q <= {lut[4][3:0], lut[1][3:0], lut[7][3:0], lut[6][3:0]};\n\t\t// Fill in the rest of your cases here...\n\t\t\t3'b100: q <= {lut[2][3:0], lut[5][3:0], lut[4][3:0], lut[7][3:0]};\n      \t\t3'b111: q <= {lut[6][3:0], lut[3][3:0], lut[1][3:0], lut[5][3:0]};\n\t\tendcase \n\tend \nendmodule\n"}
{"task_id": "circuit6", "completion": "\nalways @(*) begin\n\tcase (a)\n\t\t3'd0 : q = 16'h1232;\n\t\t3'd1 : q = 16'haee0;\n\t\t3'd2 : q = 16'h27d4;\n\t\t3'd3 : q = 16'h5a0e;\n\t\t3'd4 : q = 16'h2066;\n\t\t3'd5 : q = 16'h64ce;\n\t\t3'd6 : q = 16'hc526;\n\t\t3'd7 : q = 16'h2f19;\n\t\tdefault: q = {a, 8'b0}; // If a is not one of the above values, set q to the value 'aaaa_00xx', where 'aaa' is the binary representation of 'a'.\n\tendcase\nend\nendmodule\n"}
{"task_id": "circuit6", "completion": "\n\talways @(*) begin\n\tcase(a)\n\t\t3'b000 : q = 16'h1232;\n\t\t3'b001 : q = 16'haee0;\n\t\t3'b010 : q = 16'h27d4;\n\t\t3'b011 : q = 16'h5a0e;\n\t\t3'b100 : q = 16'h2066;\n\t\t3'b101 : q = 16'h64ce;\n\t\t3'b110 : q = 16'hc526;\n\t\t3'b111 : q = 16'h2f19;\n\t\tdefault: q = 16'hxxxx;\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "lemmings4", "completion": "\n\treg [17:0] counter; // Counter for falling time.\n\tparameter WALK_LEFT = 4'h1; \n\tparameter WALK_RIGHT = 4'h2;\n\tparameter FALLING = 4'h3;\n\tparameter DIGGING = 4'h4;\n\treg [3:0] state, next_state; // States for Moore machine.\n    \n    always @(posedge clk or posedge areset) begin \n        if (areset) begin\n            state <= WALK_LEFT;\n\t\t\tcounter <= 18'h0;\n        end else begin \n            state <= next_state;\n\t\t\tif (falling) counter <= counter + 1'b1; // Increase the falling time.\n\t\tend\n    end  \n    \n    always @(*) begin \n        case (state)\n             WALK_LEFT: begin\n                 walk_left = 1'b1;\n                 walk_right = 1'b0;\n\t\t\t\t aaah = 1'b0;\n\t\t\t\t digging = 1'b0;\t\n                 if(ground && !dig ) next_state = WALK_LEFT; // If on ground and not digging.\n\t\t\t\t\t else if (bump_right) next_state = WALK_RIGHT;  //If bumped right.\n                  else if (!ground && counter >= 18'd20 ) next_state = 4'h0;// If fell for more than 20 clock cycles and hit the ground, it will splatter.\n\t\t\t\t\telse if (dig) next_state = DIGGING; // If digging.\n\t\t\t\t\t else next_state = FALLING;   // If falling or no change.\t\n             end\n             \n\t\t\t WALK_RIGHT: begin\n                 walk_left = 1'b0;\n                 walk_right = 1'b1;\n\t\t\t\t aaah = 1'b0;\n\t\t\t\t digging = 1'b0;\t\t \n                 if(ground && !dig ) next_state = WALK_RIGHT; // If on ground and not digging.\n\t\t\t\t\t else if (bump_left) next_state = WALK_LEFT; //If bumped left.\n                  else if (!ground && counter >= 18'd20 ) next_state = 4'h0;// If fell for more than 20 clock cycles and hit the ground, it will splatter.\n\t\t\t\t\telse if (dig) next_state = DIGGING; // If digging.\n\t\t\t\t\t else next_state = FALLING;   // If falling or no change.\t\t\t\n             end\t\n             \n\t\t\t FALLING: begin \n                 walk_left = 1'b0;\n                 walk_right = 1'b0;\n\t\t\t\t aaah = 1'b1;\n\t\t\t\t digging = 1'b0;\t\t  \t \n                 if(ground) next_state = WALK_LEFT; // If on ground, go back to walk left.\n\t\t\t\t\t else next_state = FALLING;  // Stay falling if not on the ground yet.\t\n             end\n\t\t\t \n\t\t\t DIGGING: begin\n                 walk_left = 1'b0;\n                 walk_right = 1'b0;\n\t\t\t\t aaah = 1'b0;\n\t\t\t\t digging = 1'b1;\t\t  \t \n                 if(!ground) next_state = WALK_LEFT; // If on ground, go back to walk left.\n\t\t\t\t\t else next_state = DIGGING;  // Stay digging if not on the ground yet.\t\n             end\t\t\t \n             \n        endcase\n    end  \nendmodule\n"}
{"task_id": "lemmings4", "completion": "\nparameter SPLAT = 10; // splat after 2^SPLAT cycles\nreg [5:0] state; // 6 states (walking left, right, falling, bumped left/right, digging and not ground)\nreg [4:0] splat_timer; // timer for when to go back to walking\nlocalparam WALK = 3'b001, RIGHT = 3'b010, LEFT = 3'b100, DIGGING = 3'b011, FALLING = 3'b101; // states\n\talways @(posedge clk or posedge areset) begin \n\t\tif (areset) begin // asynchronous reset\n\t\t\tstate <= LEFT; // start by walking left\n\t\t\tsplat_timer <= 0; // no need to splat at the beginning\n\t\tend else case (state)\n\t\t\tWALK: if (ground && !dig) begin\n\t\t\t\tif (bump_left) state <= RIGHT; // walked on ground and bumped right, walk right next\n\t\t\t\telse if(bump_right) state <= LEFT; // walked on ground and bumped left, walk left next\n\t\t\tend else if (!ground && dig) state <= DIGGING; // fell but now digging -> enter this state\n\t\t\telse begin // default action: walk in same direction\n\t\t\t\tif(bump_left) state <= LEFT; // walked on ground and bumped left, stay walking left next\n\t\t\t\telse if (bump_right) state <= RIGHT; // walked on ground and bumped right, stay walking right next\n\t\t\tend \n\t\t\tRIGHT: begin\n\t\t\t\tif(ground && dig) state <= DIGGING; // walked to the right on ground and now digging -> enter this state\n\t\t\t\telse if(!ground && !dig) state <= FALLING; // fell while walking right, but no longer digging/on ground -> fall\n\t\t\tend \n\t\t\tLEFT: begin\n\t\t\t\tif(ground && dig) state<= DIGGING; // walked to the left on ground and now digging -> enter this state\n\t\t\t\telse if(!ground && !dig) state <= FALLING; // fell while walking left, but no longer digging/on ground -> fall\n\t\t\tend \n\t\t\tDIGGING: if (ground) begin// keep digging till the end of cycle when on ground or falling\n\t\t\t\tif(bump_left|| bump_right) state <= FALLING; // fell while digging, but not enough time for splat -> fall\n\t\t\tend \n\t\t\tFALLING: if (ground && !dig ) begin\n\t\t\t\t\t\t\t\t\t   state <= WALK;// landed on ground and now walking in same direction as before falling\n\t\t\t\t\t\t\t\t\t\t\tif(bump_left) splat_timer<= SPLAT; // walked on ground after fall while bumping left -> start counting for splat \n\t\t\t\t\t\t\t\t\t\t\telse if (bump_right) splat_timer <=SPLAT;// walked on ground after fall while bumping right -> start counting for splat\n\t\t\t\t\t\t\t\t\t   end else if(splat_timer > 0 ) begin // still falling, but not long enough to count down yet\n\t\t\t\t\t\t\t\t\t\t\tsplat_timer<= splat_timer +1 ; // keep counting down for splat\n\t\t\t\t\t\t\t\t\t   end else state <= WALK;// long enough after fall to walk in same direction -> return back to walking \n\t\t\t\t// all other states are handled by default actions\n\t\tendcase \n\tend \n\t// output assignments (aaah and digging will be high for the corresponding action)\n\tassign aaah = state == FALLING;\n\tassign digging = state == DIGGING || state==WALK && dig; // walk on ground while digging or just walking in other cases\n\tassign walk_right = ~(state[1] | (state == RIGHT) );// when state is not right or the state is right \n\tassign walk_left = ~(state[0] | (state== LEFT)); // when state is not left or the state is left\nendmodule\n"}
{"task_id": "lemmings4", "completion": " \n    reg [5:0] state = 6'b000101; // start in 'walk right' state\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset == 1) \n            state <= 6'b000101; // reset to walk right state\n         else begin\n                case (state)\n                    6'b000101 : begin //walk right state\n                        if(ground && !dig) begin\n                            walk_left  <= 0; \n                            walk_right <= 1;\n                            aaah       <= 0; \n                            digging    <= 0;\n                        end else if (!bump_left && bump_right && ground) begin\n                            state <= 6'b011001; // fall and right state\n                        end else if (bump_left && bump_right && ground) begin \n                            walk_left  <= 0; \n                            walk_right <= 0; \n                            aaah       <= 1; \n                            digging    <= 0; \n                        end else if(dig == 1'b1 )begin\n                            state      <= 6'b001101; //dig and right/left state\n                        end\n                    end\n                    \n                    6'b011001 : begin //falling state\n                        walk_left  <= 0; \n                        walk_right <= 0; \n                        aaah       <= 1; \n                        digging    <= 0;   \n                        if(ground)begin  \n                            state <= 6'b000101; // back to walk right/left state from falling\n                        end else if (bump_right || bump_left ) begin \n                            state <=6'b100001 ; // splatter state when more than 20 clk cycles fall without ground contact\n                        end\n                    end\n                    \n                    6'b001101 : begin// digging right/left state\n                      walk_left  <= 0;\n                      walk_right <= 0;\n                      aaah        <= 0;\n                      digging     <= 1;  //digging flag on\n                      if(!ground)begin  \n                        state <=6'b001001 ;// back to fall and right/left when not grounded after start of digging\n                      end else begin\n                        state <= 6'b000101;// walk right/left again \n                      end   \n                    end  \n                    \n                    6'b100001 : begin //splatter state\n                        walk_left  <= 0; \n                        walk_right <= 0; \n                        aaah       <= 0; \n                        digging    <= 0;    \n                    end   \n                endcase \n            end\n        end  \nendmodule\n"}
{"task_id": "lemmings4", "completion": "\nlocalparam SPLAT = 4'b0000;\nlocalparam WALKING_LEFT = 4'b1000;\nlocalparam WALKING_RIGHT = 4'b0100;\nlocalparam FALLING = 4'b0010;\nlocalparam DIGGING = 4'b0001;\nreg [3:0] state, nextstate;\nalways @(posedge clk or posedge areset) \n\tbegin\n\tif (areset)\n\t\tstate <= WALKING_LEFT;\n\telse\n\t\tstate <= nextstate;\n\tend\n\t\t\nalways @(*) begin\n\tcase(state)\n\t\tWALKING_LEFT: if((bump_left && ~ground) || dig ) \n\t\t\t\t\t\t\tnextstate = FALLING;\n\t\t\t\t\t\telse if (~ground && bump_right)\n\t\t\t\t\t\t\t nextstate = WALKING_RIGHT ;\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\t nextstate=WALKING_LEFT;\n\t\t\n\t\tWALKING_RIGHT: if((bump_right && ~ground )|| dig )\n\t\t\t\t\t\t     nextstate =  FALLING;\n\t\t\t\t\t    else if (~ground && bump_left)\n\t\t\t\t\t\t\t  nextstate = WALKING_LEFT ;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t nextstate=WALKING_RIGHT;\t  \n\t\t\n\t\tFALLING: if( ground ) \n\t\t\t\t\t\t   nextstate =  DIGGING;\n\t\t\t\t  else \n\t\t\t\t\t\tnextstate=  FALLING;\t\t\t\n\t\tDIGGING : if (~ground)\n\t\t\t\t\t    nextstate = WALKING_LEFT ;\n\t\t\t\t\telse\n\t\t\t\t\t    nextstate=DIGGING;\t\t\n\n\t\tdefault: nextstate = SPLAT; // when a splat occurs, stay in that state until reset\n  endcase\nend\nassign walk_left= (state==WALKING_LEFT);\nassign walk_right=(state==WALKING_RIGHT );\nassign aaah=(state==FALLING || state ==SPLAT ) ;\nassign digging =(state==DIGGING)  ;\t\t\nendmodule\n"}
{"task_id": "lemmings4", "completion": "\n  reg [2:0] state;\n  parameter WALK_LEFT = 3'b100,\n            WALK_RIGHT = 3'b010,\n\t\t\t\t\t SPLAT = 3'b000,\n             FALL = 3'b110;\n\treg falling;\n\tinteger fallCounter;\n  \n  always @(posedge clk or posedge areset) begin\n    if (areset) begin\n      state <= WALK_LEFT;\n\t\t\tfalling <= 1'b0;\n\t\t\tfallCounter <= 20; // reset to the falling time limit\n    end else begin \n       case(state)\n           WALK_LEFT: begin  \n                if (bump_right | ~ground ) begin\n                    state <= FALL;\n\t\t\t\t\t          fallCounter <= 19;// start counting down from 20 cycles minus one, since we are on cycle 20 now.\n\t\t\t\t\t\t\t\tfalling <= 1'b1;\n                end else if(dig & ground) begin \n                      state <= digging;\n\t\t\t\t\t\t\t\tfalling <= 1'b0;\n                end else if (bump_left )begin   // switch directions\n                    state<= WALK_RIGHT ;\n\t\t\t\t\t          falling <= 1'b0;\n                end       \n            end\n           WALK_RIGHT: begin \n                if( bump_left | ~ground)begin \n                    state <= FALL;\n                  fallCounter <= 20; // reset to the falling time limit\n\t\t\t\t\t\t\t\tfalling <= 1'b1;\n                end else if (dig & ground ) begin  \n                      state <= digging;\n\t\t\t\t\t\t\t\tfalling <= 1'b0;\n                end  else if( bump_right)begin   // switch directions\n                    state <= WALK_LEFT ;\n\t\t\t\t\t        falling <= 1'b0;\n                end    \n            end   \n           FALL: begin  \n\t\t\t\t\t\t fallCounter <= fallCounter - 1;\n                if (fallCounter == 0 & ground ) begin\n                      state <= WALK_LEFT ; // return to walk left after the specified time\n\t\t\t\t\t\t\t\tfalling <= 1'b0;\n                end else if (dig)begin  \n\t\t\t\t\t           state <= digging;\n\t\t\t\t\t\t\t\tfalling <= 1'b0;\t\t    \n\t\t\t\t\t\t  end        \t\t\t       \n            end      \n\t\t\t\t SPLAT: begin // staying in splat state until reset\n\t\t\t\t\t\tstate <= SPLAT;\n                falling <= 1'b0;\t  \t   \t\n            end             \n        endcase     \n    end\n  end  \n assign walk_left = (state==WALK_LEFT);\n assign walk_right=(state == WALK_RIGHT );\n assign aaah =  falling;\n assign digging = (state==FALL)?1'b0:dig; // once lemming has fallen, it can't start digging until ground appears again\nendmodule  \n\n"}
{"task_id": "lemmings4", "completion": "\n\nlocalparam [3:0] \n    STATE_WALKING = 4'h1,\n    STATE_RIGHT  = 4'h2,\n    STATE_LEFT   = 4'h3,\n    STATE_DIG    = 4'h4;\nreg [3:0] state = STATE_LEFT;\n\nwire falling = (state == STATE_WALKING && !ground);\nassign walk_left  = (state == STATE_RIGHT || (falling && bump_right)); \nassign walk_right = (state == STATE_LEFT  || (falling && bump_left ));\nassign aaah       = falling;\nassign digging    = state == STATE_DIG;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) \n\t    state <= STATE_LEFT;\n    else case (state)\n    \tSTATE_RIGHT, STATE_WALKING: \n        \tif      (ground && bump_right)  state <= STATE_DIG;       // walk -> dig on right bump\n        \telse if (!bump_left  )        state <= STATE_LEFT ;       // keep walking or falling left\n        \telse /*if (!falling)*/             state <= STATE_WALKING;      // else keep walking/digging (or fall and hit ground)\n    \tSTATE_LEFT, STATE_DIG: \n        \tif      (ground && bump_left )  state <= STATE_RIGHT ;       // dig -> walk on left bump or right\n        \telse if (!bump_right)           begin state <= STATE_WALKING; end // keep walking or falling right\n        \telse /*if (!falling)*/             state <= STATE_DIG  ;       // else keep digging (or fall and hit ground)\n        default:                            state <= STATE_LEFT ;      // reset to walk left\n    endcase\nend\n\n"}
{"task_id": "lemmings4", "completion": "\n\t// State definitions \n\tlocalparam STATE_WALK_LEFT = 2'b00;\n\tlocalparam STATE_WALK_RIGHT = 2'b01;\n\tlocalparam STATE_FALL = 2'b10;\n\tlocalparam STATE_DIG = 2'b11;\n\n\t// FSM variable declaration \n\treg [1:0] state, nextstate;\n\tinteger falling_counter; // fall counter\n    \n\t// FSM state transition logic  \n\talways @(posedge clk or posedge areset) begin\n        \tif (areset) begin\n\t\t\tstate <= STATE_WALK_LEFT;\n\t\t\tfalling_counter <= 0;\n\t\tend \n        \telse \n            \t\tstate <= nextstate;\n    \tend\n   \n\t// FSM state transition logic  \n\talways @(*) begin\n            case (state)\n                STATE_WALK_LEFT: begin\n                    if(bump_right & ground) nextstate = STATE_WALK_RIGHT;\n                    else if((~ground | falling_counter > 20)) nextstate = STATE_FALL; // fall if not on ground or fell for more than 20 clock cycles\n                    else if(dig) nextstate = STATE_DIG;  \t\t// dig state when told to by input\n                    else nextstate = state;\t\t\t// else remain in current state i.e., walk left\n                end\n                STATE_WALK_RIGHT: begin\n                    if(bump_left & ground) nextstate = STATE_WALK_LEFT;   // change direction to left when bumped on left and on ground \n                    else if((~ground | falling_counter > 20)) nextstate =STATE_FALL;// fall if not on ground or fell for more than 20 clock cycles\n                    else if(dig) nextstate = STATE_DIG;\t\t\t// dig state when told to by input\n                    else nextstate = state;\t\t\t // else remain in current state i.e., walk right\n                end\n                STATE_FALL: begin\n                \tfalling_counter <= falling_counter + 1; \n                    if(ground) nextstate = (dig)?STATE_DIG:(bump_right & ground)?STATE_WALK_RIGHT:STATE_WALK_LEFT; // change direction based on input and whether ground is available or not\t\n                    else nextstate = state;\t\t\t// remain in fall until the Lemming hits the ground \n                end\n                STATE_DIG: begin\n                \tif(ground) nextstate =STATE_WALK_RIGHT;   // continue digging until ground disappears and then start walking towards right\t\n                    else nextstate = state;\t\t\t// remain in current state i.e., dig if the ground is not available \n                end\n                default: nextstate = STATE_WALK_LEFT;        // default to walk left at any unknown state \n            endcase\n    \tend\n\n\t// Output Logic based on state  \n\tassign aaah = (state==STATE_FALL);\t\t\t\n\tassign digging = (state==STATE_DIG);\t\t\n\tassign walk_left = (state==STATE_WALK_LEFT); \n\tassign walk_right =(state==STATE_WALK_RIGHT);  \nendmodule\n\n"}
{"task_id": "lemmings4", "completion": "\n    \n    reg [1:0] state;\n    parameter WALK_LEFT = 2'b01, WALK_RIGHT = 2'b10, FALLING = 2'b11;\n    integer fallCounter;\n      \n\talways @(posedge clk or posedge areset) begin\n        if (areset == 1) begin\n            state <= WALK_LEFT;\n            walk_left <= 1'b1;\n            walk_right <= 1'b0;\n            aaah <= 1'b0;\n            digging <= 1'b0;\n            fallCounter <= 21;  // more than enough time to splatter :P\n        end\n        else begin\n            case (state)\n                WALK_LEFT: begin\n                    walk_left <= 1'b1;\n                    walk_right <= 1'b0;\n                    aaah <= 1'b0;\n                    digging <= dig & ground;  // can only start digging while on the ground and when directed to do so by the input.\n                    if (bump_right | ~ground) begin\n                        state <= FALLING;\n                        fallCounter <= 21;  \n                    end\n                    else if (bump_left & ground)  // bumping left on the ground will make the Lemming walk right\n                        state <= WALK_RIGHT;\n                end\n                \n                WALK_RIGHT: begin\n                    walk_right <= 1'b1;\n                    walk_left <= 1'b0;\n                    aaah <= 1'b0;\n                    digging <= dig & ground;  // can only start digging while on the ground and when directed to do so by the input.\n                    if (bump_left | ~ground) begin\n                        state <= FALLING;\n                        fallCounter <= 21;  \n                    end\n                    else if (bump_right & ground)  // bumping right on the ground will make the Lemming walk left\n                        state <= WALK_LEFT;\n                end\n                \n                FALLING: begin\n                    walk_left <= 1'b0;\n                    walk_right <= 1'b0;\n                    aaah <= 1'b1; // let it fall :P\n                    digging <= 1'b0;\n                    fallCounter <= fallCounter - 1;\n                     if (fallCounter==0 | ground) begin  // If Lemming has been falling for more than 20 cycles or hit the ground. Splatter and stop walking, falling, and digging\n                        state <= WALK_LEFT;\n                        aaah <= 1'b0;\n                    end\n                end\n            endcase\n        end     \n\tend\nendmodule\n\n"}
{"task_id": "lemmings4", "completion": "\n//Declare state type as enum\n    typedef enum logic[3:0] {walking = 4'b0001, falling = 4'b0010, ddig =  4'b0100, splat= 4'b1000} state_t; \n    \n//Declare current and next states.\n\tstate_t curr_state, next_state;\n\n\t// Synchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            curr_state <= walking; // default to walk left on reset\n        else \n            curr_state <= next_state; // otherwise transition to next state\n    end\n\t\n\t// Next State Logic\n\talways @(*) begin\n\t\tcase(curr_state)\n\t\t\twalking: begin\n\t\t\t\tif (ground && !dig)\n\t\t\t\t\tnext_state = walking; // keep walking if there's ground but not digging. \n\t\t\t\telse if ((bump_left || bump_right) && ground)\n\t\t\t\t\tnext_state = falling; // fall if you hit something on the ground.\n                else if (dig && ground)\n                    next_state = ddig; // start digging while grounded\n\t\t\t\telse \n\t\t\t\t\tnext_state = splat; // Splatter if bumped during fall for too long or while falling\n\t\t\tend\n\t\t\tfalling: begin\n                if (!ground)\n                    next_state = walking; // continue walking until hit ground.\n                else if (dig && !bump_left && !bump_right) \n                    next_state = ddig; // start digging while falling\n\t\t\t\telse \n\t\t\t\t\tnext_state = splat; // Splatter if bumped during fall for too long or while grounded. \n\t\t\tend\n            ddig: begin \n                if (!ground)\n                    next_state = walking; // continue walking until hit ground, can only happen after dig\n\t\t\t\telse if ((bump_left || bump_right) && !dig)  \n\t\t\t\t\tnext_state = falling; // fall and stop digging if hit something on the ground or start to dig.\n                else \n                    next_state = ddig; \n\t\t\tend\n            splat: begin \n\t\t\t\t//Lemming has been splatted, remain in same state until reset\n                next_state = splat; \n\t\t\tend  \n         endcase\n     end       \n    // Output Logic - Use case statement to assign outputs based on current state.\n    always @(*) begin\n            {walk_left, walk_right, aaah, digging} = 4'b0000; \n          \tcase (curr_state) \n\t\t\t\twalking:  \t{walk_left, walk_right } = ground ? 2'b10 : 2'b00; //If on the ground move in direction of bump else idle\n                falling:   {walk_left, walk_right, aaah} = ground ? (dig ? {1'b0, 1'b0, 1'b1}:{1'b0, 1'b1, 1'b0}) : {2'b01,1'b0}; //If on the ground move in direction of bump else idle and say aaah\n                ddig:  \t{walk_left, walk_right, digging} = ground ? ({1'b0, 1'b1, 1'b0}) : {2'b01, 1'b0}; //If on the ground move in direction of bump else idle and continue to dig\n                splat:    4'b0000; //Splatted state remains idle.     \n            endcase\n        end   \nendmodule  \t\n"}
{"task_id": "lemmings4", "completion": "\nreg [18:0] count; // 20 bit counter to keep track of how many clock cycles since falling\n\nparameter WALK_LEFT = 4'b0001, \n          WALK_RIGHT = 4'b0010, \n          FALLING = 4'b0100;\n          \nreg [3:0] state; // current state of the Lemming machine\n\t\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        count <= 20'd0;\n\t    state <= WALK_LEFT;\n    end else case (state) \n    \n    // walk left/right states\n\tWALK_LEFT: begin\n            count <= 20'd0;\n\t\t\tif ((bump_left & ~ground & ~dig) | dig) begin\n\t\t\t    state <= WALK_RIGHT;\n\t\t\tend else if (bump_right & ground & ~dig) begin \n                state <= FALLING; // fall only if hit right bump and there is ground and not dug yet\n            end\n\t    end \n    \n        WALK_RIGHT: begin \n\t\t\tif ((bump_left & ~ground & ~dig) | dig) begin \n\t\t\t    state <= WALK_LEFT;\n\t        end else if (bump_right & ground & ~dig) begin \n                state <= FALLING; // fall only if hit right bump and there is ground and not dug yet\n            end\n\t\tend \n        \n        // falling state    \n\t    FALLING: begin \n\t\t\tif (~bump_left & ~bump_right & ground) begin \n\t\t\t    count <= 20'd0;\n                state <= WALK_LEFT; // start walking again after hitting the ground, switch to walk left direction\n            end else if(count >= 20'd20)begin // when falling for more than 20 clocks then hits the ground\n\t\t\t    count <= 20'd0;  \n                state <= 4'b0000;  // splatter, all outputs become 0\n            end else begin \n\t\t        count <= count + 1; // increment counter if Lemming is still falling and not hitting ground yet\n\t\t\tend     \n\t\tend         \n    endcase\nend    \n      \nassign walk_left = (state == WALK_LEFT);  \nassign walk_right = (state == WALK_RIGHT); \nassign aaah = (count < 20'd20 & count > 0); // \"aaah\" output is active for the duration between falling and hitting ground, so when counter from fall state reaches less than 20 clock cycles but greater than zero.\nassign digging = ~(state == WALK_LEFT | state == WALK_RIGHT | state == FALLING); // when Lemming is in the process of dugging it will be active until other states occur.\nendmodule \n"}
{"task_id": "lemmings4", "completion": "\n\treg state; \t//0 for right and 1 for left direction\n    reg [21:0] counter = 22'b0; //counter to count falling cycles.\n\talways @(posedge clk or posedge areset) begin \n        if (areset == 1) begin\n            state <= 1'b1;\n            walk_left <= 1'b1;\n\t\t\twalk_right <= 1'b0;\n\t\t    aaah <= 1'b0;\n\t\t    digging <= 1'b0;\n        end \n        else if (ground == 1 && state == '0) begin //if falling and ground is there, reset the counter.\n            counter <=  22'b0;\n\t\tend\n\t    else if(~|counter[21:0] && ground==0 )begin//falling for more than 20 cycles.\n\t\t    walk_left <= 1'b0;\n\t\t    walk_right <= 1'b0;\n\t\t    aaah<= 1'b1 ;\n            digging <= 1'b0;\n        end  \t\n\t    else if (ground == 1) begin//if ground is there, reset the counter. \n\t        counter <=  22'b0;\n            walk_left <= state;\n\t\t    walk_right <= ~state ;\n\t\t    aaah<= 1'b0 ;\n            digging <= 1'b0;\n        end \t\t\t\n\t    else if (dig == 1 && ground==1) begin//start digging.\n            counter <=  22'b0;\n            walk_left <= 1'b0;\n\t\t    walk_right <= 1'b0;\n\t\t    aaah<= 1'b0 ;\n            digging <= 1'b1;\n\t    end \t\t\t\n        else if (counter < 22'd20) begin //if not yet falling, just count.\n\t        counter <= counter + 1;  \t\n    \tend\n\t\telse if(bump_left == 1 && ground==1)begin//when bumped on left and is walking.\n\t\t    state <= 1'b1; \n        end \t\t\t\n\t    else if (bump_right == 1 && ground==1) begin// when bumped on right and is walking.\n\t        state <= 1'b0;  \t\n        end \t\t\t\t\n    end\t\nendmodule\n"}
{"task_id": "lemmings4", "completion": "\n    reg [19:0] timer = 20'd0; // Timer to count the falling cycles\n\treg falling = 1'b0;       // Falling signal \n    \n    localparam IDLE_L =  3'b000, LEFT  =  3'b001, RIGHT = 3'b010, DIG   =  3'b100;\n\tlocalparam FALL_L = 3'b101,  FALL_R = 3'b110 ;       // State to handle falling case\n    \n    reg [2:0] state = LEFT;         // Default state is walk left\n    \n    wire canFall = ~ground & (timer < 20'd20);   // Condition to check if Lemming can fall \n\twire canDig = ground & ~falling ;               // Condition to check if Lemming can dig\n\t \n\t// Next State Logic and Output Decode\t \n    always @(posedge clk or posedge areset) begin    \n        if (areset) begin\n            state <= LEFT;  // Async reset, return to walk left when pressed\n\t\t\ttimer <= 20'd0;   // Reset timer\n        end\n\t\telse if ((bump_left | bump_right) & canFall ) begin \n\t\t\tif (state == LEFT)    state <= FALL_L ;       // If walk left and bumped, fall left. \n\t\t\telse                state <= FALL_R ;       // Else fall right. \n\t\t\t falling <= 1'b1;        // Set Falling signal to high  \n\t\t\t timer   <= 20'd0;     // Reset Timer for falling cycle count\n\t\tend\n        else if( dig & canDig) begin                 state <= DIG ;    // If can dig, go into Digging State. \n\t\t\ttimer <= 20'd0;   // reset timer while digging\n\t\t\t falling<= 1'b0;          // Reset Falling Signal to low for not falling while dig\n\t\tend\n        else if( bump_left) begin                   state <= RIGHT ;  // If can walk, go into walk right state. \n\t\t\ttimer <= 20'd0;   // reset timer when bumped on left\n\t\t\t falling<= 1'b0;          // Reset Falling signal to low for not falling while walking\n\t\tend\n        else if( bump_right) begin                 state <= LEFT ;   // If can walk, go into walk right state. \n\t\t\ttimer <= 20'd0;    // reset timer when bumped on right\n\t\t\t falling<= 1'b0;          // Reset Falling signal to low for not falling while walking\n\t\tend      \n        else if(ground & ~falling) begin             state <= LEFT ;   // If ground is there and Lemming is not falling, then keep walk left. \n\t\t\ttimer <= 20'd0;    // reset timer when hit the ground\n\t\t\t falling<= 1'b0;           // Reset Falling signal to low for not falling while walking\n\t\tend      \n        else begin                                state <= LEFT ;   // If no condition met, keep walk left. \n\t\t\ttimer <= timer+2'd1;    // Count the cycles when Lemming is not bumping or digging\n\t\t\t falling<= 1'b0;           // Reset Falling signal to low for not falling while walking\n\t\tend       \n\t end\n    \n    assign walk_left = (state == LEFT) | (falling & ~(bump_right));\n\tassign walk_right= (state == RIGHT )|( falling&~(bump_left)) ;  // If Falling, we can't move in the opposite direction.\n    assign aaah = falling;               \n\tassign digging = (state==DIG);           \nendmodule  \n"}
{"task_id": "lemmings4", "completion": " \n    reg [5:0] state;\n    parameter WALK_LEFT = 6'h3F, // all bits on\n              WALK_RIGHT = 6'hBF,// bit 1 and bit 2 are on\n\t\t\t  FALLING = 6'h7E;   // bit 0 is on\n\talways @(posedge clk or posedge areset) begin\n        if (areset == 1) state <= WALK_LEFT;\n        else case(state)\n            WALK_LEFT:  if (bump_right) state <= WALK_RIGHT;   // turn right\n                        else if (ground && dig) state <= FALLING;// fall and start digging\n                        else if (dig) state <= FALLING;        // just start diging\n            WALK_RIGHT: if (bump_left)  state <= WALK_LEFT;    // turn left\n                        else if (ground && dig) state <= FALLING;// fall and start digging\n                        else if(dig) state <= FALLING;          // just start diging\n            default:     state <= FALLING;                      // any other state, falling starts\n        endcase\n    end\n\tassign walk_left = (state == WALK_LEFT);\n    assign walk_right =(state==WALK_RIGHT);\n\tassign aaah=((state[0] == 1'b1)? 1:0);// falling state is represented by bit 0 so we check this bit to get \"aaah\" signal.\n\tassign digging= (dig && ground) || (state == FALLING); //Lemmings can start dig only when on the ground or falling, if \"dig\" input comes high and Lemming is either on the ground or falling\nendmodule\n"}
{"task_id": "lemmings4", "completion": "\ntypedef enum logic [2:0] {S1 = 3'b000, S2 = 3'b001, S3 = 3'b010, S4 = 3'b011, S5 = 3'b100} state_type;\n\tstate_type current_state, next_state;\n\treg falling_detected; // used to keep track if Lemming started falling.\n\tinteger fall_counter; // count the falling time in cycles.\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) \n\t\t\tcurrent_state <= S1;\t// Reset state machine to default start state S1.\n        else \n\t\t\tcurrent_state <= next_state; // Transition from current state to next state on every clock cycle.\n    end\n    \n    always @(*) begin\n\tcase (current_state)\n\tS1: begin\t// Lemming is walking left\n\t    walk_left = 1'b1;\n\t    walk_right = 1'b0;\n\t    aaah = 1'b0; \n        digging = 1'b0;\n\t\tif(ground == 1'b0) falling_detected <= 1; // If Lemming hit the ground, start to fall.\n\t\telse if ((bump_left == 1'b1) || (bump_right == 1'b1)) next_state <= S2; \t// Switch direction when bumped left or right.\n        else next_state = S1; // No change in state, remain walking left.\n\tend\n    S2: begin\t// Lemming is falling.\n\t    walk_left = 1'b0;\n\t    walk_right = 1'b0;\n\t    aaah = 1'b1; \n        digging = 1'b0;\n\t\tif (ground == 1'b1) next_state <= S3; // If Lemming hit ground, start walking in same direction.\n        else if(fall_counter > 20) next_state = S5;\t// If fall time is more than 20 cycles, then splatter and stop all activities.\n\t\telse next_state = S2;\n    end\n\tS3: begin // Lemming is walking right.\n\t    walk_left = 1'b0;\n        walk_right = 1'b1;\n\t\taaah = 1'b0; \n        digging = 1'b0;\n\t    if (ground == 1'b0) falling_detected <= 1; // If Lemming hit the ground, start to fall.\n        else if ((bump_left == 1'b1) ||( bump_right == 1'b1)) next_state <= S4; \t// Switch direction when bumped left or right.\n\t\telse next_state = S3; // No change in state, remain walking right.\n    end\n\tS4: begin // Lemming is falling and digging.\n\t    walk_left = 1'b0;\n        walk_right = 1'b0;\n\t\taaah = 1'b1; \n        digging = 1'b1;\n\t\tif (ground == 1'b1) next_state <= S5; // If Lemming hit ground, start walking in same direction.\n        else if(fall_counter > 20) next_state = S5;\t// If fall time is more than 20 cycles, then splatter and stop all activities.\n\t\telse next_state = S4;\n    end\n    S5: begin // Lemming is in splattered state (stopped).\n\t    walk_left = 1'b0;\n        walk_right = 1'b0;\n\t\taaah = 1'b0; \n        digging = 1'b0;\n\t\t// Stay in this stopped state, until reset. No other transition is possible now.\n    end  \n\tendcase\n\tif (falling_detected == 1) fall_counter <= fall_counter + 1; // Increase the fall counter if Lemming started falling.\n\telse fall_counter <= 0; \t// If Lemming didn't start falling, reset the fall counter to zero.\n    end\t  \nendmodule\n"}
{"task_id": "lemmings4", "completion": "\n\treg [5:0] state = 6'b001_000;  // Initial state is walk left and not falling/digging.\n\n\t// Synchronous reset\n\talways @(posedge areset)\n\t    state <= 6'b001_000;  \n\n\talways @(posedge clk) begin\n\t\t case (state)\n\t\t\t 6'b001_000: if(ground & ~dig) // If ground is present and not digging, keep walking.\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif(~bump_left & bump_right)     // Change direction to right if bumped on the right side. \n\t\t\t\t\t\t    state <= 6'b100_000;   // Walking right\n\t\t\t\t\t\telse if (bump_left & ~bump_right)// Change direction to left if bumped on the left side. \n\t\t\t\t\t\t\tstate <= 6'b010_000;  // Walking left\n\t\t\t\t\tend    \t\t   \n\t\t\t   else state <= {ground,dig,2'b10};         // If not ground and digging, start digging (not falling)\n\t\t\t 6'b010_000: if(~ground | dig) state <= 6'b001_001;  // Falling/digging state if no ground or still digging.\n\t\t\t   else state <= 6'b010_100;           // Changing direction to right if bumped on the left side while falling/digging.\n\t\t\t 6'b100_000: if(~ground | dig) state <= 6'b001_101;  // Falling/digging state if no ground or still digging.  \n\t\t\t   else state <= 6'b100_100;          // Changing direction to left if bumped on the right side while falling/digging.\n\t\tendcase    \t\t   \t     \t   \t      \n  end     \n\n\t// Output decoding\n\tassign {walk_left, walk_right, aaah, digging} = state[5:0];   // Assign respective outputs based on the current state.\n\n\t// Splatter condition (aaah is set after 20 clock cycles)\n\tif(state == 6'b010_001 || state == 6'b010_101 || state == 6'b100_001 || state == 6'b100_101) begin\n\t    aaah <= 1;   // When falling for 20 clock cycles.\n\tend\n\telse aaah <= 0;   // Otherwise, no \"aaah\" sound. \n\t\t      \t     \nendmodule\n"}
{"task_id": "lemmings4", "completion": "\n\treg [2:0] state = 3'b01; // default to left walking\n\treg falling=0, falling_count=0; \n\tparameter MAX_FALLING_COUNT=20;\n\n\t// State transitions and output decoding\n\talways @(posedge clk or posedge areset) begin\n\t  if (areset) begin\n\t    state <= 3'b01; // reset to walk left\n\t    falling <= 0;\n      falling_count <= 0;\n    end else \n    case (state)  \n      3'b01: begin // walk left\n        if(bump_right | ground & ~dig) state <= 3'b10; // bumped on the right or ground and not digging -> walk right next cycle\n      end\n      3'b10: begin  // walk right\n        if (bump_left | ground & ~dig ) state <= 3'b01; // bumped on the left or ground and not digging -> walk left next cycle\n      end    \n    endcase\n\tend\n\n\t// Falling mechanic\n\tif(falling) begin \n\t  falling_count <= falling_count + 1;\n   if (falling_count == MAX_FALLING_COUNT) state <= 3'b00; // splatter after x cycles\n\t end\n\telse if(!ground & ~dig) falling <= 1; // start falling when not ground and not digging\n\telse if(ground & dig & (state == 3'b10 | state==3'b01)) falling_count <=0; // reset fall count when ground is back and lemming started to walk \n\t\n\t// Output decoding\n\tassign walk_left  = state[1];\n\tassign walk_right = ~state[1] & ~state[0];\n\tassign aaah = falling;\n\tassign digging = (dig | ground) & ~falling;\nendmodule\n\n"}
{"task_id": "lemmings4", "completion": "\n\treg walk_left_next;\n        reg walk_right_next;\n        reg [5:0] state;\n        parameter WALKLEFT = 6'b100000, \n                  WALKRIGHT= 6'b010000,\n                  FALLING  = 6'b001000, \n                  DIGGING  = 6'b000100;\n        parameter [5:0] MAX_FALL = 20;\n        \n        always @(posedge clk or posedge areset) begin\n            if (areset) begin\n                state <= WALKLEFT;\n            end\n             else begin\n                 case (state)\n                    WALKLEFT: begin  // walking left\n                        walk_left <= 1'b1;\n                        walk_right <= 1'b0;\n                        if(dig && ground )begin\n                            state <= DIGGING;\n                        end\n                         else if ((bump_right | bump_left) && ground) begin  // switch direction if hit on the side or falling down\n                            state <= FALLING;\n                        end\n                    end\n                     WALKRIGHT:begin  // walking right\n                        walk_left <= 1'b0;\n                        walk_right <= 1'b1;\n                         if (dig && ground) begin\n                             state <= DIGGING;\n                         end \n                          else if ((bump_right | bump_left )&& ground)begin  // switch direction if hit on the side or falling down\n                            state<=FALLING;\n                        end\n                     end  \n                    FALLING: begin    //falling\n                        walk_left <= 1'b0;\n                        walk_right <= 1'b0;\n                         aaah <= 1'b1;  //make Lemming say \"aaah!\" when falling\n                        if (ground)begin  // when ground is back, resume previous state\n                            state <=(dig)? DIGGING :((bump_left )? WALKLEFT:WALKRIGHT);\n                            aaah <= 1'b0;    //stop saying \"aaah!\" after falling\n                        end \n                    end  \n                      DIGGING: begin  //digging\n                         walk_left <=1'b1;// keep the direction of digging when bumped or ground changes.\n                          walk_right<=1'b0;\n                         digging <= 1'b1;    //lemming is digging\n                        if (ground == 0 || (bump_left | bump_right ))begin  // end the dig and fall down when ground disappears or lemming gets hit.\n                            state <= FALLING;   // switch to falling state\n                            digging <= 1'b0;    // stop digging\n                        end       \n                    end                    \n                endcase              \n            end\n       end        \nendmodule\n\n"}
{"task_id": "lemmings4", "completion": "\n\ttypedef enum {WalkLeft, WalkRight, Falling} State;\n\tState next_state;\n\treg falling_count; // To count the falling time\n\talways @(posedge clk) begin\n\t\tif (areset) \n\t\t\tfalling_count <= 0;\n\t\t\t\n\t\tcase (next_state)\n\t\t\tWalkLeft:   if (bump_left && !ground || dig && ground) next_state <= Falling; else if (!ground && falling_count >= 20) next_state <= Falling; \n\t\t\tWalkRight:  if (bump_right && !ground || dig && ground) begin falling_count <= 0; next_state <= Falling; end else if (!ground && falling_count >= 20) next_state <= Falling;\n\t\t\tFalling:    if (ground) begin falling_count <= 0; if (bump_left || bump_right || dig ) next_state <= WalkLeft; end  // After landing, return to walking state if there's a trigger or the ground is back.\n\t\tendcase\n\t\t// Output assignments\n\t\tif (!areset) begin\n\t\t\tcase (next_state)\n\t\t\t\tWalkLeft:   {walk_left, walk_right} <= 2'b10; // 10 means walking left\n\t\t\t\tWalkRight:  {walk_left, walk_right} <= 2'b01; // 01 means walking right\n\t\t\t\tFalling:    {walk_left, walk_right} <= 2'b00; aaah <= 1; digging <= dig & ground; // No movement while falling. Aaah is active and also continue to dig if on the ground.\n\t\t\tendcase \n\t\tend else begin\n\t\t\t// Asynchronous resetting of all outputs to avoid metastability in case of asynchronous resets.\n\t\t\t{walk_left, walk_right, aaah, digging} <= 4'b1000; // initial state: walk left and no sounds or action.\n\t\tend \n\tif (areset) falling_count <= 0; else if (!ground && next_state == WalkLeft || !ground && next_state == WalkRight ) falling_count <= falling_count + 1'b1;   // Counting falling time while not on ground and walking.\n\tend\nendmodule\n\n"}
{"task_id": "lemmings4", "completion": "\nenum {LEFT=2'b01, RIGHT=2'b10} direction;\nreg [1:0] state, next_state;\ninteger fallen;\n\nalways @(posedge clk)  begin\n    if (areset) begin\n        state <= LEFT;\n\tfallen <= 0;\n    end else if(fallen < 20 ) begin  // count how long Lemming has fallen.\n      fallen <= fallen + 1 ;  \n      walk_left<= state[0];\n      walk_right<= state[1];\n      aaah<=  (state==LEFT && bump_right) || (state==RIGHT && bump_left);  // if it is falling and hit ground.\n     end else begin   // Lemming has fall for more than 20 clock cycle, so it splatted.\n\twalk_left<= 1'b0;\n        walk_right<=1'b0;\n\taaah <= 1'b0;\n\tdigging <=1'b0 ;\n     end   \nend\n\nalways @(*) begin  // next state logic, Moore FSM.\n\tif((state==RIGHT && ground)|| (state==LEFT && ground))begin  \n\t    if(bump_left || bump_right )next_state<=(bump_right)? RIGHT: LEFT;\n\telse\n\t     next_state <= state ;  // no change in direction.\n    end else begin      \n      next_state = (dig) ? state : ((state == RIGHT && bump_left)||(state ==LEFT&&bump_right))? (state==RIGHT)? LEFT: RIGHT :state; //change of direction if dig is pressed or hit the bumped wall.\n    end\nend    \t   \n\nalways @(posedge clk ) begin\n   fallen <= 0 ; \n   state <= next_state;\n   if((state ==RIGHT || state==LEFT) && ground) aaah<=1'b0; // Lemming has hit the ground and now not falling, so say \"\"aaah!\"\".\nend\ndigging <= (state == LEFT && bump_left )||(state == RIGHT&&  bump_right);\nendmodule\n"}
{"task_id": "lemmings4", "completion": "\n\treg [5:0] state;\n\tparameter [2:0] WALKLEFT=3'b001, WALKRIGHT=3'b010, FALL=3'b100;\n\tparameter [2:0] DIGGING=3'b011, SPLATTER=3'b111;\n\treg falling_counter; // Counter to count how many clock cycles a Lemming has been in the fall state\n\n\t// Reset synchronous\n\talways @(posedge clk or posedge areset) begin \n\t\tif (areset)\n\t\t\tstate <= WALKLEFT;\n\tend\n\n\t// State Machine Transitions\n\talways @(posedge clk) begin\n\t\tcase (state)\n\t\t\tWALKLEFT: if (bump_right | falling_counter >= 20) state <= FALL; \n\t\t\t\telse if ((ground & ~dig) | bump_left) state <= WALKRIGHT;  \n\t\t\t\t     else if(dig) state <= DIGGING; \n\t\t\tWALKRIGHT:if (bump_left | falling_counter >= 20) state <= FALL;\n\t\t\t\telse if ((ground & ~dig) | bump_right) state <= WALKLEFT;  \n\t\t\t\t     else if(dig) state <= DIGGING; \n\t\t\tFALL: begin falling_counter <= falling_counter + 1'b1;\n\t\t\t\tif (ground) state <= state; // Continue fall state until ground comes back on\n\t\t   \t\telse state <= WALKLEFT; // When ground reappears, assume bumped left and walk left \n\t   \t  \tend \n\t\t\tDIGGING: if(~ground | bump_left | bump_right) state <= FALL;  \n\t\t\t\telse if (dig & ground )state<=WALKLEFT; // Continue digging until the other side is reached and then fall \n\t   \t \t// If spatter condition, go to splatter state directly\n\t\t\tSPLATTER: ;// State remains in splat. No need to do anything as it will remain same till reset signal comes\n\t\tendcase\n\tend\n\n\t// Output Decoding\n\tassign walk_left = (state == WALKLEFT);\n\tassign walk_right = (state == WALKRIGHT);\n\tassign aaah = falling_counter >= 20; // A Lemming will fall for 21 clock cycles before saying \"aaah\"\n\tassign digging = (state == DIGGING);\nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "    \n    localparam PATTERN = 4'b1101;\n\treg [3:0] state_reg = 4'h0, state_next;\n\treg [2:0] bit_count; // count the bits of pattern to be detected\n\twire data_sync;     // synchronized version of data\n\n\t// State machine: patterns and transitions.\n\talways @(posedge clk, posedge reset) begin\n\t    if (reset)\n\t\t    state_reg <= 4'h0;\n\t\telse \n            state_reg <= state_next;\n\tend\n\talways @(*) begin\n        data_sync = data; // can remove it for synchronous version\n\t    shift_ena = 1'b0; \n\t\tcase (state_reg)\n\t\t    4'h0: begin             \n                if (data == PATTERN[3]) state_next = 4'h1;  \n\t\t\t\telse state_next = state_reg;        \n            end                      \n            4'h1: begin             \n                if (data == PATTERN[2]) state_next = 4'h2; \n\t\t\t    else state_next = state_reg;         \n            end                     \n\t\t    4'h2: begin             \n                if (data == PATTERN[1]) state_next = 4'h3;  \n\t\t\t\telse state_next = state_reg;        \n            end                      \n            4'h3: begin             \n                if (data == PATTERN[0]) begin \n\t\t\t\t    shift_ena = 1'b1;     // assert for 4 clock cycles\n                    bit_count <= 3'd3;  \n\t\t\t\t\tstate_next = 4'h7; \n\t\t\t\tend\n\t\t\t\telse state_next = state_reg;        \n            end                      \n\t\t    4'h7: begin              \n                if (bit_count == 0) begin\n                    counting = 1'b1;    // start counting\n\t\t\t\t\tif(done_counting) begin \n                        done = 1'b1;      // notify the user\n\t\t\t\t\t\tstate_next = bit_count > 0 ? state_reg : 4'h8;  \n                    end else begin\n                        state_next = state_reg;    \n\t\t\t\t    end             \n                end else begin        \n                    bit_count <= bit_count - 1; // shift in the next bit of pattern to detect\n\t\t\t        counting = 1'b0;     \n                    done = 1'b0;         \n                    state_next = state_reg;  \n\t\t\t\tend           \n\t\t    end                      \n\t\t    4'h8: begin              \n                if (ack) begin  // wait for user to acknowledge the timer\n\t\t\t\t\tstate_next = 4'h0;      // reset to initial state, start searching for next pattern\n                end else state_next = state_reg;   \n            end                      \n\t\t    default: state_next = state_reg;    \n        endcase \n    end      \nendmodule\n"}
{"task_id": "review2015_fsm", "completion": " \n\treg [3:0] pattern;\n\tparameter PATTERN = 4'b1101;\n\ttypedef enum {IDLE, SHIFT, COUNT} state_t;\n\tstate_t state;\n\t\n\talways @(posedge clk or posedge reset) begin\n    if (reset) \n        state <= IDLE;\n    else\n    \tcase (state)\n        \tIDLE:  \tif (pattern == PATTERN) \n                \t\tstate <= SHIFT;\n            \t\telse \n                \t\tstate <= IDLE;\n         \tSHIFT:\tif (!shift_ena) begin\n                 \t\t\tshift_ena <= 1'b1;\n                    \t\tcounting <= 1'b0;\n               \t \tend else state <= COUNT;\n        \tCOUNT:  if (done_counting) begin\n                \t\tstate <= IDLE;\n\t\t\t\t    \t\tshift_ena <= 1'b0;\n                  \t\tdone <= 1'b1;\n\t\t\t        end else state <= COUNT;\n\t\t    default: state <= IDLE;\n      \tendcase\n      if (ack) \n         done <= 1'b0;\n\tend\n    \n\talways @(posedge clk or posedge reset) begin\n    if (reset)\n        pattern <= 4'b0;\n    else if (!shift_ena || state == COUNT )\n       pattern <= {pattern[2:0], data};\n  end\nendmodule\n\n"}
{"task_id": "review2015_fsm", "completion": "\n    \n\treg [3:0] state;\n\tparameter PATTERN = 4'b1101;\n\treg [3:0] received_data;\n\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t    state <= 4'd0;\n        else case (state)\n            4'd0 : if (~data) \n                        state <= state + 1; // idle and looking for the start pattern\n                    else state <= state;\n\t\t\t    4'd1 : if (data == PATTERN[3]) begin \n                            received_data <= {received_data[2:0], data};\n                            state <= state + 1;\n                        end  \n\t\t            else if(~data)begin\n                            state <= 4'd1; // still looking for the start pattern, but found something different so reset and look again.\n                        end \n                    else state <= state ; \n\t\t\t    4'd2 : begin \n                            shift_ena <= 1; // asserted for four clock cycles to shift in the duration data\n                            state <= state + 1;\n                        end  \n\t\t\t    4'd3 : begin \n                            counting <= 1; // start of count down\n                            state <= state + 1;\n                            shift_ena <= 0; // de-asserting shift_ena so no more shifting can happen till done_counting goes high.\n                        end  \n\t\t\t    4'd4 : if (done_counting) begin \n                            counting <= 0 ; // stop the count down as it is finished\n                            state <= state + 1;\n                        end  \n\t\t            else state <= state; \n                    4'd5: if(ack)begin\n                          done <= 1;// asserting done to notify user of timeout.\n                          state<=0; //back to initial state so it can start searching for the next occurrence of the start sequence (1101).\n                        end\n                    else begin \n                          state <=state ; //wait till ack is high, then go back to idle stage\n                      end  \t                    \n                default: state <= 4'd0;   \t\t\t//default state set back to initial\n            endcase    \t\t\t\t        \t                \t\t\t        \n        end\t            \t                        \t                   \t   \t       \nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "\n\treg [3:0] pattern;\n\tparameter PATTERN = 4'b1101;\n\ttypedef enum {IDLE, SHIFTING, COUNTING} state_t;\n\tstate_t state;\n  \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tpattern <= 4'b0;\n\t\t\tshift_ena <= 1'b0;\n\t\t\tcounting <= 1'b0;\n\t\t\tdone <= 1'b0;\n\t\t\tstate <= IDLE;\n\t\tend \n\t\telse case(state)\n\t\t\tIDLE: begin\n\t\t\t\tpattern <= {data, pattern[3:1]};\n\t\t\t\tif (pattern == PATTERN) begin\n\t\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\t\tcounting <= 1'b0;\n\t\t\t\t\tdone <= 1'b0;\n\t\t\t\t\tstate <= SHIFTING;\n\t\t\t\tend \n\t\t\tend\n\t\t\tSHIFTING: begin\n\t\t\t\tif (ack) begin // Wait for ack\n\t\t\t\t\tshift_ena <= 1'b0;\n\t\t\t\t\tcounting <= 1'b1;\n\t\t\t\t\tdone <= 1'b0;\n\t\t\t\t\tstate <= COUNTING;\n\t\t\t\tend \n\t\t\tend\n\t\t\tCOUNTING: begin\n\t\t\t\tif (done_counting) begin // Wait for counters to finish\n\t\t\t\t\tshift_ena <= 1'b0;\n\t\t\t\t\tcounting <= 1'b0;\n\t\t\t\t\tdone <= 1'b1;\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\tend \n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "review2015_fsm", "completion": "\nreg [3:0] pattern;\nreg [1:0] state;\nparameter IDLE = 2'd0, PATTERN = 2'd1, COUNTING = 2'd2, DONE = 2'd3; \n    \nalways @(posedge clk or posedge reset) begin  \n    if (reset) begin\n        shift_ena <= 0;\n        counting <= 0;\n        done <= 0;\n\t    pattern <= 4'b0;        \n        state <= IDLE; \n\tend else begin  \n    \tcase(state)\n\t\t\tIDLE: begin \n\t\t\t\tif (data == 1) \n\t\t\t\t\tpattern[3:0] <= {data, pattern[3:1]};\n                if (pattern==4'b1101) begin\n                    state <= PATTERN;  \n                    shift_ena <= 1;  \n                end   \n\t\t\tend        \n            PATTERN: \n\t\t\t\tif(shift_ena == 1)begin\n                \tstate <= COUNTING;\n                     counting <= 1;      \n              \t  end\n            COUNTING: begin         \n            \tif(done_counting==1) begin\n                   state<=DONE;\n                   done<= 1; \n                end     \n\t\t\tend        \n            DONE: begin    \n\t\t\t   if (ack == 1) begin\n                    shift_ena <= 0;   \n                    counting <= 0;      \n                    done <= 0;\n                    pattern <= 4'b0;\n                    state <= IDLE; \n                end else \n                    state<=DONE;        \n\t\t\tend\n            default: state <=IDLE;     \n    \tendcase\n    End  \nend\n"}
{"task_id": "review2015_fsm", "completion": "\n    \n\ttypedef enum {IDLE, SHIFT, COUNTING} state_t;\n\tstate_t state, next_state;\n    \n\t// Sequential Logic\n\talways @(posedge clk) begin\n\t    if (reset) \n\t\t    state <= IDLE;\n        else \n            state <= next_state;\n\tend\n\n\t// Combinational Logic\n\talways @(*) begin\n    \tcase (state)  \n        \tIDLE: if (data == 1) \n                \t    next_state = SHIFT;\n             \telse \n                    \tnext_state = IDLE;\n          \tSHIFT: if (&shift_ena==1)\n                 \t\tnext_state = COUNTING;\n               else\n                 \tnext_state = SHIFT;\n          COUNTING : if (done_counting == 1 ) \n                    \t    next_state = IDLE;  \n               \telse \n                     \tnext_state = COUNTING ;   \n        endcase\n        \n    \tcase (state)\n            IDLE: begin shift_ena = 0; counting = 0; done=0; end\n            SHIFT :begin if(data == 1 ) shift_ena = ~shift_ena & 4'b1111; counting = 0; done = 0 ; end\n             COUNTING: begin shift_ena = 0; counting = ~done_counting ; done = done_counting&ack;  end  \n            default :begin shift_ena = 0; counting = 0; done = 0; end\n      \tendcase\n    end    \nendmodule\n\n"}
{"task_id": "review2015_fsm", "completion": "\n    \n\treg [3:0] pattern = 4'b1101; // pattern to search for\n\treg [3:0] shift_register = 4'd0; \n\tinteger state = 0;\n    integer counter=0;\n            \n\talways @(posedge clk or posedge reset) begin\n\t    if (reset == 1) begin \n            state <= 0;\n\t\t\tshift_ena <= 0;\n\t        counting <= 0;\n\t        done <= 0;\n        end else case(state) \n\t\t\t2'b00: begin // waiting for pattern\n                shift_register <= {shift_register[2:0], data};\n                if (shift_register == pattern) begin\n                    state <= 1;\n                    counting <= 0;\n                end    \n            end\n            2'b01: begin // shifting in 4 more bits to determine duration, assert shift_ena for 4 clocks\n                if(counter < 4 )begin\n                     counter <= counter+1;\n\t                 shift_ena <= 1;  \n                end else begin\n                    state<=2;\n                    counting <= 1; // start counting\n                    counter <= 0;   \n                end    \n            end\n            2'b10: if(done_counting)begin \n                        state <=3 ;//wait for user to acknowlege after done_counting signal is high\n                     end     \n\t\t\t2'b11 : begin //timer has timed out, notify the user and wait for ack before resetting.\n                if(ack)begin\n                    state <= 0; \n                    done <=1; \n                 end  \n            end   \n        endcase\n\tend      \nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "\nlocalparam PATTERN = 4'b1101;  // The pattern to wait for\nlocalparam COUNT = 2;  // Number of clock cycles to shift when pattern detected\n\t\nreg [3:0] state, next_state;\nreg [3:0] data_reg;  // A register to capture the last 4 bits of input.\ninteger count_clk;  \n\t\t\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tstate <= 4'b0000;\n\telse \n\t\tstate <= next_state;\nend\n\n// Next state logic and output decoder\nalways @(*) begin\n\tcase(state) \n\t\t4'b0000: if (data_reg == PATTERN)\n\t\t\t\t\tnext_state <= 4'b0010; // Goto 'wait for ack' state after pattern detected.\n\t\t\t\telse \n\t\t\t\t\tnext_state <=  4'b0000; // Stay in current state if not yet detecting the sequence\n\t\t4'b0010: next_state <= 4'b0110; // Set shift enable for COUNT clock cycles then goto 'wait for done counting'.\n        4'b0110: if(done_counting) \n\t\t\t\t\tnext_state <= 4'b1010; // Goto 'notify user' state when done_counting is high.\n\t\t\t\telse\n\t\t\t\t\tnext_state <= 4'b0110; // Stay in current state if not yet counting.\n\t\t4'b1010: if(ack) \n\t\t\t\t\tnext_state <= 4'b1100; // Goto 'wait for reset' state when ack is high.\n\t\t\t\telse\n\t\t\t\t\tnext_state <= 4'b1010; // Stay in current state if not yet acknowledging.\n\t\t4'b1100: next_state <= 4'b0000; // Reset the state machine back to waiting for start sequence '1101'. \n\tendcase\n\t// Output decoder\n\tcase(state) \n\t\t4'b0000, 4'b1100: {shift_ena, counting} = 2'b00; // Not doing anything in idle or waiting for reset states.\n\t\t4'b0010: {shift_ena, counting} = 2'b01; // Enable shift during pattern detection.\n        4'b0110: {shift_ena, counting} = 2'b00; // Not shifting but allowing counters to finish counting. \n\t\t4'b1010: {shift_ena, counting, done} = {1'b0, 1'b0, 1'b1}; // Not enabling shift or counter and asserting 'done'. \n\tendcase  \nend\n\t\n// Capture the last four bits of input data asynchronously.\nalways @(posedge clk) begin\n    data_reg <= {data_reg[2:0], data}; \nend \n\nendmodule\n\n"}
{"task_id": "review2015_fsm", "completion": "\n\treg [3:0] state;\n\tparameter IDLE = 4'b0001, CHECKING = 4'b0010, SHIFTING = 4'b0100, WAITING = 4'b1000;\n    \n    always @(posedge clk or posedge reset) begin \n        if (reset == 1'b1)\n            state <= IDLE;\n        else\n            case (state)\n                IDLE:      if (data == 1'b1) state <= CHECKING;\n                CHECKING:  if (~data & data == 'b0) begin state <= SHIFTING; shift_ena <= 1'b1; end\n                            else state <= IDLE;\n                SHIFTING:  begin counting <= 1'b1; count_done = 1'b0; shift_ena <= 1'b0; if (count_done == 1'b1) state <= WAITING; end\n                WAITING:   if ((~data & data == 'b0)&(done_counting == 1'b1)) begin counting <= 1'b0; done <= 1'b1; state <= IDLE; end \n                            else if (ack == 1'b1) done <= 1'b0;\n            endcase        \n    end  \t    \nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "\n\treg [3:0] state = 4'b1111; // Start state. The sequence of 1101 must start from any state but here we choose to start from all ones.\n    \n    localparam START_SEQ  = 4'b1101,\n               SHIFT_STATE = (state + 1), //Next state\n\t\t       DONE        = 4'hE;  //E is a special number where 2 bits are not used to detect the pattern.\n    \n\talways @(posedge clk or posedge reset) begin\n        if(reset == 1'b1) //Active high synchronous reset.\n            state <= 4'b1111;  \n        else        \t\t\t//State transition.\n            case (state) \n                START_SEQ: state <= SHIFT_STATE;       //Shifted to next state when pattern is found\n                2'b000?: begin if(data == 1'b1) state <= 2'b0010; end //if data is high, we continue to count.\n                DONE: begin done <= 1'b1; if (ack == 1'b1) begin \tstate <= START_SEQ; done <= 1'b0; end end     //Timer finished and ack has gone high, so reset.\n            endcase   \t\t\t//End case\n            \n        //Setting outputs based on the state.\n         if(state == START_SEQ || state[2:1] == 2'b00)  counting <= 1'b0; else counting <=  1'b1;\n         \n         if((state != DONE && (data ^ state[3])==1'b1 )|| state == START_SEQ) begin shift_ena <= 1'b1; @(posedge clk) shift_ena<= 1'b0 ; end else shift_ena <=  1'b0 ;\n        \n\tend //End always.    \t\t \nendmodule  // End module top_module.   \n"}
{"task_id": "review2015_fsm", "completion": "    \n   reg [3:0] pattern;\n   parameter PATTERN = 4'b1101;\n   \n   typedef enum {IDLE, SHIFTING, WAIT_FOR_COUNTING, TIMER_DONE} state_type;\n   state_type state, next_state;\n    \n   //State transition logic\n   always @(posedge clk or posedge reset) begin\n       if (reset) \n           state <= IDLE;\n       else \n           state <= next_state;\n    end\n        \n    //Next-state logic and outputs logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                shift_ena = 1'b0;\n                counting  = 1'b0;\n                done      = 1'b0;\n                if (pattern == PATTERN) \n                    next_state = SHIFTING;\n                else \n                    next_state = IDLE;\n            end\n            \n            SHIFTING: begin\n                shift_ena = 1'b1;\n                counting  = 1'b0;\n                done      = 1'b0;\n                if (pattern == PATTERN) \n                    next_state = WAIT_FOR_COUNTING;\n                else \n                    next_state = IDLE;\n            end\n            \n            WAIT_FOR_COUNTING: begin\n                shift_ena = 1'b0;\n                counting  = 1'b1;\n                done      = 1'b0;\n                if (done_counting) \n                    next_state = TIMER_DONE;\n                else \n                    next_state = WAIT_FOR_COUNTING;\n            end\n            \n            TIMER_DONE: begin\n                shift_ena = 1'b0;\n                counting  = 1'b0;\n                done      = 1'b1;\n                if (ack) \n                    next_state = IDLE;\n                else \n                    next_state = TIMER_DONE;\n            end\n            \n            default: begin\n                shift_ena = 1'b0;\n                counting  = 1'b0;\n                done      = 1'b0;\n                next_state= IDLE;\n            end\n        endcase\n    end\n    \n    //Register to store pattern in\n    always @(posedge clk) begin \n      pattern <= {pattern[2:0], data};  \n    end\nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "\n\n   localparam IDLE = 4'b0001;\n   localparam PATTERN = 4'b0010;\n   localparam DELAY = 4'b0100;\n   localparam WAITING = 4'b1000;\n   \n   reg [3:0] state, next_state;\n   reg [2:0] data_shift_reg; // For storing 4 bits received from the data input\n\t\n\t// State transition\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n   \n   // Data shift register for detecting the pattern 1101\n   always @(posedge clk or posedge reset) begin\n      if (reset == 1'b1)\n         data_shift_reg <= 3'b000;\n      else\n         data_shift_reg <= {data, data_shift_reg[2:1]}; \n   end\n\t\n\t// Next State logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE : begin\n\t\t\t\tif (data_shift_reg == 3'b110) // Pattern found\n\t\t\t\t    next_state = PATTERN;\n\t\t\t\telse \n\t\t\t\t    next_state = IDLE;\n                shift_ena = 1'b0;\n                counting  = 1'b0;\n                done      = 1'b0;\n\t\t\tend\n          PATTERN : begin // Asserted for 4 clock cycles to shift in the duration bits\n               next_state = DELAY;\n\t\t\t      if (data == 1)\n                     shift_ena = 1'b1;\n               else\n                     shift_ena = 1'b0;\t\t  \n                counting = 1'b0;\t\n                done    = 1'b0;\t\n          end \n         DELAY : begin // Wait for the counters to finish and user acknowledgment\n\t\t\t      next_state = WAITING;\n               shift_ena = 1'b0;\t\t   \n               if (done_counting == 1) // Counters finished\n                     counting = 1'b0;\t    \n               else \n                     counting = 1'b1;\t  \t\n                done    = 1'b0;\t      \t     \n          end\n         WAITING : begin // Wait for user acknowledgment \n\t\t\t      next_state = (ack == 1) ? IDLE : WAITING; // If user ack is high, go back to idle state otherwise stay in this state\n               shift_ena = 1'b0;\t  \t\t   \n               counting  = 1'b0;\t    \n\t\t\t      if ((done_counting == 1) && (ack == 1)) begin // Counters finished and user acknowledged\n                     done = 1'b1;\t// Notify the user that the timer has timed out\n                end else \n                      done = 1'b0;\t\t  \t    \t     \n         end       \n\t\tendcase\n\tend\n   \nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "\n  localparam [3:0] IDLE = 4'b0001;\n  localparam [3:0] SEARCHING = 4'b0010;\n  localparam [3:0] SHIFTING = 4'b0100;\n  localparam [3:0] COUNTING = 4'b1000;\n  \n\treg [3:0] state = IDLE, next_state;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= IDLE;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n  \n\talways @(*) begin\n\t  shift_ena = 0;\n    counting = 0;\n    done = 0;\n\t\tcase (state) \n\t\t\tIDLE : if (data == 1)\n\t\t\t\t\t\t\tnext_state = SEARCHING;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext_state = IDLE;\n\t\t\tSEARCHING: if ({data, state[2:0]} == 4'b1101) begin\n                           next_state = SHIFTING;\n                        end else begin \n                           next_state = SEARCHING;\n                        end\n\t\t\tSHIFTING : shift_ena = 1; // Asserted for 4 clock cycles.\n            COUNTING: if (done_counting) begin\n                            counting = 1; // Indicates it is waiting on counters to finish.\n                            done = ~(ack); // Notifies user and waits until ack goes high before resetting state machine to idle.\n                            next_state = DONE;\n                        end else \n                           next_state = COUNTING;\n            DONE : if (ack) begin\n                          counting = 0; // Reset counters.\n                          done = 0;\n                          next_state = IDLE;\n                      end else begin \n                         counting = 1;\n                         done = 1;\n                         next_state = DONE;\n                       end\n\t\t\tdefault : next_state = state;\t\t\t    \n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "review2015_fsm", "completion": " \n\n    localparam [3:0] SEARCH = 4'b1101;\n    localparam [3:0] COUNTING = 4'b0000;\n    \n    reg [3:0] state, next_state;\n    wire [2:0] pattern = {data, state[3:1]};\n    \n\talways @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= SEARCH;\n        else \n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            SEARCH: begin\n                shift_ena = 0;\n                counting = 0;\n                done = 0;\n                if (pattern == SEARCH) begin\n                    next_state = COUNTING;\n                    shift_ena = 1;\n                end \n\t\t\t\telse\n\t\t\t\t\tnext_state = SEARCH;\n            end\n            \n            COUNTING: begin\n                counting = 1;\n                done = 0;\n                if (done_counting) begin\n                    next_state = SEARCH;\n                    shift_ena = 0;\n                    done = 1;\n\t\t\t\t\tif(ack) \n\t\t\t\t\t\tnext_state = SEARCH;\n                end \n\t\t\t\telse\n\t\t\t\t\tnext_state = COUNTING;\n            end\n            \n            default: begin\n                next_state = SEARCH;\n                shift_ena = 0;\n                counting = 0;\n                done = 0;\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "    \n    reg [3:0] pattern = 4'b1101; \n    reg [2:0] state = 3'd0; \n\treg [3:0] counter_data; \n\t \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'h1) begin\n            shift_ena <= 1'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            state <= 3'd0; \n        end else begin   \n            case (state)\n                3'd0: if(data == pattern[3]) state <= 3'd1;  // looking for first bit of pattern\n                3'd1: if(data == pattern[2]) state <= 3'd2;  // looking for second bit of pattern\n                3'd2: if(data == pattern[1]) state <= 3'd3;  // looking for third bit of pattern\n                3'd3: begin                                                  // found the pattern\n                    shift_ena <= 1'b1; // start shifting for next 4 bits (duration)\n\t\t\t\t\tstate <= 3'd4; // move to duration state\n                end\n\t\t\t\t3'd4: if(done_counting == 1'h1 && ack == 1'h0) begin           // waiting for counters and not yet acknowledged\n                    counting <= 1'b0; // stop the counter (assumed that done_counting goes high when it is actually finished)\n\t\t\t\t\tstate <= 3'd5; // move to acknowledge state\n\t\t\t    end\n                3'd5: if(ack == 1'h1) begin                                 // acknowledging \n                    done <= 1'b1; // notify the user that timer has timed out \n\t\t\t\t\tstate <= 3'd0; // reset and wait for next start sequence\n                end\n            default: state <= 3'd0; // if any other condition, go back to initial state\n\t\t    endcase\n\t    end\n\tend    \nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "  \ntypedef enum {IDLE, SHIFT, COUNTING} state_type;\nstate_type state;\nreg [3:0] shift_reg;\n\nalways @(posedge clk or posedge reset) begin \n    if (reset) \n        state <= IDLE;\n\telse case(state) \n\t\tIDLE:      \tif(data == 1 && shift_reg[0] == 1 && shift_reg[1] == 1) begin \n\t\t\t\t\t\t\tshift_reg <= 4'b1101;\n                            state <= SHIFT;\n                        end else begin \n                        \tshift_reg <= {shift_reg[2:0], data};\n                        end  \n        SHIFT:    \tif (&shift_reg) begin \n\t\t\t\t\t\t    shift_ena <= 1'b1;\n                            state <= COUNTING;\n                        end \t\t  \n\t\tCOUNTING: \tif(done_counting == 1) begin \n                        \tstate <= IDLE; \n                            done <= ~done;\n                        end else if (ack==1) begin\n\t\t\t\t\t\t    shift_ena <= 0;\n                            state <= IDLE;\n                        end \t\t  \n        default: \tstate <= IDLE;\t\t\t    \t\n\tendcase\t\t\t\t\t\t\t\t\t     \nend \nassign counting = (state == COUNTING);\t\n"}
{"task_id": "review2015_fsm", "completion": "\n   reg [3:0] state;\n   parameter IDLE = 4'b0001, PATTERN = 4'b0010, SHIFT = 4'b0100, COUNTING_WAIT = 4'b1000;\n   \n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n            state <= IDLE;\n        else\n            case (state) \n                IDLE: \n                    if(data)\n                        state <= PATTERN;\n                     else \n                         state <= IDLE;   \n                PATTERN: \n                    if(!data)\n                        state <= SHIFT;\n                     else \n                         state <= PATTERN;    \n                SHIFT: \n                    begin\n                       shift_ena <= 1'b1; // assert shift enable for four clock cycles  \n\t\t               @(posedge clk)\n\t\t               @(posedge clk)\n\t\t\t           @(posedge clk)\n\t\t\t           @(posedge clk)\n                       shift_ena <= 1'b0; \n                       state <= COUNTING_WAIT;    // transition to counting wait state.\n                    end    \n                COUNTING_WAIT: \n                     if(done_counting) begin       // wait until counters are done counting  \n                        state <= IDLE;          // and then go back to idle for the next timer\n                     \tend\n                     else\n                       state <= COUNTING_WAIT;    // stay in this state till counters finish their job \n            endcase        \n            \n\t    if (state == SHIFT) begin // assert counting output while we are shifting\n\t        counting <= 1'b1;  \n\t    end    \n        else if(state == COUNTING_WAIT ) begin\n\t\t    counting <= 1'b0;  // de-assert counting output when in the waiting state.\n\t\tend      \n        \n         if (ack & done) begin // upon acknowledgment of timer, reset to beginning state IDLE\n\t        state <= IDLE;  \n\t    end    \n        else if(state == COUNTING_WAIT )begin \n\t\t    if (done_counting)\n\t\t\t\tstate <= DONE ;  // go to done state once counters have finished counting\n\t       end     \n        \n        if ((state==COUNTING_WAIT) && done_counting) begin//assert done when both in the COUNTING_WAIT and done_counting is high \n            done <= 1'b1;  \n\t    end    \n        else if(ack )begin // de-assert done upon ack received.\n\t        done <= 1'b0;   \n\t       end     \n                \nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "\nreg [3:0] state; \t// FSM states\nparameter IDLE = 4'b0001, SHIFT = 4'b0010, WAIT = 4'b0100, NOTIFY = 4'b1000;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n        state <= IDLE;\t\t// Reset the FSM\n\telse case (state) \n\t\tIDLE:\tif (data) \n\t\t\t\t\tbegin\n\t\t\t\t\t\tshift_ena <= 0;\n                        counting <= 0;\n\t\t\t\t\t\tstate <= SHIFT;\n                    end\n\t\tSHIFT:\tif (!done_counting && shift_ena == 1'b1 )  \n                    begin\n                        state <= WAIT ;  // Shift the bit and go to the next state if we have not completed counting yet.\n\t\t\t\t\tend\t\t\n        default :;      // Do nothing in any other states.\n    endcase\nend\n\nalways @(posedge clk or posedge reset) begin  \n\tif (reset) \n\t\tdone <= 1'b0;\n\telse case (state) \n\t\tWAIT: if(counting && done_counting ) // If we are in WAIT state and counting is completed then go to NOTIFY state.\n\t\t\tbegin \n\t\t\t\tcounting <= 0;\n                shift_ena <= 0;\n\t\t\t\tdone <= 1'b1 ;\t// Timer timeout detected notify user\n\t\t\t\tif(ack)\t// if acknowledge the notification reset back to IDLE for next sequence detection \n\t\t\t\t\tstate <= IDLE;\t\t\n            end\t  \n        default :;      // Do nothing in any other states.   \n\tendcase\nend\n\nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "  \n    \nenum {IDLE, SEARCHING, SHIFTENA, COUNTING} state;\nreg [3:0] pattern = 4'b1101;\nreg [2:0] counter = 3'd0;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset == 1) \n        state <= IDLE;\n    else case (state)  \n        \n        IDLE : \n            if (data == pattern[0]) \n                state <= SEARCHING;      \n                \n        SEARCHING: \n            if (counter < 3'd4 && data==pattern[counter+1]) begin\n                counter <= counter + 1'b1;\n                if(counter == 3'd3)begin\n                    shift_ena <= 1;   //asserted for 4 clock cycles\n                    state <= SHIFTENA;   \n                end              \n            end     \n         else \n            begin \n             counter <= 0;\n             state <= IDLE; \n            end    \n         \n        SHIFTENA:\n            if (counter < 3'd4) begin   //asserted for 4 clock cycles\n                counter <= counter + 1'b1;\n                if(counter == 3'd3)begin\n                    shift_ena <= 0;   \n                    state <= COUNTING;    \n                end              \n            end          \n         \n        COUNTING: \n            if (done_counting == done_counting) begin //if high, counting is finished.\n            \tstate <= DONE;  \n        \t    counting<=1'b0;\n             end else state <= COUNTING ;//keep checking if counting has been finished.          \n         \n        DONE: \n            if(ack == ack)begin //if user acknowledges the timer, reset everything and wait for the next occurrence of pattern to begin again\n                done <= 1'b0;\n        \t    state <= IDLE;\n        \t    counting<=1'b0;\n        \tend else state <= DONE ;//keep checking if ack is high. \n            \n        endcase  \n    end             \nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "\n\treg [3:0] pattern;  // Stores last four inputs.\n\tenum { IDLE, SHIFTING, COUNTING } state;\t// Define states of FSM.\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= IDLE;    // Asynchronous reset.\n\t\telse \n\t\t\tcase (state)\n\t\t\t\tIDLE: \n\t\t\t\t\tif (pattern == 4'b1101)\n\t\t\t\t\t\tstate <= SHIFTING;\t// If pattern 1101 is detected, go to the SHIFTING state.\n\t\t\t\t    else \n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t  shift_ena <= 0;\t// When not in idle state, make sure shift_ena and counting are deasserted.\n\t\t\t\t\t\t  counting  <= 0;\t\t\n\t\t\t\t\t\tend  \n\t\t\t\tSHIFTING: \n\t\t\t\t\tif (shift_ena) begin\n\t\t\t\t\t\tstate <= COUNTING; // After asserting shift_ena for 4 cycles, go to the COUNTING state.\n\t\t\t\t\t\tshift_ena <= 1;\t// Maintain shifting until done_counting is high.\n\t\t\t\t\tend  \n\t\t\t\tCOUNTING:\n\t\t\t\t\tif (done_counting) begin // When counters are finished counting, notify user and wait for ack.\n\t\t\t\t\t  done <= 1;\t\t  \n                      if (ack) begin\n                         state <= IDLE; // Reset FSM to idle when ack is received.\n\t\t\t\t\t\t\tshift_ena <= 0;\t// Deassert shift_ena after ack is received.\n                   \t  end   \n                   end        \n            endcase      \n        end \n     always @(*) begin\n\t\t pattern <= {pattern[2:0], data}; // Shift in new bit into the stored value on each clock cycle.\n\tend  \nendmodule\n"}
{"task_id": "always_casez", "completion": "\nalways @(*) begin\n\tif(in[0]) \n\t\tpos = 3'd0;\n\telse if(in[1]) \n\t\tpos = 3'd1;\n\telse if(in[2]) \n\t\tpos = 3'd2;\n\telse if(in[3]) \n\t\tpos = 3'd3;\n\telse if(in[4]) \n\t\tpos = 3'd4;\n\telse if(in[5]) \n\t\tpos = 3'd5;\n\telse if(in[6]) \n\t\tpos = 3'd6;\n\telse if(in[7]) \n\t\tpos = 3'd7;\n\telse pos = 'x;\nend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\talways @(*) begin\n    \tif (in[0]) \n        \tpos = 3'd0;\n   \t \telse if (in[1])  \n       \t\tpos = 3'd1;\n     \t else if (in[2])  \n       \t\tpos = 3'd2;\n      \t else if (in[3])  \n        \tpos = 3'd3;\n     \t else if (in[4])  \n       \t\tpos = 3'd4;\n    \telse if (in[5]) \n        \tpos = 3'd5;\n   \t \telse if (in[6]) \n        \tpos = 3'd6;\n      \t else if (in[7])\n          \tpos = 3'd7;\n     \t else  \n       \t\tpos = 'b0;\n \tend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\talways @(*) begin\n\t\tfor(pos = 7; pos >= 0; pos = pos - 1) begin\n\t\t\tif(in[pos])\n\t\t\t\tbreak;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\t// Initialize the position to zero\n\tassign pos = 3'd0;\n\n\t// Priority encoder for 8-bit input\n\talways @* begin\n\t\tif(in[7]) // if in[7] is high, bit is at position 7\n\t\t\tpos <= 3'b111;\n\t\telse if (in[6])// if in[6] is high, bit is at position 6\n\t\t\tpos <= 3'd6;\n\t\telse if (in[5]) // if in[5] is high, bit is at position 5\n\t\t\tpos <= 3'd5;\n\t\telse if (in[4])// if in[4] is high, bit is at position 4\n\t\t\tpos <= 3'd4;\n\t\telse if (in[3]) // if in[3] is high, bit is at position 3\n\t\t\tpos <= 3'd3;\n\t\telse if (in[2])// if in[2] is high, bit is at position 2\n\t\t\tpos <= 3'd2;\n\t\telse if (in[1]) // if in[1] is high, bit is at position 1\n\t\t\tpos <= 3'd1;\n\t\telse if(in[0])// if in[0] is high, bit is at position 0\n\t\t\tpos <= 3'b0;\n\tend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\talways @(*) begin\n\t\tfor(pos = 7; pos >= 0; pos = pos - 1) begin\n\t\t\tif(in[pos]) break;\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "always_casez", "completion": "\n\talways @* begin\n\t\tfor(pos = 0; pos < 8; pos = pos + 1) \n\t\t\tif(in[pos]) break;\n\t\t\t\n\t\t//if there is no high bit, then set it to zero.\n\t\tif (pos == 8) \n\t\t\tpos <= 3'd0;\n\tend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\talways @(*) begin\n\t\tfor (pos = 8; pos > 0; pos = pos - 1) begin\n\t\t\tif (in[pos-1]) break;\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "always_casez", "completion": "\nalways @(in) begin\n    if      (in[0])  pos = 3'd0;\n    else if (in[1])  pos = 3'd1;\n    else if (in[2])  pos = 3'd2;\n    else if (in[3])  pos = 3'd3;\n    else if (in[4])  pos = 3'd4;\n    else if (in[5])  pos = 3'd5;\n    else if (in[6])  pos = 3'd6;\n    else if (in[7])  pos = 3'd7;\n    else              pos = 3'dx;   // no bits are high in input.\nend\n\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\tfor(pos=0; pos<3 ; pos++) \n\t\t if (in[pos]) break;\nendmodule\n\n"}
{"task_id": "always_casez", "completion": "\n\n\talways @* begin\n\t\tfor(pos = 7; pos >= 0; pos = pos - 1)\n\t\t\tif(in[pos]) break;\n\tend\nendmodule\n\n"}
{"task_id": "always_casez", "completion": "\n\talways @(*) begin\n\t    casex ({1'b0, in[7], in[6], in[5], in[4], in[3], in[2], in[1], in[0]}) // Case statement for the priority encoder \n\t     \t 8'bx: pos = 3'd7; \n\t\t 8'b1xxxxxxx: pos = 3'd0; \n\t\t 8'b01xxxxxx: pos = 3'd1; \n\t\t 8'b001xxxxx: pos = 3'd2; \n\t\t 8'b0001xxxx: pos = 3'd3; \n\t\t 8'b00001xxx: pos = 3'd4;  \n\t\t 8'b000001xx: pos = 3'd5; \n\t\t 8'b0000001x: pos = 3'd6; \n\t\t default:    pos = 3'd7; // no high bit found, return some 'unknown position', which is 7.\n\t    endcase\n\tend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\talways @* begin\n    \tif(in[7])      pos = 3'd7; \n        else if(in[6]) pos = 3'd6;   \n        else if(in[5]) pos = 3'd5;  \n        else if(in[4]) pos = 3'd4;  \n        else if(in[3]) pos = 3'd3; \n        else if(in[2]) pos = 3'd2; \n        else if(in[1]) pos = 3'd1; \n        else            pos = 3'd0;      //All are zero, so position is also zero. \n    end  \nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\tfor(i = 0; i < 8; i = i + 1) begin : loop\n    \t\tif (in[i]) \n\t\t   pos <= i;\n\tend\n\t\n\t// if no bits are high, report as zero.\n\tif (!in[7] && !in[6] && ... && !in[0]) begin\n       \t \tpos <= 3'd0;\n    \tend\n"}
{"task_id": "always_casez", "completion": "\n\n\talways @(*) begin \n\t  for (pos = 7; pos >= 0 ; pos = pos - 1) \n\t    if (in[pos]) break; \n\tend  \n\nendmodule\n\n"}
{"task_id": "always_casez", "completion": "\n\talways @(*) begin\n\t\tfor (pos = 0; pos < 8; pos = pos + 1) \n\t\t\tif (in[pos]) break;\n\tend\nendmodule\n\n"}
{"task_id": "always_casez", "completion": "\n\talways @(*) begin\n\t\tfor (pos = 8; pos > 0; pos = pos - 1) \n\t\t\tif (in[pos-1]) break; // Break the loop as soon as a '1' bit is found\n\tend\nendmodule\n\n"}
{"task_id": "always_casez", "completion": "\nalways @(*) begin \n\tif (!$countones(in)) // if no bits are high then pos is zero\n\t\tpos <= 3'd0;\n\telse begin\n\t\tfor (int i=7; i>=0; i--) begin // go through each bit from left to right and find the first one\n\t\t\tif (in[i]) begin\n\t\t\t\tpos <= (3'(8-i)); \n\t\t\t\tbreak;\n\t\t end\n\tend\nend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\nalways @* begin\n  for(pos=0; pos<8; pos++) begin\n    if(in[pos]) break;\n  end\nend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\talways @(*) begin\n\t\tif(in[7]) \n\t\t\tpos = 3'd7; // 8th bit\n\t\telse if(in[6]) \n\t\t\tpos = 3'd6; // 7th bit\n\t\telse if(in[5]) \n\t\t\tpos = 3'd5; // 6th bit\n\t\telse if(in[4]) \n\t\t\tpos = 3'd4; // 5th bit\n\t\telse if(in[3]) \n\t\t\tpos = 3'd3; // 4th bit\n\t\telse if(in[2]) \n\t\t\tpos = 3'd2; // 3rd bit\n\t\telse if(in[1]) \n\t\t\tpos = 3'd1; // 2nd bit\n\t\telse if(in[0]) \n\t\t\tpos = 3'd0; // 1st bit\n\t\telse \n\t\t\tpos = 3'dx; // No bits are high\n\tend\nendmodule\n"}
{"task_id": "always_casez", "completion": "\n\n\talways @(*) begin\n\t\tfor (pos = 0; pos < 8; pos = pos + 1) \n\t\t\tif (in[pos]) break;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using Assign Statement\n\tassign out_assign = a & b;\n\n\t// Using Combinational Always Block\n\talways @(*) begin\n\t\tout_alwaysblock <= a & b;\n\tend\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using Assign Statement\n\tassign out_assign = a & b;\n\n\t// Using Always Block\n\talways @(*) begin\n\t\tif (a == 1 && b == 1) \n\t\t    out_alwaysblock = 1;\n\t\telse\n\t\t\tout_alwaysblock = 0;\n\tend\n\t\nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using Assign Statement\n\tassign out_assign = a & b;\n\n\t// Using Combinational Always Block\n\talways @(*) begin\n\t\tout_alwaysblock <= a & b;\n\tend\n\nendmodule \n"}
{"task_id": "alwaysblock1", "completion": "\n\n\tassign out_assign = a & b; // Using assign statement\n\t\n\talways @(*) begin // Using combinational always block\n\t\tout_alwaysblock <= a & b;\n\tend \n\t\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b; // Using assign statement\n  \n\talways @(*) begin //Using combinational always block\n\t\tout_alwaysblock <= a & b;\n\tend \nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\n     // Using an assign statement\n    assign out_assign = a & b;\n    \n    // Using always block\n    always @(*) begin\n        if (a==1 && b==1) \n            out_alwaysblock <= 1;\n        else  \n            out_alwaysblock <= 0;\n    end\nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b;\n\n\talways @* begin\n\t\tout_alwaysblock <= a & b;\n\tend\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b;\n\t\n\talways @(*) begin\n\t\tout_alwaysblock <= a & b;\n\tend\nendmodule \n\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b; // assign statement\n  \n\talways @ (*) begin // combinational always block\n\t    if (a == 1'b1 && b == 1'b1 ) \n\t\t    out_alwaysblock = 1'b1 ;\n        else \n\t\t     out_alwaysblock = 1'b0;\n\t  end  \nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b;\n\t\n\talways @(*) begin\n\t\tout_alwaysblock <= a & b;\n\tend\nendmodule \n\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Assign Statement\n\tassign out_assign = a & b;\n\n\t// Combinational Always Block\n\talways @(*) begin\n\t\tout_alwaysblock <= a & b; \n\tend\n\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b; // Using assign statement for AND gate\n\n\talways @(a or b) begin // Using combinational always block for AND gate\n\t\tif (a == 1 && b == 1) \n\t\t\tout_alwaysblock <= 1;\n\t\telse\n\t\t\tout_alwaysblock <= 0;\n\tend\nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b;\n\t\n\talways @(*) begin\n\t\tout_alwaysblock <= a & b;\n\tend\n\t\nendmodule \n\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using assign statement for AND gate\n\tassign out_assign = a & b;\n\n\t// Using combinational always block for AND gate\n\talways @(*) begin\n\t    out_alwaysblock <= a & b;\n\tend\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b; // This is an AND gate implemented using assign statement.\n\n\talways @(*) begin // This block will execute whenever any of the input changes\n\t  out_alwaysblock <= a & b;  // This is another way to create an AND gate in verilog\n\tend\nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using Assign Statement\n\tassign out_assign = a & b;\n\t\n\t// Using Combinational Always Block\n\talways @(*) begin\n\t    out_alwaysblock <= a & b;\n\tend\n\nendmodule \n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b;\n\t\n\talways @* begin\n\t\tout_alwaysblock <= a & b;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\tassign out_assign = a & b;\n\t\n\talways @* begin\n\t\tout_alwaysblock <= a & b;\n\tend\nendmodule\n\n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using Assign Statement\n\tassign out_assign = a & b;\n\n\t// Using Combinational Always Block\n\talways @(*) begin\n\t\tout_alwaysblock <= a & b;\n\tend\nendmodule \n"}
{"task_id": "alwaysblock1", "completion": "\n\t// Using an assign statement\n\tassign out_assign = a & b;\n\t\n\t// Using always block\n\talways @(*) begin\n\t\tif (a==1 && b==1)\n\t\t\tout_alwaysblock = 1;\n\t\telse\n\t\t\tout_alwaysblock = 0;\n\tend\nendmodule \n\n"}
{"task_id": "fsm2", "completion": "\n\treg state; // State register\n\twire nextState1 = (!state && !j) || (state && k);\n\twire nextState0 = (!state && j) || (state && !k);\n\n\talways @(posedge clk or posedge areset) begin \n\t  if(areset) state <= 1'b0; // Asynchronous reset active high\n    else state <= nextState0 | nextState1;\n\tend  \n\t\t\n\tassign out = state;\n\t\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n\n\treg state; // 0 for off and 1 for on\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\t\tif (areset)\n\t\t\t\tstate <= 0; // set to OFF after reset\n\t\t\telse if (!j && !state) \n\t\t\t\t\tstate <= state; // stay in the same state since j=0 and current state is off\n\t\t\telse if (!j && state)  \n\t\t\t\t\tstate <= ~state; // flip the state because j=0 and current state is on\n\t\t\telse if (k && !state) \n\t\t\t\t\tstate <= ~state; // stay in the same state since k=1 and current state is off\n\t\t\telse if (k && state)  \n\t\t\t\t\tstate <= state; // flip the state because k=1 and current state is on\n\tend\n\n\tassign out = state;\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n\treg state;  // state = 0 means OFF and state = 1 means ON\n\twire newState = state ^ ((~j)&k | (j&~state));\n\n\t// Synchronous reset with async active-high reset\n\talways @(posedge clk or posedge areset) begin\n\t\tif(areset) \n\t\t\tstate <= 0;\n\t    else      \n\t\t    state <= newState;\n\tend\n\tassign out = state;\nendmodule\n"}
{"task_id": "fsm2", "completion": "\nreg [1:0] state;\n    parameter ON  = 2'b10,\n              OFF = 2'b01;\n    \nalways @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= OFF;\n        else \n            case (state) \n                OFF : if (j == 1'b1)\n                        state <= ON;\n                      else\n                        state <= OFF;\n                ON  : if (k == 1'b1)\n                        state <= OFF;\n                      else \n                        state <= ON;\n            endcase\n    end\n    \nassign out = (state == ON)? 1'b1: 1'b0 ;\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n    \n    reg state; // State register \n  \n    always @(posedge clk or posedge areset) begin      // Synchronous reset\n        if (areset) \n            state <= 0;                           \n        else begin \n            case({j, k})               // State transitions based on j and k inputs\n                2'b00: state <= state;          // No change in state \n                2'b01: state <= ~state;         // Toggle the state\n                2'b10: state <= state;           // No change in state  \n                2'b11: state <= ~state;          // Toggle the state\n            endcase\n        end \n    end\n    \n    assign out = state;       // Assigning output as the current state of the machine\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n     reg [1:0] state;\n     \n     parameter OFF = 2'h0, ON  = 2'h1; \n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case(state)\n                OFF: if (j == 0) state <= OFF; else state <= ON;\n                ON : if (k == 0) state <= ON;  else state <= OFF;\n            endcase\n       end        \n    end\n   assign out = (state == ON);\nendmodule \n"}
{"task_id": "fsm2", "completion": "\n\treg state;\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= 1'b0;\n\t\telse if (j == 1'b0 && k == 1'b0) \n\t\t\tstate <= state;\n\t\telse if (j == 1'b1 && k == 1'b0) \n\t\t\tstate <= ~state;\n\t\telse \n\t\t\tstate <= ~state;\n\tend\n\n\tassign out = state;\nendmodule\n"}
{"task_id": "fsm2", "completion": "\nreg state; //define the current state as a register\nalways @(posedge clk or posedge areset) begin //the always block with synchronous reset\n\tif (areset) \n\t\tstate <= 0;   //asynchronous reset\n\telse \n\t\tcase ({j, k})\t//4-bit input j and k are used as index to transition between states. \n\t\t\t2'b00: state <= OFF;\n\t\t\t2'b01: state <= ON;\n\t\t\t2'b10: state <= ON;\n\t\t\t2'b11: state <= OFF;\n\t\tendcase\t\t\nend\nassign out = state; //output is the current state \nendmodule\n"}
{"task_id": "fsm2", "completion": "\n\treg state; // Define state register\n  \n\t// State transition function \n\talways @(posedge clk or posedge areset) begin\n\t  if (areset)\n\t    state <= 0; // Asynchronous reset to OFF\n\t  else\n\t    case(state)\n\t\t2'b00:  if (j==1'b0 && k==1'b0) state <= 2'b00;\n\t\t          else if (j==1'b1 && k==1'b0) state <= 2'b01;\n\t\t               else if(j==1'b0 && k==1'b1) state <=2'b01; // Stay ON for all other transitions \n\t      2'b01:  if (j==1'b0 && k==1'b0) state <= 2'b01; // Stay ON for all other transitions \n\t\t          else if (j==1'b1 && k==1'b0) state <= 2'b10;\n\t\t               else if(j==1'b0 && k==1'b1) state <=2'b11;\n\t      2'b10:  if (j==1'b0 && k==1'b0) state <= 2'b10; // Stay OFF for all other transitions \n\t\t          else if (j==1'b1 && k==1'b0) state <=2'b11;\n\t\t               else if(j==1'b0 && k==1'b1) state <=2'b00; \n\t      2'b11:  if (j==1'b0 && k==1'b0) state <= 2'b11; // Stay OFF for all other transitions  \n\t\t          else if (j==1'b1 && k==1'b0) state <=2'b00;\n\t\t               else if(j==1'b0 && k==1'b1) state <=2'b01; \n\t    endcase\n\tend\n  \n\t// Output function\n\tassign out = (state == 2'b10); // State ON corresponds to output 1, otherwise output is 0\n  \nendmodule\n\n"}
{"task_id": "fsm2", "completion": "\n\treg state;\n\twire next_state; \n\tassign next_state = ((~state) & j )| (state & ~k ); //Next State Logic\n\t\n\talways @(posedge clk or posedge areset) begin   //Syncronous D FlipFlop\n\t\tif(areset)\n\t\t\tstate <= 1'b0;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\tassign out = state;    // Output Logic\nendmodule\n\n"}
{"task_id": "fsm2", "completion": "\n\treg state; //0 for OFF and 1 for ON\n\n\t//asynchronous reset\n\talways @(posedge areset)\n\t\tstate <= 0;\n\t\t\n\talways @(posedge clk) begin\n\t\tif (~j & ~state) //from OFF to OFF\n\t\t\tstate <= 0;\n\t\telse if (j & ~state) //from OFF to ON\n\t\t\tstate <= 1;\n\t\telse if (state & k) //from ON to ON\n\t\t\tstate <= 1;\n\t\telse if (state & ~k) //from ON to OFF\n\t\t\tstate <= 0;\n\tend \n\n\t//assign the output based on state\n\tassign out = state;\n\t\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n\treg state; // define the state \n  \n\talways @(posedge clk or posedge areset) begin\n        \tif (areset) state <= 0; // asynchronous reset to OFF\n       \telse begin // synchronous logic\n            \tcase (state) \n                \t2'b00: if (j==1'b0 && k ==1'b0) state <= 2'b00;\n                    \t\t else if(j == 1'b1 && k == 1'b0) state <=2'b10;\n                    \t\t else if(j== 1'b0 &&k ==1'b1 )state<=2'b01 ;\n                 \t\t\t else state <= 2'b11; //no change\n               \t     \t2'b01: if (j == 1'b0 && k == 1'b0) state <= 2'b01;\n                    \t\t else if( j== 1'b1 && k ==1'b0) state <=2'b11 ;\n                    \t\t else if( j== 1'b0&&k==1'b1 )state<=2'b00 ;\n                     \t\t\telse state <= 2'b10; //no change\t\n                 \t\t\t2'b10: if (j == 1'b0 && k ==1'b0) state <=2'b10 ;\n                    \t\t else if( j== 1'b1 &&k==1'b0 )state<=2'b00 ;\n                    \t\t else if(j== 1'b0&&k==1'b1 ) state<= 2'b11;\n                 \t\t\t\telse state <= 2'b01; // no change \n                \t  \t2'b11: if (j == 1'b0 && k ==1'b0) state <=2'b11 ;\n                    \t\t else if( j== 1'b1&&k==1'b0 )state<=2'b01;\n                    \t\t else if(j== 1'b0 &&k==1'b1) state <= 2'b00;\n                 \t\t\t\telse state <=2'b10 ;//no change\n            \t\tendcase\n        \tend   \n    \tend  \n    \n\t//output logic:\n\tassign out = (state == 2'b01);\n\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n\treg state;\n\twire next_state1, next_state2;\n\n\tassign next_state1 = (state==1'b0 && j==1'b0) ? 1'b0 :\n                         (state==1'b0 && j==1'b1) ? 1'b1 :\n\t\t\t state;\n\tassign out = state;\n\n\talways @(posedge clk or posedge areset) begin\n        \tif (areset == 1'b1)\n            \t\tstate <= 1'b0;\n       \t \telse\n\t\t\tstate <= next_state1;  //first transition on clock edge.\n    \tend\n\n    always @(posedge clk or posedge areset) begin\n        \tif (areset == 1'b1)\n            \t\tstate <= 1'b0;\n       \t \telse\n\t\t\tstate <= next_tate2;  //second transition on clock edge.\n    \tend\n    assign next_state2 = (state==1'b1 && k==1'b0) ? 1'b1 :\n                         (state==1'b1 && k==1'b1) ? 1'b0 :\n\t\t\t state;\n\n"}
{"task_id": "fsm2", "completion": "\n   reg state;  //State register.\n   \n   always @(posedge clk or posedge areset) begin\n      if (areset) \n         state <= 0;     //Reset state to OFF\n      else \n        case ({j, k})\n          2'b00: state <= state;  //Maintain current state when j and k are both zero\n          2'b01: state <= ~state; //Toggle the state when k is one\n          2'b10: state <= state;  //Maintain current state when j is one\n          2'b11: state <= ~state; //Toggle state when j and k are both one\n        endcase\n   end\n    assign out = state;\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n\treg state;\n\tassign out = state;\n\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t\t    state <= 1'b0; // OFF\n        else \n            case({j, k}) \n                2'b00: state <= state; \n                2'b01: state <= ~state;  \n                2'b10: state <= state; \n                2'b11: state <= ~state;  \n            endcase\t    \n\tend\nendmodule\n\n"}
{"task_id": "fsm2", "completion": "\nreg [1:0] state;\nparameter ON = 2'b10, OFF = 2'b01;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'h1) \n\t\tstate <= OFF;\n\telse if (j==1'h0 && k==1'h0 ) \n\t\tstate <= state;\n\telse if (j==1'h0 && k==1'h1 ) \n\t\tstate <= ON;\n\telse if (j==1'h1 && k==1'h0)\n\t\tstate <= OFF;\n\telse if (j==1'h1 && k==1'h1)  \n\t\tstate <= ON;\nend\n\t\nassign out = state[0];\n\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n    reg state; // state 0 for off and state 1 for on.\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 0;   // Asynchronous reset\n        else\n            case({j, k})\n                2'b00: state <= state;  \n                2'b01: state <= ~state; \n                default: state <= ~state;\n            endcase\n    end\n    \n    assign out = state;\nendmodule\n"}
{"task_id": "fsm2", "completion": "\n\treg state; \n  \n\talways @(posedge clk or posedge areset) begin \n\t    if (areset == 1'b1) begin // active high reset  \n\t\t    state <= 0; \n        end else if (j==0 && k ==0 )begin\n            state <= state;\n\t    end else if ( j==0 && k==1) begin\n\t\t\tstate <= ~state;\n\t\tend else if(j==1 && k==0) begin\n            state <= state; \n        end else if(j==1 && k==1)begin  \n\t\t    state <= ~state;\n\t    end\n\tend\n       assign out = state ;\nendmodule\n"}
{"task_id": "fsm2", "completion": "\nreg state; // current state of the machine\n    initial begin \n       state <= 0; // initialize to OFF\n   end\n\talways @(posedge clk or posedge areset)\n      if (areset) \n         state <= 0; // Asynchronous reset to off state\n      else\n        case(state)\n          0: if(j==1'b0) state <= 0; else state <= 1; // staying OFF if j=0, transitioning to ON if j=1\n          1: if(k==1'b0) state <= 1; else state <= 0; // staying ON if k=0, transitioning to OFF if k=1\n          default : state <= 'x; // undefined states are errors so we assign an error value (default case)\n       endcase\n\tassign out = state; \nendmodule \n"}
{"task_id": "fsm2", "completion": "\n\treg [1:0] state;\n\tparameter  OFF = 2'b00, ON = 2'b01;\n\t\n\t// Async reset\n\talways @(posedge areset) begin\n\t\tstate <= OFF;\n\tend\n\t\t\n\t// State transitions\n\talways @(posedge clk) begin\n\t\tcase (state) \n\t\t\tOFF : if (!j & k) state <= ON;  \n\t\t\t       else if (j & !k) state <= ON;\n\t\t\tON:   if (!j & k ) state <= OFF ;\n\t\t\t      else if ( j& k) state <= ON;  // Deadly lock when both inputs are same as current state.\n\t\tendcase\n\tend\n\t\n\t// Outputs\n\tassign out = state[0];\n\n"}
{"task_id": "conwaylife", "completion": "\n\t// Game of Life Rules\n\tfunction automatic [31:0] countNeighbours;\n\t\tinput [255:0] cells;\n\t\tinput integer x, y;\n\t\treg [4:0] neighbours = 0;\n\t\tinteger i, j;\n\t\t\n\t\tfor (i = -1 ; i < 2 ; i ++) begin\n\t\t\tfor (j = -1; j < 2; j++) begin\n\t\t\t\tif ((x+i >= 0 && x+i < $size(cells)/32) && (y+j >=  0 && y+j < $size(cells[0])/32)) \n\t\t\t\t\tneighbours += cells[(x+i)*32 + y+j];\n\t\tend\n\t\tend\n\t\t\t\n\t\treturn neighbours;\n\tendfunction\n\t\n\tfunction automatic [15:0] countAliveNeighbours;\n\t\tinput [255:0] cells;\n\t\tinteger x, y;\n\t\t\n\t\tfor (x = 0; x < $size(cells)/32; x++) begin\n\t\t\tfor (y = 0; y < $size(cells[0])/32 ; y++ )begin \n\t\t\t\tif(countNeighbours(cells, x, y) < 4 && countNeighbours(cells, x, y) > 1) cells[(x)*32 + y] = 1;\n\t\t\t\telse if (countNeighbours(cells, x, y) == 3 ) cells[(x)*32 + y] = 1;\n\t\t\tend\n\t\tend \n\t\t\t\t\n\t\treturn cells;\n\tendfunction\n\t// Game of Life Rules Ends Here.\n\t\n\talways @(posedge clk) begin\n\t\tif (load) q <= data;\n\t\telse q <= countAliveNeighbours(q);\n\tend\n\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n`include \"nextStateLogic.sv\"  // Contains the logic for determining next state of cell\n\treg [255:0] new_q;\t\t   // Temporarily holds new game state until all cells have been updated\n\n\t// Logic to generate Moore machine output\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tnew_q <= data;\n\t\telse\n\t\t\tfor (int i = 0 ; i < 16 ; ++i)\n\t\t\t\tfor (int j = 0 ; j < 16 ; ++j) \n\t\t\t\t\tnew_q[i*16+j] = nextState(q, i, j);  // Calculate the new state of each cell based on current state and its neighbours\n\t\t\n\t\t// Assign the temporary game state to q for output after all cells have been updated\n\t\tq <= new_q;  \n\tend\n\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n\n\t// Count the number of live neighbours for each cell. \n\tfunction [7:0] countNeighbors;\n\t\tinput [79:0] row_1, row_0, row_f; // rows above and below current row\n\t\tinput [31:0] cell;                 // the current row\n\t\treg   [8:0]  neighbors;            // sum of neighbours (extra bit for overflow)\n\t\tbegin\n\t\t\t// Sum neighbours in row above.\n\t\t\tif (row_1[cell[5:0]+2'd7]) neighbors += {3{row_1[cell[5:0]]}}; // wrap around left 8 bits\n\t\t\tif (row_1[cell[5:0]-2'd1]) neighbors += {3{row_1[cell[5:0]+2'd7]}};\n\t\t\t\n\t\t\t// Count neighbours in same row.\n\t\t\tif (cell[31:0]) begin  // if not left edge cell\n\t\t\t\tif (cell[5:0] != 6'h1f) neighbors += {3{cell[31:24]}}; // wrap around left 7 bits\n\t\t\t\tneighbors += {2{cell[23:16]}, cell[24]};\n\t\t\tend\n\t\t\t\n\t\t\t// Sum neighbours in row below.\n\t\t\tif (row_f[cell[5:0]+2'd1]) neighbors += {3{row_f[cell[5:0]]}}; // wrap around right 8 bits\n\t\t\tif (row_f[cell[5:0]+2'd2]) neighbors += {2{row_f[cell[5:0]+2'd1]}, row_f[cell[5:0]]};\n\t\t\t\n\t\t\tcountNeighbors = neighbors;\n\t\tend\n\tendfunction // countNeighbors\n\t\n\t// Compute next state.\n\tfunction [79:0] computeNextState;\n\t\tinput [255:0] current_state, next_state; \n\t\treg   [15:0] temp;\n\t\tbegin\t\t\n\t\t\tfor (int i = 0; i < 16; i = i + 1) begin\n\t\t\t\ttemp[i+8*i : i+8*(i+1)] = current_state[7:0];  // grab row from state\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<16; j++ )begin\t\t\n\t\t\t\t\t\tif (j==0 && i==0) begin    // if left edge top cell.\n\t\t\t\t\t\t\t\tnext_state[i*8+j : i*(8+1)] = ~temp[7:0];   // wrap around to right \n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t end\n\t\t\t\telse if(j == 0 )begin         // if left edge cells other than top row.\n\t\t\t\t\t\t\t\t\t\tnext_state[i*8+j : i*(8+1) ]=~temp[(7+16*(i-1)): 8*(i-1)];// wrap around to right and below\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tend  \t\t\n\t\t\t\telse if(i == 0 )begin         //if top row other than left edge cell.\n\t\t\t\t\t\t\t\tnext_state[i*8+j : i*(8+1)]=~temp[(7+j)-1: j-1];  // wrap around to below\n\t\t\t\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t end\t\t\n\t\t\t\telse if(j==15 && i ==15)begin //if right edge bottom cell.\n\t\t\t\t\t\t\t\tnext_state[i*8+j : i*(8+1)] = ~temp[(7+16*(i-1)): 8*(i-1)];// wrap around to top and left\n\t\t\t\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t end\t\t\t\t\t\t\t\t\t \t\t\t\n\t\t\t\telse if( j == 15 ) begin       //if right edge cells other than bottom row.\n\t\t\t\t\t\t\t\tnext_state[i*8+j : i*(8+1)] =~temp[(7+16*(i-1)): 8*(i-1)];// wrap around to left and above  \n\t\t\t\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t\t\t    \t\t\t   \n\t\t\t\t\t\t end\t\t\t\t\t\t\t\t\t \t\t\n\t\t\t\telse if(i == 15 ) begin       //if bottom row other than right edge cell.\n\t\t\t\t\t\t\t\tnext_state[i*8+j : i*(8+1)] =~temp[(7+j)-1: j-1];// wrap around to above and left"}
{"task_id": "conwaylife", "completion": "\n// Moore machine that computes next state based on current and neighbouring states\nfunction automatic [15:0] count_neighbours;\n\tinput [31:0] row;  // input rows, each containing 4 cells (abcd) and their neighbours (efgh)\n\treg  [31:0] r1,r2,r3,r4;\n\nbegin\n\tr1 = {row[27:0],4'bxxxx};   // abcd -> bcde (with x4 added at end)\n\tr2 = {row[31:4],4'bxxxx};   // bcde -> cdef (with x3 at start and end)\n\tr3 = row;                    // cdef -> defg (unchanged)\n\tr4 = {4'bxxxx,row[27:0]};    // defg -> efgh (with x4 at start and x3 removed at end)\n\treturn r1[15:0] + r2[15:0] + r3[15:0] + r4[15:0];  // return the sum of all neighbour counts\nend\nendfunction\n\n// Moore machine that computes next state based on current and neighbouring states\nalways @(posedge clk) begin\n\tif (load) q <= data;   // Load new pattern at start of game\n\telse begin             // Otherwise, advance by one timestep\n\t\tfor(n = 0; n < 16; n++) \n\t\t\tq[((n+1)*16)-1:n*16] = ((count_neighbours({q[(n-1)*16+15:n*16], q[(n+1)*16-1:n*16]}) == 2'd3) ? 16'hFFFF :\n\t\t\t        (count_neighbours({q[(n-1)*16+15:n*16], q[(n+1)*16-1:n*16]}) == 2'd4) ? 16'h0000 :\n\t\t\t\t\t ((count_neighbours({q[(n-1)*16+15:n*16], q[(n+1)*16-1:n*16]}) < 2'd3) ? 16'h0000 :  16'hFFFF;\n\tend\nend\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\nHere is how we can implement this. The logic for calculating the next state of a cell's neighbours involves bitwise operations and shifts that wrap around the grid:\n\nmodule top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n  \n\treg [255:0] nextq; // Next state register\n\twire [15:0] wrap[7:0]; // Wrap around indices\n\t\t\n\t// Generate the 8 neighbours for each cell in a row (0-16)\n\tfor(i = 0; i < 4; i++) begin : GEN_NEIGHBOURS\n\t\tassign wrap[2*i] = {q[((j+1)*16)-:16}, q[(15-(8'd14-j))*16 +: 16], q[(j+7)*16 +: 16}}; // j is the column\n\t\tassign wrap[2*i + 1] = {q[(15-(((j+1)-1)%16))*16 +: 16}, q[(8'd15 - (((15-(j+7))%16)))*16 +: 16], q[(((j+7)%16))*16 +: 16}};\n\tend\n\t\t  \n\t// The logic to calculate the next state of a cell's neighbours, with wrap-around indexing\n\tfor (i = 0; i < 16; i++) begin : GEN_NEXTQ\n\t    for(j = 0; j<8; j++) begin: GEN_CELLS\n\t\t    // Count live neighbour cells\n\t\t\twire [3:0] count = wrap[4*i+j][59:56] + wrap[4*i+j][75:72] + wrap[4*(i-1)%8 + 4'd1 + 7'd1 + 3 - j/2][(j==1? 4 : (j==0 ? 12 : 7)) +: 4];\n\t\t\t    \n\t\t    // Determine next state based on count of live neighbours\n\t\t\tassign nextq[(i*16)+j] = ((count == 3'd3) || (!q[(i*16)+j] && (count==2))) ? 1'b1: 1'b0;\n\t    end\n        end    \n\t\t\t\n\t// Synchronous load and shift register\n\talways @(posedge clk) begin\n\t\tif(load) q <= data;\n\t\telse q <= nextq;\n\tend\n  \nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n\treg [255:0] next;  // temporary variable to hold the next state of the game\n\t// helper function that counts the number of live neighbours around a cell in a toroidal grid\n\tfunction [3:0] count_neighbors;\n\t\tinput [255:0] cells;\n\t\tinput [7:0] row, col;  // coordinates of the cell to count neighbours for\n\t\tinteger r, c;          // loop variables\n\t\tbegin\n\t\t\tcount_neighbors = 0;\n\t\t\tfor (r = row-1; r <= row+1; r++) begin\n\t\t\t\tfor (c = col-1; c <= col+1; c++) begin\n\t\t\t\t\tif ((r != row || c != col) && cells[(((r%16)<<4) + (c%16))])  // if this is not the cell itself and it's alive\n\t\t\t\t\t\tcount_neighbors = count_neighbors + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tendfunction\n\t// main logic of the game\n\talways @(posedge clk) begin\n\t\tif (load)  // load new initial state at next clock edge\n\t\t\tq <= data;\n\t\telse begin\n\t\t\tfor (integer i = 0; i < 256; i++) begin  // for each cell\n\t\t\t\tcasex({q[i], q[(i+1)&255], q[(i-1)&255], q[(i+16)&255], q[(i-16)&255]})  \n\t\t\t\t\t4'b000X: next[i] = (count_neighbors(q, i>>4, i&15) == 3); // dead cell becomes alive if 3 live neighbours\n\t\t\t\t\t4'b00X0: next[i] = ~(count_neighbors(q, i>>4, i&15)[2]);      // live cell survives if 2 or 3 neighbours\n\t\t\t\t\t4'b00XX: next[i] = (count_neighbors(q, i>>4, i&15) == 3);     // live cell becomes alive if 3 live neighbours\n\t\t\t\t\tdefault: next[i] = ~((count_neighbors(q, i>>4, i&15)[2]) | count_neighbors(q, i>>4, i&15)[3]);// dead cell survives if 0 or >3 neighbours\n\t\t\t endcase\t\n\t\t\tend\n\t\t\tq <= next; // update current state with the calculated new state at each clock cycle\n\tend\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n\t//Neighbor count and wrap around grid indices.\n\tfunction [3:0] n_neighbors;\n\t\tinput [7:0] i;\n\t\treg [7:0] im1, ip1;\n\tbegin \n\t\tim1 = (i==8'h00) ? 8'hFF : i-1; //previous row\n\t\tip1 = (i==8'hFF) ? 8'h00 : i+1; //next row\n\t\t\n\t\treturn q[im1*16 +: 4] + q[ip1*16 +: 4] + \n\t\t\t   q[(i-1)*16 + 15:(i-1)*16 - 13]  + q[(i+1)*16 - 15:(i+1)*16]; //neighbors above and below the current row (with wrap around)\n\tend\nendfunction\n\t\t\n\t//Game of life logic.\n\tfunction [255:0] game_of_life;\n\tbegin\n\t \tfor(int i = 0; i < 16*16; i++) begin //iterating over all cells in the grid\n        \tgame_of_life[i] = ((n_neighbors(i) == 3) || (q[i] && n_neighbors(i)==2)) ? 1 : 0 ; //the cell lives or reproduces if it has exactly three neighbours, else it dies\n\t   end\n   \tend\n\tendfunction\n\n\talways @(posedge clk) begin\n\t\tif (load == 1'b1) q <= data; //loading initial state\n\t\t\n\t\telse q <= game_of_life();  //updating game status every clock tick\n\tend\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n// This is a complex implementation as the 16x16 grid requires calculation of neighbours in toroidal (circular) manner. I've kept it simple by using Xilinx IP core \"Reduce AND/OR\" to count live neighbours and used multiplexers for wrap around connections.\n\twire [255:0] n, ne;  // 'n' - current state, 'ne' - next state\n\twire [15:0] q_temp[7:0], d[7:0];  \n\tgenvar i,j;\n\tgenerate\n\t\tfor (i = 0; i<8; i++) begin : row  //split rows into 8 chunks to save resources\n\t\t\tif(i==0 || i ==7) assign q_temp[i] = {q[15:0],q[239:224]};    // wrap around connections for first and last row\n\t\t\t else assign q_temp[i]={q[(i+1)*16-1:(i)*16]; // normal connection between rows i-1,i,i+1. \n\t\t\tfor(j=0; j<4; j++) begin : col   // split columns into four chunks for easy calculations using Xilinx IP core \"Reduce AND/OR\"\n\t\t\t\tif(i==0 && j==3 || i == 7 && j ==0 ) assign d[((i*4)+j)] = {q_temp[(i+1)%8][(j-1)*16 +:16], q_temp[(i+1)%8][15:(j-2)*16 -1]}; // wrap around connections for corners\n\t\t\t\telse if (i==0 || i == 7 ) assign d[((i*4)+j)] = {q_temp[(i+1)%8][(j-1)*16 +:16], q_temp[(i+1)%8][(j+1)*16 - 1:(j-2)*16]; // wrap around connections for first and last row\n\t\t\t\telse assign d[((i*4)+j)] = {q_temp[(i+1)%8][(j-1)*16 +:16], q_temp[(i-1)%8][(j-1)*16 +:16], q_temp[(i+1)%8][(j+1)*16 - 1:(j-2)*16]}; // normal connections between rows i-1,i,i+1 and columns j-1,j,j+1.\n\t\t\t\tReduceAnd (ne[((i*4)+j)], n[(i*4 + j)] ,d[((i*4)+j)]) ;  // Count live neighbours using Reduce AND IP core for row 'i' and column 'j'.\n\t\t\tend \n\t\tend \n\tendgenerate\n   assign ne = (load==1)? data :n;      // if load is high, load the data else calculate next state.\n\talways @(posedge clk) begin    // on positive edge of clock, update current state to be same as next state and vice versa for real time updating.\n\t\tq <= ne; \n\t\tn <= ~ne;\n\tend\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n\n    wire [7:0][15:0] neighbourcount;  // Counts the neighbours of each cell in a row.\n    assign neighbourcount[15:8] = {q[63:48],q[95:80],q[127:112],q[159:144],q[191:176],q[223:208],q[255:240], q[7:0]};\n    assign neighbourcount[7:0] = {q[55:40],q[87:72],q[119:104],q[151:136],q[183:168],q[215:192],q[247:232], q[15:8]};\n  \n    wire [7:0][15:0] newstate;  // The state of each cell in the next timestep.\n    assign newstate = neighbourcount + (neighbourcount<<1) - (neighbourcount>>1);\n  \n    always @(posedge clk) begin\n        if (load)\n            q <= data[255:0];  // Loads initial state.\n        else \n            q <= {newstate[7], newstate[6], newstate[5], newstate[4], newstate[3], newstate[2], newstate[1], newstate[0]};  // Updates to next timestep's states.\n    end\n    \nendmodule\n"}
{"task_id": "conwaylife", "completion": "\nreg [7:0] neighborBits[0:15];\nwire [7:0] nextState;\n  \nassign nextState = (neighborBits[q] == 3'b01 || neighborBits[q] == 3'b10) ? 8'hff : // 2 or more neighbors becomes alive, none become dead\n                  (neighborBits[q] > 3'b10) ? 8'h0 : q; \n  \nalways @(posedge clk) begin\n\tif (load)\n\t\tq <= data;\n\telse // Otherwise calculate next state of all cells.\n    for (integer i = 0; i < 16; i = i + 1) begin\n      neighborBits[i] <= ~((q[(i-1)%16*8 +: 8] | q[(i+1)%16*8 +: 8]) & ~(q[i*8 +: 8])); // Neighbor bitmask for this cell, 0 = alive.\n    end\n\tq <= nextState;    \nend  \nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n\n\t// Calculate neighbour count for a cell (i, j) in a 16x16 grid.\n\tfunction [3:0] get_neighbour_count;\n\t\tinput [3:0] i, j;\n\t\tbegin\n\t\t\tget_neighbour_count = q[(i-1)&15'hFFFF][j&15'hFFFF] \n\t\t\t\t+ q[(((i+1)&15'hFFFF)+1)&15'hFFFF][j&15'hFFFF]\n\t\t\t\t+ q[i&15'hFFFF][(j-1)&15'hFFFF] \n\t\t\t\t+ q[i&15'hFFFF][((j+1)&15'hFFFF)+1&15'hFFFF];\n\t\t\tget_neighbour_count += q[(((i+1)&15'hFFFF)+1)&15'hFFFF][((j-1)&15'hFFFF)+1&15'hFFFF] \n\t\t\t\t+ q[(i+1)&15'hFFFF][((j+1)&15'hFFFF)+1&15'hFFFF] \n\t\t\t\t+ q[(((i-1)&15'hFFFF)+1)&15'hFFFF][((j+1)&15'hFFFF)+1&15'hFFFF] \n\t\t\t\t+ q[(i-1)&15'hFFFF][((j-1)&15'hFFFF)+1&15'hFFFF];\n\t\tend\n\tendfunction\n\t\n\t// Calculate next state of a cell (i, j).\n\tfunction [0:0] get_next_state;\n\t\tinput [3:0] i, j;\n\t\tbegin\n\t\t\tcase(get_neighbour_count(i, j))\n\t\t\t\t2:  get_next_state = q[i&15'hFFFF][j&15'hFFFF]; // stay same if it has 2 neighbours\n\t\t\t\t3:  get_next_state = 1'b1; // becomes alive if it has 3 neighbours\n\t\t\t\tdefault: get_next_state = 1'b0; // dies otherwise\n\t\t\tendcase\n\t\tend\n\tendfunction\n\t\n\t// Update game state.\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse \n\t\t\tfor (int i=0; i<16; i++)\n\t\t\t\tfor (int j=0; j<16; j++)\n\t\t\t\t\tq[i][j] <= get_next_state(i, j); // apply the rules to every cell in parallel\n\tend\nendmodule \n"}
{"task_id": "conwaylife", "completion": "\n\t// Neighbour count lookup table\n\treg [3:0] neighbour_count;\n\talways @(*) begin\n\t\tcase (q)\n\t\t\t// For each cell, calculate the number of its neighbours in a 16x16 toroid.\n\t\t\t16'b????_????_????_???? : ; // Fill this in with your own lookup logic for the neighbour count\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse \n\t\t\t// Based on the calculated neighbour count, update each cell's state.\n\t\t\t case (neighbour_count)\n\t\t\t\t2'b00 : ; // Fill in with your own logic for when neighbours = 2\n\t\t\t\t2'b01 : ; // neighbours = 3\n\t\t\t\t2'b10 : ; // neighbours = 4+\n\t\t\t\t2'b11 : ; \n\t\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\nreg [7:0] rows[15:0]; // Store each row of the game state \n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tfor (integer i = 0; i < 16; i = i + 1) begin\n\t\t\trows[i] <= data[(8*(i+1)-1)-:8]; // Load each row into a separate 8-bit register from the input data.\n\t\tend\n\tend else begin\n\t\tfor (integer i = 0; i < 16; i = i + 1) begin\n\t\t\tif(i > 0 && i < 15)begin\n\t\t\t\trows[i][7:0] <= {rows[(i-1)%16][0], rows[i][7:1], rows[(i+1)%16][0]}; // For each row, calculate the new state by wrapping to the other side of the grid.\n\t\t\tend else if(i == 0){\n\t\t\t\trows[i][7:0] <= {rows[15][0], rows[i][7:1], rows[(i+1)%16][0]}; // For row 0, calculate the new state by wrapping to the other side of the grid.\n\t\t\t} else if(i == 15){\n\t\t\t\trows[i][7:0] <= {rows[(i-1)%16][0], rows[i][7:1], rows[0][0]}; // For row 15, calculate the new state by wrapping to the other side of the grid.\n\t\t\t}\n\t\tend\n\t\tfor (integer i = 0; i < 16; i = i + 1) begin\n\t\t\tq[(8*(i+1)-1)-:8] <= rows[i]; // Convert the new state back into a 256-bit vector to output.\n\t\tend\n\tend\nend\n"}
{"task_id": "conwaylife", "completion": "\n\n\treg [15:0] neighbours; //to hold the count of alive neighbours\n\twire [7:0] row_mask[3:0]; \n\t//array to store masks for neighbour count calculation. Each mask has one bit set at position corresponding to cell being considered and its eight neighbours. For example, row_mask[1][3] = 8'b10010001 means that in the second row (second 16 cells of q), we are considering the fifth cell (at position 4) and its two left neighbour cells (positions 2 and 5).\n\tassign row_mask[0] = 8'hFF; //all ones\n\tassign row_mask[1] = {~q[15], ~q[13:9], q[7], ~q[6], q[5], ~q[4]};\n\tassign row_mask[2] = {q[0], ~q[15:8], 1'b0}; //the last bit is always zero as per toroid rule\n\tassign row_mask[3] = ~(q >> 16);\n\t\n\t//calculate the alive neighbour count for each cell in q using masking and shifting. The neighbours variable stores the result. \n\talways @* begin\n\t\tfor (int i=0; i<4; i++) begin //for each row, calculate the counts of live cells by AND-ing with corresponding masks and left shifting. Store in the array count[]\n\t\t\tneighbours[i] = |((q >> ((2 * i) + 16)) & row_mask[i]); \n\t\tend\n\tend\n\t//next state calculation for q using neighbours calculated above. A cell is live if it was alive and has 3 or more neighbors, else dead\n\tfor(genvar k=0;k<256;k++) begin:g_loop //for each cell in the grid\n         always @ (posedge clk) begin \n\t\t\tif (load) \n\t\t\t\tq[k] <= data[k];\n            else if((neighbours[(k>>4)]&(1<<(k&7))) == 0) \n                 q[k] <= 1'b0; //dead cell\n             else if ((neighbours[(k>>4)]&(1<<(k&7))) == 8'h2) \n                  q[k] <= q[k];//live but unchanged\n              else \n                  q[k] <= ~q[k];//become live or dead\n         end  \t\n       end\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n\treg [255:0] next; // temporary register to hold the new state of the game\n\twire [15:0] neighbor_counts; // 16-bit vector representing count of each cell's neighbors\n\tgenvar i, j;\n\tgenerate\n\t    for(i=0; i<4; i++) begin : rows\n\t        for(j=0; j<4; j++) begin : columns\n\t            // neighbor_counts calculation using a 3x3 window\n\t            assign neighbor_counts[16*i+j] = q[(16*(i-1)+j+16)%256] + // top left corner\n\t                                              q[(16*i+j+16)%256] +       // top middle\n\t                                              q[(16*(i+1)+j+16)%256] +   // bottom right corner\n\t                                              q[16*(i-1)+(j+1)%16] +  // left side, not corners and edges\n\t                                              q[16*i+(j+1)%16];       // right side, not corners and edges\n\t        end \n\t    end \n\tendgenerate\n\n\t// Next state calculation: apply the rules of the game to calculate new states for all cells simultaneously\n\tfor (genvar k=0; k<256; ++k) begin : calc_next\n\t    assign next[k] = ((neighbor_counts[k] == 3) || (neighbor_counts[k] == 2 && q[k])) ? 1'b1: 1'b0;\t\n\tend\n\n\t// Update on clock edge\n\talways @(posedge clk) begin\n\t    if (load)\n\t        q <= data;\n        else \n            q <= next; // update game state for next cycle.\n\tend\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\n\treg [255:0] nextState; // Temporary register to hold the state of the game at the next clock edge. \n\tgenvar i, j; // Generate variables for looping through the grid. \n\tgenerate\n\t\tfor (i=0; i<16; i++) begin : rows\n\t\t\tfor (j=0; j<16; j++) begin : cols\n\t\t\t\t// Calculates number of alive neighbours by summing neighbouring cells for each cell in the grid.\n\t\t\t\tinteger count = 0;\n\t\t\t\tif(i>0 && q[(i-1)*16+j]) \t\t\t\t\tcount = count + 1; // Top\n\t\t\t\tif((i+1)%16 != 0 && q[i*16+(j+1)%16]) \t\tcount = count + 1; // Right side of grid wraps around.\n\t\t\t\tif(i<15 && q[(i+1)*16+j]) \t\t\t\t\tcount = count + 1; // Bottom\n\t\t\t\tif((i>0 && j==0) || (i==15 && j==15))\t \tcount = count + 1; // Top left of grid wraps around.\n\t\t\t\tif(j>0 && q[i*16+j-1]) \t\t\t\t\tcount = count + 1; // Left side\n\t\t\t\tif((i==0 && j==15) || (i==15 && j==0))\t \tcount = count + 1; // Bottom right of grid wraps around.\n\t\t\t\tif(j<15 && q[i*16+j+1]) \t\t\t\t\tcount = count + 1; // Right side of grid\n\t\t\t\t// Game rules are applied to determine cell's state for the next clock edge.\n\t\t\t\talways @(posedge clk) begin\n\t\t\t\t\tif (load) begin\n\t\t\t\t\t\tnextState[i*16+j] <= data[i*16+j]; // Load initial game state from data at next clock edge.\n\t\t\t\t\tend else if (count <= 1 || count >= 4) begin\n\t\t\t\t\t\tnextState[i*16+j] <= 0; \t\t\t// Cell dies due to underpopulation or overcrowding.\n\t\t\t\t\tend else if (count == 3) begin\n\t\t\t\t\t\tnextState[i*16+j] <= 1; \t\t    // Cell becomes alive by reproduction.\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnextState[i*16+j] <= q[i*16+j]; \t// No change in cell state due to stasis (2 neighbours).\n\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tendgenerate\n\t// Register the next game state for every clock edge.\n\talways @(posedge clk) begin\n\t\tq <= nextState; \n\tend\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\nThe following Verilog code models the game of life. We will use a 16x16 toroid grid and count neighbours using modulo operation to wrap around at the edges. \n\n\treg [31:0] neighbour_cnt; // Counts neighbours in one dimension for simplicity\n\twire [255:0] neighbours, next_q;\n\t\n\t// Counting neighbours\n\tfor (genvar i = 0; i < 16; ++i) begin : count_neighbours \n\t    for (genvar j = 0; j < 16; ++j) begin : count_line_neighbours\n\t        for(genvar k = -1; k <= 1; ++k) begin : count_column_neighbours\n\t            always @* begin\n\t                if ((i+k)<0)  neighbour_cnt[((i+k+16)%16)*16 + j] += q[(i % 16)*16 + (j-1 + 16)%16]; // Wrap to right of toroid\n\t                else if ((i+k)==16) neighbour_cnt[((i+k)%16)*16 + j] += q[(i % 16)*16 + (j-1 + 16)%16]; // Wrap to left of toroid\n\t                else neighbour_cnt[((i+k)%16)*16 + j] += q[(i + k)*16 + (j-1 + 16)%16]; \n\t            end\n\t        end  \n\t    end\n\tend    \n\t// Process neighbours count to get the final state\n\tfor(genvar i=0;i<256;++i) neighbours[i] = neighbour_cnt[(i+1)%256]; // Wrap at edges\n\tassign next_q = ~neighbours & (neighbours >> 1); // Count 3 and more neighbours as live cell\n\t\t\n\t// Clocked process to update the game state\n\talways @(posedge clk) begin\n\t    if (load) q <= data;\n\t    else q <= next_q;\n\tend   \nendmodule  \n"}
{"task_id": "conwaylife", "completion": "\n\t// In order to solve this problem, we need to define a function countNeighbors that counts the number of alive neighbors for a given cell. \n\tfunction [31:0] countNeighbors;\n\t\tinput [255:0] cells;\n\t\tinput [47:0] coords; // Row and column coordinates of the cell we want to check\n\t\t\n\t\t// We define the size of our grid (16x16 in this case)\n\t\tlocalparam SIZE = 16; \n\t\t\n\t\tinteger i, j, count = 0;\n\t\tbegin\n\t\t\tfor(i=-1; i<2; i++) begin // Check cells above and below the current cell\n\t\t\t\tfor(j=-1; j<2; j++) begin // Check cells to the left and right of the current cell\n\t\t\t\t\t// If we are not looking at the current cell itself...\n\t\t\t\t\tif(!(i == 0 && j == 0)) begin \n\t\t\t\t\t\t// Compute the coordinates of the neighbor cell, wrapping around if necessary.\n\t\t\t\t\t\tinteger x = (coords[6:0] + i) % SIZE;\n\t\t\t\t\t\tinteger y = (coords[13:7] + j) % SIZE;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Count the alive neighbors by summing up all corresponding bits in the cells vector.\n\t\t\t\t\t\tif(cells[(y * 16 + x)] == 1'b1) // If the neighbor is alive\n\t\t\t\t\t\t\tcount = count + 1;\n\t\t\t\t\tend\n\t\t\t\t});\n\t\t\tend\n\t\treturn count;\n\tendfunction\n\n\t// This function returns a new state for a single cell. \n\tfunction [0:0] nextState;\n\t\tinput [31:0] neighborsCount, currentState;\n\t\t\n\t\tif(currentState == 2'b00 && neighborsCount == 3) // If the cell is dead and has exactly 3 alive neighbours...\n\t\t\treturn 1'b1; // The new state of the cell is 'alive'.\n\t\telse if(neighborsCount < 2 ||  neighborsCount > 3) // If there are less than 2 or more than 3 live cells in a Moore neighborhood (not including the current cell)...\n\t\t\treturn 1'b0; // The new state of the cell is 'dead'.\n\t\telse \n\t\t\treturn currentState;\n\tendfunction\n\t\n\t// We can then write our sequential logic. At every clock edge, we will calculate a new vector where each bit represents the next state for its corresponding cell.\n\talways @(posedge clk) begin\n\t\tif (load == 1'b1) \n\t\t\tq <= data; // Load the initial game state from data if load is high\n\t\telse begin \n\t\t\t// Calculate new game state by applying our rules to each cell.\n\t\t\tfor (integer i = 0; i < 256; i = i + 1)\n\t\t\t\tq[i] <= nextState(countNeighbors(q, i), q[i]);\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\nreg [15:0] tmp;\nalways @ (posedge clk) begin \n\tif(load == 1'b1)begin\n        for(integer i=0;i<4;i++)begin\n            q[((i+1)*16)-1:(i*16)] <= data[(i+1)*16-1:i*16];\t\n\t    end\n    end \t\t\n\telse begin  \t\n        for(integer j=0;j<256;j++)begin\n            if (j%16 == 0)\n                tmp <= ~q[(j+15)%256] & q[(j+17)&255];  // Neighbours on right side of grid.\n\t\t\telse  \n                tmp <= ~q[(((j-1)%256) + 15) % 256 ] & q[(((j-1)%256) + 17 )& 255]; // Neighbours on left side of grid.\n\t\t\tend\n\t    for (integer i=0;i<256;i++)begin  \n            if ((tmp[$clog2(q)-1:0] == 3'b0 || tmp[$clog2(q)-1:0]== 3'b1)) q[i] <= (~q[i])|(((tmp[$clog2(q)-1:0] == 3'b0) |( tmp[$clog2(q)-1:0] == 3'b1 )) & ((tmp[$clog2(q)-1:0] != 3'b2)));\n            else if (tmp[$clog2(q)-1:0]>=4) q[i] <= ~q[i];  \t\t// Any number of live neighbours.\n\t\t  end       \n\t    end\t\t\t\nend\n\n"}
{"task_id": "conwaylife", "completion": "\n\treg [15:0] neighborSum; // holds sum of neighbour cells' states for each cell in row \n\twire [15:0] neighborSumToroid; // wraps around to toroid grid by connecting ends\n\tassign neighborSumToroid = {neighborSum[7:0], neighborSum[15:8]};\n\t\t\n\t// calculate neighbour sum\n\tfor(genvar i = 0; i < 256; i++) begin : calc_sums // 4 nested loops to iterate over each cell in grid, calculating their neighbour's state sums\n\t\talways @ (posedge clk or posedge load) begin\n\t\t\tif(load) neighborSum[i/16] <= data[(i+15)%256 + i/16*16];  // if loading initial state, calculate sum for current row's cell from loaded data\n\t\t\telse if (i%16 == 0 ) begin   // wrap around to next row on reaching last column in current row\n\t\t\t\tneighborSum[i/16] <= neighborSumToroid[(i+15)%256 + i/16*16];  // else calculate sum for next row's cell based on previous row's neighbour sums (wrapped around toroid)\n\t\tend \n\t\tend\n\tend  \n    \n\t// calculate new state of cells\n\tfor(genvar i = 0; i < 256; i++) begin : calc_state // 4 nested loops to iterate over each cell in grid, calculating their new state based on neighbour's sums\n\t\talways @ (posedge clk or posedge load) begin\n\t\t\tif(load) q[i] <= data[i];  \t// if loading initial state, copy current state of cell from loaded data \n\t\t\telse if((neighborSumToroid[(i+15)%256 + i/16*16])==3'b0 || (q[i-16] && (neighborSumToroid[(i+14)%256 + i/16*16])) ) q[i] <= 1'b1; // if less than 2 neighbours or 3 neighbours then live\n\t\t\telse q[i] <= 1'b0;  \t// else dead\n\t\tend\n    end    \n\t\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n    always_comb begin\n        // two input XNOR gate\n        var logic xnor_out;\n        xnor_out = ~(in1 ^ in2);\n        \n        // two input XOR gate\n        out = in3 ^ xnor_out;\n    end\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n    always @(in1 or in2 or in3) begin\n\t    out <= ~(in1 ^ in2) ^ in3;\n\tend\n    \nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n     always @(*) begin\n         out <= ~(in1 ^ in2) ^ in3;\n     end\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n\n\tassign out = ~(in1 ^ in2) ^ in3;\nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n\t// Assuming that 'xnor' and 'xor' are the built-in Verilog operators for XNOR and XOR respectively.\n\tassign xnor_out = ~(in1 ^ in2);\n\tassign out = xnor_out ^ in3;\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n\tassign out = (in1 ~^ in2) ^ in3; // XNOR of in1 and in2 is then XOR with in3 \nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n\n\t// Two-input XNOR gate connected to the input of a two-input XOR circuit. \n\t// This is equivalent to an exclusive OR (XOR) where in1 == in2. \n\tassign #(in1 == in2 ? out = in3 : out = !in1 ^ in3);\n\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\nassign out = ^(in1 ~^ in2 ^ in3);\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n\n\tassign out = (~(in1 ^ in2)) ^ in3;  // XNOR operator is ~(A=B) and XOR operator is A^B.\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n  always @(*) begin\n    if (!(in1 ^ in2)) \n      out = in3;\n   else \n     out = 0;\n end\nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n    \n\tassign out = in3 ^ ~(in1 ~^ in2);   //XNOR and XOR operations in Verilog are represented by '~^' and '^' respectively.\nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n\t// Two-input XNOR gate\n\tfunction xnor;\n\t\txnor = !(in1 ^ in2);\n\tendfunction\n\t\n\t// Two-input XOR gate\n\tfunction xor;\n\t\txor = in1 ^ in2;\n\tendfunction\n\t\n\t// Assignments of output 'out' from the XOR function on inputs \n\tassign out = xor(xnor(),in3);\n\t\t\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n    always @(in1 or in2 or in3) begin\n    \tout = (~in1 ~^ in2) ^ in3;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n    \n\tassign #1 in1_xnor = in1 ^ in2; // XNOR of inputs 1 and 2\n    assign #1 xor_out = ~(in_xnor | ~in3); // XOR of the result with input 3\n    assign out = xor_out; // Output is the result of the previous line.\n\t\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n\t// Two input XNOR\n\tfunction xnor_func;\n\t  begin\n\t    xnor_func = !(in1 ^ in2);\n\t  end\n\tendfunction\n      \n\talways @* begin\n\t   // The two-input XOR operation\n\t   out = xnor_func() ^ in3;\n\tend \n\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n\tassign out = in1 ^ ((~in1 & ~in2) | (in1 & in2));\nendmodule\n\n"}
{"task_id": "m2014_q4g", "completion": "\n\tassign out = (in1 ~^ in2) ^ in3;\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\n\tassign out = ~(in1 ^ in2) ^ in3;\nendmodule \n\n"}
{"task_id": "m2014_q4g", "completion": "\n\tlogic xnorOut; //internal output of the two input XNOR gate\n\talways @(*) begin \n\t\txnorOut = ~(in1 ^ in2); // calculate output for XNOR\n\tend\n\tassign out = (xnorOut ^ in3); //calculate output for XOR by using internal output of the two input XNOR gate as one input\n"}
{"task_id": "m2014_q4g", "completion": "\n\t// Two-input XNOR gate implementation\n\tfunction logic xnor2;\n\t    input a, b;\n\t    return ~(a ^ b);\n\tendfunction\n\t\n\t// Two-input XOR gate implementation\n\tfunction logic xor2;\n\t    input a, b;\n\t    return (a ^ b);\n\tendfunction\n\n\tassign out = xor2((xnor2(in1, in2)), in3);\n    \nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\n\treg [2:0] state;\n\talways @(*) begin\n\t    case (state)\n\t\t    3'b001:  z = ~y & ~x;\n\t\t    3'b010:  z = y;\n\t\t    3'b100:  z = x;\n\t\t    default: z = 1'bx;\n\t    endcase\n\tend\n\talways @(posedge x, posedge y) begin\n\t    case ({x,y})\n\t\t    2'b01: state <= 3'b001;\n\t\t    2'b10: state <= 3'b100;\n\t\t    2'b11: state <= 3'b010;\n\t    endcase\n\tend \nendmodule\n\n"}
{"task_id": "mt2015_q4b", "completion": "\n\n\twire w;\n    \n\tassign z = (x | y) & ~w;\n\tassign w = x ^ y;  // asynchronous reset of w\nendmodule\n\n"}
{"task_id": "mt2015_q4b", "completion": "\nassign #5 z = ~x & (y | ~z) | x;\nendmodule\n\n"}
{"task_id": "mt2015_q4b", "completion": "\n\n\tassign z = (~x & ~y) | (x & ~y) | (~x & y) | (x & y); \nendmodule\n\n"}
{"task_id": "mt2015_q4b", "completion": "\n\n\treg [2:0] state;\n\talways @(*) begin\n\t\tcase ({x,y}) \n\t\t\t2'b00 : state <= 3'b100;\n\t\t\t2'b01 : state <= 3'b001;\n\t\t\t2'b10 : state <= 3'b010;\n\t\t\t2'b11 : state <= 3'b100;\n\t\tendcase\n\tend\n\tassign z = state[2];\nendmodule \n"}
{"task_id": "mt2015_q4b", "completion": "\n    reg a,b;\n   assign z = (~x & ~y & b) | (x & ~a & ~b);\n   always @(posedge x or posedge y) begin \n      a <= x;\n      b <= y;\n   end\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\treg [1:0] state;\n\talways @(*) begin\n\t\tcase ({x,y}) \n\t\t\t2'b00: begin //state = 0\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\t\tz <= 0; end\n\t\t\t2'b01: begin //state = 1\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tz <= 0; end \n\t\t\t2'b10: begin //state = 2\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\tz <= 1; end\n\t\t\t2'b11: begin //state = 3\n\t\t\t\t\tif (y==x) begin\n\t\t\t\t\t\t//remain in state 3\n\t\t\t\t\t\tstate <= 2'b11;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\t//go to state 0\n\t\t\t\t\t\tstate <= 2'b00;\n\t\t\t\t end\n\t\t     z <= (state == 2'b10)? 1:0; // z output is based on current state, if state = 2 then z=1 else z=0\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\twire [2:0] state;\n\n\t// State transition diagram:\n\t//   state[0]: 0->0->1->1->0->0->1->1->... (periodic pattern)\n\t//   state[1]: 0->1->1->0->0->0->0->... (same as above, but shifted by one bit)\n\t//   state[2]: 1->1->0->0->0->1->1->... (invert of above)\n\tassign state = {x, y, ~(state[0] ^ state[1])};\n    \n    // Output depends on the final state:\n\tassign z = ~((state[2] && state[1]) || (!state[1] && state[0])); \nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\t// z = (x' + y')'\n\tassign z = ~(~x + ~y);\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\nreg [2:0] state; //state machine to track the state of X and Y.\n  \nalways @(*) begin \n\tcase ({y,x}) \n\t\t2'b11 : state <= 3'b001;\n\t\t2'b10 : state <= 3'b011;\n\t\t2'b01 : state <= 3'b111;\n\t\tdefault: state <= 3'b000; \n\tendcase\nend\n\nassign z = (state == 3'b011) || (state == 3'b111); //z is true when the current state is either 011 or 111.\n  \nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\n    reg tmp;\n    \n\t// Output Z is the XOR of Temp and Y.\n    assign z = tmp ^ y; \n\t \n    always @(posedge x or posedge y) begin\n        if (y == 1'b0 && $past(x) == 1'b1 || y == 1'b1 && $past(x) == 1'b0 ) // If Y changes and X is changing in the same clock cycle.\n            tmp <= ~tmp; \t// Toggle the value of temp\n    end\t  \nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n    reg temp;\n    \n\talways @ (x or y) begin\n\t    #5ns temp = x ^ y;  // asynchronous reset\n        #5ns $display(\"%d\\t%d\\t%b\",$time,temp,temp);\n\tend\n    assign z = temp;\nendmodule\n\n"}
{"task_id": "mt2015_q4b", "completion": "\n\n\treg [2:0] state; // State variable to hold the current states of x and y.\n\t\n\t// Transition table for Moore machine (State change based on input).\n\talways @(*) begin\n\tcase({x,y})\n\t\t2'b00 : state <= 3'b111;\n\t\t2'b01 : state <= 3'b000;\n\t\t2'b10 : state <= 3'b010;\n\t\t2'b11 : state <= 3'b001;\n\t\tdefault: state <= 3'bx; // Indicate an unknown state.\n\tendcase\n\tend\n\t\n\t// Output logic (What is the output based on the current state).\n\tassign z = (state == 3'b000) ? 1'b0 : 1'b1;\n\t\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\treg [2:0] state = 3'b100; // Initial state is 100 in binary\n\n\talways @* begin\n\t\tcase ({y,x})\n\t\t\t2'b00: state <= 3'b100; // State remains the same on 00 input\n\t\t\t2'b01: state <= 3'b001; // State transitions to 001 on 01 input\n\t\t\t2'b10: state <= 3'b010; // State transitions to 010 on 10 input\n\t\t\tdefault: state <= 3'b100; // State returns to 100 for any other inputs\n\tend\n\tassign z = (state == 3'b100); // Output is '1' if the current state is 100, else it is '0'\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\nreg [2:0] state;\n\talways @(*) begin\n\tcase (state) \n\t\t3'b001: if (x==0 && y==0) state <= 3'b001; else if (x==0 && y==1) state <= 3'b010; else state <= 3'b000; //Z=1\n\t\t3'b010: if (x==0 && y==0) state <= 3'b010; else if (x==0 && y==1) state <= 3'b001; else state <= 3'b011; //Z=0\n\t\t3'b011: if (x==0 && y==0) state <= 3'b011; else if (x==0 && y==1) state <= 3'b100; else state <= 3'b101; \n\t\t3'b100: if (x==0 && y==0) state <= 3'b100; else if (x==0 && y==1) state <= 3'b111; else state <= 3'b100; //Z=0\n\t\t3'b101: if (x==0 && y==0) state <= 3'b101; else if (x==0 && y==1) state <= 3'b011; else state <= 3'b110; \n\t\t3'b110: if (x==0 && y==0) state <= 3'b110; else if (x==0 && y==1) state <= 3'b101; else state <= 3'b000; //Z=1\n\t\t3'b111: if (x==0 && y==0) state <= 3'b111; else if (x==0 && y==1) state <= 3'b010; else state <= 3'b001; \n\tendcase\n\tend\n\tassign z = (state == 3'b111 || state == 3'b000); //when in these states, output Z is true\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n    \n    reg a;\n    always @* begin\n        case ({x,y})\n            2'b00: begin \n                z = 1'b1;\n                a = x;\n            end\n            2'b01: begin \n                z = 1'b0; \n                a = y;\n            end\n            2'b10: begin \n                z = 1'b0; \n                a = x; \n            end\n            2'b11: begin \n                z = ~a;\n                a = y;\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\n\t// We can describe the state change of Z by a series of if-statements.\n\tassign z = (x==0 && y==1) || \n\t\t  (y==1 && ~(x==0)) ||\n\t\t  (x==0 && ~(y==1));\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\treg [2:0] state;\n\tparameter PARAM = 3'b101; // PARAM is a 3-bit parameter of the system. Initialized as 101 in this example.\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t3'd0: if (!x & !y) state <= 3'd0; else state <= PARAM[2] ? 3'd5 : 3'd4;\n\t\t\t3'd1: if ( x & !y) state <= 3'd1; else state <= PARAM[1] ? 3'd6 : 3'd7;\n\t\t\t3'd2: if (!x &  y) state <= 3'd2; else state <= PARAM[0] ? 3'd8 : 3'd0;\n\t\t\t3'd3: if ( x &  y) state <= 3'd3; else state <= PARAM[1] ? 3'd6 : 3'd5;\n\t\t\t3'd4: if (!x & !y) state <= 3'd4; else state <= PARAM[2] ? 3'd8 : 3'd7;\n\t\t\t3'd5: if ( x & !y) state <= 3'd5; else state <= PARAM[0] ? 3'd1 : 3'd2;\n\t\t\t3'd6: if (!x &  y) state <= 3'd6; else state <= PARAM[0] ? 3'd4 : 3'd3;\n\t\t\t3'd7: if ( x &  y) state <= 3'd7; else state <= PARAM[1] ? 3'd2 : 3'd1;\n\t\t\t3'd8: if (!x & !y) state <= 3'd0; // Back to initial state.\n\t\tendcase\n\tend\n\tassign z = (state == 3'd8);   // When the machine reaches final state, output 'z'.\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\twire w;\n\n\t// state transition diagram\n\tassign w = (~x & ~y) | (x & y);\n\tassign z = ~w;\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\n\twire a = x & ~y;\n\twire b = ~x | (y & z);\n\tassign #5 z = a | b;\nendmodule\n\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [2:0] state;\n\tassign z = (state == 3'b101) ? 1'b1 : 1'b0; // output is '1' when in state 'E', else '0'\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tstate <= 3'b000; //initial state is A\n\t\telse \n\t\t\tcase (state)\n\t\t\t\t3'b000: state <= w ? 3'b100 : 3'b000; // from A to B or remain in A if 'w' = 0\n\t\t\t\t3'b001: state <= w ? 3'b101 : 3'b000; // from B to C or remain in A if 'w' = 0\n\t\t\t\t3'b010: state <= w ? 3'b101 : 3'b001; // from C to E or from E to D if 'w'=0/1 respectively\n\t\t\t\t3'b011: state <= w ? 3'b100 : 3'b001; // from D to F or remain in E if 'w' = 0\n\t\t\t\t3'b100: state <= w ? 3'b101 : 3'b010; // from F to C or from C to D if 'w'=0/1 respectively\n\t\t\t\tdefault: state <= 3'b000; // in any other case go back to A (Default)\n\t\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\t// Declare the states\n\ttypedef enum {A=0, B=1, C=2, D=3, E=4, F=5} state_t;\n\tstate_t current_state, next_state;  // State variables\n\n\t// Synchronous process\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tcurrent_state <= A;   // Asynchronous reset to initial state\n\t\telse \n\t\t\tcurrent_state <= next_state;  // Update current state on clock cycle\n\tend\n\n\t// Next State Decoding Process\n\talways @(*) begin \n\t    case (current_state)\n\t        A: next_state = w ? E : A;\n\t        B: next_state = w ? A : C;\n\t        C: next_state = w ? E : D;\n\t        D: next_state = w ? F : A;\n\t        E: next_state = w ? E : D;\n\t        F: next_state = w ? C : D;\n\t    endcase\n\tend\n\t \n\t// Output Processing \n\tassign z = (current_state == E);\nendmodule\n\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [2:0] state;\n\t\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 3'b000; // start at A\n\t\telse \n\t\t\tcase ({w, state[2], state[1:0]})  \n\t\t\t\t5'b0_0000: state <= 3'b001; // w=0, state=A -> B\n\t\t\t\t5'b1_0000: state <= 3'b000; // w=1, state=A -> A\n\t\t\t\t5'b0_0001: state <= 3'b011; // w=0, state=B -> C\n\t\t\t\t5'b1_0001: state <= 3'b010; // w=1, state=B -> D\n\t\t\t\t5'b0_0010: state <= 3'b100; // w=0, state=C -> E\n\t\t\t\t5'b1_0010: state <= 3b011;  // w=1, state=C -> D\n\t\t\t\t5'b0_0011: state <= 3'b110; // w=0, state=D -> F\n\t\t\t\t5'b1_0011: state <= 3'b000; // w=1, state=D -> A\n\t\t\t\t5'b0_0100: state <= state;  // w=0, state=E -> E (stay)\n\t\t\t\t5'b1_0100: state <= 3'b010; // w=1, state=E -> D\n\t\t\t\t5'b0_0101: state <= 3'b101; // w=0, state=F -> C\n\t\t\t\t5'b1_0101: state <= 3'b010; // w=1, state=F -> D\n\t\t\t\tdefault:   state <= state;  // no change\n\t\t\tendcase\n\tend\n\t\n\t// Output logic (z depends on current state)\n\tassign z = state[2];\n\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [3:0] state;\n\twire next_state;\n\tassign z = (state == 4'h5 || state== 4'h7);\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 4'b0001; // A State\n\t\telse case (state)\n\t\t\t4'h0: next_state = w ? 4'h5 : 4'h1; // A\n\t\t\t4'h1: next_state = w ? 4'h0 : 4'h2; // B\n\t\t\t4'h2: next_state = w ? 4'h6 : 4'h3; // C\n\t\t\t4'h3: next_state = w ? 4'h4 : 4'h1; // D\n\t\t\t4'h4: next_state = w ? 4'h5 : 4'h7; // E\n\t\t\t4'h6: next_state = w ? 4'h0 : 4'h3; // F\n\t\t\tdefault: state <= 4'b0001;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\nreg [2:0] currentState;\nparameter A = 3'b000;\nparameter B = 3'b001;\nparameter C = 3'b010;\nparameter D = 3'b011;\nparameter E = 3'b100;\nparameter F = 3'b101;\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tcurrentState <= A;\n\telse\n\tcase(currentState)\n\tA: if (!w) currentState <= B; else currentState <= A;\n\tB: if (!w) currentState <= C; else currentState <= D;\n\tC: if (!w) currentState <= E; else currentState <= D;\n\tD: if (!w) currentState <= F; else currentState <= A;\n\tE: if (!w) currentState <= E; else currentState <= D;\n\tF: if (!w) currentState <= C; else currentState <= D;\n\tdefault : currentState <= A;\n\tendcase\nend\nassign z = (currentState == F); // Output is 1 only when the state equals to 'F'\n\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [2:0] state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= 3'b001;\n        else \n            case(state)\n                3'b001: state <= w ? 3'b101 : 3'b010; // A --0--> B, A --1--> A\n                3'b010: state <= w ? 3'b011 : 3'b001; // B --0--> C, B --1--> D\n                3'b011: state <= w ? 3'b100 : 3'b010; // C --0--> E, C --1--> D\n                3'b100: state <= w ? 3'b100 : 3'b001; // D --0--> F, D --1--> A\n                3'b101: state <= w ? 3'b101 : 3'b011; // E --0--> E, E --1--> D\n                default: state <= 3'b001;              // F --0--> C, F --1--> D\n            endcase\n    end\n    \n    assign z = (state == 3'b100); \nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [2:0] state;\n   assign z = (state==3'b111) ? 1 : 0; // setting the output as per requirement\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= 3'b000;\t// Setting initial state as 'A'.\n       else\n           case(state) \n              3'b000: state <= w ? 3'b010 : 3'b001; // State Transitions\n              3'b001: state <= w ? 3'b000 : 3'b011;\n              3'b010: state <= w ? 3'b100 : 3'b000;\n              3'b011: state <= w ? 3'b010 : 3'b000;\n              3'b100: state <= w ? 3'b101 : 3'b000;\n              3'b101: state <= w ? 3'b011 : 3'b000;\n              3'b110, 3'b111: state <= 3'b000;   // All other states will go to 'A'.\n           endcase\n    end\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [2:0] state;\n\tassign z = state[0];\n\t\n\t//State machine\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 3'b000; // A State\n\t\telse \n\t\t\tcase ({w,state}) \n\t\t\t\t4'b1000: state <= 3'b000; // from B to A\n\t\t\t\t4'b1001: state <= 3'b001; // from B to C\n\t\t\t\t4'b1010: state <= 3'b011; // from C to E \n\t\t\t\t4'b1011: state <= 3'b010; // from C to D\n\t\t\t\t4'b1100: state <= 3'b010; // from D to E\n\t\t\t\t4'b1101: state <= 3'b011; // from D to F\n\t\t\t\t4'b1110: state <= 3'b100; // from E to B\n\t\t\t\t4'b1111: state <= 3'b000; // from F to A\n\t\t\t\tdefault:  state <= state;\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\t// Declare states as 4-bit binary values\n\treg [2:0] state;\n\n\t// State machine process\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n\t        state <= 3'b000;   // A initial state\n\t    else\n    \t\tcase (state) \n        \t\t3'b000: if (!w) state <= 3'b010; // from A to B on 0\n            \t\t\t\telse state <= 3'b000; // from A to A on 1\n        \t\t3'b001: if (!w) state <= 3'b001; // from B to C on 0\n            \t\t\t\telse state <= 3'b010; // from B to D on 1\n        \t\t3'b010: if (!w) state <= 3'b011; // from B to E on 0\n            \t\t\t\telse state <= 3'b000; // from B to A on 1\n        \t\t3'b011: if (!w) state <= 3'b010; // from C to D on 0\n            \t\t\t\telse state <= 3'b010; // from C to E on 1\n        \t\t3'b100: if (!w) state <= 3'b101; // from D to F on 0\n            \t\t\t\telse state <= 3'b000; // from D to A on 1\n        \t\t3'b101: if (!w) state <= 3'b110; // from E to C on 0\n            \t\t\t\telse state <= 3'b001; // from E to B on 1\n        \t\t3'b110: if (!w) state <= 3'b000; // from F to A on 0\n            \t\t\t\telse state <= 3'b001; // from F to B on 1\n\t      \tendcase\n  \tend\n\t\n\t// Output process\n\tassign z = (state == 3'b010) ? 1'b1 : 1'b0; // z equals 1 if we are in state E, else it equals zero\n\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [2:0] state; // 3 bit state machine\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)\n\t\t\tstate <= 3'd0; // Reset to initial state A\n\t\telse\n\t\t\tcase ({state[2], w}) // Combinational logic to determine next state \n\t\t\t\t2'b00: state <= 3'd1;   // B -> C if w = 0 \n\t\t\t\t2'b01: state <= 3'd4;   // B -> E if w = 1 \n\t\t\t\t2'b10: state <= 3'd6;   // A -> F if w = 0 \n\t\t\t\t2'b11: state <= 3'd7;   // A -> D if w = 1 \n\t\t\tendcase\n\tend\n\n\t// Output logic, depending on the current state \n\tassign z = (state == 3'd5) ? 1'b0 : 1'b1; // z is high in states B and C, low in E and F\n\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n   reg [3:0] state;  // Define the states as a 4-bit register\n\n   always @(posedge clk or posedge reset) begin \n      if (reset == 1'b1) // Asynchronous active high reset\n         state <= 4'd0; // Reset to A state\n      else\n        case(state)\n          4'd0: state <= w ? 4'd0 : 4'd1; // A goes to B if w = 1, stays at A if w =0\n          4'd1: state <= w ? 4'd2 : 4'd0; // B goes to C if w = 1, goes to A if w = 0\n          4'd2: state <= w ? 4'd3 : 4'd5; // C goes to E if w=1, F if w =0\n          4'd3: state <= w ? 4'd7 : 4'd4; // D goes to H if w = 1, G if w= 0\n          4'd4: state <= w ? 4'd7 : 4'd5; // E goes to H if w=1, F if w =0\n          4'd5: state <= w ? 4'd2 : 4'd6; // F goes to C if w=1, D if w = 0\n          4'd6: state <= w ? 4'd3 : 4'd0; // G goes to H if w=1, A if w =0\n          4'd7: ;                          // State remains at H\n        endcase\n   end\n   \n   assign z = (state == 4'd2) || (state == 4'd3) || (state ==4'd7);  // Z = 1 only when we are in states C,E or F\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [3:0] state;\n\tassign z = (state == 4'b1100) | (state == 4'b0000);  //Output 'z' is asserted if state is C or F.\n\n\talways @(posedge clk, posedge reset) begin\n    \tif (reset) \n        \tstate <= 4'b0000;\t//Reset to initial state A\n    \telse case ({w,state[2]})\n\t\t   \t2'b00: state <= 4'b0001; //Transition from A to B\n      \t\t2'b01: state <= 4'b0000; //Stay at A\n     \t\t2'b10: state <= 4'b0110; //Transition from B to C\n       \t\t2'b11: state <= 4'b0101; //Transition from B to D\n      \tendcase\n  \tend \nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\t// Define the states\n\tparameter [2:0] A = 3'b001;\n\tparameter [2:0] B = 3'b010;\n\tparameter [2:0] C = 3'b011;\n\tparameter [2:0] D = 3'b100;\n\tparameter [2:0] E = 3'b101;\n\tparameter [2:0] F = 3'b110;\n\t\t  \n\t// Declare the state variable\n\treg [2:0] current_state, next_state;\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (current_state) \n\t\t\tA : if (!w) next_state = B;\n\t\t\t\telse    next_state = A;\n\t\t\tB : if (!w) next_state = C;\n\t\t\t\telse    next_state = D;\n\t\t\tC : if (!w) next_state = E;\n\t\t\t\telse    next_state = D;\n\t\t\tD : if (!w) next_state = F;\n\t\t\t\telse    next_state = A;\n\t\t\tE : if (!w) next_state = E;\n\t\t\t\telse    next_state = D;\n\t\t\tF : if (!w) next_state = C;\n\t\t\t\telse    next_state = D;\n\t\t\tdefault :   next_state = A;  // default state\n\t\tendcase\n\tend\n\t\n\t// Output logic\n\tassign z = (current_state == E);\n\t\n\t// State register\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) current_state <= A;\n\t\telse       current_state <= next_state;\n\tend\n\t\nendmodule  // top_module\n"}
{"task_id": "m2014_q6", "completion": "\n    reg [2:0] state;\n    \n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n\tassign z = (state == E || state == F) ? 1 : 0;\n        \n    always @(posedge clk or posedge reset) begin\n        if(reset)\n            state <= A;\n        else\n            case (state)\n                A: state <= w ? B : A;\n                B: state <= w ? C : D;\n                C: state <= w ? E : F;\n                D: state <= w ? D : A;\n                E: state <= w ? E : D;\n                F: state <= w ? C : D;\n            endcase\n    end\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\t// Internal states declaration\n\treg [2:0] currentState; \n\n    // State definition\n    parameter A = 3'b000;\n    parameter B = 3'b001;\n    parameter C = 3'b010;\n    parameter D = 3'b011;\n    parameter E = 3'b100;\n    parameter F = 3'b101;\n\t  \n\t// Synchronous state transition\n\talways @ (posedge clk or posedge reset)  begin\n\t    if(reset == 1'b1)\n\t\t    currentState <= A; // Reset to State A\n        else case(currentState)\n            A: if(w==0) currentState <= B; else currentState <= A;\n            B: if(w==0) currentState <= C; else currentState <= A;\n            C: if(w==0) currentState <= E; else currentState <= D;\n            D: if(w==0) currentState <= F; else currentState <= A;\n            E: if(w==0) currentState <= E; else currentState <= D;\n            F: if(w==0) currentState <= C; else currentState <= D;\n\t\t\tdefault : ; // default case, nothing happens. \n        endcase\n    end  \n    \n\t// Outputs assignment\n    assign z = (currentState == E); \nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\nreg [2:0] current_state; // define the state as 3 bit binary number for state A = 000, B =001, C=010 and so on.\n\tassign z = (current_state==3'b111); // assign output Z as high when current state is F i.e., 111\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) // if reset = 1, go back to initial/start state A = 000\n\t\t\tcurrent_state <= 3'b000;\n\t\telse // otherwise keep changing the states based on input w\n\t\t\tcase(current_state) \n\t\t\t\t3'b000: current_state <= w ? 3'b001 : 3'b000;\n\t\t\t\t3'b001: current_state <= w ? 3'b010 : 3'b000;\n\t\t\t\t3'b010: current_state <= w ? 3'b110 : 3'b011;\n\t\t\t\t3'b011: current_state <= w ? 3'b010 : 3'b000;\n\t\t\t\t3'b110: current_state <= w ? 3'b111 : 3'b011;\n\t\t\t\t3'b111: current_state <= w ? 3'b111 : 3'b000;\n\t\t\t\tdefault: current_state <= 3'b000;\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [3:0] state;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 4'h0; // A\n\t\telse \n\t\t\tcase (state)\n\t\t\t\t4'h0 : state <= w ? 4'h5 : 4'h1; // B if w==0, A if w==1\n\t\t\t\t4'h1 : state <= w ? 4'h2 : 4'h0; // C if w==0, B if w==1\n\t\t\t\t4'h2 : state <= w ? 4'h3 : 4'h4; // E if w==0, D if w==1\n\t\t\t\t4'h3 : state <= w ? 4'h5 : 4'h1; // F if w==0, A if w==1\n\t\t\t\t4'h4 : state <= w ? 4'h2 : 4'h0; // C if w==0, B if w==1\n\t\t\t\t4'h5 : state <= w ? 4'h3 : 4'h4; // E if w==0, D if w==1\n\t\t\tendcase\n\tend\n\tassign z = (state == 4'h2 | state == 4'h3); // output is high when at states C or E\n"}
{"task_id": "m2014_q6", "completion": "\n    reg [3:0] state;\n    \n    parameter A = 4'b0000, B = 4'b0001, C = 4'b0010, D = 4'b0011, E = 4'b0101, F = 4'b1001;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= A;\n        else\n            case (state)\n                A:   state <= w ? E : A;\n                B:   state <= w ? C : D;\n                C:   state <= w ? F : E;\n                D:   state <= w ? A : D;\n                E:   state <= w ? E : D;\n                F:   state <= w ? C : D;\n            endcase\n    end \n    \n    assign z = (state == B) | (state == E);\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\n\treg [2:0] state;\n\n\talways @(posedge clk or posedge reset) begin \n\t\tif(reset)\n\t\t\tstate <= 3'b001;   // initialize the state to 'A'\n        else\n        \tcase ({w,state[2], state[1:0]})      \n            \t3'b000 : state <= 3'b001;      // from A to B when w = 0 \n                3'b001 : state <= 3'b001;      // remain in A when w = 0   \n                3'b010 : state <= 3'b011;      // from B to C when w = 0  \n                3'b011 : state <= 3'b011;      // remain in B when w = 0 \n                3'b100 : state <= 3'b101;      // from C to E when w = 0   \n                3'b101 : state <= 3'b101;      // remain in E when w = 0  \n                3'b110 : state <= 3'b110;      // from D to F when w = 0 \n                3'b111 : state <= 3'b110;      // remain in F when w = 0 \n        \tendcase   \n        end  \n     assign z = (state == 3'b110);     // output z is high if current state is 'F'.\nendmodule\n\n"}
{"task_id": "m2014_q6", "completion": "\nreg [2:0] state; // 3 bit register to hold the state of the FSM.\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) // asynchronous reset\n\t\tstate <= 3'b000; // start from state A\n\telse\n\t\tcase ({w, state}) \n\t\t\t4'b0_000: state <= 3'b001; // from state A on w=0 to B\n\t\t\t4'b0_001: state <= 3'b100; // from state B on w=0 to C\n\t\t\t4'b0_011: state <= 3end <= 'b111';// D\n\t\t\t4'b0_110: state <= 3'b010; // E\n\t\t\t4'b0_100: state <= 3'b100; // F\n\t\t\t// default remains the same\n\t\tendcase\nend\nassign z = (state == 3'b001) || (state == 3'b110); \n// for states B and E, z = 1. In all other states z=0.\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((a&&c)||(b&&d)) || ((b&&c)||(a&&d));\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((~c) & d) | (b & (~d)) | ((~a) & (~d)) | ((~a) & b & c);\nendmodule \n\n// This implementation corresponds to the given Karnaugh map.\n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((a & ~b & ~c) | (~d & c & b ) | (~c & ~d));\nendmodule \n\n// Explanation:\n// The output is '1' only when the inputs satisfy one of the conditions indicated by the Karnaugh map. This gives us a simplified expression for the outputs in terms of the four input variables, which we can use to build our circuit.\n"}
{"task_id": "kmap2", "completion": "\n   assign out = ((a & b) | (c & ~d)) | (~b & d);\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\nassign out = ((~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (a & b & c & d) | (~a & b & c & ~d));\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\nassign out = ((a && (!b)&&d) || (c&&(!d)) || (b&&d));\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\n\tassign out = ((a&&c)||(b&&d)) || (!(a&&d) && !(b&&c));\nendmodule \n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((c & ~d) | (~a & ~b)) ^ (~(c & d));\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = (!a && !b && !c) || (!a && d && !c) || (d && !b && c) || (a && !d && b); \nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\nassign out = ((a || c) && (b || d)) || (!c && !d);\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((c || !d) && (!a || b)) || (b && c && d);\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = (b & ~c) | (~d & b) | d;\nendmodule\n"}
{"task_id": "kmap2", "completion": "\n\n\tassign out = ((a & ~b) & (c | d)) | ((~a & b) & (~c | d));\n\t\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\n\tassign out = ((a && !b) || (!c && d));\nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\nassign out = ((~a)&b)^c; // from the Karnaugh map equation.\nendmodule\n"}
{"task_id": "kmap2", "completion": "\n    assign out = ((~a & ~b & c) ^ (~d)) | (a & b & (c ^ d));\nendmodule\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = (b&d)|(a&~c&~d)|(~a&c&~b&d)|(~a&~b&~c&~d);\nendmodule \n"}
{"task_id": "kmap2", "completion": "\n    \n    assign out = ((a && !b) || (!c && d)) ? 1'b1 : 1'b0;\n      \nendmodule\n\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((~a) & b & (~c) & (~d)) | ((~a) & (~b) & c & d )|((a) &( ~b)  & (~c)& d) |((a)& b&(~c) & (~d));\nendmodule\n"}
{"task_id": "kmap2", "completion": "\n\tassign out = ((~c) & a & (b | ~d)) | (c & ~a & ~(b ^ d));\nendmodule\n\n"}
{"task_id": "always_case2", "completion": "\n\n    always @(*) begin\n        if (in[3]) \n            pos = 2'd3;\n        else if (in[2]) \n            pos = 2'd2;\n        else if (in[1]) \n            pos = 2'd1;\n        else if (in[0]) \n            pos = 2'd0;\n        else \n            pos = 2'b00;\n    end\n\t  \nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\talways @* begin\n\t\tif(in[3]) pos = 2'd3;\n\t\telse if(in[2]) pos = 2'd2;\n\t\telse if(in[1]) pos = 2'd1;\n\t\telse if(in[0]) pos = 2'd0;\n\t\telse pos = 2'd0;\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\talways @(*) begin\n\t\tif(in[3]) \n\t\t\tpos = 2'd3;\n\t\telse if(in[2]) \n\t\t\tpos = 2'd2;\n\t\telse if(in[1]) \n\t\t\tpos = 2'd1;\n\t\telse if(in[0]) \n\t\t\tpos = 2'd0;\n\t\telse \n\t\t\tpos = 2'b00;\n\tend\n\t\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\t// A simple case statement can be used to solve the problem\n\talways @* begin  // The asterisk means \"always evaluate this\"\n\t\tcase (in)   // Case statement with input 'in' as condition\n\t\t\t4'b0001: pos = 2'd0;  // if in is 4'b0001, output will be 2'd0\n\t\t\t4'b0010: pos = 2'd1;  // if in is 4'b0010, output will be 2'd1\n\t\t\t4'b0100: pos = 2'd2;  // and so on...\n\t\t\t4'b1000: pos = 2'd3;\n\t\t\tdefault: pos = 2'd0;  // if all bits are zero, output will be 2'd0\n\tendcase\n\t\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\n\talways @(*) begin\n    \tif      (in[3]) pos = 2'd3;  //if highest priority bit is set\n        else if (in[2]) pos = 2'd2;  \n        else if (in[1]) pos = 2'd1;\n        else if (in[0]) pos = 2'd0; //lowest priority bit is set\n    \telse         pos = 2'b0;  //all bits are zero\n\tend\n\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\n\talways @(*) begin\n\t\tif(in[3]) \n\t\t\tpos = 2'd3;\n\t\telse if(in[2])  \n\t\t\tpos = 2'd2;\n\t\telse if(in[1]) \n\t\t\tpos = 2'd1;\n\t\telse if(in[0]) \n\t\t\tpos = 2'd0;\n\t\telse\n\t\t\tpos = 2'b0;\n\tend\n\t\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\talways @(*) begin\n\t\tif (in[3]) \n\t\t\tpos = 2'd3;\n\t\telse if (in[2]) \n\t\t\tpos = 2'd2;\n\t\telse if (in[1]) \n\t\t\tpos = 2'd1;\n\t\telse if (in[0]) \n\t\t\tpos = 2'd0;\n\t\telse \n\t\t\tpos = 2'd0;\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\talways @* begin\n        if(in[3])\n            pos=2'd3;\n        else if(in[2]) \n            pos = 2'd2;\n        else if(in[1]) \n            pos = 2'd1;\n        else if (in[0])\n            pos = 2'd0;\n        else\n            pos=2'b00;\n    end\nendmodule\n\n"}
{"task_id": "always_case2", "completion": "\n     always @(*) begin\n         if      (in[3]) pos = 2'd3;\n         else if (in[2]) pos = 2'd2;\n         else if (in[1]) pos = 2'd1;\n         else if (in[0]) pos = 2'd0;\n         else             pos = 2'b00;\n     end \nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\n\t// Priority Encoder using case statement. \n\talways @* begin\n\t\tcase(in)\n\t\t\t4'b0001 : pos = 2'd0;\n\t\t\t4'b0010 : pos = 2'd1;\n\t\t\t4'b0100 : pos = 2'd2;\n\t\t\t4'b1000 : pos = 2'd3;\n\t\t\tdefault : pos = 2'd0; // Default case for when all 0s is treated as zero.\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\n\talways @* begin\n\t    if(in[3]) \n\t        pos = 2'd3;\n        else if(in[2]) \n            pos = 2'd2;\n        else if(in[1])\n            pos = 2'd1;\n        else if(in[0]) \n            pos = 2'd0;\n      \telse \n          \tpos = 2'b00; //input is zero\n    end\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\talways @(*) begin\n\t    if (in[3]) pos = 2'd3; \n        else if (in[2]) pos = 2'd2; \n        else if (in[1]) pos = 2'd1; \n        else if (in[0]) pos = 2'd0; \n        else pos = 2'd0; //none are high\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\nalways @(*) begin\n\tif      (in[3]) pos = 2'd3; \n\telse if (in[2]) pos = 2'd2;\n\telse if (in[1]) pos = 2'd1;\n\telse if (in[0]) pos = 2'd0;\n\telse            pos = 2'b0; // All zeros.\nend\n\n"}
{"task_id": "always_case2", "completion": "\n\talways @(*) begin\n\t\tcasez(in)\n\t\t\t4'b1zzzz : pos = 2'd0;\n\t\t\t4'b?1zzz : pos = 2'd1;\n\t\t\t4'b??1zz : pos = 2'd2;\n\t\t\t4'b???1z : pos = 2'd3;\n\t\t\tdefault  : pos = 2'd4; //None of the bits are high\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\talways @(*) begin\n\t\tif (in[3]) pos = 2'd3;\n\t\telse if (in[2]) pos = 2'd2;\n\t\telse if (in[1]) pos = 2'd1;\n\t\telse if (in[0]) pos = 2'd0;\n\t\telse pos = 2'd0; // If all inputs are 0, output is also 0.\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\nalways @* begin\n    if(in[3])       //Input is 8 or higher\n        pos = 2'd3;\n    else if(in[2]) //Input is 4 or higher\n        pos = 2'd2;\n    else if(in[1]) //Input is 2 or higher\n        pos = 2'd1;\n    else if(in[0]) //Input is 1\n        pos = 2'd0;\n    else           //No input bits are high.\n        pos = 2'b0;\nend\n\t\n"}
{"task_id": "always_case2", "completion": "\n\n\talways @(*) begin\n    \tif (in[3]) \n        \tpos = 2'd3;\n    \telse if (in[2]) \n        \tpos = 2'd2;\n   \t \telse if (in[1]) \n        \tpos = 2'd1;\n    \telse if (in[0]) \n       \t\t pos = 2'd0;\n    \telse \n        \tpos = 2'b0;\n  \tend\nendmodule\n\n"}
{"task_id": "always_case2", "completion": "\n\t// Priority Encoder using case statement\n\talways @* begin\n\tcase(in)\n\t\t4'b0001 : pos = 2'd0;  // position 0 is highest priority for '1'\n\t\t4'b0010 : pos = 2'd1;  // position 1 is second highest priority\n\t\t4'b0100 : pos = 2'd2;  \n\t\t4'b1000 : pos = 2'd3;  // position 3 is lowest priority\n\t\tdefault: pos = 2'd0;    // default case, if there's no '1', output 0\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\n\n\talways @* begin\n    if(in[3])\n      pos = 2'd3;\n   else if(in[2]) \n      pos = 2'd2;\n   else if (in[1])\n      pos = 2'd1;\n   else if (in[0])\n      pos = 2'd0;\n   else \n      pos = 2'b00;\n\tend\nendmodule\n"}
{"task_id": "always_case2", "completion": "\nalways @* begin\n\tcase(in) \n\t\t4'b0001 : pos = 2'd0;\n\t\t4'b0010 : pos = 2'd1;\n\t\t4'b0100 : pos = 2'd2;\n\t\t4'b1000 : pos = 2'd3;\n\t\tdefault: pos = 2'd0; // if there are no set bits, it will return 0.\n\tendcase\nend\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\t// Define internal wires to use in calculations \n\twire a, b;\n\treg [2:0] dff_out;\n\t\n\t// D flip-flops with synchronous reset (active low)\n\talways @(posedge clk or negedge x) begin\n\tif (!x)\n\t    dff_out <= 3'b0;\n\telse \n\t    dff_out <= {dff_out[1:0], a}; \n\tend\n\t\t\n\t// Two-input XOR gate (a XOR D flipflop output)\n\tassign a = x ^ dff_out[0];  \n\t\n\t// Two-input AND gate (b AND ~D flipflop complemented output)\n\tassign b = x & ~dff_out[1]; \n\t\n\t// Two-input OR gate (x OR D flipflop complementary output)\n\tassign z = a | dff_out[2];  \n\t\t\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\nreg q1, q2, q3; // D Flip Flops\n\n// D flip flops for the three states\nalways @(posedge clk) begin\n   q1 <= ~q1 & (x ^ q2);  // XOR gate connected to input x and one of the outputs of D flip flop\n   q2 <= q1 | ~q3;         // AND gate connected to one of the outputs of D flip flops and complemented output of other D flip flip\n   q3 <= ~(q1 ^ (x & ~q2));// OR gate connected to input x, one of the outputs of D flip flop and its complemented output.\nend\n   \nassign z = ~((q1 ^ q2) | q3); // three-input XNOR gate with second input being corresponding D flip-flops output and third input being complemented output\n\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\treg q1, q2, q3; // D Flip flops \n\twire w1, w2, w3; // Gates Outputs\n\t\n\t// D flip flops\n\talways @(posedge clk) begin\n\t\tq1 <= ~x ^ (w2 | ~w3);\n\t\tq2 <= x ^ (w1 & w3);\n\t\tq3 <= x ^ (w1 | w2);\n\tend\n\t\n\t// Gate operations\n\tassign w1 = ~(q1 ^ q2) ; // XOR gate output\n\tassign w2 = q1 & w3;     // AND gate output\n\tassign w3 = q1 | ~w2;    // OR gate output\n\t\n\t// Output Z\n\tassign z = ~(w1 & w2 & w3);\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\twire a; // Output from XOR gate\n\twire b; // Output from AND gate\n\twire c; // Output from OR gate\n\treg q1; // Output D flip-flop 1\n\treg q2; // Output D flip-flop 2\n\treg q3; // Output D flip-flop 3\n\twire not_q1; // Complement of q1\n\twire not_q2; // Complement of q2\n\twire not_q3; // Complement of q3\n\n\t//D FlipFlops\n\talways @(posedge clk) begin\n\t\tq1 <= x; \n\t\tq2 <= ~x;\n\t\tq3 <= a ^ b ^ c;  \n\tend\n   \n\t//Complement Outputs\n\tnot n1 (not_q1, q1);\n\tnot n2 (not_q2, q2);\n\tnot n3 (not_q3, q3); \n    \n\t//Two Input Gates\n\txor g1(a, x, q1);\n\tand g2(b, not_q2, q2);\n\tor g3(c, not_q3, q3);  \n   \n\t//Three input XNOR gate \n\tassign z = ~(a ^ b ^ c);    \nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n    \n\twire a1,a2,b1,b2;\n    wire [1:0] d;\n\tDFF D1 (.q(d[0]), .clk(clk), .d(x ^ d[0]));  // XOR flip flop.\n\tDFF D2 (.q(d[1]), .clk(clk), .d(!d[0]) );    // NOT flip flop for AND and OR gates.\n    \n\t//AND gate outputs to Z of next stage (XNOR)\n    assign a1 = x & d[1]; \n\tDFF D3 (.q(a2), .clk(clk), .d(a1)); // AND flip flop.\n\t\n\t// OR gate outputs to first input of XNOR circuit and second input of Z.\n    assign b1 = x | d[1]; \n\tDFF D4 (.q(b2), .clk(clk), .d(b1)); // OR flip flop.\n    \n\t// XNOR gate to produce final output 'Z'.\n\tassign z = ~(a2 ^ b2);  \nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\treg q1, q2, q3;  // Flip-Flops\n\n\t//D Flip Flop 1\n\talways @(posedge clk) begin\n\t  q1 <= ~q1 & x | ~x & q1;  \n\tend\n\n\t//D Flip Flop 2\n\talways @(posedge clk) begin\n          q2 <= (~q2 & x) | (x & q1);\n        end\n        \n        //D Flip Flop 3\n        always @(posedge clk) begin\n            q3 <= ~q3 & x | ~x & q1;  \n\tend\n\t\n\t// Output z\n\tassign z = ~((q2 ^ q1) & (q2 & ~q3) | ((~q2)&q1));  // XOR, AND and OR gates are implemented here.\n\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\t// D flip-flops for each gate input\n\treg dff1q, dff2q, dff3q; \n\t\n\t// D FlipFlop 1\n\talways @(posedge clk) begin\n\t\tdff1q <= x;\n\tend\n  \n\t// D FlipFlop 2\n\talways @(posedge clk) begin\n\t\tdff2q <= ~dff1q; // Complemented output of dff1q\n\tend\n\n\t// D FlipFlop 3\n\talways @(posedge clk) begin\n\t\tdff3q <= dff1q; // Output of dff1q goes to dff3\n\tend\n\n\t// Three-input XNOR gate\n\tassign z = ~(dff1q ^ (dff2q & ~dff3q | ~dff2q & dff3q));\n   \nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\nreg d1,d2,d3;\nassign z = ~(x ^ (((~d1)&d2)|((~d1)^d2)^d3));\nalways @ (posedge clk) begin\n\td1 <= x;\n\td2 <= ~d1;\n\td3 <= ~d1^d2;\nend\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n    wire a; // intermediates wires for AND, OR and XOR gates\n\twire b; \n\twire c; \n\t\n\t// D flip-flops declaration\n\treg q_dff1 = 0, q_dff2 = 0, q_dff3 = 0;\n\t\n    // First two input D flip flop\n\talways @(posedge clk) begin\n        {q_dff1,q_dff2} <= {x,q_dff1};\n    end  \n    \n    // Third input D flip flop\n\talways @(posedge clk) begin \n         q_dff3 <= x; \n    end\n\t\n\t// XOR gate implementation using ^ operator\n\tassign a = (~q_dff1)^x;  \n    \n    // AND gate implementation using & operator\n\tassign b = ~(q_dff2&(~q_dff3));\n\t\n\t// OR Gate Implementation \n\tassign c = (a|b);\n\t\n\t// Output Z is calculated as third input of a XNOR gate which means it will be complemented value for output z\n\tassign z = ~(c^x);    // xnor operator in verilog ^ with ~ used to take complement. \n\nendmodule \n"}
{"task_id": "ece241_2014_q4", "completion": "\n\t// Declaration of Wire\n\twire a;\n\twire b;\n\twire c;\n\twire d;\n\treg q1;\n\treg q2;\n\treg q3;\n\n\t// Assignments of the gates \n\tassign a = x ^ q1; // XOR gate to D flip flop q1\n\tassign b = ~x & q2; // AND gate to D flip flop q2\n\tassign c = x | ~q3; // OR gate to D flip flop q3\n\tassign d = a & b & c; \n\tassign z = ~(d ^ (a | b | c)); // Three-Input XNOR gate\n\n\t// D Flip Flops with Synchronous Reset\n\talways @(posedge clk) begin\n\t\tq1 <= x;\n\tend\n  \n\talways @(posedge clk) begin\n\t\tq2 <= ~x;\n\tend\n  \n\talways @(posedge clk) begin\n\t\tq3 <= x;\n\tend\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\nwire a, b, c; // wire to store the outputs of D flip flops \n\n// Defining the three instances of D Flip Flop with asynchronous reset\nDFF dff1 (.clk(clk), .d(x), .q(a)); \nDFF dff2 (.clk(clk), .d(b), .q(c)); // b is not flipped and c is the output for z\nDFF dff3 (.clk(clk), .d(c), .q()); // not connected to any other flip-flop but serves as complement of c \n\n// Defining XOR, AND & OR gate\nwire xor_gate = a ^ b; // between input and D flip flop\nwire and_gate = a & (~c); // between complemented output and D flip flop \nwire or_gate = ~a | c; // between non-complemented output and its complement\n\t\n// Defining the three-input XNOR gate using xor_gate, and_gate, and or_gate as inputs.\nassign z =  ~(xor_gate & and_gate & or_gate); \n\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\nreg a, b, c; // D Flip Flops for AND, OR and XOR gates\nalways @(posedge clk) begin \n    {a,b,c} <= {x^c, x&~b, x|~a};  \nend\nassign z = ~(a ^ b ^ c); // Z output\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\n\twire a; // Output from XOR gate\n\twire b; // Complemented output from AND gate\n\twire c; // Complementary output from OR gate\n\treg q1, q2, q3; // D flip-flop outputs\n\n\t// D flip flops\n\talways @(posedge clk) begin\n    \tq1 <= x;\n    \tq2 <= ~x;\n    \tq3 <= ~x & a | ~b | c;\n  \tend\n\n\t// XOR gate\n\tassign a = q1 ^ x;\n\t\n\t// AND gate\n\tassign b = ~(~x & q2);\n\t\n\t// OR gate\n\tassign c = x | q3;\n\n\t// Output Z\n\tassign z = ~(a & ~b & c);\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n    wire a;\n\twire b;\n\twire c;\n\n\t// D flip flops\n\tDFF dff1(.clk(clk), .d(x), .q(a));\n\tDFF dff2(.clk(clk), .d(b), .q(c)); // Complemented outputs for AND and OR gates.\n\tDFF dff3(.clk(clk), .d(~c), .q(b)); // Complemented output for XOR gate.\n\t\n\t// Three input XNOR gate\n\tassign z = ~(a ^ b ^ c);\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\n\t// D Flip Flops and Gates\n\treg d1_out, d2_out, d3_out;\n\twire not_d1_out, not_d2_out, not_d3_out;\n    \n    // Instantiate D flip-flops for each input. \n\tDFF DFF_x (.clk(clk), .d(x), .q(d1_out));\n\tDFF DFF_not_d1_out (.clk(clk), .d(not_d1_out), .q(d2_out));\n\tDFF DFF_and_out (.clk(clk), .d(~(d1_out & d2_out)), .q(d3_out));\n    \n    // NOT Gate \n\tnot not_gate_x (not_d1_out, x);\n  \n\t// XOR Gate\n\tassign z = ~((d1_out ^ d2_out) | d3_out);\nendmodule\n\n// Define D flip-flop module\nmodule DFF(clk, d, q);\n    input clk;\n    input d;\n    output reg q;\n    \n    always @ (posedge clk) begin \n        q <= d;\n    end\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\twire a; // intermediate wire for XOR gate\n    wire b; // intermediate wire for AND gate\n    wire c; // intermediate wire for OR gate\n    \n    // D flip-flops\n    reg q1,q2,q3; \n    \n    // two input gates: XOR, AND and OR\n    assign a = x ^ q1;\n    assign b = ~x & ~(q2);\n    assign c = x | (~q3);\n    \n    // D flip flops synchronous with clock and store the result of the logic operations on input x\n    always @(posedge clk) begin \n        q1 <= a;\n\t\tq2 <= b;\n\t\tq3 <= c;\n    end\n        \n   // The three-input XNOR gate\n    assign z = ~((a == q1)& (b==~q2) & (c == ~q3)); \n    \nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\nreg q1, q2, q3;  // The three D flip flops\n\nalways @(posedge clk) begin\n\t// Each D flip-flop is connected to an XOR gate where the output is fed into the AND and OR gates.\n\tq1 <= x ^ q2;  \n\tq2 <= ~x ^ q3;  // The complemented output of q3 is used for the AND input and the complemented output from q3 for OR input.\n\tq3 <= (x & ~q1) | (x & q2);  // Using q1's complemented output and q2's output to compute the OR gate result.\nend\n// The final output is fed into a XNOR gate with the outputs of all D flip-flops.\nassign z = ~(q1 ^ q2 ^ q3) ;  // As the three inputs are identical, Z will be high if and only if every input to the XNOR was zero, i.e., all were same.\n\t\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\nwire a; // XOR gate output\nwire b; // AND gate output\nwire c; // OR gate output\n\n// D flip-flops\nreg d_ff1, d_ff2, d_ff3; \n\n// XOR Gate\nxor xor_gate(a, x, d_ff1);\n\n// AND Gate\nand and_gate(b, ~d_ff2, d_ff1);\n\n// OR Gate\nor or_gate(c, ~d_ff3, d_ff1);\n\n// D flip-flops\nalways @ (posedge clk) begin \n\td_ff1 <= a;\n\td_ff2 <= ~b;\n\td_ff3 <= ~c;\nend\n\n// XNOR gate\nassign z = ~(a ^ d_ff1 ^ b ^ ~d_ff2 ^ c ^ ~d_ff3); \n\nendmodule\n\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\t// Declare D Flip Flops\n\treg q1,q2,q3;\n\t\n\t// Declare wire to save complemented output of Q2 for AND gate \n\twire cQ2 = ~q2;\n\t// Declare wire to save complemented output of Q3 for OR and AND gates \n\twire cQ3 = ~q3;\n\t\t\n\t// Create D Flip Flops using D Flip Flop description\n\talways @(posedge clk) begin\n\t\tq1 <= x ^ q2 ^ q3; // XOR gate\n\t\tq2 <= ~cQ3 | (x & cQ2); // AND gate and its complemented output from Q2\n\t\tq3 <= cQ2 | (x & ~q1) ; // OR gate and its complemented output from Q3\n\tend\n\t\n\t// Z is the XNOR of outputs of each D flip-flop \n\tassign z = ~(q1 ^ q2 ^ q3);\n\t\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\n\n\twire q1,q2,q3;\n\tDFF DFF1 (.clk(clk), .d(x ^ q1), .q(q1));\n\tDFF DFF2 (.clk(clk), .d((~x) & q2), .q(q2));\n\tDFF DFF3 (.clk(clk), .d(x | q3), .q(q3));\n\tassign z = (q1, ~q2, ~q3);\nendmodule\n\n"}
{"task_id": "rule110", "completion": "\n\treg [511:0] nextq;\n\tinteger i;\n  \n\talways @(posedge clk) begin \n\t\t\tif (load) \n\t\t\t\tq <= data; \n\t\t\telse \n\t\t\t\t\tfor (i = 1; i < 511; ++i ) \n\t\t\t\t\t\tcase({q[i-1], q[i+0], q[i+1]}) // Center's next state\n\t\t\t\t\t\t\t3'b111: nextq[i+0] <= 1'b0;\n\t\t\t\t\t\t\t3'b110: nextq[i+0] <= 1'b1;\n\t\t\t\t\t\t\t3'b101: nextq[i+0] <= 1'b1;\n\t\t\t\t\t\t\t3'b100: nextq[i+0] <= 1'b0;\n\t\t\t\t\t\t\t3'b011: nextq[i+0] <= 1'b1;\n\t\t\t\t\t\t\t3'b010: nextq[i+0] <= 1'b1;\n\t\t\t\t\t\t\t3'b001: nextq[i+0] <= 1'b1;\n\t\t\t\t\t\t\t3'b000: nextq[i+0] <= 1'b0;\n\t\t\t\t\t\tendcase \n\t\t\t\tq <= nextq;  \n\t\t\tend \nendmodule\n"}
{"task_id": "rule110", "completion": "\n\treg [511:0] next;\n\t\n\t// Next state calculation\n\talways @* begin\n\t    for (integer i = 1 ; i < 511 ; ++i) begin\n\t\t    case({q[i-1], q[i+0], q[i+1]})  // Center | Left | Right\n\t\t\t    2'b111: next[i] = ~(data[i]);\t// 1 | 1 | 1 -> 0\n\t            2'b110: next[i] = data[i];   // 1 | 1 | 0 -> 1\n\t\t        2'b101: next[i] = data[i];   // 1 | 0 | 1 -> 1\n\t\t        2'b100: next[i] = ~(data[i]);\t// 1 | 0 | 0 -> 0\n\t            2'b011: next[i] = data[i];   // 0 | 1 | 1 -> 1\n\t\t        2'b010: next[i] = data[i];   // 0 | 1 | 0 -> 1\n\t          \t2'b001: next[i] = data[i];   // 0 | 0 | 1 -> 1\n\t\t         2'b000: next[i] = ~(data[i]);\t// 0 | 0 | 0 -> 0\n    \t        default : next[i]=q[i];   \t\t// Default case, no change\n\t\t    endcase\n\t    end\n        // Boundaries are off (0)\n\t\tnext[511] = 0;  \n        next[-1]  = 0; \n\tend\n    \n\t// Output and input register\n\talways @(posedge clk) begin\n\t\t if (load) q <= data;\n         else      q <= next ;  // Update the array only at the rising edge of clock. \n    end\n    \n"}
{"task_id": "rule110", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse \n\t\t\tfor(i=0; i<512; i++)\n\t\t\t\tq[i] <= ~(q[(i-1)%512] ^ q[(i+1)%512]);\n\tend\n\t\nendmodule\n\n"}
{"task_id": "rule110", "completion": "\n\n\treg [511:0] nextState;\n\talways @ (posedge clk) begin\n\t    if(load == 1'b1)\n\t        q <= data;\n        else \n            q <= nextState;  \n    end\n    \n    always @ (*) begin\n         for (i=1 ; i<511 ; ++i) \n            \tnextState[i] = ~(q[i-1] ^ q[i+1]); // from table\n        nextState[0] = ~(q[0] ^ q[2]);   //same rule as index 1, but at boundaries it will look for third cell and the one after.\n        nextState[511] = ~(q[511] ^ q[510]); //same logic applied to last cells.\n    end \nendmodule\n"}
{"task_id": "rule110", "completion": "\n   // 2D array to store current state and next state of the cells.\n\treg [511:0] state_array;\n\treg [511:0] new_state_array;\n   \n\tinitial begin\n\t\t// Initial states are zeros, so they don't matter for calculation.\n\t\tfor (integer i=0; i< 512 ; ++i) begin\n\t\t\tnew_state_array[i] <= 1'b0;\n\t\tend\n\tend\n   \n\talways @(posedge clk) begin\n\t    // load new state into current state on clock edge.\n\t\tif (load == 1)\n\t\t\tstate_array <= data;\n\t\t\t\n\t\tfor (integer i=1; i<511 ; ++i) \n        begin   \n            // Get the three bits for rule calculation\n\t\t\tcase({state_array[i-1], state_array[i+0], state_array[i+1]})            \n\t\t\t3'b000: new_state_array[i] <= 1'b0;//0; 0, 0 -> 0\n\t\t\t3'b001: new_state_array[i] <= 1'b1;//0; 0, 1 -> 1\n            3'b010: new_state_array[i] <= 1'b1;//0; 1, 0 -> 1\n\t\t\t3'b011: new_state_array[i] <= 1'b0;//0; 1, 1 -> 0\n            3'b100: new_state_array[i] <= 1'b1;//1; 0, 0 -> 1\n\t\t\t3'b101: new_state_array[i] <= 1'b1;//1; 0, 1 -> 1\n            3'b110: new_state_array[i] <= 1'b1;//1; 1, 0 -> 1\n\t\t\t3'b111: new_state_array[i] <= 1'b0;//1; 1, 1 -> 0\n\t\t\tdefault :new_state_array[i] <= state_array[i]; //no change if out of the range.\n            endcase             \n        end        \n\t\t\t\n\t\t// Copy new states to current state array.\n\t\tstate_array = new_state_array; \n\tend  \n   \n\tassign q=state_array; // outputting current state to monitor\n    \nendmodule\n"}
{"task_id": "rule110", "completion": "\n  \n\treg [512:0] nextq; // one extra bit to account for the boundaries.\n  \n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tnextq[511:0] <= data;\n\t\telse \n\t\t\tfor(integer i = 0 ; i < 512; ++i) // go through each bit.\n\t\t\t\t// The center cell depends on the left, right and current states of neighbors.\n\t\t\t\tnextq[i] <= ~( q[i-1] ^ q[i+1]); \n\t\t\n\t\tq <= nextq[511:0]; // update output register.\n  \tend\nendmodule\n"}
{"task_id": "rule110", "completion": "\n\n\treg [511:0] nextState; // Temporary register to hold the next state.\n\t\n\t// Next state calculation\n\talways @* begin \n\t\tfor (integer i = 1; i < 511; i++) begin\n\t\t\tcase({q[i-1], q[i+1], q[i]})  \n\t\t\t\t3'b000: nextState[i] = 1'b0; // Case - 000, Center is off.\n                3'b001: nextState[i] = 1'b0; // Case - 001, Center is on and Right is off.\n                3'b010: nextState[i] = 1'b1; // Case - 010, Center is off and Right is on.\n                3'b011: nextState[i] = 1'b0; // Case - 011, Center and Right are both on.\n                3'b100: nextState[i] = 1'b1; // Case - 100, Left is off, Center and Right are on.\n                3'b101: nextState[i] = 1'b1; // Case - 101, Left and Center are off, Right is on.\n                3'b110: nextState[i] = 1'b1; // Case - 110, Left and Center are both on, Right is off.\n                3'b111: nextState[i] = 1'b0; // Case - 111, All are on.\n\t\t\tendcase\n\t\tend\n         // Boundary cells are always off\n        nextState[511] <= 1'b0;\n        nextState[0] <= 1'b0;\n    end\n    \n\t// DFFs for state update\n\talways @(posedge clk) begin \n\t\tif (load) q <= data; // Synchronous load input\n\t    else q <= nextState; // Otherwise, advance to the next time step.\n   end\nendmodule\n"}
{"task_id": "rule110", "completion": "\n   wire [512:0] n;\n\tassign n[511:0] = {q[510:0], q[511]};\n\tassign n[512] = 0; // for negative index -1, always 0 as per boundary condition.\n\t\n   reg [1:0] sel_l, sel_r;\n\talways @(*) begin\n\t\t unique case ({q[-1], q[0], q[1]}) // using previous and next cells states to select from lookup table\n\t\t\t 2'b111 : sel_l = 2'b0; \n          2'b110 : sel_l = 2'b1;  \n          2'b101 : sel_l = 2'b1;   \n          2'b100 : sel_l = 2'b0;    \n\t\t\t 2'b011 : sel_l = 2'b1;\n          2'b010 : sel_l = 2'b1;\n          2'b001 : sel_l = 2'b1;\n          2'b000 : sel_l = 2'b0; \n        endcase   \n\t\t\t\n\t\t unique case ({q[509], q[510], q[511]}) // using previous and next cells states to select from lookup table\n\t\t\t  2'b111 : sel_r = 2'b0; \n          2'b110 : sel_r = 2'b1;   \n          2'b101 : sel_r = 2'b1;    \n          2'b100 : sel_r = 2'b0;     \n\t\t\t  2'b011 : sel_r = 2'b1; \n          2'b010 : sel_r = 2'b1;   \n          2'b001 : sel_r = 2'b1;    \n          2'b000 : sel_r = 2'b0;  \n        endcase  \t\t      \t      \n\tend \n\t\n\t// Synchronous code:\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n    else // If not loading, perform step.\n      q[511:0] <= {sel_r , n[512:2], sel_l}; \n\tend\n\nendmodule  \n"}
{"task_id": "rule110", "completion": "\n\treg [511:0] nextQ;\n    \n    always @(posedge clk) begin\n        if (load == 1'b1) \n            q <= data;\n        else\n            q <= nextQ;\n    end  \n            \n    integer i;\n\talways @(*) begin\t\t\n\t\tfor (i=0 ; i<512 ; i++ ) begin\t\t\t\n\t\t\tcase({q[i-1], q[i+1]})  //using two bit wide slice to decide the next state of cell from current and adjacent cells\n\t\t\t\t2'b11: nextQ[i] = 1'b0;\n\t\t\t\t2'b10: nextQ[i] = 1'b1;\n\t\t\t\t2'b01: nextQ[i] = 1'b1;\n                2'b00: nextQ[i] = 1'b0;\t\t\t\t\t\n\t\t\tendcase \t\t\t\n        end  \t\t\n    end    \nendmodule \n\n"}
{"task_id": "rule110", "completion": "\n \n\treg [512:0] tmp; // temporary register to hold the cell states including the two fake cells on either side of 'q'\n    \n\talways @(posedge clk) begin\n        \tif (load)\n            \t\ttmp[511:0] <= data;\n        \telse\n            \t\tfor (integer i=0; i<512; i++)\n                \t\tcase({tmp[i-1], tmp[i+1], tmp[i]})\n\t\t                    4'b111, 4'b110: tmp[i] <= 0;   // rule 110 table for '1' and '0'\n\t\t                    4'b101, 4'b100: tmp[i] <= 1;   \n\t\t                    4'b011, 4'b010: tmp[i] <= 1;\n\t\t                    4'b001, 4'b000: tmp[i] <= 0;  \n                \t\tendcase\n    \t\tq <= tmp[511:0]; // assign the 'q' register with the relevant part of the temporary register after each clock cycle\n    \tend\nendmodule\n\n"}
{"task_id": "rule110", "completion": "\n\t// State register.\n    reg [512:1] state; \n    \n    always @(posedge clk) begin\n        if (load) begin\n            // Load new data into state.\n            state <= data[511:0];\n\t\t\tq<=data[511:0];\n        end else begin\n           // Advance one step in time for each clock cycle. \n           for(int i = 1; i < 512; ++i) begin\n               state[i] <= (((state[i-1] == 1'b1) && (state[i+1] == 1'b1)) || ((state[i-1] == 1'b0) && \n\t\t\t   (state[i+1] == 1'b0))) ? 1'b0 : 1'b1;\n           end\n\t\t\tq <= state[511:0]; // output the current state to q.\n        end\n    end\nendmodule\n"}
{"task_id": "rule110", "completion": "\n    \n    // We use bitwise operations to compute the next state of each cell based on its own state and two neighbours.\n\t// Since we have a 512-bit system with boundaries, cells at index -1 (q[-1]) are treated as having an off neighbour (0), and cells at index 512 (q[512]) are treated as having an off neighbour (0).\n\talways @(posedge clk) begin\n\t    if (load == 1'b1) begin // Load new data into q on the rising edge of clock.\n            q <= data;\n        end else begin \n            for (integer i = 0; i < 512 ; i = i + 1 ) begin  \n                reg [2:0] neighbours = {q[i-1], q[i+1], q[i]}; // The current cell and its two neighbours.\n                case(neighbours) \n                    3'b111, 3'b110, 3'b101, 3'b000:   q[i] <= 1'b0; // Cell is off next time step.\n                    3'b100, 3'b011, 3'b010, 3'b001:   q[i] <= 1'b1; // Cell is on next time step.\n                    default :                   q[i] <= q[i];     // No change in cell state.\n                endcase\n            end \n        end \n\tend\nendmodule\n"}
{"task_id": "rule110", "completion": "\n \talways @(posedge clk) begin\n        if (load) \n\t\t    q <= data;\n\t    else \n\t\t    q <= {q[510:0], ~((~q[0])^(~q[2]))}; // Rule 110 implementation\n\tend\nendmodule\n"}
{"task_id": "rule110", "completion": "\n\t// Create the next state of each cell based on its neighbours\n\tfunction [511:0] calc_next;\n\t\tinput [511:0] curr;\n\t\treg [511:0] next;\n\t\t\n\t\tfor (int i=1 ;i< 512; ++i) begin\n\t\t\tcase({curr[i-1], curr[i+1 & 511], curr[i]})\t// get the neighbours for each cell and current state\n\t\t\t\t3'b011, 3'b101, 3'b110: next[i] = ~curr[i];\t   // if left and right neighbour is on then turn off else turn on\n\t\t\t\tdefault: next[i] = curr[i];\t\t\t\t\t\t// all other cases stay the same\n\t\tendcase\n\t\tend \n\t\treturn next;\n\tendfunction : calc_next\n\t\n\talways @(posedge clk) begin // clocked by posedge because we want to advance by one step each clock cycle\n\t\tif (load) q <= data;    // if load is high then load the system with input data \n\t\telse       q <= calc_next(q);\t// otherwise calculate next state of the system based on current state\n\tend\nendmodule\n"}
{"task_id": "rule110", "completion": "\n\treg [512:0] next_q;\n\t\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tnext_q[511:0] <= data[511:0];\n\t\telse\n\t\t\tfor(i = 0; i < 512; i = i + 1) begin\n\t\t\t\tnext_q[i-1] <= q[i-1];\n\t\t\t\tnext_q[i+1] <= q[i+1];\n\t\t\t\tcase ({q[i-1], q[i+0], q[i+1]}) \n\t\t\t\t\t3'b111: next_q[i] <= 0;\n\t\t\t\t\t3'b110: next_q[i] <= 1;\n\t\t\t\t\t3'b101: next_q[i] <= 1;\n\t\t\t\t\t3'b100: next_q[i] <= 0;\n\t\t\t\t\t3'b011: next_q[i] <= 1;\n\t\t\t\t\t3'b010: next_q[i] <= 1;\n\t\t\t\t\t3'b001: next_q[i] <= 1;\n\t\t\t\t\t3'b000: next_q[i] <= 0;\n\t\t\t\tendcase\n\t\t\tend \n\t\tq <= next_q[511:0];    // Outputs the result in range from index 0 to 511.\n\tend  \nendmodule\n"}
{"task_id": "rule110", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (load == 1'b1) \n\t\t\tq <= data;\n\t\telse // on rising edge of clock but not load\n\t\t\tfor (integer i = 0; i < 512; i++) begin\n\t\t\t\tcase ({q[i-1], q[i+1 & 511], q[i]})\n\t\t\t\t\t3'b111: q[i] <= 1'b0; // Left | Center | Right\n\t\t\t\t\t3'b110: q[i] <= 1'b1;\n\t\t\t\t\t3'b101: q[i] <= 1'b1;\n\t\t\t\t\t3'b100: q[i] <= 1'b0;\n\t\t\t\t\t3'b011: q[i] <= 1'b1;\n\t\t\t\t\t3'b010: q[i] <= 1'b1;\n\t\t\t\t\t3'b001: q[i] <= 1'b1;\n\t\t\t\t\t3'b000: q[i] <= 1'b0;\n\t\t\t\tendcase\n\t\t\tend // for i\n\tend // always\nendmodule\n"}
{"task_id": "rule110", "completion": "\n\n\t// 2D array to store the previous and next state of each cell\n\treg [513:0] prev_state; // one extra bit at both ends for boundary conditions\n\twire [511:0] current_state, next_state;\n\t\t\n\tassign q = load ? data : next_state;\n\t\n\t// calculate the next state of each cell in parallel\n\tgenvar i;\n\tgenerate\n\tfor (i = 0; i < 512; i++) begin: next_cell_state\n\t    always @(*) begin\n\t\t\tcasexz({prev_state[i+2], prev_state[i+1], prev_state[i]}) // the current state of each cell is the 3 bits in prev_state at positions i, i+1 and i+2\n\t\t\t    4'b111: next_state[i] = 0;\n\t\t        4'b110: next_state[i] = 1;\n\t            4'b101: next_state[i] = 1;\n\t            4'b011: next_state[i] = 1;\n\t\t\t    4'b010: next_state[i] = 0;\n\t\t\t    4'b001: next_state[i] = 1;\n\t\t\t    4'b000: next_state[i] = 0;\n\t\t        default: next_state[i] = 0; // for any other values, the cell is off (0)\n\t    \tendcase \n\t    end\n\tend\n\tendgenerate\n\t\n\t// update prev_state every clock cycle, and initialize it with data at load\n\talways @(posedge clk) begin\n\t    if(load) \n\t\t    prev_state[512:0] <= data; // middle bits of prev_state are updated to be the same as data\n\t    else\n    \t    prev_state <= {2{next_state, 1'b0}}; // shift next state into position for future calculation and pad two extra zeroes at ends \n\tend\nendmodule\n"}
{"task_id": "rule110", "completion": "\n\treg [511:0] nextq;  // Register to hold the value for next clock cycle.\n    \n    always @(posedge clk) begin  \n        if (load)\n            q <= data;\n        else \n            q <= nextq;\n    end\n      \n    always @(*) begin  // Determine the new state of each cell in the nextq register.\n      for (i=0; i<512; i++) begin:each_cell\n          if (i==0 || i==511)     // The boundaries are both zero.\n            nextq[i] = 0;  \n          else \n            case({q[i-1], q[i], q[i+1]}) // Get the state of current, left and right cell.\n                3'b111: nextq[i] = 0;\n                3'b110: nextq[i] = 1; \n                3'b101: nextq[i] = 1;\n                3'b100: nextq[i] = 0;\n                3'b011: nextq[i] = 1;\n                3'b010: nextq[i] = 1; \n                3'b001: nextq[i] = 1;\n                default: nextq[i]= 0; // All other cases, i.e., 000 give the cell state to be 0.\n            endcase\n        end : each_cell\n    end  \nendmodule\n"}
{"task_id": "rule110", "completion": "\n\n\t// Declare a temporary register to hold the next state\n\treg [511:0] next_q; \n\n\talways @(posedge clk) begin\n\t    int i; // declare an integer for loop counter\n\n\t\tif (load) \n\t\t    q <= data;\n    \telse begin\n        \tfor (i = 0 ; i < 512 ; ++i) begin\n            \tcase({q[i-1], q[i+1], q[i]}) // Table lookup to determine next state\n                \t3'b111: next_q[i] <= 0;\n                \t3'b110: next_q[i] <= 1;\n                \t3'b101: next_q[i] <= 1;\n                \t3'b100: next_q[i] <= 0;\n                \t3'b011: next_q[i] <= 1;\n                \t3'b010: next_q[i] <= 1;\n                \t3'b001: next_q[i] <= 1;\n                \tdefault: next_q[i] <= 0; // 000, so off\n            \tendcase\n        \tend\n        \t// Update q to the computed next state after all cells have been updated.\n            q <= next_q;\n        end    \n    end\nendmodule\n"}
{"task_id": "rule110", "completion": "\n\treg [511:0] nextState; // intermediate variable to hold the new state\n\n\t// Rule 110 table\n\tfunction [511:0] rule110;\n\t\tinput [2:0] neighbors;\n\t\tcase(neighbors)\n\t\t\t3'b000, 3'b001, 3'b110, 3'b100: return 512'd0;\n\t\t\t3'b011, 3'b111:                  return 512'd1;\n\t\t\tdefault:                         return 512'dx;\n\t\tendcase\n\tendfunction\n\n\t// combinational part to calculate next state for each cell\n\talways @* begin\n\t\tfor (integer i = 0 ; i < 512 ; ++i) begin\n\t\t\tnextState[i] = rule110({q[i-1], q[i], q[(i+1)%512]}); // use modulo to wrap around the boundaries\n\t\tend\n\tend\n\t\n\t// sequential part to update state and load new data when needed\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse \n\t\t\tq <= nextState; // advance by one time step each clock cycle\n\tend\nendmodule\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8]; //upper byte\n\tassign out_lo = in[7:0];  //lower byte\nendmodule\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0]; \nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];  // The upper byte is the second half of the input word.\n    assign out_lo = in[7:0];   // The lower byte is the first half of the input word.\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n  assign out_hi = in[15:8]; // upper byte\n\tassign out_lo = in[7:0]; // lower byte\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\nendmodule \n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];  //upper byte\n\tassign out_lo = in[7:0];   //lower byte\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\nassign out_hi = in[15:8];  // upper 8 bits\nassign out_lo = in[7:0];   // lower 8 bits\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8]; \n\tassign out_lo = in[7:0];\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule \n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\nendmodule\n"}
{"task_id": "vector1", "completion": "\n\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\n\t\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0]; \nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\nendmodule\n\n"}
{"task_id": "vector1", "completion": "\n\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\n\t\nendmodule \n\n"}
{"task_id": "vector0", "completion": "\n\tassign {o2, o1, o0} = vec;\n\tassign outv = vec; \nendmodule \n"}
{"task_id": "vector0", "completion": "\n\tassign o2 = vec[2];\n\tassign o1 = vec[1];\n\tassign o0 = vec[0]; \n\tassign outv = vec;\nendmodule \n\n"}
{"task_id": "vector0", "completion": "\n    \n\tassign {o2, o1, o0} = vec;\n\tassign outv = vec;  // same vector output\n    \nendmodule\n"}
{"task_id": "vector0", "completion": "\n    assign {o2, o1, o0} = vec;\n    assign outv = vec; \nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\tassign outv = vec;\n\tassign {o2, o1, o0} = vec;\nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n    \n    assign outv = vec;\n\tassign {o2, o1, o0} = vec;  // Assigns o2 to bit 2, o1 to bit 1 and o0 to bit 0 of the vector. \nendmodule \n\n"}
{"task_id": "vector0", "completion": "\n\n\tassign {o2, o1, o0} = vec; // splits the vector into separate 1-bit outputs.\n\tassign outv = vec; // gives back same vector as output.\nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n    \n    assign {o2, o1, o0} = vec;\n\tassign outv = vec; \nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\tassign {o2,o1,o0} = vec;\n\tassign outv = vec;\nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\t// The assign statements split the vector into individual bits and store them in separate output variables.\n\tassign {o2, o1, o0} = vec; \n\t// Assigning 'outv' with same value as 'vec'.\n\tassign outv = vec; \nendmodule\n"}
{"task_id": "vector0", "completion": "\n\tassign outv = vec;\n    assign {o2, o1, o0} = vec; \nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\n\t// vector output and individual bit outputs connected with array slicing.\n\tassign {o2,o1,o0} = vec[2:0]; \n\tassign outv=vec; //3-bit input vector is outputted to the same vector\nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\tassign {o2, o1, o0} = vec;\n\tassign outv = vec;\nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\tassign {o2, o1, o0} = vec;\n\tassign outv = vec;\nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\n\tassign outv = vec;\n\tassign {o2, o1, o0} = vec; \nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\tassign {o2, o1, o0} = vec;\n\tassign outv = vec; \nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\n\tassign {o2, o1, o0} = vec;\n\tassign outv = vec;\n\t\nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\tassign outv = vec;\n    assign {o2, o1, o0} = vec; //Order of assignment matters here. It should be from left to right i.e. first goes o2 then o1 and finally o0\n    \nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\tassign outv = vec;\n\tassign {o2, o1, o0} = vec;\nendmodule\n\n"}
{"task_id": "vector0", "completion": "\n\n\tassign {o2, o1, o0} = vec;\n\tassign outv = vec;\n\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n    \n    always @ (posedge clk) begin\n        if (shift_ena == 1'b1)\n            q <= {data,q[3:1]};\n\t    else if (count_ena == 1'b1) \n\t         q<= q - 4'b0001;\n    end  \nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (shift_ena == 1'b1)\n\t\t\tq <= {data, q[3:1]}; \n\t\t\t\n\t\telse if (count_ena == 1'b1) \n\t\t\tq <= q - 4'h1;\n\tend\n\t\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\n\talways @ (posedge clk) begin\n\t\tif(shift_ena==1'b1)begin\n\t\t\tq[3] <= data;\n        \t\tq[2:0]<= q[3:1]; \n    \t\tend   \n      \tif(count_ena == 1'b1 )begin  \n       \t\tfor (int i = 0;i < 4 ; ++i) begin //decrement the value in the shift register by one bit each clock cycle.\n            \t\tq[i] <= q[i] & ~shift_ena;  //do not decrement if we're shifting\n        \tend \n      \tend    \n\tend  \nendmodule \n"}
{"task_id": "review2015_shiftcount", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena) \n\t\t\tq <= {q[2:0],data}; // Shifts in most significant bit first.\n\t\telse if(count_ena) \n\t\t\tq <= q - 1;        // Decrement the current value.\n\tend\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (shift_ena == 1'b1 && count_ena == 1'b1 ) begin \n\t\t\tq <= {data, q[3:1]};\n\t\t\tq <= q - 4'd1;\n\t\tend  \n\t\telse if( shift_ena == 1'b1) begin\n\t\t    q <= {data, q[3:1]};\n\t\tend\n\t\telse if (count_ena == 1'b1) begin\n\t\t     q<= q - 4'd1;\n\t\tend ; \n\tend\nendmodule\n\n"}
{"task_id": "review2015_shiftcount", "completion": "\n    \n    always @(posedge clk) begin\n        if (shift_ena == 1'b1) \n            q <= {data, q[3:1]};   // Shift in the new bit and remove the most significant bit.\n        \n        else if(count_ena==1'b1)   \n             q <= q - 4'd1;       // Decrement counter.\n         \n     end\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] temp; // temporary variable to hold the value of q while decrementing\n    \n    always @(posedge clk) begin \n        if (shift_ena)\n            q <= {q[2:0], data};\n        else if (count_ena) begin\n\t       \ttemp <= q; // copy current value to temp varible\n     \t\tfor(int i=3; i>=0; i--) begin \n               \tif(temp[i] == 1'b1) begin  \n                   \ttemp[i] <= 1'b0;        \n\t\t\tend      \n            end\n\t        q <= temp; // copy the updated value back to q\n        end     \n    end \nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n   always @(posedge clk) begin \n       if (shift_ena == 1'b1) \n          q <= {q[2:0],data};\n       \n       if (count_ena ==1'b1 ) \n           q<= q-4'd1;  \n    end\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= {data, q[3:1]};\n\t\telse if (count_ena && (|q)) // Only decrement if the count is non-zero\n\t\t\tq <= q - 1;\n\tend\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\talways @(posedge clk) begin\n\t\tif (shift_ena == 1'b1) \n\t\t\tq <= {data, q[3:1]};\n\t\telse if (count_ena == 1'b1 && |q > 0 )   // Count can only decrease and must not go to zero\n\t\t\t\tq <= q - 4'd1;\n\tend\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] temp; \n\talways @(posedge clk) begin\n\t\tif (shift_ena==1'b1 && count_ena==1'b1 ) begin\n\t\t\ttemp <= {temp[2:0],data};\n\t\t\tq <= q-4'd1;   // Countdown by one. \n\t\tend \n\t\telse if(count_ena == 1) begin\n\t\t\tq <= q - 4'd1;   \n\t\tend    \n\t\telse if (shift_ena == 1 ) begin\n\t\t\ttemp <= {temp[2:0],data};   // Shift in.\n\t\t\tq<= temp;                 // Update shift register.\n\t\tend     \n\tend\nendmodule \n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] temp;\n\talways @ (posedge clk) begin \n\t\tif (shift_ena == 1'b1)  \n\t\t\ttemp <= {data, temp[3:1]}; // shift in data on the left \n\t\t\t\n\t\telse if (count_ena == 1'b1) \n\t\t\tq <= q - 4'b0001; // decrement count\n\tend\n"}
{"task_id": "review2015_shiftcount", "completion": "\nalways @ (posedge clk) begin \n\tif (shift_ena == 1'b1)\n\t\tq <= {data, q[3:1]};\n\telse if(count_ena ==1'b1 )\n\t\tq <= q - 4'b0001;\nend  \nendmodule\n\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] temp; \n  \n\talways @(posedge clk) begin\n\t  if (shift_ena)\n\t    temp <= {temp[2:0], data}; // Shift in data bit \n      else if (count_ena)   \n        temp <= temp - 1;          // Decrement count by 1\n\tend  \n\tassign q = temp;                 // Assign value to output\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n    always @ (posedge clk) begin \n        if (shift_ena == 1'b1 ) \n            q <= {q[2:0],data}; // Shift operation.\n         else if(count_ena ==1'b1)  \n            q <= q - 4'd1; // Decrement Operation. \n    end\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\talways @(posedge clk) begin\n\t\t\n\t\tif (shift_ena == 1'b1 ) \n\t\t\t\tq <= {data , q[3:1]};\n\t\t\t\t\t\n\t\telse if (count_ena == 1'b1)\n\t\t\t\t\tq <= q - 4'd1;\n\tend\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] temp;\n\talways @(posedge clk) begin\n\t\tif (shift_ena == 1'b1)\n\t\t\ttemp <= {data, temp[3:1]};\n\t\t\t\n\t\telse if(count_ena == 1'b1)\n\t\t\tbegin\n\t\t\ttemp<= temp - 4'b0001; // Decrement counter by 1\n\t\t\tend\n\tq = temp;\n   end\n   \nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] count;\n\talways @(posedge clk) begin \n\t\t if (shift_ena == 1'b1) \n\t\t\t\tq <= {data, q[3:1]}; \n\t\t else if (count_ena == 1'b1 && count > 0 ) \n\t\t\t\t\tcount <= count - 4'd1;  \n\t\t\telse \n\t\t\t\tcount <= 4'd9; //initial value for count is set to 9\n\tend\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\treg [3:0] tmp;\n  \n\talways @ (posedge clk) begin\n    \tif(shift_ena) \n      \t\ttmp <= {tmp[2:0], data};\n   \t\telse if(count_ena) \n      \t\ttmp <= tmp - 1;\n  \tend\n  \n\tassign q = tmp;\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\n\n\t// Initialize the register to zero.\n\treg [3:0] shift_register = 4'b0; \n\n\talways @(posedge clk) begin\n  \tif (shift_ena == 1'b1) // Shift in new data if shift is enabled\n    \tshift_register <= {data, shift_register[3:1]};\n    if (count_ena == 1'b1) // Decrement the counter\n\t\t  q <= q - 4'd1;\n\tend\n\t// Set q to current state of shift register.\n\tassign q = shift_register;\n  \nendmodule\n"}
{"task_id": "dff8", "completion": "\n    always @ (posedge clk) begin\n        q <= d;\n    end\nendmodule  // 8-bit D flip flop module\n\n"}
{"task_id": "dff8", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\nalways @(posedge clk) begin \n\tq <= d; \nend\nendmodule\n"}
{"task_id": "dff8", "completion": "\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule \n"}
{"task_id": "dff8", "completion": "\n\n\t//8 D Flip-Flops\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n\t// 8 D flip-flops module\n\tfor (genvar i=0; i<8; i++) begin : gen_dffs\n  \t\talways @(posedge clk) begin\n    \t\t\tq[i] <= d[i];\n  \t\tend\n\tend\nendmodule\n"}
{"task_id": "dff8", "completion": "\n\n\t//D Flip-flop\n\tfor (i = 0; i < 8; i = i + 1) begin : each_dff\n\talways @(posedge clk) begin \n\t\tq[i] <= d[i];\n\tend\n\tend : each_dff\nendmodule\n"}
{"task_id": "dff8", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend \nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "dff8", "completion": "\n\talways @(posedge clk) begin  // positive edge triggered D flip flop\n\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n\n\talways @(posedge clk) begin\n\t\tfor (integer i=0;i<8;i++)\n\t\t  q[i] <= d[i];\n    end\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n\t// 8 D flip-flops\n\tfor (genvar i = 0; i < 8; i++) begin : dff_instances\n  \t    always @(posedge clk) begin\n     \t     q[i] <= d[i];\n   \t    end\n\tend\n\n"}
{"task_id": "dff8", "completion": "\nalways @ (posedge clk) begin \n    q <= d; \nend\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n    \n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule \n"}
{"task_id": "dff8", "completion": "\n\tfor (genvar i=0; i<8; ++i) begin : gDFFs\n  \talways @(posedge clk)\n    \tq[i] <= d[i];\n\tend \nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n    always @ (posedge clk) begin \n        q <= d;\n    end\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\n\n\t// D Flip-Flop module\n\talways @ (posedge clk) begin\n\t    q <= d; // Assign new value to Q at rising edge of clock\n\tend\nendmodule\n\n"}
{"task_id": "dff8", "completion": "\nalways @(posedge clk) begin\n   q <= d;\nend\n\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~(a ^ b); //Xnor gate implementation\nendmodule\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~(a ^ b); //XNOR Gate\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n    assign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n    assign out = ~(a ^ b);\nendmodule\n"}
{"task_id": "xnorgate", "completion": "\n    assign out = !(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\n\tassign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~(a ^ b);\nendmodule\n"}
{"task_id": "xnorgate", "completion": "\n\n\tassign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~((a ^ b));\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n    assign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n    \n    assign out = ~(a ^ b);\n    \nendmodule\n"}
{"task_id": "xnorgate", "completion": "\nassign out = ~(a ^ b); // An XNOR gate can be implemented as ~(a^b) in verilog.\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n    assign out = ~(a ^ b); // The XNOR gate is implemented by inverting the exclusive-or (XOR) output.\nendmodule\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\n\tassign out = ~(a ^ b); //XNOR gate implementation\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~(a ^ b);\nendmodule\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = ~(a ^ b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\nassign out = ~(a^b);\nendmodule\n\n"}
{"task_id": "xnorgate", "completion": "\n\tassign out = !(a ^ b);\nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\t//state encoding: 00 = walk right, 01 = fall and walk left, 10 = walk left, 11 = fall and walk right.\n\treg [1:0] state;\n\twire falling; //falling flag\n\tassign falling = (state == 1'b1); //check if in falling state\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= 2'b00; //default to walk left on reset.\n\t\telse case( {bump_right, bump_left} )\n\t\t\t2'b10: if(ground && !falling) state <= 2'b00; else if(!dig && ground) state <= 2'b01;  //bumped right and not falling. If can dig walk right otherwise fall\n\t\t\t2'b01: if(ground && !falling) state <= 2'b10; else if(!dig && ground) state <= 2'b11;  //bumped left and not falling. If can dig walk left otherwise fall\n\t\t\t2'b11: if(ground && !falling) begin if(bump_left) state <= 2'b01; else state <= 2'b11; end  //if bumped on both sides or ground disappear while falling\n\t\t\tdefault: if(!dig && ground) state <= {bump_right, bump_left};   //while not digging and there is ground walk in the direction of last movement.\n\t\tendcase\n\tend\n\t//output decoding \n\tassign walk_left = (state == 2'b10);//if falling it will continue walking left otherwise idle\n\tassign walk_right = (state == 2'b00);//if falling it will continue walking right otherwise idle\n\tassign aaah = falling; //signal that indicates when lemming fall.\n\tassign digging = (!falling && ground && dig );//if can start dig while not falling and there is ground and requested to dig. \nendmodule\n"}
{"task_id": "lemmings3", "completion": "\nlocalparam [1:0] WALKING = 2'b01;\nlocalparam [1:0] LEFT = 2'b00;\nlocalparam [1:0] RIGHT = 2'b10;\nlocalparam [1:0] FALLING = 2'b11; \n\nreg [1:0] state, next_state;\n\nalways @(posedge clk) begin\n\tif (areset)\n\t\tstate <= LEFT; // Reset to walking left.\n\telse\n\t\tstate <= next_state;\nend\n\nalways @(*) begin\n\tcase (state) \n\t\tWALKING:  if ((bump_left & ~ground) | (~dig))  \n\t\t\t\t\t    next_state = FALLING ;\n\t\t\t\t else if (bump_right & ~ground) \n\t\t\t\t\t    next_state = RIGHT;\n\t\t\t\t else \n\t\t\t\t\t    next_state = state;\t\t \n\t\tLEFT:     if (bump_left | bump_right )  \n\t\t\t\t\t    next_state = WALKING ;\n\t\t\t\t else \n\t\t\t\t\t    next_state = state;\t\t\t\n\t\tRIGHT:    if (bump_right | bump_left) \n\t\t\t\t\t    next_state = WALKING ;\n\t\t\t\t else \n\t\t\t\t\t    next_state = state;\t\t  \n\t\tFALLING:\tif (ground & ~dig) \n\t\t\t\t\t    next_state = WALKING;\n\t\t\t\telse if(bump_left | bump_right ) \n\t\t\t\t\t    next_state = FALLING;\n                else \n                     next_state = state ;\t\t\t\t    \t   \n\tendcase\nend\n\nassign walk_left  = (state == LEFT );\nassign walk_right = (state == RIGHT);\nassign aaah       = (state == FALLING & ~dig) | (state==LEFT&bump_right&~ground)|(state==RIGHT&bump_left&~ground);\nassign digging    = (state == WALKING  & ground & dig); // Continuously dig while walking on the ground.\t  \t\t\nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\treg [1:0] state;\n\tparameter WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01, FALLING = 2'b10, DIGGING = 2'b11;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= WALK_LEFT;\n\t\telse \n\t\t\tcase (state)\n\t\t\t\tWALK_LEFT:  if(ground & ~bump_right) state <= ground ? WALK_LEFT : FALLING;\n\t\t\t\t\t\t\t else if(dig) state <= DIGGING;\n\t\t\t\tWALK_RIGHT: if(ground & ~bump_left) state <= ground ? WALK_RIGHT : FALLING;\n\t\t\t\t\t\t\t else if (dig) state <= DIGGING;\n\t\t\t\tFALLING: \tif(~bump_right | ~bump_left) state <= ground ? bump_right ? WALK_LEFT : WALK_RIGHT : FALLING;\n\t\t\t\tDIGGING: \tstate <= ground ? WALK_LEFT & ~bump_right | WALK_RIGHT & ~bump_left : FALLING;\n\t\t\tendcase\n\tend\n\n\tassign walk_left = state[0];\n\tassign walk_right = state[1];\n\tassign aaah = ~ground & (state == FALLING);\n\tassign digging = (state == DIGGING);\nendmodule\n\n"}
{"task_id": "lemmings3", "completion": "\n\treg [1:0] state;\n\tparameter WALKRIGHT = 2'b10, \n\t\t\t  WALKLEFT  = 2'b01, \n              FALL      = {aaah,digging}; // aaah is MSB and digging is LSB\n\t// State transitions\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) state <= WALKLEFT;\n        else case (state)\n\t\t    WALKRIGHT: if (bump_left || ~ground) state <= FALL; \n                       else if (dig) state <= {~aaah, digging}; // start digging while grounded\n                   WALKLEFT:  if (bump_right|| ~ground) state <= FALL; \n                       else if (dig) state <= {~aaah, digging};\n\t\t\tFALL:       if (ground) state <= (bump_left)?WALKRIGHT:WALKLEFT ; // Change direction while grounded\n                    default : state <= WALKLEFT; \t\t\t\n                endcase\n    end  \n\t// Outputs\n\tassign walk_right = (state==WALKRIGHT);\n\tassign walk_left  = (state==WALKLEFT);\n\tassign aaah       = (state[0]); // MSB of state is aaah\n\tassign digging    = (state[1]); // LSB of state is digging \nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\treg walk_left_reg, walk_right_reg, aaah_reg, digging_reg;\n\twire falling, moving, dug;\n\tassign falling = ground & ~(bump_left | bump_right) ? 1 : 0;\n    assign moving = ~falling & (dig | (ground & (walk_left_reg ^ walk_right_reg)));\n    assign aaah = ~falling & falling;\n    assign dug = ground & dig;\n\tassign walk_left = ~dug & ~moving & bump_left ? 1 : 0;\n    assign walk_right = ~dug & ~moving & (bump_right | walk_left);\n    assign digging = ~falling & dug;\n    \n\talways @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) begin\n            walk_left_reg <= 1'b1; //initialize to walk left\n            walk_right_reg <= 1'b0;\n            aaah_reg <= 1'b0;\n            digging_reg <= 1'b0;\n        end  else if (dug == 1) begin\n\t\t\twalk_left_reg <= ~walk_left_reg; //toggle state when dug\n            walk_right_reg <= ~walk_right_reg;\n            aaah_reg <= falling ? 1'b0 : aaah_reg;\n            digging_reg <= 1'b1;\n        end else begin\n\t\t\twalk_left_reg <= bump_right | (falling & walk_left_reg); //update state on no dug and not falling or falling\n            walk_right_reg <= bump_left | (falling & ~walk_right_reg);\n            aaah_reg <= falling ? 1'b1 : aaah_reg;\n            digging_reg <= ~moving & ~digging_reg;\n        end\n\tend  \nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\treg state; // 0 for walk left and 1 for walk right.\n\twire falling = !ground & (bump_left || bump_right) & state;   // condition to fall while walking.\n\twire switch_dir = bump_left && bump_right; // condition to switch directions.\n\t\t\n\t// Synchronous reset and flip-flop for state storage.\n\talways @(posedge clk or posedge areset) begin \n\tif (areset) \n\t\tstate <= 0; \n\telse \n\t\tif ((falling && !dig) || switch_dir)   // falling without digging or switch directions.\n\t\t\tstate <= !state; \t\t\t\t   \n\tend\n\t \n\t// Output assignments based on state and additional inputs.\n\tassign walk_left = state;\n\tassign walk_right = ~state;\n\tassign aaah = falling;\n\tassign digging = (ground & (bump_left || bump_right)) & dig;  // condition to start digging when on ground and bumped.\nendmodule\n"}
{"task_id": "lemmings3", "completion": " \n    reg [1:0] state; // two bit state variable to represent different states \n    parameter LEFT = 2'b10, RIGHT = 2'b01;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end\n        else begin\n            case (state) \n                LEFT: begin\n                    walk_left <= 1'b1;\n                    walk_right <= 1'b0;\n                    \n                    if (!ground) begin // falling\n                        aaah <= 1'b1;\n                        digging <= 1'b0;\n                        \n                        if (dig && bump_right) state <= RIGHT; // start digging on ground when not falling and being bumped right \n                    end\n                     else if (bump_left || bump_right) begin // switch direction when bumping left or right while walking to the left \n                        walk_left <= 1'b0;\n                        walk_right <= 1'b1;\n                        state <= RIGHT;\n                        \n                    end\n                end\n                \n               RIGHT: begin\n                    walk_left <= 1'b0;\n                    walk_right <= 1'b1;\n                    \n                    if (!ground) begin // falling \n                        aaah <= 1'b1;\n                        digging <= 1'b0;\n                        \n                        if (dig && bump_left) state <= LEFT; // start digging on ground when not falling and being bumped left \n                    end\n                     else if(bump_right || bump_left) begin // switch direction when bumping right or left while walking to the right  \n                        walk_left <= 1'b1;\n                        walk_right <= 1'b0;\n                        state <= LEFT;\n                        \n                    end \n                end\n            endcase\n        end\n    end    \nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\t// States for the finite state machine\n\ttypedef enum logic [2:0] {\n\t\tsLeft = 3'b001,  // State: Walking left\n\t\tsRight = 3'b010, // State: Walking right\n\t\tsBumpLeft = 3'b100, // State: Bumped on the left side. Transition state to walk Right after one clock cycle\n\t\tsBumpRight = 3'b000, // State: Bumped on the right side. Transition state to walk Left after one clock cycle\n\t\tsFalling = 3'b110  // State: Falling from ground\n\t} state_t;\n\tstate_t state, next_state;\n\n\t// Sequential logic for FSM\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= sLeft; // Reset to default starting position of walking left\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\n\t// Combinational logic for FSM - determines next state and output values\n\talways @(*) begin\n\t\tcase (state) \n\t\t\tsLeft : begin   // Lemming is currently walking to the left\n\t\t\t\tif (ground && dig) next_state = sFalling; else\n\t\t\t\tif (bump_right & ~dig) next_state = sBumpRight; else\n\t\t\t\tif (~ground | (aaah& ground)) next_state = sFalling ; else \n\t\t\t\t\tnext_state = sLeft;\n\t\t\tend\n\t\t\tsRight : begin // Lemming is currently walking to the right\n\t\t\t\tif (ground && dig) next_state = sFalling; else\n\t\t\t\tif (bump_left & ~dig ) next_state = sBumpLeft ; else \n\t\t\t\tif(~ground | (aaah& ground)) next_state = sFalling; else \n\t\t\t\t\tnext_state = sRight;\n\t\t\tend\n\t\t\tsBumpLeft: begin // Lemming has just bumped on the left side and is transitioning to walk right after one clock cycle.\n\t\t\t\tif(ground) next_state = sRight ; else next_state =sBumpLeft;\n\t\t\tend \n\t\t\tsBumpRight : begin // Lemming has just bumped on the right side and is transitioning to walk left after one clock cycle.\n\t\t\t\tif(ground) next_state = sLeft; else next_state = sBumpRight;\n\t\t\tend\n\t\t\tsFalling: begin \t// Lemming is currently falling\n\t\t\t\tif (~bump_left & ~bump_right ) next_state= state ;else\n\t\t\t\t if (dig ) next_state  = sLeft | sRight; else\n\t\t\t\t\t   next_state =sFalling;\n\t\t\tend\n\t\t\tdefault: begin // default to walk left position\n\t\t\t\tif(ground) \n\t\t\t\t    next_state = sLeft ;\n\t\t\t\telse \n\t\t\t\t     next_state= state;\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Assign outputs based on the current FSM state\n\tassign walk_left = (state == sLeft | state==sBumpRight)&(~aaah|ground) ;  \n\tassign walk_right = (state == sRight | state==sBumpLeft )&(~aaah|ground);   \n\tassign aaah =  (state == sFalling);  // aaah is asserted when falling\n\tassign digging = (state ==sLeft & dig)|(state ==sRight & dig);   // digging is asserted during dig action.\nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\treg state; // 0 is right, 1 is left\n\tassign walk_left = state;\n\tassign walk_right = ~state;\n  \n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= 1'b1; // Reset to left on reset\n\t\telse \n\t\t\tcase ({bump_left, bump_right, ground, dig})\n\t\t\t\t4'b0000: state <= state;            // Stay the same when not falling or diving\n        \t\t\t4'b010?: state <= 1'b0;           // Bumped on left side so go right\n        \t\t\t4'b100?: state <= 1'b1;           // Bumped on right side so go left\n        \t\t\t4'b?010: begin                  // Falling or diving, ignore bump signals and stay the same direction\n\t\t\t\t\t      aaah <= 1'b1;              // Say \"aaah!\" when falling\n\t\t\t\t\t      digging <= ground & ~state; // Dig while on ground and not falling \n\t\t\t\t     end\n        \t\t\t4'b?100: begin                  // Falling or diving, ignore bump signals and reverse direction\n\t\t\t\t\t      aaah <= 1'b1;              // Say \"aaah!\" when falling\n\t\t\t\t\t      digging <= ground & state;  // Dig while on ground and not falling \n\t\t\t\t     end\n        \t\t\tdefault: begin                    // Invalid combination of conditions, ignore it\n\t\t\t\t      \tstate <= state;              \n\t\t\t\t\t      aaah <= 1'b0;              // Don't say \"aaah!\"\n\t\t\t\t\t      digging <= 1'b0;            // Not in diving mode\n\t\t\t             end\n\t\t\tendcase\n \tend\nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n    reg state; //0 for left and 1 for right.\n\talways @(posedge clk or posedge areset) begin\n    \tif (areset) begin\n        \t//reset to walk_left\n          \tstate <= 0;\n        end\n        else if ((ground == 0 & bump_right == state) || dig) begin\n\t\t    //fall and dig, switch direction and start digging.\n          \tstate <= ~state;  \n          \taaah <= 1; \n          \tdigging <= (bump_left | bump_right);\n        end\n        else if ((ground == 0 & ~(bump_left == state)) || (~ground & ground != state)) begin\n\t\t    //fall but no direction change, so stop digging and do not switch.\n          \taaah <= 1; \n          \tdigging <= 0;\n        end\n    \telse if ((bump_right ^ bump_left) == (~state & ground == 1)) begin\n        \t//only a single bump and it is on the other side, so change direction.\n         \taaah <= 0; \n          \tdigging <= bump_left | bump_right;  \n        end\n    \telse if (bump_left == state & ~(bump_right == state)) begin\n        \t//single left bump while still walking in the same direction, so continue.\n         \taaah <= 0; \n          \tdigging <= dig | bump_left;  \n        end\n    \telse if (~dig) begin\n\t\t    //no action so do nothing.\n          \taaah <= 0; \n          \tdigging <= 0;\n        end\n  \tend \n\t//outputs are active when state equals to its corresponding bit.\n   assign walk_left = (state == 0);\n   assign walk_right = (state == 1);\n   \nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\treg walking_right;\n\treg falling;\n\treg digging_loc;\n\twire bumped = bump_left | bump_right;\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\twalking_right <= 1'b0;\n\t\t\tfalling <= 1'b0;\n\t\t\tdigging_loc <= 1'b0;\n\t\tend else begin \n\t\t\tcase({bumped, ground})\n\t\t\t\t2'b00 : ; // do nothing if not bumped and ground exists\n\t\t\t\t2'b01 : falling <= 1'b1;  // start falling if not bumped but ground doesn't exist\n\t\t\t\t2'b10 : begin // transitioning to new state due to obstacle\n\t\t\t\t\tif(dig) digging_loc <= 1'b1;   // initiate digging if the Lemming is allowed to dig and was walking on the ground when an obstacle occurs\n\t\t\t\tend\n\t\t\t\t2'b11 : falling <= 1'b0;  // no longer in the fall state once ground reappears. But, still bumped so don't change direction.\n\t\t\tendcase\n\t\t\tcase({bumped, walking_right})\n\t\t\t\t2'b00 : ; // if not bumped then continue current state of walking/not walking\n\t\t\t\t2'b01 : begin \n\t\t\t\t\t\tif (dig) digging_loc <= 1'b1; // if bump while walking right and the Lemming can start digging, initiate digging. \n\t\t\t\tend\n\t\t\t\t2'b10 : begin \n\t\t\t\t\t\twalking_right <= 1'b0; // if bumped on left side (i.e., changed from walk right to walk left) then change state to walk left and stop digging.\n\t\t\t\t\t\tdigging_loc <= 1'b0;  \n\t\t\t\tend\n\t\t\t\t2'b11 : begin \n\t\t\t\t\t\tif(~dig) // if bumped while walking right but can't start digging, continue the current state of walking right (and no need to stop digging).\n\t\t\t\t\t\t\twalking_right <= 1'b1;  \n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend \n\tassign walk_left = ~walking_right & ~falling; //Lemming is walking left when not currently walking right and not falling.\n\tassign walk_right = walking_right | falling;// Lemming is walking right if currently in the state of walking or falling.\n\tassign aaah = falling; // Lemming says \"aaah\" while falling (not during normal walks).\n\tassign digging = digging_loc; // The Lemming is actively digging when this output is 1.\nendmodule\n\n"}
{"task_id": "lemmings3", "completion": "\ntypedef enum logic [2:0] {WALKING_LEFT = 3'b011, \n\t\t\t\t\t     WALKING_RIGHT = 3'b101, \n\t\t\t\t\t\t DIGGING = 3'b110, \n\t\t\t\t\t\t FALLING = 3'b001} state_t;\n\tstate_t state, next_state;\n\t\n\t// state transition logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= WALKING_LEFT;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\t\n\t// output decoding\n\tassign walk_left = state[0];\n\tassign walk_right = state[1];\n\tassign aaah = (state == FALLING);\n\tassign digging = (state == DIGGING);\n\t\t  \n    // next state logic \n\talways @(*) begin\n        case (state)\n            WALKING_LEFT:\tif (bump_right && ground == 1'b1)\tnext_state <= WALKING_RIGHT;\n\t\t\t\t\t\t\telse if (dig == 1'b1 && ground == 1'b1) next_state <= DIGGING;\n\t\t\t\t\t\t\telse if ((~ground == 1'b0)) next_state <= FALLING; \n\t\t\t\t\t\t\telse next_state <= WALKING_LEFT;\t\t\n            WALKING_RIGHT:\tif (bump_left && ground == 1'b1)\tnext_state <= WALKING_LEFT;\n\t\t\t\t\t\t\t else if (dig == 1'b1 && ground == 1'b1) next_state <= DIGGING; \n\t\t\t\t\t\t\t else if ((~ground == 1'b0)) next_state <= FALLING;  \n\t\t\t\t\t\t\t else next_state <= WALKING_RIGHT;\t\n            DIGGING:\t\t\tif (ground == 1'b0)\t\t\t\tnext_state <= FALLING; \n\t\t\t\t\t\t    \telse if(dig==1'b0 && ground ==1'b1)  next_state <= (walk_left)?WALKING_LEFT : WALKING_RIGHT;   \t\t\t\t\t\t\t  \t\n            default:\t\t\t\t\t\t\t\t\t\tnext_state <= FALLING;\t\t\t\t// Falling state if in any other case or unknown state\n        endcase\n\tend \t\t\nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\n\treg walking_left;\n\twire falling;\n\twire [1:0] next_state;\n\tassign walk_left = walking_left;\n\tassign walk_right = ~walking_left;\n\tassign aaah = falling & ~ground;\n\tassign digging = ground & (walking_left ? bump_right : bump_left);\n\t\n\t// State transition\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\twalking_left <= 1'b1;\n\t\telse \n\t\t\tcase (next_state) \n\t\t\t\t2'h0: walking_left <= 1'b1; // walk left state\n\t\t\t\t2'h1: walking_left <= 1'b0; // walk right state\n\t\t\t\t2'h2: ;                     // falling state, keep current direction\n\t\t\t\tdefault:                    // digging state, keep current direction\n\t\t\tendcase \n\tend\n\t\n\t// Next State Logic\n\talways @(*) begin\n\t\tif (dig) begin\n\t\t\tcase ({falling, walking_left}) \n\t\t\t\t2'h0 : next_state = 2'h1; // walk right after digging in grounded state\n\t\t\t    2'h3 : next_state = 2'h2; // falling state while digging\n\t\t\t    default: next_state = {falling, walking_left}; // keep current direction when not digging or bumped \n\t\t\tendcase \n\t\tend else begin\n\t\t\tcase ({bump_right, ground}) \n\t\t\t\t2'h0 : next_state = 2'h1; // walk right if bumped on the left and there is ground\n\t\t\t    2'h3 : next_state = 2'h2; // falling state when hit from left or no ground\n\t\t\t    default: next_state = {bump_left, ground}; // keep current direction when not bumped or grounded\n\t\t\tendcase \n\t\tend  \n\tend  \n\t\n\t// Falling Detection Logic\n\talways @(posedge clk) begin\n\t\tif (areset)\n\t\t\tfall <= 1'b0;\n\t\telse if ((walking_left ? bump_right : bump_left) | ~ground) \n\t\t\tfall <= 1'b1;\n\t\telse if (dig & walking_left == ground) // only reset fall when digging and back to original direction \n\t\t\tfall <= 1'b0; \n\tend  \n\t\nendmodule \n"}
{"task_id": "lemmings3", "completion": "\nreg [1:0] state = 2'b01; // start in left state (walking to the left)\nwire bumped = bump_left | bump_right; \n  \nalways @(posedge clk or posedge areset) begin\n\tif(areset)\n\t\tstate <= 2'b01; // reset to walk to the left state on rising edge of areset\n\telse begin \n\t\tcase ({bumped, ground})\n\t\t\t2'b00: state <= dig ? {~walk_left & ~digging, ~walk_right & digging} : state;\t// if not bumped and no ground -> falling. If digging enable, then start digging else stay in current state.\n\t\t\t2'b01: state <= 2'b10; \t\t // if there is ground but no bump -> continue walking in same direction unless being bumped or digged which causes transition to the fall/dig state\n            2'b10: state <= {~walk_left, ~walk_right}; \t\t\t\t                  // falling: either bumping on both sides changes the walk direction or was told to 'dig'. So reset walk_{left, right} signals.\n\t\t\t2'b11: state <= dig ? {bump_right & ground, bump_left & ground} : state;\t// if there is ground and being bumped -> either stay in same state or go into the fall/dig state depending on whether it was told to 'dig'. \n\t\tendcase\n\tend\nend\n\nassign walk_left = state[1];\nassign walk_right = ~state[1];\nassign aaah = bumped & ~ground; // being bumped while ground==0 -> fall\nassign digging = (bumped | ~ground) & dig;  // if either bumped or not grounded, and the enable to 'dig' then start digging\n\t\nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\t// State encoding: 00 - walk right, 01 - fall right, 10 - dig right, 11 - walk left, 20 - fall left, 21 - dig left\n\treg [4:0] state;\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= 5'b00_000; // start with walk right\n\t\telse case (state[4:2]) \n\t\t\t3'd0: if (!ground & ~dig) state <= {1'b1, bump_left, 2'd2}; else if(dig & ground) state <= {1'b0, bump_right, 2'd3}; // walk right and dig\n\t\t\t3'd1: if (ground | dig) state <= 5'd6; else state[4] = ~state[4]; // fall - switch direction or continue falling\n\t\t\t// the same as for state 0 but bump_left/bump_right are negated due to fall and we start from state 3 after aaah.\n\t\t\t3'd2: if (!ground & ~dig) state <= {1'b0, ~bump_left, 2'd0}; else if(dig & ground) state <= 5'd4; // walk left and dig\n\t\t\tdefault : if (ground | dig) state <= 5'd6; else state[4] = ~state[4]; // fall - switch direction or continue falling\n\t\tendcase \n\tend\n\t// Output decoding: aaah is the fourth bit, digging is the third bit\n\tassign walk_left = state[1];\n\tassign walk_right = state[0] | (state[4] & ~dig); // if we're falling or about to fall then keep moving in our current direction\n\tassign aaah = state[3];\n\tassign digging = state[2] | (state[4] & dig & ground); // while digging and there is ground or falling due to dig\nendmodule\n\n"}
{"task_id": "lemmings3", "completion": "\n  reg [1:0] state;\n  parameter WALK_LEFT = 2'b00,\n            WALK_RIGHT = 2'b01,\n            FALL = 2'b10,\n            DIGGING = 2'b11;\n  \t  \n  always @(posedge clk or posedge areset) begin\n    if (areset == 1)\n      state <= WALK_LEFT;\n    else case (state)\n          WALK_LEFT: \tif (ground & ~dig | bump_right) \tbegin state <= FALL; walk_left <= 0; walk_right <= 0; aaah <= 1; digging <= 0; end\n                      else if (dig) begin state <= DIGGING; walk_left <= 0; walk_right <= 0; aaah <= 0; digging <= 1; end \n                      else\tbegin walk_left <= 1; walk_right <= 0; aaah <= 0; digging <= 0; end   \n          WALK_RIGHT:\tif (ground & ~dig | bump_left) begin state <= FALL; walk_left <= 0; walk_right <= 0; aaah <= 1; digging <= 0; end \n                      else if(dig )begin state <= DIGGING; walk_left <= 0; walk_right <= 0; aaah <= 0; digging <= 1; end  \n                      else\tbegin walk_left <= 0; walk_right <= 1; aaah <= 0; digging <= 0; end \t\t        \n          FALL:   \tif(ground) begin state <= WALK_LEFT; walk_left <= 1; walk_right <= 0; aaah <= 0; digging <= 0; end\t    \t\t\t  \t \n          DIGGING:\tif (~ground | bump_right | bump_left ) begin  state <= FALL; walk_left <= 0; walk_right <= 0; aaah<= 1;digging <= 0; end   \t\t   \t\t\t\t\t \n                      else\tbegin walk_left <= 0; walk_right <= 0;aaah <= 0; digging <= 1;end    \n      endcase      \n  end         \nendmodule  \n"}
{"task_id": "lemmings3", "completion": "\n\treg state; // 0 for walk left, 1 for walk right\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= 0;\n\t\t\twalk_left <= 1'b1;\n\t\t\twalk_right <= 1'b0;\n\t\t\taaah <= 1'b0;\n\t\t\tdigging <= 1'b0;\n\t\tend \n\t\telse if (ground) begin // while grounded\n\t\t\tif ((state == 0 && bump_left) || (state == 1 && bump_right)) begin // change state on bumps\n\t\t\t\tstate <= ~state;\n\t\t\t\twalk_left <= (state==1'b0);\n\t\t\t\twalk_right <= (state==1'b1);\n\t\t\tend\n\t\t\telse if (dig) begin  // start digging while grounded\n\t\t\t\taaah <= 1'b0;\n\t\t\t\tdigging <= 1'b1;\n\t\t\tend\n\t\t\telse begin // stay in same state and stop digging or aaah when ground is back up\n\t\t\t\twalk_left <= (state==1'b0);\n\t\t\t\twalk_right <= (state==1'b1);\n\t\t\t\tdigging <= 1'b0;\n\t\t\t\tif(~ground) begin // if falling state reset the aaah signal.\n\t\t\t\t\taaah <= 1'b1;\t\t\t\t\t\n\t\t\t\tend else \n\t\t\t\t   aaah <= 1'b0; \t\t\n\t\t\tend\n\t\tend \n\t\telse begin // in air state, start aaah\n\t\t\tdigging <= 1'b0;\n\t\t\tif(~ground) begin // if falling state reset the aaah signal.\n\t\t\t\taaah <= 1'b1;\t\t\t\t  \n\t\t\tend else\n\t\t\t   aaah <= 1'b0; \n\t\tend\t\n\tend\nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n\t// Internal signal definitions\n\treg currentState; // 0 for left walking, 1 for right walking\n\treg falling;      // Is the Lemming falling or not?\n\twire next_state = ground ? (bump_left | bump_right) : 1'b1 ;  // Calculate next state\n        \n\t// Moore machine output assignment\n\tassign walk_left  = currentState & ~falling;   // If in left walking state and not falling, output 1\n\tassign walk_right = ~currentState & ~falling;    // If in right walking state and not falling, output 1\n\tassign aaah       = falling ;                   // Output 1 if Lemming is falling\n\tassign digging    = (ground & ~falling) & dig;   // If on ground and not falling and dig input is 1, then output 1\n        \n\t// Synchronous reset for the Moore machine\n\talways @(posedge clk or posedge areset) begin\n\tif(areset)\n\t    currentState <= 0;     // Async reset to left walking state\n        else if (next_state != currentState )// If next_state changes, update state\n            currentState <= next_state ; \n        \n\t// Handle falling. The Lemming can fall only when it is on ground and not already falling or digging\n\tif(ground & ~falling & ~digging)\n\t   falling <= 1;        // Set falling flag if conditions are met\n\telse\n\t   falling <= 0;          // Reset falling flag \n         end     \nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n    reg [1:0] state;\n    parameter LEFT = 2'b10, RIGHT = 2'b01, STOPPED = 2'b00;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset == 1) begin\n            state <= LEFT;\n            walk_left <= 1;\n            walk_right <= 0;\n            aaah <= 0;\n            digging <= 0;\n        end else case(state) \n            LEFT: begin\n                walk_left <= 1;\n                walk_right <= 0;\n                if (ground == 0 || bump_right == 1) begin \n                    state <= STOPPED;\n                    aaah <= 1;\n                end else if(dig == 1 && ground == 1)begin\n                \tstate <= LEFT;\n                \tdigging <= 1;\n\t\t\t\tend\n            end\n             RIGHT: begin\n                walk_left <= 0;\n                walk_right <= 1;\n                if (ground == 0 || bump_left == 1 ) begin \n                    state <= STOPPED;\n                    aaah <= 1;\n                end else if(dig == 1 && ground == 1)begin\n                \tstate <= RIGHT;\n                \tdigging <= 1;\n\t\t\t\tend\n            end\n             STOPPED: begin\n                walk_left <= 0;\n                walk_right <= 0;\n                aaah <= 0;\n                if(ground==1 && bump_left == 0)begin \n                    state <= LEFT;\n                    digging <= 0;\n\t\t\t\tend else if(ground ==1 && bump_right == 0) begin\n\t\t\t\t    state <= RIGHT;\n\t\t\t\t    digging <= 0;\n                end \n            end \n        endcase\n     end  \nendmodule\n"}
{"task_id": "lemmings3", "completion": "\n// FSM States \n    localparam [1:0] STATE_LEFT = 2'b01;\n    localparam [1:0] STATE_RIGHT = 2'b10;\n    \n\t// Registers to hold current and next state.\n\treg [1:0] currState, nextState;\n\t\n\t// Outputs based on current state.\n\tassign walk_left = (currState == STATE_LEFT);\n\tassign walk_right = (currState == STATE_RIGHT);\n\tassign aaah = ~ground & ~dig;\n\tassign digging = ground & dig;\n    \n    always @(posedge clk or posedge areset) begin  // Asynchronous reset.\n        if (areset)\n            currState <= STATE_LEFT;\n        else\n            currState <= nextState;\n    end\n\t\n\t// Next State Logic.\n\talways @(*) begin\n\t    case (currState)\n\t        STATE_LEFT: \n\t        \tif(bump_right & ground)      // if bumped on right while standing, walk right\n                \tnextState = STATE_RIGHT;\n                else if(bump_left & ground)    // if bumped on left and there's ground, fall or dig\n                \tbegin\n                    \tif (digging | aaah )  \n                        \tnextState = currState;  // continue current state while falling/digging\n                     \telse\n                     \t\tnextState = STATE_LEFT; // otherwise, keep walking left\n                 \tend\n            \telse if(bump_right & ~ground)    // if bumped on right and there's no ground, walk right\n                \tnextState = STATE_RIGHT;\n                else \n                    nextState = currState;     // if not bumped, keep current state\n           \n\t        STATE_RIGHT:\n\t\t\t\tif(bump_left & ground)       // if bumped on left while standing, walk left\n                \tnextState = STATE_LEFT;\n                else if(bump_right & ground)  // if bumped on right and there's ground, fall or dig\n                 begin   \n                    \tif (digging | aaah )  \n                        \tnextState = currState;// continue current state while falling/digging\n                     \telse\n                      \t\tnextState = STATE_RIGHT; // otherwise, keep walking right\n                 \tend \n                else if(bump_left & ~ground)    // if bumped on left and there's no ground, walk left\n                \tnextState = STATE_LEFT;\n                else \n                    nextState = currState;   // if not bumped, keep current state\n        endcase\n\tend\nendmodule\n\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\t//State definition\n\ttypedef enum logic [1:0] {S0 = 2'b00, S1 = 2'b01, SE = 2'b10, SD = 2'b11} statetype;\n\tstatetype state, nextstate; \n  \n\t//State transition logic\n\talways_ff @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= S0;\n\t\telse \n\t\t\tstate <= nextstate;\n\tend\n  \n\t//Next state and output decoding logic\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS0: if (data) \n\t\t\t\t\tnextstate = SE;\n\t\t\t\telse \n\t\t\t\t\tnextstate = S1;\n\t\t\tS1: if(data) \n\t\t\t\t\tnextstate = SD;\n\t\t\t\telse \n\t\t\t\t\tnextstate = S0;\n\t\t\tSE: if(~data) \n\t\t\t\t\tnextstate = S1;\n\t\t\t\telse \n\t\t\t\t\tnextstate = SE;\n\t\t\tSD: nextstate = ~reset ? S0 : SD; // reset will keep the state. \n\t\tendcase\n  \n\t\t//output logic\n\t\tif (state == SD) \n\t\t\tstart_shifting = 1'b1;\n\t\telse \n\t\t\tstart_shifting = 1'b0;\n\tend   \nendmodule\n\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\n\t// FSM states definition\n\ttypedef enum {STATE_RESET, STATE_IDLE, STATE_SEARCHING} state;\n\tstate currentState, nextState;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tcurrentState <= STATE_RESET;\n\t\telse \n\t\t\tcurrentState <= nextState;\n\tend\n\n\t// FSM combinational logic\n\talways @(*) begin\n\t\tcase (currentState)\n\t\t\tSTATE_RESET: begin\n\t\t\t\tstart_shifting = 0;\n\t\t\t\tif (!reset)\n\t\t\t\t\tnextState = STATE_IDLE;\n\t\t\t\telse \n\t\t\t\t\tnextState = STATE_RESET;\n\t\t\tend\n\t\t\tSTATE_IDLE: begin\n\t\t\t\tstart_shifting = 0;\n\t\t\t\tif (data && data && !data) // sequence is 110, not starting with a 1.\n\t\t\t\t\tnextState = STATE_SEARCHING;\n\t\t\t\telse\n\t\t\t\t\tnextState = STATE_IDLE;\n\t\t\tend\n\t\t\tSTATE_SEARCHING: begin\n\t\t\t\tstart_shifting = 1;\n\t\t\t\tif (data && data) // sequence is 11, not ending with a 0.\n\t\t\t\t\tnextState = STATE_SEARCHING;\n\t\t\t\telse if (!data) // sequence found 1101, reset state and start shifting.\n\t\t\t\t\tnextState = STATE_RESET;\n\t\t\t\telse // partial match in the middle of 11\n\t\t\t\t\tnextState = STATE_IDLE;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state;\n\tassign start_shifting = (state==4'b1101)? 1 : 0;\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) \n\t\t\tstate <= 4'b0000;\n\t\telse \n\t\t\tcase(state)\n\t\t\t\t4'b0000: state <= data ? 4'b1 : 4'b0000;\n\t\t\t\t4'b1: state <= data ? 4'b11 : 4'b0000;\n\t\t\t\t4'b11: state <= data ? 4'b110 : 4'b0000;\n\t\t\t\t4'b110: state <= data ? 4'b1101 : 4'b0000;\n\t\t\t\tdefault: state <= 4'b0000;\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state;\n\twire next_state = (state & 2'b10) | (data & ~state[0]); // if last bit was '0', then the new sequence is just data, but if last bit was '1' then we have to start again so its data & ~state[0]\n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset) state <= 4'h0; // reset state machine\n\t\telse state <= next_state ? state + 1 : 4'h1; // if we found a sequence advance our state, else start again\n\tend\n\tassign start_shifting = state == 4'b1101;\nendmodule\n\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state;\n\tassign start_shifting = (state == 4'b1101);\n    \n    always @(posedge clk or posedge reset) begin\n        if(reset) \n            state <= 4'd0;\n        else begin\n        \tcase (state) \n            \t4'd0: data ? state <= 4'd1 : state <= 4'd0;\n               \t4'd1: data ? state <= 4'd2 : state <= 4'd0;\n                4'd2: data ? state <= 4'd3 : state <= 4'd0;\n            \t4'd3: data ? state <= 4'd4 : state <= 4'd0; \n                4'd4: data ? state <= 4'd1 : state <= 4'd0; // Found sequence, start shifting\n                default : state <= 4'd0;\n           \tendcase\n        end      \n    end  \nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n    \n    reg [3:0] state;\n\n    always @ (posedge clk or posedge reset) begin\n        if(reset) \n            state <= 4'b0000;\n        else\n            case(state) \n                4'b0000: data ? state <= 4'b0001 : state <= 4'b0000; // idle\n                4'b0001: data ? state <= 4'b0010 : state <= 4'b0000; \n                4'b0010: data ? state <= 4'b0011 : state <= 4'b0000; \n                4'b0011: data ? state <= 4'b0101 : state <= 4'b0000; // sequence found, start shifting\n                4'b0101: state <= 4'b0101;                             // stay in this state until reset \n                default: state <= 4'b0000;\n            endcase\n    end    \n\n    assign start_shifting = (state == 4'b0101);\n\t\nendmodule\n\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state = 4'b0000;\n\tassign start_shifting = (state == 4'b1101)? 1 : 0;\n\t\t\n\talways @(posedge clk or posedge reset) begin\n\t    if(reset)\n\t        state <= 4'b0000;\n        else\n            case (state)\n                4'b0000: state <= data? 4'b0001 : 4'b0000;\n                4'b0001: state <= data? 4'b0011 : 4'b0000;\n                4'b0011: state <= data? 4'b0111 : 4'b0000;\n                4'b0111: state <= data? 4'b1101 : 4'b0000;\n                default: state <= 4'b0000;\n            endcase\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n    reg [3:0] state;  //4 bit counter to search the sequence in input bits.\n    \n    always @ (posedge clk or posedge reset) begin\n        if(reset) begin\n            state <= 4'b0000;\n\t\t\tstart_shifting <= 1'b0;  \n        end\n         else begin\n             case (state) \n                 4'b0000 : data ? (state <= 4'b0001):(state <= state);      // if input bit is '1' then move to next state.\n                 4'b0001 : data ? (state <= 4'b0011):(state <= state);      \n                 4'b0011 : data ? (state <= 4'b0110, start_shifting<=1'b1) : (state <= 4'b0000, start_shifting<=1'b0);    // if input bit is '0' then back to initial state.\n                 default: state <= state; \n             endcase        \n        end      \n     end     \nendmodule\n\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state;\n\tparameter SEARCH = 4'b0001, FOUND = 4'b1010;\n\t\t\n\talways @(posedge clk or posedge reset) begin \n\tif (reset) \n\t\tstate <= SEARCH;\n\telse \n\t\tcase(state) \n\t\tSEARCH: state <= data ? SEARCH : FOUND; //If the input bit is '1' stay in current state, else go to found state.\n\t\tFOUND: state <= FOUND;   //stay in Found state until reset\n\t\tdefault: state <= SEARCH; \n\t\tendcase\n\tend\n\t\t\n\t//Output start shifting should be high if and only if we are in the \"Found\" state\n\tassign start_shifting = (state == FOUND);  \nendmodule\n\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\n    reg [3:0] state = 4'b0000; // Initialize State to 0\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1) begin   // Reset Condition\n            state <= 4'd0;      // Reset state\n            start_shifting <= 0; // Reset start shifting\n        end\n        else begin \n            case (state)\n                4'b0000: data ? (state <= 4'b1001): (state <= state);\n                4'b0001, 4'b0010, 4'b0011, 4'b0100, 4'b0101: data ? (state <= state + 4'd1) : (state <= 4'd0);\n                4'b1001: start_shifting <= 1; // Start shifting when sequence found\n                default: state <= 4'd0;   // Default Case to reset \n            endcase\n        end\n    end    \nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state;\n\tassign start_shifting = (state == 4'b1101) ? 1 : 0;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n\t        state <= 4'b0;\n\t    else\n    \t    state <= {data, state[3:1]};\n    end\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state;\n\tassign start_shifting = (state == 4'b1101) ? 1 : 0;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 4'b0000;\n\t\telse\n\t\t\tstate <= {state[2:0], data};\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state;  // State register\n\tassign start_shifting = (state == 4'hA);  \n\t\t\n\talways @(posedge clk or posedge reset) begin   \n\t  if(reset)                        \n\t    state <= 4'b0000;              \n\t  else                             \n\t    case(state)                    \n\t      4'b0000: data ? state <= 4'h1 : state <= state; \n\t      4'h1: data ? state <= 4'h2 : state <= state;  \n\t      4'h2: data ? state <= 4'h3 : state <= state; \n\t      4'h3: data ? state <= 4'hA : state <= state;   \n\t      default: state <= 4'b0000; \n\t    endcase                     \n\tend                                \nendmodule \n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 4'h0;\n\t\telse \n\t\t\tcase (state)\n\t\t\t\t4'h0 : data ? state <= 4'h1 : state <= state;\n\t\t\t\t4'h1 : data ? state <= 4'h2 : state <= state;\n\t\t\t\t4'h2 : ~data ? state <= 4'h3 : state <= state;  //0 to start shifting\n\t\t\t\t4'h3 :        state <= 4'h3;\n\t\t\tendcase\n\tassign start_shifting = (state == 4'h3);\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state = 4'b0000; // state is 4-bit wide because we need to look at the last 4 bits only.\n\tassign start_shifting = (state == 4'b1101);\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tstate <= 4'b0000; // reset state to initial condition\n\t\telse\n\t\t\tcase(state) \n\t\t\t\t// shift in the new bit on each clock cycle and keep last 3 bits of state (which represent last 3 bits of input stream).\n\t\t\t\t4'b0000: state <= {data,1'b0}; \n\t\t\t\t4'b0001: state <= {data,state[2]};  \n\t\t\t\t4'b0010,\n\t\t\t\t4'b0011,\n\t\t\t\t4'b0100,\n\t\t\t\t4'b0101,\n\t\t\t\t4'b0110,\n\t\t\t\t4'b0111: state <= {data,state[3]};  \n\t\t\t\t4'b1000: state <= {data,state[2]};  \n\t\t\t\tdefault : state <= 4'bxxxx; // undefined\n\t\t endcase\n\tend \nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state = 4'h0;\n\tassign start_shifting = (state == 4'hD) ? 1 : 0; // Start shifting when sequence is found (1101 in binary).\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) state <= 4'h0;\n\t\telse case (state)\n\t\t\t4'hF: state <= data ? 4'hE : 4'h0; // If we reached the final state and got a '1', go to error state.\n\t\t\t4'hE: state <= data ? 4'hD : 4'h0; // Go back to start state if '1' is not followed by '0'.\n\t\t\tdefault: state <= (state << 1) | data; // Shift left and add the new bit.\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n     reg [1:0] state;\n     \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 2'b00;\n\t\t\tstart_shifting <= 1'b0;\n        end \n        else begin\n            case (state)\n                2'b00: data ? (state <= 2'b01):(state <= state);\n                2'b01: data ? (state <= 2'b11):(state <= state);\n                2'b11: (data ? (state <= 2'b01) : ((start_shifting <= 1'b1))); \n                default: state <= 2'b00;\n            endcase\n        end\n    end\nendmodule  \n"}
{"task_id": "review2015_fsmseq", "completion": "\n    \n    reg [3:0] state = 4'b0000;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin \n            state <= 4'b0000;\n\t\t\tstart_shifting <= 1'b0;\n        end else begin\n           case (state)\n                4'b0000: if (data == 1'b1)   state <= 4'b0001; \n                else                    state <= 4'b0000;\n                4'b0001: if (data == 1'b1)   state <= 4'b0011; \n                else                    state <= 4'b0000;\n                4'b0011: if (data == 1'b0)   state <= 4'b0110; \n                else                    state <= 4'b0000;\n                4'b0110: if (data == 1'b1) begin state <= 4'b1101; start_shifting <= 1'b1; end\n\t\t\t\telse begin state <= 4'b0000; start_shifting <= 1'b0; end\n                4'b1101: if (data == 1'b1)   state <= 4'b1101; \n                else                    state <= 4'b0000;\n           endcase\n        end     \n    end    \nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n    reg [1:0] state;\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset == 1'b1)  // Resetting the state machine to its initial state when reset is high\n            state <= 2'b00;\n        else begin\n            case(state)\n                2'b00: data == 1'b1 ? state <= 2'b01 : state <= 2'b00;   // If the input data is 1, go to next state, if not stay in the same state.\n                2'b01: data == 1'b1 ? state <= 2'b10 : state <= 2'b00;   // If the input data is 1, go to next state, if not reset the machine.\n                2'b10: data == 1'b0 ? state <= 2'b11 : state <= 2'b01;   // If the input data is 0, go to next state, if not return to first state.\n                2'b11: data == 1'b1 ? state <= 2'b11 : state <= 2'b00;   // If the input data is 1, stay in this state, if not reset the machine.\n            endcase\n        end\n    end\n\tassign start_shifting = (state==2'b11);// Output will be high whenever sequence '1101' is found and reset is low\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\n\treg [3:0] state; //4-bit state for the finite state machine\n  \n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset) \n\t\t\tstate <= 4'b0000; \n\t\telse \n\t\t\tcase (state) \n\t\t\t\t4'b0000: if (~data) state <= 4'b0001; \n\t\t\t\t4'b0001: if (~data) state <= 4'b0011; \n\t\t\t\t4'b0011: if ( data) state <= 4'b0111; \n\t\t\t\t4'b0111: if (data) begin state <= 4'b1111; start_shifting <= 1; end //set the output to 1 when sequence found\n\t\t\t\tdefault: state <= 4'b0000; \n\t\t\tendcase  \n\tend   \nendmodule\n\n"}
{"task_id": "fsm3", "completion": "\n\t// state variables declaration\n\treg [1:0] ps, ns;\n\t\n\t// output variable declaration\n\tassign out = ps[0];\n\t\n\t// next state logic\n\talways @(*) begin\n\t\tcase (ps) \n\t\t\t2'b00: if (!in) ns = 2'b00; else ns = 2'b10;\n\t\t\t2'b01: if (!in) ns = 2'b00; else ns = 2'b01;\n\t\t\t2'b10: if (!in) ns = 2'b00; else ns = 2'b11;\n\t\t\t2'b11: if (!in) ns = 2'b01; else ns = 2'b10;\n\t\tendcase\n\tend \n\t\n\t// state register\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) ps <= 2'b00; // reset to state A\n\t\telse ps <= ns;  // otherwise, transition to next state\n\tend   \n\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n\treg [1:0] state;\n\treg [1:0] nextstate; \n   reg out;\n   \n   // State transition\n   always @(posedge clk or posedge areset)\n      if (areset) \n         state <= 2'b00; \n      else \n         state <= nextstate; \n      \n   // Next state logic and output decoder\n   always @(*) begin\n      case (state)\n         2'b00: begin \n            if (in == 1'b0) begin\n               nextstate = 2'b00;\n\t         out=1'b0;\n            end\n            else begin \n               nextstate = 2'b01;\n\t         out=1'b0;\n            ]\n         2'b01: begin\n\t    if (in == 1'b0) begin\n             \t   nextstate = 2'b00;\n\t\t   out=1'b0;\n            end\n            else begin \n               nextstate = 2'b10;\n               out=1'b0;\n            end\n         2'b10: begin\n\t    if (in == 1'b0) begin\n             \t   nextstate = 2'b10;\n\t\t   out=1'b0;\n            end\n            else begin \n               nextstate = 2'b11;\n\t\t   out=1'b0;\n            end\n         2'b11: begin\n\t    if (in == 1'b0) begin\n             \t   nextstate = 2'b01;\n\t\t   out=1'b1;\n            end\n            else begin \n               nextstate = 2'b11;\n\t\t   out=1'b1;\n            end\n      endcase\n   end // always @ (*)\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n\n\t// declare state register and next state variables as enum type\n\ttypedef enum {A, B, C, D} statetype;\n\tstatetype state, nextstate;\n\n\t// define Moore outputs for each state\n\tassign out = (state == D);\n\n\t// state transition function: 0,1 -> 0,2,3 are possible\n\talways_comb begin\n\t    case(state) \n\t\t    A: if (~in) nextstate = A; else nextstate = B;\n\t\t    B: if (~in) nextstate = C; else nextstate = B;\n\t\t    C: if (~in) nextstate = A; else nextstate = D;\n\t\t    D: if (~in) nextstate = C; else nextstate = B;\n\t    endcase\n\tend \n\n\t// reset synchronous state transition\n\talways_ff @(posedge clk, posedge areset) begin\n\t    if (areset) state <= A;\n\t    else state <= nextstate;\n\tend\n\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    always @(posedge clk or posedge areset) begin \n        if (areset) \n            state <= A; \n        else\n            case (state)\n                A: begin out <= ~in; if (!in) state <= B; end\n                B: begin out <=  in ; if  (in) state <= C; else state <= A; end\n                C: begin out <= ~in; if (!in) state <= D; end\n                D: begin out <=  in ; if  (in) state <= B; else state <= C; end\n            endcase\n    end\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n\treg [1:0] state;\n\treg [3:0] nextState;\n\tassign out = state[0];\n\t\n\t// State transition table\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t2'b00 : begin \n\t\t\t\tif (!in) begin nextState = 4'b00; end // A to A, B\n\t\t\t\telse begin nextState = 4'b01; end   // A to B, C\n\t\t\tend\n\t\t\t\t\n\t\t\t2'b01 : begin \n\t\t\t\tif (!in) begin nextState = 4'b10; end // B to A, D\n\t\t\t\telse begin nextState = 4'b01; end   // B to C, B\n\t\t endcase\n\t\t\t\n\t\t\t2'b10 : begin \n\t\t\t\tif (!in) begin nextState = 4'b00; end // C to A, B\n\t\t\t\telse begin nextState = 4'b11; end   // C to D, E\n\t    \tend\n\t\t\t\t\n\t   \t2'b11 : begin \n\t\t\t\tif (!in) begin nextState = 4'b10; end // D to A, B\n\t\t\t\telse begin nextState = 4'b01; end   // D to C, B\n\t\t\tend\n\t\t endcase\n\t  end\n\tend\n\t\n\t// State register\n\talways @(posedge clk or posedge areset) begin \n\t    if (areset) \n\t        state <= 2'b00;  // Async reset\n        else \n            state <= nextState[1:0]; // Regular operation\n    end\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n    parameter A = 2'h0, B=2'h1, C= 2'h2, D = 2'h3; \n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n           case (state)\n               A:begin  \n                   out <= 0;\n                    if (!in)\n                        state <= B; \n                    else \n                         state<= C;  \n                end                \n              B: begin   \n                  out <= 0;\n                     if(in)\n                       state <= B; \n                      else \n                       state <= A ;     \n               end           \n              C:begin    \n                   out <= 0;\n                    if (in)\n                        state <= D; \n                      else \n                         state<=A;  \n                end                 \n              \n              D: begin   \n                     out <= 1;\n                     if (!in)\n                       state <= B; \n                     else \n                        state <= C;     \n                   end            \n           endcase\n     end\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n    parameter A = 2'd0, B = 2'd1, C = 2'd2, D = 2'd3;\n    \n    always @(posedge clk or posedge areset) begin \n        if (areset) \n            state <= A;\n        else\n            case (state) \n                A:begin  \n                    out <= 1'b0;\n                    state <= in ? B : A;\n                end\n                B:begin   \n                    out <= 1'b0;\n                    state <= in ? C : B;\n                end\n                C:begin   \n                    out <= 1'b0;\n                    state <= in ? D : A;\n                end \n                D:begin   \n                    out <= 1'b1;\n                    state <= in ? B : C;\n                end  \n            endcase      \n     end        \nendmodule\n"}
{"task_id": "fsm3", "completion": "\n\t// State declaration\n\treg [1:0] state;\n  \tparameter A = 2'b00;\n \tparameter B = 2'b01;\n \tparameter C = 2'b10;\n \tparameter D = 2'b11;\n    \n    // Output assignment\n    assign out = (state == D);\n  \n\t// State transition logic\n\talways @(posedge clk or posedge areset) begin\n\t    if(areset) \n\t\t\tstate <= A;\n\t\telse\n        \tcase(state) \n            \tA: state <= in ? C : A;\n              \tB: state <= in ? D : B;\n              \tC: state <= in ? A : C;\n             \tD: state <= in ? B : D;\n       \t \tendcase\n    \tend   \nendmodule \n\n"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= A;\n        else\n        case (state)\n            A: begin out <= 0; if (in == 0) state <= A; else state <= B; end\n            B: begin out <= 0; if (in == 0) state <= C; else state <= B; end\n            C: begin out <= 1; if (in == 0) state <= A; else state <= D; end\n            D: begin out <= 1; if (in == 0) state <= C; else state <= B; end\n        endcase\n    end\nendmodule \n"}
{"task_id": "fsm3", "completion": "\n\n\t//state definition\n\ttypedef enum {A=2'b00, B=2'b01, C=2'b10, D=2'b11} state_t;\n\t\n\tstate_t currentState, nextState;\n\t\t\n\t//next state logic \n\talways @(*) begin\n    case (currentState) \n        A: if (!in) nextState = A; else nextState = B;   //in=0 goes to A, in=1 goes to B\n        B: if (!in) nextState = C; else nextState = B;   //in=0 goes to C, in=1 stays at B\n        C: if (!in) nextState = A; else nextState = D;   //in=0 goes to A, in=1 goes to D\n        D: if (!in) nextState = C; else nextState = B;   //in=0 goes to C, in=1 goes to B\n\t\tdefault : nextState = A;\n    endcase \n\tend    \n\t\t\n\t//output logic (from current state)\n\tassign out = (currentState==D);\n\t\t\t\n\t//state transition\n\talways @(posedge clk or posedge areset) begin\n\tif(areset)\n\t    currentState <= A;\n\telse\n\t    currentState <= nextState; \n\tend   \t\t  \nendmodule \n"}
{"task_id": "fsm3", "completion": "\n\treg [1:0] state;\n\treg [1:0] nextState;\n\treg outputSignal;\n\t\t\n\t// state machine definition\n\talways @(*) begin \n\t    case (state)\n\t\t    2'b00 : begin\n\t\t\t    if (!in) begin \n\t\t\t\t    nextState = 2'b00;\n\t\t\t\t    outputSignal = 1'b0;\n\t\t\t    end else begin \n\t\t\t\t    nextState = 2'b01;\n\t\t\t\t    outputSignal = 1'b0;\n\t\t\t    end\n\t\t\tend\n\t\t    2'b01 : begin\n\t\t\t    if (!in) begin \n\t\t\t\t    nextState = 2'b01;\n\t\t\t\t    outputSignal = 1'b0;\n\t\t\t    end else begin \n\t\t\t\t    nextState = 2'b10;\n\t\t\t\t    outputSignal = 1'b0;\n\t\t\t    end\n\t\t\tend\n            2'b10 : begin\n                if (!in) begin \n                    nextState = 2'b10;\n                    outputSignal = 1'b1;\n                end else begin \n                    nextState = 2'b00;\n                    outputSignal = 1'b0;\n                end\n            end\n\t\t    2'b11 : begin\n\t\t\t    if (!in) begin \n\t\t\t\t    nextState = 2'b11;\n\t\t\t\t    outputSignal = 1'b0;\n\t\t\t    end else begin \n\t\t\t\t    nextState = 2'b01;\n\t\t\t\t    outputSignal = 1'b0;\n\t\t\t    end\n\t\t\tend\n\t    endcase\n\tend\n\t\n\t// state register\n\talways @(posedge clk or posedge areset) begin \n        if (areset) \n            state <= 2'b00;\n        else\n            state <= nextState;\n\tend\n\t\t  \n    assign out = outputSignal;\n    \nendmodule\n"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n    reg [1:0] next_state;\n\t output reg out;\n\t \n    // State transition table\n    always @(*) begin\n        case (state)\n            2'b00: begin\n                next_state = in ? 2'b10 : 2'b00;\n\t\t\t\t\t\tout = 1'b0;\n            end\n            2'b01: begin\n                next_state = in ? 2'b00 : 2'b01;\n\t\t\t\t\t\tout = 1'b0;\n            end\n\t\t\t  2'b10: begin\n                next_state = in ? 2'b01 : 2'b10;\n\t\t\t\t\t\tout = 1'b0;\n            end\n            2'b11: begin\n                next_state = in ? 2'b11 : 2'b11;\n\t\t\t\t\t\tout = 1'b1;\n            end\n        endcase\n    end\n    \n\t  // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 2'b00;\n        else\n            state <= next_state;\n    end\nendmodule\n\n"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n    \n    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;\n    \n    always @ (posedge clk or posedge areset) begin\n        if(areset) \n            state <= A;\n        else\n        case(state)\n            A: if(!in)  state <= B; //next_state in=0, next_state in=1 = B,B\n               else     state <= C; //next_state in=0, next_state in=1 = A,D\n            B: if(!in)  state <= A; //next_state in=0, next_state in=1 = A,A\n               else     state <= B; //next_state in=0, next_state in=1 = C,B\n            C: if(!in)  state <= D; //next_state in=0, next_state in=1 = C,C\n               else     state <= A; //next_state in=0, next_state in=1 = A,D\n            D: if(!in)  state <= C; //next_state in=0, next_state in=1 = B,D\n               else     state <= B; //next_state in=0, next_state in=1 = D,B\n        endcase\n    end\n    \n    assign out = (state == D);  //if last state is D then output 1 otherwise 0.\nendmodule \n"}
{"task_id": "fsm3", "completion": "\n\treg [1:0] state;\n\tparameter A = 2'h0, B = 2'h1, C = 2'h2, D = 2'h3;\n\t\n\t// State transitions\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= A;\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tA: state <= in ? B : A;\n\t\t\t\tB: state <= in ? C : B;\n\t\t\t\tC: state <= in ? D : A;\n\t\t\t\tD: state <= in ? B : C;\n\t\t\tendcase\n\tend \n\n\t// Output logic\n\tassign out = (state == D);\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n\treg [2:0] state; // define states A=2'b00, B=2'b01, C=2'b10 and D=2'b11\n\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t        state <= 2'd0; // Resets the fsm to A = 2'b00 on reset\n\t    else\n    \t    case (state)\n        \t    2'd0: begin out <= 1'b0; state <= in ? 2'd3 : 2'd1; end   // If input is 0, stay at state A and output 0. If input is 1, go to state D and output 1.\n        \t    2'd1: begin out <= 1'b0; state <= in ? 2'd0 : 2'd2; end   // same as above for B\n                2'd2: begin out <= 1'b0; state <= in ? 2'd1 : 2'd3; end   // same as above for C\n\t\t2'd3: begin out <= 1'b1; state <= in ? 2'd2 : 2'd0; end    // same as above for D\n        \tendcase\n    \tend\n\tend\n\n"}
{"task_id": "fsm3", "completion": "\n     reg [1:0] state;\n    always @(posedge clk or posedge areset) begin \n        if(areset)   // asynchronous reset\n            state <= 2'b00;\n       else\n           case (state)\n            2'b00 : if (!in) state <= 2'b00; \n                    else state <= 2'b01; \n            2'b01 : if (!in) state <= 2'b00; \n                    else state <= 2'b10;  \n            2'b10 : if (!in) state <= 2'b10; \n                    else state <= 2'b11;  \n            2'b11 : if (!in) state <= 2'b01; \n                    else state <= 2'b11;   \n           endcase\n    end\n     assign out = (state == 2'b11); // output is high when in state D\nendmodule\n"}
{"task_id": "fsm3", "completion": "\n\treg [1:0] state;\n\tparameter A = 2'd0, B = 2'd1, C = 2'd2, D = 2'd3;\n\twire [1:0] next_state;\n\tassign out = (state == D);\n    \n\talways @(posedge clk or posedge areset) \n\tbegin  \n\t    if(areset)\n\t\t    state <= A;\n        else\n            state <= next_state;\n\tend  \n      \n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? C : B;\n\t\t\tC: next_state = in ? D : C;\n\t\t\tD: next_state = in ? A : D;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n    end  \n      \nendmodule \n"}
{"task_id": "fsm3", "completion": "\n\t// Define states as enum data type\n\ttypedef enum {A, B, C, D} state_t;\n\tstate_t next_state, current_state;\n\t\n\t// State Transitions\n\talways @(posedge clk or posedge areset) begin \n\t\tif (areset == 1'b1) // Asynchronous Reset\n\t\t\tcurrent_state <= A;\n\t\telse\n\t\t\tcase (current_state)  \n\t\t\t\tA: if (in == 0)\n\t\t\t\t\t\tnext_state = B;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state = C;\n\t\t\t\tB: if (in == 0) \n\t\t\t\t\t\tnext_state = A;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state = B;\n\t\t\t\tC: if(in==0)\n\t\t\t\t\t\tnext_state=A;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state=D;\n\t\t\t\tD: if(in==0)\n\t\t\t\t\t\tnext_state=C;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state=B;\n\t\t\tendcase \n\tend\n\n\t// Output Logic\n\tassign out = (current_state == D); //Output '1' when state is 'D'\n\n\t// State Register\n\talways @(posedge clk) begin\n\t\tcurrent_state <= next_state;\n\tend\nendmodule \n\n"}
{"task_id": "fsm3", "completion": "\n\t// Declare internal variables for the state and output.\n\treg [1:0] state;\n\twire nextstate_in0 = (state == 2'b00) ? 2'b1 : \n\t\t\t\t\t(state == 2'b01) ? 2'b0 : \n\t\t\t\t\t~(state[0]);\n\twire nextstate_in1 = ~state[0];\n\tassign out = state[0] | (&state);\n\t\t\n\t// State transition logic.\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= 2'b00; // Resets to A state at positive edge of clock.\n\t\telse\n\t\t\tcase (in) \n\t\t\t\t1'b0: state <= nextstate_in0;\n\t\t\t\t1'b1: state <= nextstate_in1;\n\t\t\t\tdefault : state <= 2'bx; // Undefined input states, set to x.\n\t\t\tendcase\n\tend\n\t\n\t// Output logic based on the current state.\n\t// This is already done by assign statement above.\n\t\nendmodule \n\n"}
{"task_id": "fsm3", "completion": "\n    reg [1:0] state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) \n            state <= A;\n        else\n           case (state)\n                A: begin out <= ~in; if (in==0) state<=A; else state<=B; end\n                B: begin out <= ~in; if (in==0) state<=C; else state<=B; end\n                C: begin out <= in;  if (in==1) state<=D; else state<=C; end\n                D: begin out <= in;  if (in==1) state<=A; else state<=B; end\n           endcase        \n    end     \nendmodule\n"}
{"task_id": "mux2to1", "completion": "\nassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1", "completion": "\nassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n\n\tassign out = sel ? b : a; \n\t\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\nassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n    assign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n    \n   assign out = sel ? b : a; \n   \nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n    assign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1", "completion": "\n  assign out = sel ? b : a;  \nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n\tassign out = sel ? b : a;  // if sel is 1 use b else a.\nendmodule\n"}
{"task_id": "mux2to1", "completion": "\n\n\tassign out = sel ? b : a;\n\t\t\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n\tassign out = sel ? b : a; \nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\nassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1", "completion": "\n    \nassign out = sel ? b : a;\n   \nendmodule \n\n"}
{"task_id": "mux2to1", "completion": "\n   assign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n\n"}
{"task_id": "mux2to1", "completion": "\n    assign out = sel ? b : a;  // 2-to-1 mux using ternary operator.\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n\t//Initial state is set as 1's so that it can be reset to all ones\n\treg [4:0] lfsr = 5'b11111;   //initial value\n\t\t\n\talways @(posedge clk or posedge reset) begin \n        if (reset == 1) begin     //if reset is active then load initial value\n            lfsr <= 5'b11111;   \n        end else begin\n\t    lfsr <= {lfsr[4:0], ^(lfsr[4]^lfsr[3]) };  //XOR operation at bit positions 5 and 3.\n\tend\n     end  \n      assign q = lfsr; //output is same as LFSR state\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n    initial begin\n        q = 5'h1F; // initialize to a known state for easier debugging and testing.\n    end\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 5'h1F;\n        else \n            q <= {q[3] ^ q[4], q[4:1]}; // Taps are at bits 4 and 2. XOR with outputs to produce the next state.\n    end\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n\t// Galois maximum-length 5 bit LFSR with taps at bits 2 and 1.\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 5'h01; // Reset to all ones for maximal length\n\t\telse\n\t\t\tq <= { q[4] ^ q[3], q[2:0] ^ { q[4], q[2:1] } };  // Tapped LFSR equation\n\tend\n\t\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\ninitial begin\n\tq = 5'b10100; // initial seed value \nend\n\nalways @ (posedge clk or posedge reset)begin\n\tif(reset)\n\t\tq <= 5'b10100; // synchronous reset to initial state\n\telse\n\t\tq[4] <= q[4] ^ q[3]; // XOR tap at bit position 5 with output of bit position 3\n   q[3:0] <= {q[3], q[4]}; // Shift left by one\nend\n\n"}
{"task_id": "lfsr5", "completion": "\n\treg [4:0] taps;\n    \n    assign taps[4] = q[3]; // tap at position 4\n    assign taps[3] = q[5]; // tap at position 3\n    assign taps[2:0] = q[2:0]; // bits without any tap\n\t\n\t// reset and clocked operation\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n            q <= 5'b1;\n        else\n            q <= {taps ^ q[4], q[3:1]}; // shift right & xor with taps\n    end\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 5'b1;\n        else \n            q <= {q[3], ~(q[4]^q[0]), q[2], q[0], q[1]}; // taps are at positions [4,2,1,0].\n    end\n    \nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n\t// Maximal length Galois LFSR with taps at bit positions 5 and 3\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n\t        q <= 1; // Reset to all-one state\n\t    else\n    \t   q <= {q[2] ^ q[4], q[3:1]}; // Shift and XOR the bits together\n\tend \nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n    always @ (posedge clk or posedge reset) begin\n        if(reset) \n            q <= 5'b1;\n       else\n           q <= {q[3], ~(q[4]^q[2]), q[0], q[1], ~q[4]};\n    end\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) \n            q <= 5'h1F; // binary for 11111 in hexadecimal \n        else \n            q <= {q[3] ^ q[4], q[4:1]};\n    end\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n\t// Galois LFSR of order 5 with taps at positions 3 and 5\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)\n\t\t\tq <= 5'b00001; // Initialize to 1\n\t\telse \n\t\t\tq <= {q[4]^q[3], q[4:1]};\n\tend\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n\n\tinitial begin\n\t    q = 5'h1F; // All-ones for synchronous active-high reset\n\tend\n\n\talways @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 5'h1F;  // Reset to all ones\n        else  \n\t\t    q <= {q[4]^q[3], q[3:0][4:1]}; // XOR bit at position 5 and tap the bits in positions [3, 2, 1, 0] with their previous state.\n\tend\n\n"}
{"task_id": "lfsr5", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 5'b1;\n\t\telse \n\t\t\tq <= {q[3], q[2], ~(q[4] ^ q[0]), q[1], ~q[0]}; // XOR taps at positions 4, 2 and 0. Invert tap at position 1.\n\tend\nendmodule\n\n"}
{"task_id": "lfsr5", "completion": "\n    assign q[4] = reset ? 1 : (q[0] ^ q[2]);\n    always @(posedge clk) begin\n        if (!reset)\n            q <= {q[3:0], q[4]};\n    end\nendmodule\n\n"}
{"task_id": "lfsr5", "completion": "\n    \n    // Galois LFSR with taps at bit positions 5 and 3\n    always @ (posedge clk or posedge reset) begin\n        if(reset)\n            q <= 5'b1;\n        else\n            q <= {q[4] ^ q[2], q[4:1]};\n    end\n    \nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n\treg [4:0] temp; // temporary register to store XOR result\n\tassign q = temp[4]; // the 5th bit is the LFSR output\n    \n\talways @(posedge clk or posedge reset) begin\n        if (reset) \n            temp <= 1;   // synchronous active high reset\n        else \n            temp <= {temp[3], temp[4] ^ temp[2], temp[1:0], temp[4]}; // taps at bits 5 and 3, bit shift to right by one bit\n    end\nendmodule\t\n"}
{"task_id": "lfsr5", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tq <= 5'b1;\n\t\telse \n\t\t\tq <= {q[3], q[2], ~q[4] ^ q[0], q[1], q[4]};\n\tend\nendmodule\n\n"}
{"task_id": "lfsr5", "completion": "\n\treg [3:0] tap;\n\n\tassign tap = q[4] ^ q[2]; //taps at position 5 (q[4]) and 3 (q[2]) are XORed\n\n\talways @(posedge clk) begin\n\t\tif (reset == 1'b1) \n\t\t    q <= 5'b0; //reset the LFSR to all-zero state on reset active high\n  \t\telse\n    \t\t\tq <= {tap, q[4:1]}; //shifts left and replaces bit at position 0 with xor result of taps\n\tend\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n// Galois LFSR with taps at bit positions 5 and 3\nalways @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\tq <= 5'b1; // Reset to all-1s state\n\telse\n\t\tq <= {q[4] ^ q[2], q[0], q[4:1]};  // XOR tap at bit position 3, no tap at bit position 1, shift remaining bits by one position\nend\n"}
{"task_id": "lfsr5", "completion": "\n\treg [4:0] next_q; // Registered output\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) \n            q <= 5'h1F; // Reset to all 1s as per the requirement of a Galois LFSR\n        else \n            q <= next_q; // Normal operation when not in reset state\n    end\n\t// Tap positions are at bit position 4 and 2. The expression for the nth stage is:\n\talways @(posedge clk) begin\n        \tif (reset == 1'b0)\n            \tnext_q <= {q[3] ^ q[4], q[4:1]}; // Bit 5 of the next state depends on bit 3 and bit 4, others are shifted right by one.\n    end\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\n\tinitial begin\n      q = 5'b00001; // Initial state is 00001 (in decimal)\n   end\n   \n\talways @(posedge clk or posedge reset)begin\n        if(reset == 1'b1)begin\n            q <= 5'b00001;  // Asynchronous active-high reset. Resets LFSR to its initial state i.e., \"1\"\n        end\n\t\telse begin\n        \t// Galois LFSR logic with taps at bit positions 5 and 3. XOR the current output q[4] with previous output q[2]. Shift all other bits towards right by one step.\n\t\t    q <= {q[4] ^ q[2], q[3:0]};  \t\n\t    end\n     end\nendmodule\n"}
{"task_id": "dff", "completion": "\n    \n\talways @(posedge clk)\n\t\t    begin\n\t\t\t\tq <= d;\n\t\t    end\nendmodule \n\n"}
{"task_id": "dff", "completion": "\n\talways @(posedge clk) begin\n        q <= d;\n    end \nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @ (posedge clk) begin  // rs flops on rising clock edge \n        q <= d;  // async reset \n    end\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @(posedge clk) begin\n   \t   \tq <= d;\n\tend\nendmodule\n"}
{"task_id": "dff", "completion": "\nalways @ (posedge clk)  // positive edge triggered by clock signal\n    q <= d;   // D flip flop logic\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @(posedge clk) begin\n    \t    q <= d;\n\tend\nendmodule \n\n"}
{"task_id": "dff", "completion": "\n\talways @(posedge clk) begin\n\t\t    q <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\t//D FlipFlop\n\talways @ (posedge clk) begin \n  \t\tq <= d; \n\tend\n\t\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n    always @ (posedge clk) begin  // flip flops on clock edge\n        q <= d;   // assign new value to output\n    end\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @ (posedge clk) begin\n\t\tif (d == 1'b0)\n\t\t\tq <= 1'b0;\n\t\telse if (d == 1'b1)\n\t\t\tq <= 1'b1;\n\tend \nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @(posedge clk) begin\n\t\t  q <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @ (posedge clk) begin\n  \tq <= d;\n\tend\nendmodule \n\n"}
{"task_id": "dff", "completion": "\n\talways @ (posedge clk) begin \n\t   q <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n  \n    always @(posedge clk) begin\n       q <= d;\n    end\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @(posedge clk) begin\n    \tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff", "completion": "\n    \n    always @(posedge clk) begin\n        q <= d;\n    end \nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\n\talways @(posedge clk) begin \n\t\tq <= d;   // on the rising edge of clock, update output to input value.\n\tend\nendmodule\n"}
{"task_id": "dff", "completion": "\n\talways @(posedge clk) begin\n    \tq <= d;\n\tend \nendmodule\n\n"}
{"task_id": "dff", "completion": "\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff", "completion": "\nalways @(posedge clk) \n    q <= d;\nendmodule\n\n"}
{"task_id": "lfsr32", "completion": "\n\tassign q[31] = (q[22]^q[31]) ^ (q[2]^q[31]) ^ (q[1]^q[31]);\n    always @(posedge clk or posedge reset) begin \n        if(reset)\n            q <= 32'h1;\n        else\n            q <= {q[0], q[31:1]};\n    end\t\nendmodule\n\n"}
{"task_id": "lfsr32", "completion": "\n  \tinitial begin\n      \tq = 32'h1;\n   \tend \n    \n  \talways @ (posedge clk or posedge reset) \n  \tbegin\n     \tif(reset)\n        \tq <= 32'h1;\n      \telse\n        \tq <= { q[30:0], ^(q[31]^q[21]^q[1]^q[0]) };\n   \tend \n\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\tinitial begin\n\t\tq <= 32'h1; //initialize LFSR with 0x1 as per Galois implementation\n\tend\n\t\n\talways @(posedge clk or posedge reset)begin\n\t\t\n\t\tif (reset) q <= 32'h1;\n        \telse begin\n\t\t\t\n\t\t    q[31] <= q[31]; //bit 32 has no tap\n           \tq[30:0] <= {q[31], q[30:1]}; \n            \t//The rest of the bits are shifted by one, bit 0 remains fixed and does not shift in new data.\n        \tend\n    \tend\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\tinitial begin\n      q = 32'h1;\n   end \n   \n   always @ (posedge clk or posedge reset) begin\n     if(reset == 1) begin\n        q <= 32'h1;\n     end else begin        \n       q[0] <= q[31] ^ q[22] ^ q[2] ^ q[1]; // LFSR equation for bit 0\n\t\t   q <= {q[30:0], q[31]};               // Right shift register operation\t\n     end   \n   end\nendmodule \n"}
{"task_id": "lfsr32", "completion": "\n\tinitial begin\n\t\tq = 32'h1; // initial value is 1.\n\tend\n\n\talways @ (posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tq <= 32'h1;  \t// Asynchronous Reset\n\t\telse\n\t\t\tq <= {q[30:0], ^((~q[31]) ^ (q[21]) ^ (q[1]) ^ (q[0]))};  // XOR with taps at bits 32, 22, 2, and 1.\n\tend\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n    assign q[0] = reset ? 1 : (q[31] ^ q[21] ^ q[1] ^ q[0]);\n    \n    generate\n        genvar i;\n        for(i = 1; i < 32; i++) begin: lfsr_bits\n            assign q[i] = reset ? 1 : (q[i-1] ^ q[(i+21)%32] ^ q[(i+02)%32]);\n        end\n    endgenerate\n\t\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\n\t// The taps are at bit positions 32, 22, 2, and 1.\n\tfunction [31:0] lfsr_next;\n\t\tinput [31:0] seed;\n\t\tbegin\n\t\t\tlfsr_next = {seed[30:0], ^(seed[31:29])};\n\t\tend\n\tendfunction \n\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= lfsr_next(q);\n\tend\n\nendmodule\n\n"}
{"task_id": "lfsr32", "completion": "\n\t\n\t// Galois LFSR with taps at bit positions 32, 22, 2 and 1.\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= {q[30:0], ^(q[31]^q[21]^q[1]^q[0])};\n\tend \nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\t// Galois LFSR with taps at bit positions 32, 22, 2 and 1.\n\tinitial begin\n\t    q <= 32'h1; // initial state of the register\n\tend\n\t    \n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t        q <= 32'h1; // asynchronous reset, active high\n\t    else \n\t        q <= {q[30:0], ^(q[31]^q[21]^q[1]^q[0])}; // feedback XOR gate\n\tend\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\t\n\t// Galois LFSR with taps at bit positions 32, 22, 2 and 1.\n\tinitial begin\n\t\tq = 32'h1; // initialize the seed value\n\tend\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tq <= 32'h1;  \t// reset to initial state on reset signal \n\t\tend else begin\n\t\t\tq[31] <= q[30];\t\t\t // tap at bit position 32\n\t\t\tq[30:1] <= q[29:0];   // shift left by one\n\t\t\tq[0] <= q[31] ^ q[22] ^ q[2] ^ q[1];\t// tap at bits 2, 1, 22 and 32\n\t\tend\n\tend\n\n"}
{"task_id": "lfsr32", "completion": "\n\tinitial begin\n    \tq <= 32'h1;  // Reset value\n  \tend\n      \n    always @ (posedge clk or posedge reset) begin\n        if(reset) begin\n            q <= 32'h1;  // Synchronous reset\n         end else begin\n            q[0] <= q[31] ^ q[22] ^ q[2] ^ q[1];\t// Tap positions are defined as mentioned in the problem statement\n            for(i=1; i<32; i++) begin\n            \tq[i] <= q[i-1]; // Shift operation for other bits \n        \tend\n     \tend  \t \n    end\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\t// Initial seed value\n\tparameter INITIAL = 32'h1;\n\t// Tap positions in bit positions \n\tlocalparam [4:0] taps = {5{1}}; // Setting all bits to 1 for tap\n\n\tinitial begin\n\t\tif (reset)\n\t\t\tq <= INITIAL;\n\t\telse\n\t\t\tq <= 0;\n\tend\n  \n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= INITIAL;\n\t\telse\n\t\t\tq[31:1] <= q[taps];\n      // XOR operation for bit 0\n\t\tq[0] <= ^({q[31:2], q[31:31-taps+1]} & taps);  \n\tend\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n    \n    initial begin\n        q = 32'h1;  // Initial value\n    end\n      \n    always @ (posedge clk or posedge reset) begin\n      if(reset == 1) begin  // Reset sequence\n          q <= 32'h1;  \n      end else begin        \n        q[0] <= q[31] ^ q[22] ^ q[2] ^ q[1];  // Galois LFSR formula\n        for(integer i=31;i>0;i--) begin \n            q[i] <= q[i-1];  \n        end\n      end\n    end\nendmodule \n\n"}
{"task_id": "lfsr32", "completion": "\n\tassign q[0] = reset;\n    \n    always @(posedge clk) begin\n        if (reset)\n            q <= 32'h1;\n        else \n            for(integer i=0; i<31; ++i)\n                q[31-i] <= q[31-i] ^ q[32-i];\n    end\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\tassign q[31] = q[29] ^ q[28] ^ q[26] ^ q[25];\n\tgenvar i;\n\tgenerate\n\tfor (i=30; i>=0; i--) begin: lfsr_loop\n\t\tif(i==29 || i== 28|| i == 26|| i == 25 ) continue ; // we don't need to generate logic for these bits as they have a tap\n\t\telse assign q[i] = q[i+1];\n\tend\n\tendgenerate\n\talways @(posedge clk or posedge reset) begin\n\tif (reset) \n\tq <= 32'h1;\n\t else\n\t q <= {q[30:0], q[31]}; //normal shift operation\n\t end\nendmodule\n\n"}
{"task_id": "lfsr32", "completion": "\n    \n    always @(posedge clk or posedge reset) begin \n        if (reset) \n            q <= 32'h1;\n        else \n            q <= {q[30:0], ^(q[31]^q[21]^q[1]^q[0]) };\n    end\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\tif (reset)  // active high synchronous reset\n\t  q <= 32'h1;\n\telse\n      q <= {q[30:0], ~(q[31] ^ q[21] ^ q[1] ^ q[0])};\n\tend\nendmodule\n\n"}
{"task_id": "lfsr32", "completion": "\n    \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 32'h1;\n\t\telse \n\t\t\tq <= {q[30:0], ^(q[31]^q[21]^q[1]^q[0])};\n\tend\n    \nendmodule\n"}
{"task_id": "lfsr32", "completion": "\n\treg [4:0] taps;\n\t\t\n\tassign taps = (q[27]) ^ (q[21]) ^ (q[1]) ^ (q[0]);\n\t\t\t\n\talways @(posedge clk, posedge reset) begin \n\t    if(reset) q <= 32'h1; // active high reset\n\t    else      q <= {taps, q[31:1]};\n    end \t\t  \nendmodule \n"}
{"task_id": "lfsr32", "completion": "\n\tassign q[0] = reset; //resetting the output register \n    \n    always @(posedge clk) begin\n        if (~reset) \n            q <= 32'h1; //set initial value of q to 32'h1 on reset\n        else\n          q <= {q[30:0], ^(q[31]^q[21]^q[1]^q[0]) }; \n     end  \t\nendmodule \n"}
{"task_id": "7420", "completion": "\n\t// First NAND gate for output P1Y\n\twire w; //intermediate wire to be used in the nand operation\n\tassign w = ~(p1a & p1b & p1c & p1d); \n\tp1y <= w;\n\t\n\t// Second NAND gate for output P2Y\n\tassign w = ~(p2a & p2b & p2c & p2d); \n\tp2y <= w;\nendmodule\n"}
{"task_id": "7420", "completion": "\n\t// 7420 NAND gate module implementation\n\tassign p1y = ~(p1a & p1b & p1c & p1d);\n\tassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n"}
{"task_id": "7420", "completion": "\n\t// Using the NAND gates to implement NOT and AND operations\n\tassign p1y = ~(p1a & ~p1b & p1c & p1d);\n\tassign p2y = ~(p2a & ~p2b & p2c & p2d);\nendmodule \n"}
{"task_id": "7420", "completion": "\n\t// The inputs and outputs can be organized in vectors to simplify the implementation.\n\twire [3:0] pa = {p1a, p1b, p1c, p1d};\n\twire [3:0] p2 = {p2a, p2b, p2c, p2d};\n\t// 7420 chip has a dual 4-input NAND gate, each with a Y output.\n\tpand_gate g1 (pa, p1y);\n\tpand_gate g2 (p2, p2y);\nendmodule\n"}
{"task_id": "7420", "completion": "\n\t// NAND gate 1\n\twire w1;\n\tassign w1 = ~(p1a & p1b & p1c & p1d);\n\tassign p1y = w1;\n\n\t// NAND gate 2\n\twire w2;\n\tassign w2 = ~(p2a & p2b & p2c & p2d);\n\tassign p2y = w2;\nendmodule\n\n"}
{"task_id": "7420", "completion": "\n// The 7420 chip has two NAND gates. Here is a possible implementation of the 7420 using Verilog code.\nassign p1y = ~(p1a & p1b & p1c & p1d); // Output for first NAND gate\nassign p2y = ~(p2a & p2b & p2c & p2d); // Output for second NAND gate\n\nendmodule \n"}
{"task_id": "7420", "completion": "\n\twire nand_out;\n\tassign p1y = p1a & p1b & p1c & p1d;\n\tassign p2y = p2a & p2b & p2c & p2d; \nendmodule\n\n"}
{"task_id": "7420", "completion": "\n\twire w;\n   assign p1y = ~(p1a & p1b & p1c & p1d);\n   assign p2y = ~(p2a & p2b & p2c & p2d);\n   \nendmodule \n\n"}
{"task_id": "7420", "completion": "\nassign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d); \nendmodule\n"}
{"task_id": "7420", "completion": "\n   wire nand_out;\n   \n\tassign nand_out = (p1a & ~(p1b | p1c) | p1d) & (p2a & ~(p2b | p2c) | p2d); \n\tassign p1y = ~nand_out;\n\tassign p2y = ~nand_out;\n\t\nendmodule\n\n"}
{"task_id": "7420", "completion": "verilog\n\twire w; // internal wire to connect gates\n\tassign p1y = !(p1a & p1b & p1c & p1d);\n\tassign p2y = !(p2a & p2b & p2c & p2d);\nendmodule\n\n"}
{"task_id": "7420", "completion": "\n\twire a; // Intermediate wire for AND gate\n\tassign a = p1a & p1b;\n\tp1y <= p1c ? ~(p1d | a) : ~(p1d ^ a);\n\n\twire b; // Another intermediate wire for AND gate\n\tassign b = p2a & p2b;\n\tp2y <= p2c ? ~(p2d | b) : ~(p2d ^ b);\nendmodule\n"}
{"task_id": "7420", "completion": "\n\t// Inline description of the logic circuit from the 7420 chip. The output is a NAND operation between two groups of inputs.\n\tp1y = ~(p1a & p1b & p1c & p1d); // Output 1, created with 8-input NAND gate\n\tp2y = ~(p2a & p2b & p2c & p2d); // Output 2, also created with 8-input NAND gate\nendmodule\n"}
{"task_id": "7420", "completion": "\n\n\t// Internal variables for storing intermediate results of NAND gates.\n\treg nand_temp1;\n\treg nand_temp2;\n\n\t// Implementation of two 4-input NAND gates.\n\tassign nand_temp1 = ~(p1a & p1b & p1c & p1d);\n\tassign nand_temp2 = ~(p2a & p2b & p2c & p2d);\n\n\t// Output assignments based on intermediate results of NAND gates.\n\tassign p1y = nand_temp1;\n\tassign p2y = nand_temp2;\nendmodule\n"}
{"task_id": "7420", "completion": "\n\t// Creating NAND gates with the inputs and outputs as per the datasheet of the 7420 chip.\n\tassign p1y = ~(p1a & p1b & p1c & p1d); // Output of first NAND gate.\n\tassign p2y = ~(p2a & p2b & p2c & p2d); // Output of second NAND gate.\nendmodule\n"}
{"task_id": "7420", "completion": "\n\tp1y = ~(p1a & p1b & p1c & p1d); //4-input NAND gate 1 output\n\tp2y = ~(p2a & p2b & p2c & p2d); //4-input NAND gate 2 output\n\t\nendmodule\n"}
{"task_id": "7420", "completion": "\n\n\twire a; //internal signal\n\t//For output 1\n\tassign a = p1a & p1b & p1c & p1d;\n\tassign p1y = ~a;\n\n    wire b; //internal signal\n\t//For output 2\n\tassign b = p2a & p2b & p2c & p2d;\n\tassign p2y = ~b;\nendmodule\n"}
{"task_id": "7420", "completion": "\n\t// In this case we'll use the NAND gates to build a logic circuit that mirrors the behavior of an AND gate.\n\t// This is due to the fact that NAND can be used to create any logical function by combination of other Gates. \n\twire w1, w2; // internal wires for intermediary results\n\t\n\tassign w1 = ~(p1a & p1b);\n\tassign w2 = (w1 | p1c) & ~p1d;\n\tassign p1y = w2;\n\t\n\tassign w1 = ~(p2a & p2b);\n\tassign w2 = (w1 | p2c) & ~p2d;\n\tassign p2y = w2;\nendmodule\n"}
{"task_id": "7420", "completion": "\n\twire w;\n\n\t// Output of NAND gate for P1\n\tassign p1y = ~(p1a & p1b & p1c & p1d);\n\n\t// Wire connecting the outputs of two gates, which will become inputs to the second 4-input NAND gate.\n\tassign w = (~(p2a & ~p2b & p2c & p2d) | ~(p2a & p2b & ~p2c & p2d)) & ~(p1y);\n\n\t// Output of the second 4-input NAND gate for P2\n\tassign p2y = ~(w & ~(p2a & p2b & p2c & p2d));\nendmodule\n"}
{"task_id": "7420", "completion": "verilog\nmodule top_module(\n\tp1a, \n\tp1b, \n\tp1c, \n\tp1d, \n\tp1y, \n\tp2a, \n\tp2b, \n\tp2c, \n\tp2d, \n\tp2y\n);\n\tinput p1a; \n\tinput p1b; \n\tinput p1c; \n\tinput p1d; \n\toutput p1y; \n\tinput p2a; \n\tinput p2b; \n\tinput p2c; \n\tinput p2d; \n\toutput p2y;\n\nassign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\nreg [2:0] y;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\ty <= 3'b000;\n\telse\n\tcase(y)\n\t\t3'b000 : if(!x) y <= 3'b000; else y <= 3'b001; //000 to 001 when x = 1\n      \t\t3'b001 : if(!x) y <= 3'b001; else y <= 3'b100; //001 to 100 when x = 1\n\t\t3'b010 : if(!x) y <= 3'b010; else y <= 3'b001; //010 to 001 when x = 1\n\t\t3'b011 : if(!x) y <= 3'b001; else y <= 3'b010; //011 to 010 when x = 1\n      \t\t3'b100 : if(!x) y <= 3'b100; else y <= 3'b100; //100 to 100 when x = 1\n\tendcase\nend\nassign z = (y == 3'b011)? 1:0 ;// if final state is 011 then output z = 1, otherwise z=0\n\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y;\n\t\n\talways @(posedge clk or posedge reset) begin  // synchronous active high reset\n\t\tif (reset == 1'b1) begin\n\t\t\ty <= 3'd0;   // reset to state 0\n\t\t\tz <= 1'd0;   // output set to zero as well\n\t\tend else if (x == 1'd0) begin\n\t\t\tcase (y)\n\t\t\t\t3'b000: begin y <= 3'b000; z <= 1'b0; end  // stay at state 000\n\t\t\t\t3'b001: begin y <= 3'b001; z <= 1'b0; end  // stay at state 001\n\t\t\t\t3'b010: begin y <= 3'b010; z <= 1'b0; end  // stay at state 010\n\t\t\t\t3'b011: begin y <= 3'b001; z <= 1'b1; end  // go to state 001 and set output to 1\n\t\t\t\t3'b100: begin y <= 3'b011; z <= 1'b1; end  // go to state 011 and set output to 1\n\t\t\tendcase\n\t\tend else if (x == 1'd1) begin\n\t\t\tcase (y)\n\t\t\t\t3'b000: begin y <= 3'b001; z <= 1'b0; end  // go to state 001 and set output to 0\n\t\t\t\t3'b001: begin y <= 3'b100; z <= 1'b0; end  // go to state 100 and set output to 0\n\t\t\t\t3'b010: begin y <= 3'b001; z <= 1'b0; end  // go to state 001 and set output to 0\n\t\t\t\t3'b011: begin y <= 3'b010; z <= 1'b1; end  // go to state 010 and set output to 1\n\t\t\t\t3'b100: begin y <= 3'b100; z <= 1'b1; end  // stay at state 100, set output to 1\n\t\t\tendcase\n\t\tend else ;   // don't do anything if x is unknown (leave z and y alone)\n\tend\n\t\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y = 3'b000; \n\n\talways @(posedge clk or posedge reset) begin\n\t\t if (reset) \n\t\t\t y <= 3'b000; \n\t\t else case(y)\n\t\t\t\t3'b000: y <= x ? 3'b001 : 3'b000;\n\t\t\t\t3'b001: y <= x ? 3'b001 : 3'b100;\n\t\t\t\t3'b010: y <= x ? 3'b001 : 3'b001;\n\t\t\t\t3'b011: y <= x ? 3'b010 : 3'b001;\n\t\t\t\t3'b100: y <= x ? 3'b100 : 3'b100;\n\t\t\t\tdefault: y <= 3'b000;\t\t \n\t\t endcase\n\tend\n\tassign z = (y == 3'b011);\nendmodule\n\n"}
{"task_id": "2014_q3bfsm", "completion": "\nreg [2:0] y; // state register\n    \nalways @(posedge clk or posedge reset) begin \n\tif (reset) // Reset synchronous high active\n\t\ty <= 3'b000;\n\telse case({y,x}) \n\t\t5'b00_000: y <= 3'b000; \n        5'b00_001: y <= 3'b001; \n        5'b00_100: y <= 3'b100;  \n\t\t5'b01_000: y <= 3'b010; \n        5'b01_001: y <= 3'b001; \n        5'b01_100: y <= 3'b011;  \n\t\t5'b10_000: z <= 1'b0; // Outputs on state transitions. \n        5'b10_001: z <= 1'b0; \n        5'b10_100: z <= 1'b1;  \n\t\t5'b11_000: z <= 1'b0;   \n        5'b11_001: y <= 3'b001; \n        5'b11_100: y <= 3'b011;     \n\tendcase  \nend\n    \nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y = 3'd0; // Initial state\n\t\n\t// State transition function\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\ty <= 3'd0;\n\t\telse \n\t\t\tcase (y)\n\t\t\t\t3'd0 : y <= x ? 3'd1 : 3'd0;\n\t\t\t\t3'd1 : y <= x ? 3'd2 : 3'd0;\n\t\t\t\t3'd2 : y <= x ? 3'd1 : 3'd0;\n\t\t\t\tdefault: if (x) begin\n\t\t\t\t\t\t\ty <= 3'd3;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\ty <= 3'd1;\n\t\t\t\t\t\tend\n\t\t\tendcase\n\tend\n\t\n\t// Output function\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tz <= 0;\n\t\telse\n\t\t\tcase (y)\n\t\t\t\t3'd11: z <= 1'b1; // If we are in state 100 then output is 1.\n\t\t\t\tdefault: z <= 1'b0; // Otherwise, output is 0.\n\t\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\t// Internal state register\n\treg [2:0] y;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t    // Asynchronous reset\n        if (reset) \n            y <= 3'b000;\n         else\n             case (y)\n                 3'b000 : y <= x ? 3'b001 : 3'b000;\n                 3'b001 : y <= x ? 3'b001 : 3'b100;\n                 3'b010 : y <= x ? 3'b010 : 3'b001;\n                 3'b011 : y <= x ? 3'b001 : 3'b010;\n                 3'b100 : y <= x ? 3'b011 : 3'b100;\n                 default: y <= 3'b000; // Default to 0 if not defined state, can be omitted.\n             endcase  \n\tend \n\t// Output assignment based on current state\n\tassign z = (y == 3'b011);\n    \nendmodule \n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y;\n    \n    always @(posedge clk or posedge reset) begin\n        if(reset) begin\n            y <= 3'd0; // Reset to 0\n            z <= 1'b0; // Output = 0 on reset\n        end else case (y) \n            3'd0: y <= x ? 3'd1 : 3'd0; // If x is 1, go to state 1, if not stay at state 0\n            3'd1: y <= x ? 3'd2 : 3'd1; // If x is 1, go to state 2, if not stay at state 1\n            3'd2: y <= x ? 3'd1 : 3'd0; // If x is 1, go to state 1, if not go back to state 0\n            default: begin y <= 3'd0; z <= 1'b0; end // Any other states go back to initial state\n        endcase\n        \n    // Update output based on current state.\n    assign z = (y == 3'd3) ? 1'b1 : 1'b0; \nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\t// Declare states and output variables\n\treg [2:0] y;\n\t\n\t// Synchronous reset \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)\n\t\t\ty <= 3'd0;\n\tend\n\n\t// State transition logic and output generation\n\talways @(*) begin\n\t\tcase ({x, y}) \n\t\t\t2'b00_000: begin y <= 3'd0; z <= 1'd0; end // If x=0 and y=000 move to state 000\n\t\t\t2'b00_001: begin y <= 3'd0; z <= 1'd0; end // If x=0 and y=001 move to state 000\n\t\t\t2'b01_000: begin y <= 3'd1; z <= 1'd0; end // If x=1 and y=000 move to state 001\n\t\t\t2'b00_100: begin y <= 3'd4; z <= 1'd1; end // If x=0 and y=100 move to state 100 with output 1\n\t\t\t2'b01_010: begin y <= 3'd2; z <= 1'd0; end // If x=1 and y=010 move to state 010\n\t\t\t2'b00_011: begin y <= 3'd1; z <= 1'd1; end // If x=0 and y=011 move to state 001 with output 1\n\t\t\t2'b10_011: begin y <= 3'd3; z <= 1'd1; end // If x=1 and y=011 move to state 011 with output 1\n\t\t\tdefault :   begin y <= y;        z <= z;    end // Maintains current state\n\tendcase\nend\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\ty <= 3'b000;\n\t\telse\n\t\t\tcase ({x,y}) \n\t\t\t\t4'b00_000 : y <= 3'b000; \n\t\t\t\t4'b10_000 : y <= 3'b001;\n\t\t\t\t4'b00_001 : y <= 3'b001;\n\t\t\t\t4'b01_001 : y <= 3'b010;\n\t\t\t\t4'b10_001 : y <= 3'b001; \n\t\t\t\t4'b00_011 : y <= 3'b011; \n\t\t\t\t4'b01_100 : y <= 3'b100; \n\t\t\t\tdefault:   y <= y; // main state\n\t\t\tendcase\n\tend\n\tassign z = (y==3'b011);\n\t\nendmodule\n\n"}
{"task_id": "2014_q3bfsm", "completion": "\nreg [2:0] y;\n\nalways @(posedge clk or posedge reset) begin \n\tif(reset) begin\n\t\ty <= 3'b000;\n\tend\n\telse\n\tcase (y)\n\t\t3'b000: if (!x) y <= 3'b000; else y <= 3'b001;\n\t\t3'b001: if (!x) y <= 3'b001; else y <= 3'b100;\n\t\t3'b010: if (!x) y <= 3'b010; else y <= 3'b001;\n\t\t3'b011: if (!x) y <= 3'b001; else y <= 3'b010;\n\t\t3'b100: if (!x) y <= 3'b011; else y <= 3'b100;\n\tendcase \nend\n\nassign z = (y == 3'b010 | y == 3'b011);\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\t// Internal registers to hold the present state and next state\n\treg [2:0] y;\n\treg [1:0] next_state;\n\t\n\t// State transition table implementation\n\talways @(*) begin\n\t\tcase (y) \n\t\t\t3'b000 : if (x==0) {next_state, z} = 4'b0000; else {next_state, z} = 4'b0010;\n\t\t\t3'b001 : if (x==0) {next_state, z} = 4'b0010; else {next_state, z} = 4'b1000;\n\t\t\t3'b010 : if (x==0) {next_state, z} = 4'b0100; else {next_state, z} = 4'b0010;\n\t\t\t3'b011 : if (x==0) {next_state, z} = 4'b0010; else {next_state, z} = 4'b0100;\n\t\t\t3'b100 : if (x==0) {next_state, z} = 4'b0110; else {next_state, z} = 4'b1000;\n\t\tendcase \n\tend \n\n\t// State update\n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset == 1) // reset active high\n\t\t\ty <= 3'b000;\n\t\telse  \n\t\t\ty <= next_state;\n\tend \n\nendmodule\n\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y;\n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset) begin\n\t\t\ty <= 3'b000;\n\t\t\tz <= 1'b0;\n\t\tend else case ({y, x})\n\t\t\t6'b000001: y <= 3'b000; z <= 1'b0;\n\t\t\t6'b001001: y <= 3'b001; z <= 1'b0;\n\t\t\t6'b010001: y <= 3'b010; z <= 1'b0;\n\t\t\t6'b011001: y <= 3'b001; z <= 1'b1;\n\t\t\t6'b100001: y <= 3'b011; z <= 1'b1;\n\t\t\tdefault:   {y,z} <= {y,z};\n\t\tendcase\n\tend \nendmodule \n\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\n\t// Internal state variable\n\treg [2:0] y = 3'b000;   // Initial state is 000.\n\t\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t        y <= 3'b000;    // Asynchronous active high reset.\n\t    else case ({y, x})  // Concatenate state and input for state transition.\n\t        5'b00000: y <= 3'b000;   // Stay at 000 if x=0 in state 000.\n\t        5'b00010,    // For other states...\n\t        5'b00100,\n\t        5'b01001: y <= 3'b001;   // ...transition to 001 if x=0.\n\t        5'b00110,    // For other states...\n\t        5'b01011: y <= 3'b100;   // ..and transition to 100 if x=1.\n\t        5'b01100: y <= 3'b010;   // Transition to 010 if x=1 in state 010.\n\t        5'b01110: y <= 3'b001;   // Transition to 001 if x=1 in state 011.\n\t    endcase\n\tend\n\t\n\t// Output z is equal to bit 2 of the current state, since only 5th bit of input matters here (x).\n\tassign z = y[2];  \n\t\nendmodule\n\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] state;\n\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 3'b000;\n\t\telse\n\t\t\tcase (state)\n\t\t\t\t3'b000 : if (!x) state <= 3'b000; else state <= 3'b001;\n\t\t\t\t3'b001 : if (!x) state <= 3'b001; else state <= 3'b100;\n\t\t\t\t3'b010 : if (!x) state <= 3'b001; else state <= 3'b010;\n\t\t\t\t3'b011 : if (!x) state <= 3'b001; else state <= 3'b010;\n\t\t\t\t3'b100 : if (!x) state <= 3'b011; else state <= 3'b100;\n\t\t\t\tdefault: state <= 3'b000;\n\t\t\tendcase\n\tend \n  \n\t// Output logic\n\tassign z = (state == 3'b011) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\nreg [2:0] y;\nalways @(posedge clk or posedge reset) begin \n\tif(reset) begin\n\t\ty <= 3'b000;\n\tend else case ({x,y}) \n\t\t4'b10_0000, // x=0 && y==000 -> go to next state is 001\n\t\t4'b11_0000: y <= 3'b001;\n\t\t4'b10_0001, // x=0 && y==001 -> stay in this state\n\t\t4'b11_0100: y <= 3'b110;\n\t\t4'b10_0100, // x=0 && y==010 -> go to next state is 001\n\t\t4'b11_0010: y <= 3'b001;\n\t\t4'b10_0101, // x=0 && y==011 -> go to next state is 010\n\t\t4'b11_0100: y <= 3'b010;\n\t\t4'b10_0010, // x=1 && y==001 -> go to next state is 100\n\t\t4'b11_1000: y <= 3'b100;\t\n\tendcase\n\tcase(y)\n\t\t3'b000: z = 0; // Output 0 when current state is 000\n\t\t3'b001,// Output 0 when current state is 001 or 010 or 011\n        \t3'b010,\n\t\t3'b011: z = 0;\n        // Output 1 when current state is 100\n        3'b100: z = 1;\n\tendcase\nend\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] state;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 3'b000;\n\t\telse \n\t\t\tcase (state) \n\t\t\t\t3'b000 : if (!x) state <= 3'b000; else state <= 3'b001;\n\t\t\t\t3'b001 : if (!x) state <= 3'b001; else state <= 3'b100;\n\t\t\t\t3'b010 : if (!x) state <= 3'b010; else state <= 3'b001;\n\t\t\t\t3'b011 : if (!x) state <= 3'b001; else state <= 3'b010;\n\t\t\t\t3'b100 : if (!x) state <= 3'b011; else state <= 3'b100;\n\t\t\t\tdefault: state <= 3'b000;\n\t\t\tendcase\n\tend \n  \n\tassign z = (state == 3'b011 || state == 3'b100) ? 1 : 0;\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\n\treg [2:0] y; // state register\n\n\t// state assignment logic\n\talways @(*) begin\n\t\tcase ({y,x}) \n\t\t\t6'b000_000 : y <= 3'd0;\n      \t\t6'b001_001 : y <= 3'd0;\n      \t\t6'b010_010 : y <= 3'd2;\n      \t\t6'b011_001 : y <= 3'd1; \n      \t\t6'b100_011 : y <= 3'd3;\n\t\tdefault     : y <= '0;\n  \t\tendcase\n\tend\n\n\t// output logic\n\talways @(*) begin\n\t\tcase (y)\n\t\t\t3'd0 : z = 1'b0;  // state 0, outputs 0\n      \t\t3'd2 : z = 1'b0;  // state 2, also outputs 0\n      \t\t3'd1, 3'd3: z = 1'b1;  // states 1 and 3 output 1\n\t\tdefault : z = 'x;  // don't care values for other states\n  \t\tendcase\n\tend\n\n\t// reset logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) y <= 3'd0;\n\tend\n\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\treg [2:0] y; // State register\n    \n\t// State transition function\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            y <= 3'b000; // Synchronous reset\n        else case(y)\n            3'b000: if(!x) y <= 3'b000; else y <= 3'b001;\n            3'b001: if(!x) y <= 3'b001; else y <= 3'b100;\n            3'b010: if(!x) y <= 3'b001; else y <= 3'b010;  //z=y[2] & x | z= ~(y[1] ^ y[0]) & ~x\n            3'b011: if(!x) y <= 3'b001; else y <= 3'b010;  \n            3'b100: if(!x) y <= 3'b011; else y <= 3'b100; //z=(y[2] ^ x) | (y[0] & ~x); \n        endcase    \n    end\n        \n    assign z = (y == 3'b010 || y==3'b011)? 1: 0 ; // Output function\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\n\treg [2:0] y;\n\talways @(posedge clk or posedge reset) begin\n\t    if(reset) \n\t\t    y <= 3'b000;\n\t    else\n        case (y)\n            3'b000 : y <= x ? 3'b001 : 3'b000;\n            3'b001 : y <= x ? 3'b001 : 3'b000;\n            3'b010 : y <= x ? 3'b001 : 3'b010;\n\t        3'b011 : y <= x ? 3'b010 : 3'b001;\n\t        3'b100 : y <= x ? 3'b100 : 3'b011;\n            default: y <= 3'b000;\n        endcase\n    end\n    assign z = (y==3'b011);\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "\n\t// Internal register to hold the current state of the FSM\n\treg [2:0] y = 3'b000; \n\n\talways @(posedge clk or posedge reset) begin\n\t\t if (reset == 1'h1) // Reset condition, return to initial state 000\n\t\t\t   y <= 3'b000;\n\t\t else begin\n\t\t\t case (y) \n\t\t\t\t 3'b000: y <= x ? 3'b001 : 3'b000; // Transition to state 001 on input x = 1, remain in state 000 otherwise\n\t\t\t\t 3'b001: y <= x ? 3'b000 : 3'b010; // Transition to state 010 on input x = 1, transition to state 001 otherwise\n\t\t\t\t 3'b010: y <= x ? 3'b011 : 3'b001; // Transition to state 011 on input x = 1, remain in state 010 otherwise\n\t\t\t\t 3'b011: y <= x ? 3'b100 : 3'b010; // Transition to state 100 on input x = 1, transition to state 011 otherwise\n\t\t\t\t 3'b100: y <= x ? 3'b100 : 3'b000; // Transition to state 100 on input x = 1, remain in state 100 otherwise\n\t\t\t endcase\n\t\t end\n\tend\n\t// Output z is the bit 1 of the current state y. Since we only care about state 011 and 100, which have output 1, we need to check this condition.\n\tassign z = (y == 3'b011) || (y == 3'b100);  \nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n    reg state;  // state register\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= 1'b0;   // async active high reset\n        else case({j, k})          // state transition\n            2'b00: state <= 1'b0;  // OFF --j=0--> OFF\n            2'b01: state <= 1'b1;  // OFF --j=1--> ON\n            2'b10: state <= 1'b1;  // ON --k=0--> ON\n            2'b11: state <= 1'b0;  // ON --k=1--> OFF\n            default : state <= state;   // hold state on illegal inputs\n        endcase\n    end\n    \n    assign out = state;  // output assignment\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n   reg state;  // The current state of the machine\n   \n   always @(posedge clk or posedge reset) begin\n      if (reset) \n         state <= 1'b0;  // Reset to OFF\n      else begin\n\t\t\tcase (state) \n            \t1'b0 : state <= j;  // If current state is OFF, change based on input j\n              \t1'b1 : state <= k;  // If current state is ON, change based on input k\n            endcase\n         end\n      end\n   \n   assign out = state;  // The output is the current state\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n    reg state; // 0-OFF, 1-ON\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1)\n            state <= 1'b0;\n        else\n            case({j,k})\n                2'b00 : state <= state; // OFF --j=0--> OFF\n                2'b01 : state <= ~state; // ON --k=0--> ON (toggle)\n                2'b10 , 2'b11 : state <= state; // ON and OFF --k=1--> OFF\n            endcase\n    end\n    \n    assign out = state;\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n\treg [1:0] state;\n    parameter  ON = 2'b10, OFF = 2'b01;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'h1)\n            state <= OFF;\n        else\n            case (state)\n                OFF: if (j==1'h1) \n                        state <= ON;\n                      else\n                        state <= OFF;\n                    \n                ON:  if (k==1'h1)  \n                        state <= OFF;\n                     else\n                        state <= ON;   \n            endcase    \n    end\n    \n    assign out = (state == ON)? 1'h1 : 1'h0 ;\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\nreg [1:0] state; // 2-bit state register\nparameter OFF = 2'b00, ON = 2'b01; // State definitions\n\n// Synchronous reset and state change\nalways @ (posedge clk or posedge reset) begin\n\tif(reset) state <= OFF;\n\telse case (state) \n\t\tOFF: if (j == 0) state <= OFF; else state <= ON;\n\t\tON : if (k ==  0) state <= ON ; else state <= OFF;\n\tendcase\nend\n\n// Output logic\nassign out = (state == ON); // If the state is ON, output '1'\n\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n    reg [1:0] state; // 2-bit state register\n    \n    parameter OFF = 2'b00, ON  = 2'b01; \n        \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1) \n            state <= OFF;      \n        else \n            case (state) \n                OFF: if (!j && k) state <= ON;  // if j=0 and k=1, go to the next state.\n                     else state <= OFF;   // If not in this state or not going to the next state, stay in current state.\n                \n                ON:  if (j && !k) state <= OFF;    //if j=1 and k=0, go to the next state.\n                     else state <= ON;     // If not in this state or not going to the next state, stay in current state. \n            endcase  \n        end        \nassign out = (state == ON)? 1'b1:1'b0; // Assign output based on state value.\nendmodule\n\n"}
{"task_id": "fsm2s", "completion": "\n  reg [1:0] state;\n  \n  parameter OFF = 2'b00, ON = 2'b01;\n  \n  always @(posedge clk or posedge reset) begin\n    if (reset)\n      state <= OFF;\n    else\n      case (state) \n        OFF: if (j == 1'b0) state <= OFF; else state <= ON;\n        ON : if (k == 1'b0) state <= ON ; else state <= OFF;\n      endcase\n   end \n    \n assign out = (state == ON);    //If we are in the \"ON\" state, output is 1, otherwise it is 0.\n\t\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n\n\t// define the states\n\tlocalparam OFF = 1'b0;\n\tlocalparam ON  = 1'b1;\n\n\treg state; // current state of the machine\n\n\talways @(posedge clk or posedge reset) begin\n\t  if (reset) \n\t    state <= OFF;\n\t  else\n\t    case(state)\n\t      OFF:\tif (j==0 && k==1) \n\t\t\t        state <= ON;\n\t\t    else if (j==1 && k==1)\n\t    \t\t  state <= OFF;\n\t       \telse state <= OFF; // retain current state\n\t       \t \n\t      ON:\tif (j==1 && k==0)\n\t\t      state <= OFF;\n             \t    else if (j==0 && k==0)\n\t\t\t    state <= ON;\n         \t\t else  state <= ON; \n\t     endcase\n       end\n       \n\t// output depends on current state\n\tassign out = state;\nendmodule\n\n"}
{"task_id": "fsm2s", "completion": "\n    reg [1:0] state;\n    \n    parameter OFF = 2'b00, ON = 2'b01;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= OFF;\n        else  \n            case (state) \n                OFF : if (j==1) state <= ON; // j=0 --> state is OFF, but when j becomes '1', change to state 'ON'\n                ON : if (k==1) state <= OFF; // k=0 --> state is ON ,but when k becomes '1', change to state 'OFF'\n            endcase \n    end\n    \n    assign out = (state == ON);  \nendmodule \n\n"}
{"task_id": "fsm2s", "completion": "\n\n\t// Declare current state and next state as registers.\n    reg [1:0] state, nxtstate; \n\t \n    // Output assignment\n    assign out = state[0]; \n    \n   // State transition logic (Moore machine)\n\talways @(posedge clk or posedge reset) begin\n      if(reset) \n          state <= 2'b10; \n      else \n          state <= nxtstate; \n    end\n    \n\t// Next state logic\n\talways @(*) begin \n       case (state)\n          2'b10 : nxtstate = j ? 2'b00 : 2'b10 ; // OFF\n          2'b00 : nxtstate = k ? 2'b11 : 2'b00 ; // ON\n\t\t  2'b11 : nxtstate = k ? 2'b00 : 2'b11;  //ON\n          default: nxtstate = 2'bx;               // Invalid state, just keep it.\n      endcase\n    end\t\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n\treg state; // State register.\n    \n    always @(posedge clk or posedge reset) begin \n        if (reset) \n            state <= 1'b0; \n        else \n            case ({j, k}) \n                2'b00 : state <= state;\n                2'b01 : state <= state;\n                2'b10 : state <= state;\n                2'b11 : state <= ~state;\n            endcase\n    end\n    \n    assign out = state;  // Assign output to current state.\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n\treg state; \n    \n    always @(posedge clk or posedge reset) begin  \n        if(reset == 1'b1) begin  \n            state <= 0;  \n        end\n       else case ({j, k})\n            2'b00: state <= state;\n\t\t\t2'b01: state <= 1;\n\t\t\t2'b10: state <= 'b1;\n\t\t\t2'b11: state <= 0;\n\t\tendcase  \n    end \n    \n\tassign out = state;\nendmodule\n\n"}
{"task_id": "fsm2s", "completion": "\n\n\treg [1:0] state = 2'b00;\n\n\talways @(posedge clk or posedge reset) begin\n\t  if (reset) \n\t    state <= 2'b00;\n\t  else\n\t    case (state)\n\t      2'b00: state <= j ? 2'b01 : 2'b00;\n\t      2'b01: state <= k ? 2'b11 : 2'b00;\n\t      2'b11: state <= k ? 2'b11 : 2'b10;\n\t      2'b10: state <= j ? 2'b01 : 2'b10;\n\t    endcase\n\tend\n\n\tassign out = (state == 2'b10);\n\nendmodule\n\n"}
{"task_id": "fsm2s", "completion": "\n    reg state; // We use a register to keep track of our current state. \n\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin\n            state <= 0;\n        end else begin\n            case({j, k})\n                2'b00 : state <= state; // We stay in the same state. \n                2'b01 : state <= state; // We still stay in our current state.\n                2'b10 : state <= ~state; // We flip the current state. \n                2'b11 : state <= ~state; // We also flip the current state. \n            endcase\n        end\n    end\n\t\n\t// The output is simply connected to our internal 'state'.\n\tassign out = state;\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n    reg state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= 0;\n        else  \n            case({j, k})\n                2'b00 : state <= state;\n                2'b10 : state <= state;\n                2'b01 : state <= ~state;\n                2'b11 : state <= ~state;\n            endcase\n    end\n    \n    assign out = state;\nendmodule\n\n"}
{"task_id": "fsm2s", "completion": "\n\treg [1:0] state;  // two-bit state variable to hold the current and next states.\n  \n\t// State machine transition logic.\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset) \n        \tstate <= 2'b00;    // Reset to OFF state on active high reset.\n    \telse \n        \tcase (state)         \n            \t2'b00: if (j==1'b0) state <= 2'b00; else state <= 2'b01;  \n            \t2'b01: if (k==1'b0) state <= 2'b01; else state <= 2'b10; \n            \t2'b10: if (j==1'b0) state <= 2'b10; else state <= 2'b11;  \n            \t2'b11: if (k==1'b0) state <= 2'b11; else state <= 2'b00; \n        \tendcase\n    \tend\n    // Output logic to determine output based on the current state.\n\tassign out = (state == 2'b10);  \n"}
{"task_id": "fsm2s", "completion": "\n\treg state; // 0 = OFF, 1 = ON\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 0;  \t// reset to state 'OFF'\n    \telse if (!j && k) \t// 'j=0 & k=1', remain in the same state\n      \t\tstate <= state;\n   \t else if (j && !k) // 'j=1 & k=0', change from 'ON' to 'OFF'\n       \t\tstate <= ~state;  \t\t\n    \telse if (!j && !k) // 'j=0 & k=0', remain in the same state\n        \tstate <= state; \t\t\n\tend\n\n\tassign out = state; // assign output as current state.\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n\treg state; // State register\n    \n    always @(posedge clk or posedge reset) begin \n        if (reset)\n            state <= 1'b0; // Reset to OFF state\n        else \n            case({j, k}) \n                2'b00: state <= state; // No change in state\n                2'b01: state <= ~state; // Toggle the current state\n                2'b10: state <= state; // No change in state\n                2'b11: state <= ~state; // Toggle the current state\n            endcase \n    end\n    \n    assign out = state; // Output is the same as the current state of the machine\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n   reg [1:0] state;\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= 2'b00;  // go to OFF on reset\n        else begin\n           case(state)\n                2'b00 : if (j==1'b0) state <= 2'b00; else state <= 2'b01;   // stay in OFF when j=0 and transition to ON when j=1\n                2'b01 : if (k==1'b0) state <= 2'b01; else state <= 2'b10;  // stay in ON when k=0 and transition to OFF when k=1\n                2'b10 : if (j==1'b0) state <= 2'b10; else state <= 2'b11;   // stay in ON when j=0 and transition to OFF when j=1\n                2'b11 : if (k==1'b0) state <= 2'b11; else state <= 2'b00;  // stay in OFF when k=0 and transition to ON when k=1\n            endcase\n        end\n    end\n\tassign out = state[0];\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\n\treg state;\n\t\n\t// Synchronous Reset D Flip-Flop\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)\n\t\t\tstate <= 0;  // State OFF\n\t\telse if (j == 1'b0 && k == 1'b0)\n\t\t\tstate <= state; // No Change in State\n\t\telse if (j == 1'b1 && k == 1'b0)\n\t\t\tstate <= ~state; // Toggle State\n\t\telse if (j == 1'b0 && k == 1'b1)\n\t\t\tstate <= state;  // No Change in State\n\tend\n\t// Output Logic\n\tassign out = state;\n\t\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\nalways @(posedge clk or posedge ar) begin\n    if (ar == 1'b1) \n        q <= 0;\n    else \n        q <= d;\nend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\talways @(posedge clk or posedge ar) begin \n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "m2014_q4b", "completion": "\n    \n    always @(posedge clk or posedge ar) begin\n        if (ar) \n            q <= 0;\n        else \n            q <= d;\n    end\nendmodule\n"}
{"task_id": "m2014_q4b", "completion": "\nalways @(posedge clk or posedge ar) begin\n\tif (ar) \n\t\tq <= 0;\n\telse\n\t\tq <= d;\nend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\n\talways @(posedge clk or posedge ar) begin\n    \tif(ar == 1'b1) \n        \tq <= 0;\n        else \n        \tq <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\t\n\talways @(posedge clk or posedge ar) begin\n\t\tif(ar)\n\t\t\tq <= 0;\n\t\telse \n\t\t\tq <= d;\n\tend\n\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n    \n\talways @(posedge clk or posedge ar) begin\n\t\tif (ar == 1'b1) \n\t\t\tq <= 0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\talways @(posedge clk or posedge ar) begin\n\t    if(ar)\n\t        q <= 0;\n\t    else\n\t        q <= d; \n    end  \nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\nalways @(posedge clk or posedge ar) begin\n\tif(ar) \n\t    q <= 0;\n\telse \n\t    q <= d;\nend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\nalways @(posedge clk or posedge ar) begin\n\tif (ar) \n\t\tq <= 0;\n\telse \n\t\tq <= d;\nend\n\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\talways @(posedge clk or posedge ar) begin\n\t\tif(ar) \n\t\t\tq <= 0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "m2014_q4b", "completion": "\nalways @(posedge clk or posedge ar) begin\n    if(ar) \n        q <= 0;\n    else \n        q <= d;\nend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\n\talways @(posedge clk or posedge ar) begin\n\t\tif(ar) \n\t\t\tq <= 1'b0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\nalways @(posedge clk or posedge ar) begin\n\tif (ar) \n\t\tq <= 0;\n\telse \n\t\tq <= d;\nend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\talways @(posedge clk or posedge ar) begin \n        if (ar) \n            q <= 1'b0;\n        else \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\talways @(posedge clk or posedge ar) begin \n    \tif(ar) \n        \tq <= 0; \n    \telse \n        \tq <= d; \n    end\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n    always @(posedge clk or posedge ar) begin\n        if (ar) \n            q <= 0;\n        else \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\nalways @(posedge clk or posedge ar) begin\n\tif (ar) \n\t\tq <= 0;\n\telse \n\t\tq <= d;\nend\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n   always @(posedge clk or posedge ar) begin\n      if(ar) \n         q <= 0;\n      else \n         q <= d;\n   end\nendmodule\n\n"}
{"task_id": "m2014_q4b", "completion": "\n\n\talways @(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse \n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "fadd", "completion": "\nassign #1 sum = a ^ b ^ cin;\nassign #1 cout = (a & b) | ((a ^ b) & cin);\nendmodule\n"}
{"task_id": "fadd", "completion": "\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\nendmodule \n\n"}
{"task_id": "fadd", "completion": "\n\t// Full adder logic\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\tassign {cout,sum} = a + b + cin;\nendmodule \n\n"}
{"task_id": "fadd", "completion": "\n\tassign {cout, sum} = a + b + cin;\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\tassign {cout, sum} = a + b + cin;\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n  assign {cout,sum} = a + b + cin;\n  \nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\tassign {cout,sum} = a + b + cin; \nendmodule \n"}
{"task_id": "fadd", "completion": "\n\nassign {cout, sum} = a + b + cin;\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\n\tassign {cout,sum} = a + b + cin;\nendmodule\n"}
{"task_id": "fadd", "completion": "\n\n\tassign sum = a ^ b ^ cin;\n    assign cout = (a&b) | (cin & (a^b));\n    \nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\n\tassign {cout, sum} = a + b + cin;\nendmodule \n\n"}
{"task_id": "fadd", "completion": "\n\tassign {cout, sum} = a + b + cin;\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\n\tassign {cout, sum} = a + b + cin; \nendmodule\n"}
{"task_id": "fadd", "completion": "\n\n\tassign {cout, sum} = a + b + cin; \n\t\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n\tassign sum = a ^ b ^ cin; \n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\n"}
{"task_id": "fadd", "completion": "\n  \n    assign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\nendmodule\n"}
{"task_id": "fadd", "completion": "\n    assign {cout, sum} = a + b + cin;\nendmodule \n\n"}
{"task_id": "fadd", "completion": "\n\n\tassign {cout, sum} = a + b + cin;\n\nendmodule \n\n"}
{"task_id": "fadd", "completion": "\n\n    assign {cout,sum} = a + b + cin;\n  \nendmodule\n\n"}
{"task_id": "m2014_q4k", "completion": "\n    reg [3:0] q; // Shift register\n    \n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)  // Reset active low\n            q <= 4'b0;\n        else         // Synchronous D flip flop\n            q <= {in, q[3:1]};\n    end\n    \n    assign out = q[0]; // Outputs the first bit of the register (rightmost bit)\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] q;\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) \n\t\t\tq <= 4'b0;\n\t\telse\n\t\t\tq <= {in, q[3:1]};\n\tend\n\tassign out = q[0];\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\nreg [3:0] dflop; \n\nalways @(posedge clk or negedge resetn) begin\n\tif(!resetn)\n\t\tdflop <= 4'b0;\n\telse\n\t\tdflop <= {in,dflop[3:1]};\nend\nassign out = dflop[0];\n\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n    reg [3:0] shiftreg;\n    \n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) \n            shiftreg <= 4'b0;\n        else \n            shiftreg <= {shiftreg[2:0], in};\n    end\n\t\n    assign out = shiftreg[3];\n    \nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] dflops;\n\tassign out = dflops[0]; // The output is connected to the first D flip flop.\n\t\t\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) \n\t\t\tdflops <= 4'b0;\n\t\telse \n\t\t\tdflops <= {in, dflops[3:1]}; // Each D flip flop except the first takes its input from the next D flip flop and is reset to 0 when resetn=0. The first D flip flop also receives the input bit 'in'.\n\tend\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] shift_register;\n\tassign out = shift_register[3]; // output is the last bit of shift register\n  \n  always @(posedge clk or negedge resetn) begin\n    if (!resetn)\n      shift_register <= 4'b0000; // asynchronous reset to 0\n    else\n      shift_register <= {shift_register[2:0], in}; // bit shift on clock edge\n  end\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n    reg [3:0] DFFs;  // register with four D flip flops\n    \n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            DFFs <= 4'b0000;  // reset state is all zeros\n        else\n            DFFs <= {DFFs[2:0], in};  // on each clock cycle, shift the register and insert a new input bit at the end\n    end\n    \n    assign out = DFFs[3];  // the last bit of the shift register is outputted\n\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] shift_register;\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (resetn == 1'b0) \n\t\t\tshift_register <= 4'h0;\n\t\telse  \n\t\t\tshift_register <= {in, shift_register[3:1]};\n\tend\n\n\tassign out = shift_register[0];\n\t\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] q;\n\tassign out = q[0];  // Output is connected to the first bit of the register.\n\t\n\talways @(posedge clk or negedge resetn) begin\n\t    if (!resetn) // Reset sequence\n\t        q <= 4'b1111;  \n\t    else    // Normal operation: shift in new value and push out old ones\n\t        q <= {q[2:0], in};  // The last bit of the current register becomes the new first one.\n\tend\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\n\t// Define D Flip Flop\n\tmodule DFF(clk, resetn, d, q);\n\t  input clk, resetn, d;\n\t  output reg q;\n\t  \n\t  always @ (posedge clk or negedge resetn) begin\n\t    if (!resetn) \n\t      q <= 0;\n\t    else\n\t      q <= d;\n\t  end\n\tendmodule\n\t\n\t// Define Shift Register with 4 D Flip Flops\n\twire [3:0] data_out; // interconnect wires\n\tDFF dff1(clk, resetn, in, data_out[0]);  \n\tDFF dff2(clk, resetn, data_out[0], data_out[1]); \n\tDFF dff3(clk, resetn, data_out[1], data_out[2]); \n\tDFF dff4(clk, resetn, data_out[2], data_out[3]);  \n\tassign out = data_out[3]; // assign last flip flop output to shift register output\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] d; // D flip flop registers\n\tassign out = d[3]; \n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn)\n\t\t\td <= 4'b0; // Reset condition\n\t\telse \n\t\t\td <= {in, d[3:1]}; // Shift right and load in new bit at MSB\n\tend\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] d;\n\tassign out = d[3];\n\talways @(posedge clk or negedge resetn) begin\n    \tif (!resetn) \n        \td <= 4'b0;\n    \telse \n        \td <= {d[2:0], in};\n    end\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n    reg [3:0] shift_reg;\n    \n    always @(posedge clk or negedge resetn) begin\n        if (resetn == 1'b0) \n            shift_reg <= 4'h0;\n        else \n            shift_reg <= {shift_reg[2:0], in};\n    end\n    \n    assign out = shift_reg[3];\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] Q;\n  \n  always @(posedge clk or negedge resetn) begin\n    if(!resetn) begin\n      Q <= 4'b0;\n    end else begin\n\t    Q <= {in,Q[3:1]};\n    end\n  end\n\tassign out = Q[0];\nendmodule\n\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] dff;\n\tassign out = dff[3];  // Connect the output to the first D flip flop.\n\t\n\t// Synchronous process for all of the D flip flops with reset functionality.\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn)\n\t\t\tdff <= 4'b0;  // Reset the register to all zeros asynchronously on reset signal low.\n\t\telse\n\t\t\tdff <= {in, dff[3:1]};  // Shift in 'in' at the falling edge of clock and shift right by one bit.\n\tend\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n// The shift register implementation with four D flip flops\nwire q1,q2,q3; // intermediate wires to store the state of each flop\nD_FlipFlop DFF1 (.clk(clk), .resetn(resetn), .d(in), .q(out)); \nD_FlipFlop DFF2 (.clk(clk), .resetn(resetn), .d(out), .q(q1));\nD_FlipFlop DFF3 (.clk(clk), .resetn(resetn), .d(q1), .q(q2)); \nD_FlipFlop DFF4 (.clk(clk), .resetn(resetn), .d(q2), .q(q3)); \n"}
{"task_id": "m2014_q4k", "completion": "\n\n\treg [3:0] d; \n\tassign out = d[0];\n  \n\talways @(posedge clk or negedge resetn) begin\n    \tif (~resetn)\n        \td <= 4'b0;\n   \t  else\n        \td <= {in, d[3:1]};  // Shift and store in[0] at the MSB.\n   end\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\treg [3:0] q;\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) \n\t\t\tq <= 4'b0;\n\t\telse \n\t\t\tq <= {q[2:0], in};\n\tend\n\t\n\tassign out = q[3];\n\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\n\t// Shift register with four D flops\n\treg [3:0] shift_register;\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif(!resetn)  // Synchronous active-low reset\n\t\t\tshift_register <= 4'b0;\n\t\telse\n\t\t\tshift_register <= {shift_register[2:0], in};\n\tend\n\tassign out = shift_register[3];\n  \nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\n\n\treg [3:0] d;\n\t\n\tassign out = d[0];\n\t\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (resetn == 1'b0)\n\t\t\td <= 4'h0;\n\t\telse\n\t\t\td <= {in, d[3:1]};\n\tend\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\nassign out = in[sel];\nendmodule\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\n\tassign out = in[sel];\n\t\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\nassign out = in[sel];\n  \nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\t// The expression {3{sel}} generates a 3-bit number from the 8-bit selector. It's essentially multiplying the size of sel by 4, but it also allows synthesis to choose an efficient implementation for this operation.\n\tassign out = in[({3{sel}} + 256'h0)];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\nassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\n\tassign out = in[sel];\n\t\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n    assign out = in[sel];\nendmodule\n"}
{"task_id": "mux256to1", "completion": "\n\n\tassign out = in[sel];\n\t\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel]; // 1-bit wide multiplexer implementation using array slicing.\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\n\tassign out = in[sel];\n\t\nendmodule\n\n"}
{"task_id": "mux256to1", "completion": "\n\tassign out = in[sel];\nendmodule\n\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = (a[2]) || (b[2]);\n\tassign out_not = {~b[2], ~b[1:0], ~a[2], ~a[1:0]};\nendmodule\n\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = |a || |b;  // Logical OR of both vectors\n\tassign out_not = {~b, ~a};         // Inverse of b in the upper half and inverse of a in the lower half\n\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\t// Bitwise OR operation\n\tassign out_or_bitwise = ~(a | b);\n    \n    // Logical OR operation\n    assign out_or_logical = (| a) || (|b); \n  \n    // Inverse of inputs\n    assign out_not[5:3] = ~b;\n\tassign out_not[2:0] = ~a;\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = |a || |b;\n\tassign out_not = ~{3'h7, 3'h7};\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\n\t// Bitwise OR operation\n\tassign out_or_bitwise = a | b; \n\t\n\t// Logical OR operation (using logical operators)\n\tassign out_or_logical = (a[0] || b[0]) || (a[1] || b[1]) || (a[2] || b[2]); \n\n\t// Bitwise NOT operation\n\tassign out_not = {~b, ~a};\n    \nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = (|a) || (|b);\n\tassign out_not = {~b, ~a};\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n   \n   assign out_or_bitwise = a | b;\n   assign out_or_logical = |a || |b;  // Use the logical OR of their elements (vectors) instead of bitwise OR.\n   assign out_not = {~b[2:0], ~a[2:0]};\n   \nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = ~(~a & ~b); // use De Morgan's law to find logical OR of two values \n\tassign out_not = {~b, ~a};          // split the not result into upper and lower half as per requirement\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\t// Bitwise OR\n\tassign out_or_bitwise = a | b; \n\t\n\t// Logical OR\n\tassign out_or_logical = (a[2] || b[2]) || ((a[1] || b[1]) || (a[0] || b[0])) ;\n\t \n\t// NOT of both vectors, upper half is the inverse of 'b' and lower half is the inverse of 'a'\n\tassign out_not = {~b[2], ~b[1], ~b[0], ~a[2], ~a[1], ~a[0]}; \nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = (|a) || (|b); // logical OR of the two vectors\n\tassign out_not = {~b[2], ~b[1], ~b[0], ~a[2], ~a[1], ~a[0]}; \nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n    \n    assign out_or_bitwise = a | b;\n    assign out_or_logical = ~(a & ~b);\n    assign out_not = {3'b111 & ~b, 3'b111 & ~a};\n    \nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n   // Bitwise OR operation between a and b\n\tassign out_or_bitwise = a | b;\n    \n\t// Logical OR operation between a and b\n\tassign out_or_logical = $or(a) || $or(b); \n   \n\t// NOT of the inputs 'a' and 'b'.\n\tassign out_not = {~b, ~a};   // Upper half -> ~b , Lower half -> ~a\n\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = a | b; // bitwise OR\n\tassign out_or_logical = (a[0] || b[0]) && (a[1] || b[1]) && (a[2] || b[2]); // logical OR \n\tassign out_not = ~{b, a}; // inverse of both vectors, split in half.\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\n\t// Bitwise OR\n\tassign out_or_bitwise = a | b; \n\t\n\t// Logical OR\n\tassign out_or_logical = |a || |b;  \n\t\n\t// Inverse\n\tassign out_not[2:0] = ~a; // Upper half of the output\n\tassign out_not[5:3] = ~b; // Lower half of the output\n\t\nendmodule\n\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = a | b;   // bitwise-OR 3-bit vectors\n    assign out_or_logical = (a != 3'b0) || (b != 3'b0); // logical-OR of the two 3-bit numbers (nonzero means true).\n\tassign out_not = {~b[2:0], ~a[2:0]};  // inverse of a in lower half and b in upper half.\nendmodule\n\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = |a || |b ; \n\tassign out_not = {~b[2], ~b[1], ~b[0], ~a[2], ~a[1], ~a[0]};\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\tassign out_or_bitwise = ~(a | b);\n\tassign out_or_logical = ~(~a | ~b);\n\tassign out_not = {~b, ~a};\nendmodule \n\n"}
{"task_id": "vectorgates", "completion": "\n\n    assign out_or_bitwise = a | b;\n\tassign out_or_logical = |a || |b;  // Logic OR instead of bitwise OR.\n\tassign out_not = {~b[2], ~b[1], ~b[0], ~a[2], ~a[1], ~a[0]};  \nendmodule \n"}
{"task_id": "vectorgates", "completion": "\n   assign out_or_bitwise = a | b;\n   assign out_or_logical = ~(~a & ~b);\n   assign out_not = {~b, ~a};\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\n\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = (a[2:1] != 0) || (b[2:1] != 0);  // use logical OR operation.\n\tassign out_not = {~a, ~b};\nendmodule\n\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\t// The counter variable to track the number of cycles\n    reg [1:0] count;\n    \n    // Bit pattern detection\n    wire bitpattern = /* your condition here */; \n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            shift_ena <= 1'b1;\n            count <= 2'b0;\n        end else if (bitpattern && (count < 2)) begin // Increment the counter when the bit pattern is detected and count is less than 4.\n\t\t\tshift_ena <= 1'b1;\n        \tcount <= count + 1;\n    \tend else begin // Otherwise, deactivate shift_ena and reset the counter.\n            shift_ena <= 1'b0;\n        end\n    end\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n    reg [1:0] counter;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            counter <= 2'b11; // Reset counter to 3 in binary\n        else \n            counter <= counter - 2'd1; // Count down\n    end\n    \n    assign shift_ena = (counter == 2'b0); // Enable shift when the count is zero.\n\t\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\t// This state machine is designed to enable the shift register for exactly 4 clock cycles whenever a certain bit pattern is detected. After that, it stays in the '1' state until reset.\n\treg [2:0] count; // We use a three-bit counter to keep track of how many clock cycles have passed.\n\twire pattern_detected; // This signal will be asserted when the proper bit pattern is detected.\n\t\n\t// Implement the state machine\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) begin \n\t\t    count <= 3'b000; // Reset counter and shift_ena upon reset assertion.\n\t\t    shift_ena <= 1'b1; // Enable shift register on reset assertion\n\t\tend \n\t    else begin  \n\t        if (pattern_detected && count != 3'b100) begin\n\t\t\t\t// If pattern detected, enable for 4 clock cycles and then disable.\n\t\t        count <= count + 3'b001;\n                shift_ena <= ~count[2]; // After 4 clock cycles (count = 3'b100), disable the shift register.\n\t        end\n\t    end\t  \n\tend\n"}
{"task_id": "review2015_fsmshift", "completion": "\n   reg [1:0] count;\n   \n   always @ (posedge clk or posedge reset) begin \n      if (reset) begin\n         count <= 2'b00;\n         shift_ena <= 1'b0;\n      end\n       else begin\n          case(count)\n             2'b00: begin\n                shift_ena <= 1'b1;\n                count <= count + 1;\n             end\n             2'b01: begin\n                 shift_ena <= 1'b1;\n                 count <= count + 1;\n             end\n             2'b10: begin\n                  shift_ena <= 1'b1;\n                  count <= count + 1;\n               end \n             2'b11: begin\n                   shift_ena <= 1'b0;\n                   count <= 2'b00;\n                end  \n           endcase\n       end       \n    end     \nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\t// Define a counter to count up to 4 and then return to zero\n    reg [1:0] cnt;\n    \n    // Declare the states of the FSM\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n    \n    // Define the state register and next_state variables for the FSM\n\treg [1:0] state, next_state; \n      \n\t// Update state on clock edge (positively) or reset signal is received.\n\talways @(posedge clk or posedge reset) begin\n        if(reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end    \n        \n    // Define the logic for the FSM: Outputs and transitions\n    always @(*) begin\n        case (state)\n            \n            S0 : begin \n                  shift_ena <= 1'b1;\n                      if (cnt == 2'b10) \n                        next_state <= S1; // Go to the next state after 4 clk cycles.\n                       else \n                        next_state <= S0; // Stay in the current state as long as cnt is not at 4.\n                  end   \n            \n            S1 : begin  \n                      shift_ena <= 1'b0; \n                      if (cnt == 2'b11)\n                        next_state <= S2;\n                       else\n                        next_state <= S1; // Stay in the current state as long as cnt is not at 4.\n                  end  \n            \n            S2 : begin    \n                      shift_ena <= 1'b0;  \n                      if (cnt == 2'b10)\n                        next_state <= S3;\n                       else\n                         next_state <= S2; // Stay in the current state as long as cnt is not at 4.\n                  end     \n            \n            S3 : begin    \n                      shift_ena <= 1'b0;  \n                      if (cnt == 2'b11) \n                        next_state <= S0;\n                       else \n                         next_state <= S3; // Stay in the current state as long as cnt is not at 4.\n                  end     \n                  \n            default: begin  \n                      shift_ena <= 1'bx;\n                      next_state <= 2'bxx;\n                     end    \n        endcase\n    end\n            \n    // Count from zero to three and then back to zero on the clock edge (positively)\n\talways @(posedge clk or posedge reset) begin\n         if(reset) \n            cnt <= 2'b00;\n         else\n              case(state)\n                 S0 : if (cnt == 2'b10)   // If counter is at four, return to state zero.\n                       cnt <= S1;\n                     else \n                        cnt <= cnt + 2'b01; // Increment the count on every clock cycle.\n                 S1 : if (cnt == 2'b11)   // If counter is at four, return to state one.\n                       cnt <= S2;\n                     else \n                        cnt <= cnt + 2'b01; // Increment the count on every clock cycle.\n                 S2 : if (cnt == 2'b10)   // If counter is at four, return to state two.\n                       cnt <= S3;\n                     else \n                        cnt <= cnt + 2'b01; // Increment the count on every clock cycle.\n                 S3 : if (cnt == 2'b11)   // If counter is at four, return to state three.\n                       cnt <= S0;\n                     else \n                        cnt <= cnt + 2'b01; // Increment the count on every clock cycle.\n                 default: cnt <= 2'b00;    // Default case for any other states except the ones above.\n              endcase\n        end\nendmodule\n\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\n\t//Declaring the state variable and assigning its initial values\n\treg [1:0] state = 2'b00;\n  \n  // Declare the output shift register enable signal\n\tassign shift_ena = (state == 2'b01);\n    \n\talways @(posedge clk or posedge reset) begin\n    if (reset) begin\n      state <= 2'b11; \t//Reset state to 11 which means asserting the shift register for exactly four clock cycles and then zero forever.\n\t  end else begin\n\t    case (state)\n\t\t  2'b00:\tstate <= 2'b01;\n\t\t  2'b01:\tstate <= 2'b10;\n\t\t  2'b10: state <= 2'b11;  //Back to idle state when shift register is asserted for 4 cycles.\n\t      default : ;\n\t    endcase\n\t  end\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n    \n    reg [1:0] counter;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 2'b11;  // reset counter to max value for 4 clock cycles\n            shift_ena <= 1'b1;  \n        end else begin\n            counter <= counter - 1;\n            if (counter == 2'd0) \n                shift_ena <= 1'b0;  // de-assert shift_ena when counter is zero\n            else\n                shift_ena <= 1'b1;   \n       end\n    end\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\treg [1:0] counter;\n    wire pattern_detected; // Assume we have a combinational logic to detect the proper bit pattern. \n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            shift_ena <= 1'b0;\n            counter <= 2'b00;\n        end else begin\n            if (pattern_detected && counter != 2'b11) begin\n                shift_ena <= 1'b1;\n                counter <= counter + 2'd1;\n            end \n\t    else if(counter == 2'b11 )begin\n\t         counter<=2'b00 ;   //reset the counter for next pattern detection\n\t        end    \t\t  \t\t\t   \n            else begin\n                shift_ena <= 1'b0;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\n\treg [1:0] counter;\n    \n    always @ (posedge clk or posedge reset) begin\n        if(reset) begin  //Reset Condition\n            counter <= 2'b00;\n\t\t\tshift_ena <= 1'b0;  \n        end \n        \n       else if(counter < 2'b10) begin  //Maintains State for 4 clocks (0 to 3).\n                counter <= counter + 1;\n\t\t\t\tif(counter == 2'b01)\t\t//At the second cycle, assert shift_ena.\n\t\t\t\t\tshift_ena <= 1'b1;  \n\t\t\tend\t \n          else begin //Any value above 2 (which is 3 in binary)\n                counter <= 2'b00;   \n\t\t\t\tshift_ena <= 1'b0;\t//Assert shift_ena after the first 4 cycles.\n            end     \n        end  \n    endmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n    reg [1:0] counter;  // The 2-bit counter.\n    \n\talways @ (posedge clk or posedge reset) begin  \n\t    if(reset) begin       // If reset is asserted, \n\t\t  shift_ena <= 1'b1; // Assert shift_ena for the first cycle.\n\t\t  counter <= 2'd0;    // And reset the counter.\n        end \n\t\telse begin            // Else continue as usual:\n\t\t  if(counter == 2'd3) begin   // If we are at count = 3, deassert shift_ena.\n                shift_ena <= 1'b0;  \n\t\t\t    counter <= 2'd0;       // And reset the counter to start from beginning of cycle 4.\n\t\t  end\t\n\t\t  else begin           // Else continue incrementing and keeping shift_ena asserted.\n\t\t     shift_ena <= 1'b1; \n             counter <= counter + 2'd1;  \n          end\n        end   \n\tend  \nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\treg [1:0] counter;\n\tassign shift_ena = (counter == 2'b10); // enable for 4 clock cycles\n\t\t  \n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) begin\n\t\t\tcounter <= 2'b11; // reset to the maximum value, not enabling the shift register until next cycle after reset\n\t\tend else if (shift_ena) begin \n\t\t\t// if shift is enabled, decrement counter. If it reaches zero, disable again\n\t\t\tif(counter != 0)\n\t\t\t\tcounter <= counter - 1;\n\t\t\telse\n\t\t\t\tcounter <= 2'b10; // reset to initial value, enabling the shift register until next cycle\n\t\tend\n\tend  \nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\nreg [1:0] count; \nassign shift_ena = (count == 2'b10);\nalways @(posedge clk or posedge reset) begin\n\tif(reset)   // synchronous reset\n\t\tcount <= 2'b10;\n\telse if(!shift_ena && count > 0) \n\t\t\tcount <= count + 1;\nend\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\t// A counter that counts to four\n\treg [1:0] count;\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t    count <= 2'b0; // Asyncronous active high reset, return to zero after reset\n\t    else \n            count <= count + 2'b1;   // Count up every clock cycle\n\tend\n\t// When the counter reaches four, shift_ena goes high\n\tassign shift_ena = (count == 2'd3);\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\treg [1:0] counter;\n\tassign shift_ena = (counter == 2'b10);\n\t\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) begin\n\t\t\tcounter <= 2'b00;\n\t\tend else begin\n\t\t\tcase(counter)\n\t\t\t\t2'b10: counter <=  2'b00;\n\t\t\t\tdefault: counter <= counter + 1;\n\t\t\tendcase \n\t\tend\n\tend\n\t\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\treg [1:0] counter;  // Define a two bit counter.\n\twire enable;       // Enable signal for the counter to count up till it reaches 3.\n\n\t// Counter implementation\n\talways @(posedge clk or posedge reset) begin\n\t  if (reset == 1'b1) begin\n\t    counter <= 2'd0;   // Asynchronous reset, reset counter when high.\n\t  end \n\t  else if (enable == 1'b1) begin\n\t    counter <= counter + 1'd1;   // Increment the counter if enable is high.\n\t    \n\t    if(counter == 2'd3)      // If counter has reached to 4, reset it back to zero.\n\t      counter <= 2'd0;\n\t  end\n\tend\n\n\t// Enable signal implementation. It should be enabled only when the counter is at its third value (i.e., 1).\n\tassign enable = (counter == 2'd3)? 1'b0 : 1'b1; // If counter reaches to 3, disable it and wait for reset or next pattern match.\n        \n\t// Assign the output shift_ena which is same as the enable signal when counter = 2'd3. Else assign 0.\n\tassign shift_ena = (counter == 2'd3) ? 1'b1 : 1'b0;\nendmodule  \n"}
{"task_id": "review2015_fsmshift", "completion": "\n\treg [1:0] count;\n\twire pattern_detected;  // Assuming this signal indicates when a specific bit pattern is detected.\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tshift_ena <= 1'b0;\n\t\t\tcount <= 2'h3;\n\t\tend else if (pattern_detected && count != 2'h0) begin\n\t\t\tshift_ena <= 1'b1;\n\t\t\tcount <= count - 1;\n\t end else if(~pattern_detected || count == 2'h0)begin\n\t\t\t shift_ena <= 1'b0;\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\t// create a counter that increments every clock cycle and resets when the reset signal is asserted\n\treg [1:0] count;\n\talways @ (posedge clk or posedge reset) begin \n\t\tif(reset == 1'b1) \n\t\t\tcount <= 2'b00; // reset counter on high level active sync reset\n\t\telse if (count < 4)\n\t\t\tcount <= count + 1;\t// increment until it reaches 3, then stays at this number\n\tend\n\n\t// enable the shift register when the counter equals to three. \n\tassign shift_ena = (count == 2'd3);\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\t// Declaration of the counter and the register for saving the state of the FSM\n\treg [1:0] cnt;\n\treg old_reset;\n\t\n\t// Synchronous process to update the state of the FSM\n\talways @(posedge clk or posedge reset) begin \n\t\t\tif (reset == 1'b1 && old_reset == 1'b0)\n\t\t\t\tcnt <= 2'b00; // Reset counter when reset is asserted for the first time after a low level of reset signal\n\t\telse if (cnt >= 4-1) // After 4 cycles, we are ready to shift again\n\t\t\tcnt <= 2'b00; // Start over again\n\t\telse cnt <= cnt + 1; // Increment counter until it reaches 3\n\t\told_reset <= reset; // Save the old value of reset signal for checking whether it is low level or high level in order to avoid glitches.\n\tend\n\tassign shift_ena = (cnt >= 4-1); // When counter reach or exceed 4, enable shifting otherwise disable\nendmodule\n\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\treg [1:0] count;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t        count <= 2'b0;\n\t    else\n\t        count <= count + 2'b1;\n    end\n\t\n\tassign shift_ena = (count==2'h3)? 1:0 ;\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "\n\n\treg [1:0] count;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 2'b01; // Assert for 4 cycles\n            shift_ena <= 1'b1;\n        end else begin\n\t\t\tif (count == 2'b10) \n                count <= 2'b00;\n            else \n                count <= count + 1'b1;\n\t\t\t\t\n\t\t\t\tshift_ena <= (count==2'b10)? 1'b0 : 1'b1 ; // Deassert shift enable after 4 cycles\n        end\n    end\nendmodule\n"}
{"task_id": "count10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n    \tif(reset)\n        \tq <= 4'b0;  // Reset the counter to 0\n    \telse if (q == 4'd9 )\n        \tq <= 4'd0; // Once we reach 9, loop back to 0\n    \telse \n        \tq <= q + 1'b1; // Increment the counter\n    end\nendmodule\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n  \tif (reset == 1'b1) \n    \tq <= 4'd0;\n  \telse if (q < 4'd9) // counts up to 9\n    \tq <= q + 4'd1;\n  \telse if (q == 4'd9) // returns to 0 when it reaches 9\n    \tq <= 4'd0;\n\tend\nendmodule\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0;\n\t\telse \n\t\t\tq <= q + 1'b1;\n\t\t\t\n\t\tif (q == 4'd9) \n\t\t\tq <= 4'd0;\n\tend\nendmodule\n"}
{"task_id": "count10", "completion": "\n\t// State Variable\n\treg[3:0] state;\n\n\talways @(posedge clk) begin\n\t\t\n\t\tif (reset == 1'b1)  // Asynchronous Reset\n\t\t\tstate <= 4'd0; // reset to zero on high active pulse\n\t\telse if (state==4'd9 ) // Reach max count\n\t\t\tstate <= 4'd0 ;// wrap around and start over\n\t\telse\n\t\t\tstate <= state + 1 ;// Increment counter at each clock cycle\n\tend\n\tassign q = state;  // Output the current value of the counter\nendmodule\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0;\n\t\telse if (q == 4'd9)\n\t\t\tq <= 4'b0;\n\t\telse \n\t\t\tq <= q + 1'b1;\n\tend\nendmodule\n\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 4'b0;\n\t    else if (q < 10)\n\t        q <= q + 1;\n\t    else\n\t\t    q <= 4'b0;\n\tend\nendmodule\n\n"}
{"task_id": "count10", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 4'b0; //Reset to zero\n\telse if (q < 4'd9)\n\t\t//Increment if counter is less than 9\n\t\tq <= q + 1;  \n\telse\n\t\t//Reset counter when it reaches 9\n\t\tq <= 4'b0;\n\tend\nendmodule\n"}
{"task_id": "count10", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 4'd0;\n\telse \n\t\tq <= q + 1'd1;\nend\n\t\nif(q==4'd9) //If counter reaches to 9, roll over the counter to start again from 0.\n\tbegin\n\t\tq = 4'd0;\n\tend\nendmodule\n"}
{"task_id": "count10", "completion": "\nalways @ (posedge clk or posedge reset) begin\n\tif (reset == 1'b1)\n\t\tq <= 4'h0;\n\telse if(q < 4'd9)\n\t\tq <= q + 1;\n\telse \n\t\tq <= 4'h0;\nend\nendmodule\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0;\n\t\telse if (q < 4'd10) \n\t\t\tq <= q + 1;\n\t\telse \n\t\t\tq <= 4'b0;\n\tend\nendmodule\n\n"}
{"task_id": "count10", "completion": "\n\n\talways @ (posedge clk or posedge reset) begin\n        if (reset) \n\t\t\tq <= 4'b0;\n\t\telse \n            q <= q == 4'd9 ? 4'd0 : q + 1;\n    end\nendmodule\n\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t    q <= 4'b0;\n    \t\telse if (q == 4'd9) \n            \t    q <= 4'b0;\n        \telse \n            \t    q <= q + 1;\n\tend\nendmodule\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 4'b0;\n\t\telse if (q == 4'd9) \n\t\t\tq <= 4'b0;\n\t\telse \n\t\t\tq <= q + 1;\n\tend\nendmodule\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n    if (reset) \n       q <= 4'b0;\n   else\n      q <= {q[2:0], ~|q[3]};\nend\nendmodule\n\n"}
{"task_id": "count10", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 4'h0;\n\telse if (q == 4'h9) \n\t\tq <= 4'h0;\n\telse \n\t\tq <= q + 1;\nend\nendmodule\n"}
{"task_id": "count10", "completion": "\n\treg [1:0] r;\n\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset == 1'b1) \n        \tq <= 4'd0;\n    \telse if (r == 2'd1)  \n        \tq <= q + 4'd1;\n    \tr <= ~r + 2'd1; \t\t\t// rotate right\n\tend\nendmodule\n\n"}
{"task_id": "count10", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1)\n\t\tq <= 4'b0;  // Reset state is zero\n\telse if (q < 4'd9) \n\t\tq <= q + 2'd1;\t// Increment count until it reaches 9\n\telse\n\t\tq <= 4'd0;\t// If count reached, reset to zero again.\nend\n\n"}
{"task_id": "count10", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) \n\t  q <= 4'd0;   // Reset state at counter overflow\n\telse if (q < 4'd9)\n\t  q <= q + 1;  // Increment counter until it reaches 9\n\telse \n\t  q <= 4'd0;   // Then reset to 0\n\tend\nendmodule\n\n"}
{"task_id": "count10", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 4'b0;\n        else\n            q <= q + 1;\n            \n        if (q == 4'd9)  // If count reaches 9, go back to 0 for the next cycle.\n            q <= 4'b0;  \n    end\nendmodule\n"}
{"task_id": "count10", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t    q <= 4'd0; \n    \telse if (!q[3])   // counts from 0 to 9, then back to 0.\n        \tq <= q + 1;\n        else   // once count reached 9, go back to 0.\n        \tq <= 4'd0;\n    end\nendmodule\n\n"}
{"task_id": "kmap4", "completion": "\n\talways @(*) begin\n\t\tif (!c && !d) // first cell\n\t\t\tout = a && b;\n\t\telse if (c && !d) // second cell\n\t\t\tout = a || b;\n\t\telse if (c && d) // third cell\n\t\t\tout = a;\n\t\telse if (!c && d) // fourth cell\n\t\t\tout = b;\n\tend\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\t// Use Karnaugh map to simplify boolean equation for function F(a,b,c,d)\n\t// Simplified equation: ((~a & ~b & ~c) | (a & b)) == out \n\talways @* begin\n\t    if(((!a && !b && !c) || a && b)==1'b1)\n\t        out <= 1;\n        else\n            out <= 0;\n\tend\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\talways @(*) begin\n\t\tif ((~a&~b&~c&d)|(~a&b&c&~d)|(a&b&~c&~d)) \n\t\t\tout = 1;\n\t\telse \n\t\t\tout = 0;\n\tend\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\n\tassign out = ((a&b)|(c&d));\nendmodule\n\n"}
{"task_id": "kmap4", "completion": "\n    always @(*) begin\n        if (c == 0 && d == 0) \n            out = a;\n        else if (c == 1 && d == 0) \n            out = ~b;\n        else if (c == 0 && d == 1) \n            out = ~a;\n        else if (c == 1 && d == 1) \n            out =  b;\n    end\nendmodule  \n\n"}
{"task_id": "kmap4", "completion": "\n\t//The Karnaugh map simplifies the logic functions into two minterms. \n    //Minterm for 01 and 11 are (ab)'cd + ac'd' + ab'c' + a'bc;\n\tassign out = ((a & b) | (c & ~d)) | ((a & c) | (b & d));  \nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\t// Implementing the given Karnaugh Map using Verilog.\n\talways @(*) begin\n\t\tif((c == 1'b0) && (d == 1'b0)) // Corresponds to the '00' cell in the 2D Karnaugh map.\n\t\t\tout = 1'b0;  \n\t\telse if ((a== 1'b1) && (b ==1'b0) ||(c == 1'b1) && (d == 1'b1)) // Corresponds to the '01', and '11' cells in the 2D Karnaugh map.\n\t\t\tout = 1'b1;   \n\t\telse if((a == 1'b0 )&&( b== 1'b1) || (c ==  1'b1) && (d == 1'b0)) // Corresponds to the '10', and '11' cells in the 2D Karnaugh map.\n\t\t\tout = 1'b0;   \n\t\telse if((a == 1'b1) &&( b== 1'b1)) // Corresponds to the '10' cell in the 2D Karnaugh map.\n\t\t\tout = 1'b1;  \n\tend\nendmodule\n\n"}
{"task_id": "kmap4", "completion": "\n\n    always @(*) begin\n        case({c,b,a,d})   //Using Karnaugh Map to determine output for each state of inputs (a, b, c, d) \n            4'b00, 4'b01, 4'b11, 4'b10: out = 0;    //Corresponding output is set as 0\n            4'b00, 4'b10, 4'b01, 4'b11: out = 1;   //Corresponding output is set as 1\n            default: out = 'x;     //Other cases are undefined ('x')\n        endcase\n    end\n\t\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n   \n\talways @(*) begin\n\t\tif (!c & !d)       // case 00 or 10\n\t\t\tout = (a ^ b);\n\t\t\t\n\t\telse if (c & !d)   //case 01\n\t\t\tout = ~a;\n\t\t\t\n\t\telse if (!c & d)  //case 11\n\t\t\tout = ~b;\n\t\t\t\n\t\telse              // case 00 or 11\n\t\t\tout = a ^ b;\n\tend\n\t\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\talways @(*) begin\n\t    if((a == 1'b0) && (c == 1'b0))  \n\t        out = ~d;\n        else if((a == 1'b0) && (c == 1'b1)) \n            out = b;   \n        else if((a == 1'b1) && (c == 1'b0)) \n             out = ~b;  \n        else \n\t         out = d;       // a==1 & c==1 \n\tend\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n    always @(*) begin\n        if ((c & ~d) | (~a & ~b))\n            out = 1;\n        else \n            out = 0;\n    end\nendmodule\n\n"}
{"task_id": "kmap4", "completion": "\n\t// Implementing the Karnaugh map described by the question\n\tassign out = ((~a & ~b & ~c & d) | (~a & b & c & ~d) | (a & ~b & c & ~d));\n\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\n\tassign out = (~c & ~d) | (a & ~b & ~d) | (~a & ~b & ~c & d) | (a & b & ~c);\nendmodule\n\n"}
{"task_id": "kmap4", "completion": "\n\t\n\tassign out = ((~a) & (~b)) | ((~c) & (~d));\n\nendmodule\n\n"}
{"task_id": "kmap4", "completion": "\n\nassign out = ((~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (a & ~b & ~c & d));\n\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\talways @(*) begin\n        case ({c,b,a,d})\n            4'h0 : out = 1'b0;  // CD = 00\n            4'h1 : out = 1'b1;  // AD = 00\n            4'h2 : out = 1'b0;  // BC = 00\n            4'h3 : out = 1'b1;  // AB = 00\n            4'h4 : out = 1'b1;  // CD = 10\n            4'h5 : out = 1'b0;  // AD = 10\n            4'h6 : out = 1'b1;  // BC = 10\n            4'h7 : out = 1'b0;  // AB = 10\n            4'h8 : out = 1'b0;  // CD = 11\n            4'h9 : out = 1'b1;  // AD = 11\n            4'ha : out = 1'b0;  // BC = 11\n            4'hb : out = 1'b1;  // AB = 11\n            default: out = 1'bx;   // Error case for other inputs.\n        endcase\n    end\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\tassign out = ((~a & ~b & ~c) | (~d & c));\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n    always @(*) begin\n        if((a==1'b0) && (b==1'b0))      // Corresponds to the cell 00 in the Karnaugh Map.\n            out = 1'b0;\n        else if ((a==1'b0) && (c==1'b1))   // Corresponds to the cell 01 in the Karnaugh map.\n            out = 1'b1;\n        else if((c==1'b0) && (d==1'b1))    // Corresponds to the cell 11 in the Karnaugh Map.\n            out = 1'b0;\n        else                                // Corresponds to the cell 10 in the Karnaugh map.\n            out = 1'b1;\n     end\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\tfunction integer karnaugh;\n\t\tinput x;\n\t\tinput y;\n\t\t\n\t\treturn (x && !y) || (!x && y) ? 1 : 0;\n\tendfunction\n\n\talways @* begin\n\t\tout = karnaugh(a, b);\n\tend\n\nendmodule\n"}
{"task_id": "kmap4", "completion": "\n\talways @(*) begin\n\t\tcase({c,d})\n\t\t\t2'b00 : out = a;\n\t\t\t2'b10 : out = ~a & b;\n\t\t\t2'b01 : out = a | ~b;\n\t\t\t2'b11 : out = ~a |  b;\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in; \nendmodule\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule \n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule \n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in; // Assignment statement is used to assign value of 'in' to 'out'. In this case, the values are identical so we can use wire behaving like a copy.\nendmodule \n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "wire", "completion": "\n\t// The module is already implementing a basic wire functionality as it just connects the input to the output. No code is necessary for this simple case.\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule \n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "wire", "completion": "\nassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\t// Behaves like a wire\n\tassign out = in;\nendmodule \n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "wire", "completion": "\n\tassign out = in;\nendmodule \n\n"}
{"task_id": "ece241_2014_q5b", "completion": "\nreg [1:0] state;\n\n// State transitions\nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1) \n\t\tstate <= 2'b00; // reset to A\n\telse if (x==1 && state[0]==0 && state[1]==0 ) \n\t\tstate <= 2'b01; // go to B with x=1, z = 1\n   else if (x == 1 && state [0]==1 && state[1] ==1)\n     state <=2'b11 ; // stay in B with x =1 ,z=0\n   \telse \n\t\tstate <= 2'b00; // stay in A and z = 0\nend\n// Outputs for the states\nassign z = (state[0] & ~state[1]) | state[1];\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= A;\n\t\telse \n\t\t\tcase (state)\n\t\t\t\tA: state <= x ? B : A;\n\t\t\t\tB: state <= x ? B : A;\n\t\t\tendcase\n\tend\n\n\tassign z = (state == B && x == 1) || (state == A && x == 0);\n\nendmodule \n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\treg state;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) \n\t\t\tstate <= 0;\n\t\telse \n\t\t\tcase ({x, state}) \n\t\t\t\t2'b00: state <= 0; // State A\n\t\t\t\t2'b01: state <= 0; // State A\n\t\t\t\t2'b10: state <= 1; // State B\n\t\t\t\t2'b11: state <= 1; // State B\n\t\t\tendcase \n\tend\n\n\tassign z = state == 1 ? 1 : 0 ;\n\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\t// defining states as variables for readability\n\treg [1:0] state = 2'b00;  // Initial State = A\n\twire [1:0] next_state;  \n\n\tassign {z, next_state} = (state == 2'h0) ? {{1{~x}}, 2'h1} :\n                                                    ((state == 2'h1 && !x) ? {{1{(~state[0])}, 2'h1} :\n                                                    \t({{1{state[0]}}, 2'h2}));\n\t// synchronous part of the machine, reset is active high and asynchronous\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) state <= 2'b00; // Async Reset\n        else state <= next_state;\n    end \nendmodule  \n"}
{"task_id": "ece241_2014_q5b", "completion": "\nreg [1:0] state;\nparameter A = 2'h0, B = 2'h1;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tstate <= A;\n\telse\n\t\tcase(state) \n\t\t\tA: if (x == 0) state <= A; else state <= B;\n\t\t\tB: if (x == 0) state <= A; else state <= B;\n\t\tendcase\nend\n\nassign z = (state == B && x == 1) || (state == A && x == 0);\n\nendmodule \n\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\t// Internal signals for the states.\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01;\n\n\tassign z = (state == B) ? 1 : 0; // Output depends on final state.\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif(areset) state <= A;  \t// Reset to state A asynchronous.\n\t\telse case(state)\n\t\t\tA: if(x == 1'b0) state <= B; // Go from state A to B on x=0.\n\t\t\tB: if(x == 1'b1) state <= B; // Remain in B on x=1.\n\t\t\tdefault : state <= A;\t// Otherwise remain at A.\n\tendcase\n end\nendmodule \n"}
{"task_id": "ece241_2014_q5b", "completion": "\nreg A;\nwire output_mux;\n\nassign output_mux = x ? ~A : A; // Output Multiplexer\nassign z = output_mux; \n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tA <= 1'b0;  \n\tend else if ((~A & x) || (A & ~x)) begin \n\t\tA <= ~A; // State transition\n\tend\nend\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n    reg [1:0] state; \n    \n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset == 1'b1)\n            state <= A;\n        else\n            case (state) \n                A: \tif (x==0)\n                            state <= A;\n                        else\n                            state <= B;\n                B: \tif (x==0)\n                            state <= B;\n                        else\n                            state <= B;\t\n            endcase\t\t\t\n    end\n        \nassign z = (state == B && x == 1)? 1 : 0;\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n     reg [1:0] state;  //current and next state declaration\n\n    //state encoding as one hot\n   parameter A = 2'b00;\n   parameter B = 2'b01;\n\n   always @(posedge clk or posedge areset) begin\n      if (areset) \n         state <= A;        //asynchronous reset to state 'A'\n      else \n         case(state)          //next-state logic based on current states and inputs\n            A: if(x == 1'b0)  \n                  state <= B;\n               else\n                  state <= A;\n\n            B: if(x == 1'b0)\n                  state <= A; \n               else\n                  state <= B;\n         endcase          //end of case statement and always block\n    end    \n    assign z = (state == B);  //output decoding based on the current states\n\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n    \n    reg state; \n    \n    always @(posedge clk or posedge areset) begin\n        if(areset)   // active high reset \n            state <= 0;\n       else\n           case ({x,state})\n               2'b00: state <=0;\n               2'b01: state<=0;\n               2'b10: begin state <=1; z<=~(state^x); end  // output logic depends on the current and next state.\n               2'b11: begin state <=1; z<=~(state^x); end    // output logic depends on the current and next state.\n           endcase        \n    end    \nendmodule  \n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\nreg [2:0] state;\n\nparameter A = 3'b010;\nparameter B = 3'b110;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tstate <= A;\n\telse \n\t\tcase (state)\n\t\t\tA: state <= x ? B : A; // if x=0, stay in A; if x=1, go to B.\n\t\t\tB: state <= x ? B : A; // if x=0, go to A; if x=1, stay in B.\n\t\t\tdefault: state <= A;\n\t\tendcase\nend\n\nassign z = (state == B); // Output is only 1 when the machine is in state 'B'.\n\t\nendmodule\n\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\treg [1:0] state;\n\n\t// State transition logic\n\talways @(posedge clk or posedge areset) begin \n\t\tif (areset) \n\t\t\tstate <= 2'b00; // Resets to state A\n\t\telse \n\t\t\tcase (state) \n\t\t\t\t2'b00: if (!x) state <= 2'b00; else state <= 2'b01; // State A --x=0 (z=0)--> A\n\t\t\t\t2'b01: if (!x) state <= 2'b01; else state <= 2'b10; // State A --x=1 (z=1)--> B\n\t\t\t\t2'b10: if (!x) state <= 2'b10; else state <= 2'b10; // State B --x=0 (z=1)--> B\n\t\t\t\t// State B --x=1 (z=0)--> B is handled in the same way as state 2'b10\n\t\t\tendcase\n\tend\n\n\t// Output logic\n\tassign z = (state == 2'b01) ? 1'b1 : 1'b0; // Assigns 'z' according to current state. The output is 'z=1' in state A and B, otherwise it's 'z=0'.\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01;\n\n\t// Synchronous reset\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= A;\n\tend\n\t\t\t\n\t// State transition and outputs\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: if (!x) state <= A; //z = 0\n\t\t\t   else      state <= B; //z = 1\n\t\t\tB: if  x ) state <= B; //z = 1\n\t\t\t   else      state <= B; //z = 0\n\t\tendcase\n\tend\n\t\t\t\t   \n\t// Outputs\n\tassign z = (state == B);\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\nreg [1:0] state;\n\nparameter A = 2'b00;\nparameter B = 2'b01;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tstate <= A;\n\telse\n\tcase (state)\n\t\tA: state <= x ? B : A ; // if x == 1 go to B else stay in A\n\t\tB: state <= x ? B : A ; // if x == 0 stay in B else go to B\n\tendcase \nend\n\nassign z = (state == B) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\treg [2:0] state;\n\tparameter A = 3'b001;\n\tparameter B = 3'b011;\n\n\t// state register\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= A;\n\t\telse if (x != state[0])\n\t\t\tcase(state)\n\t\t\t\tA: state <= B;\n\t\t\t\tB: state <= A;\n\t\t\t\tdefault: state <= A;\n\t\t\tendcase\n\tend\n\t// output\n\tassign z = state[1]; // to get the output from state B\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\n\t// Declaring states \n\ttypedef enum {A,B} state_t;\n\tstate_t state, nextState;  \n\t\n\talways @ (posedge clk or posedge areset) begin\n\t    if(areset) // Asynchronous reset\n\t\t    state <= A;\n\t    else \n\t\t    state <= nextState;\n\tend\n\t\n\t// Next-state and output decoding in combinational logic\n\talways @ (*) begin\n\t\tcase (state)\n\t\t\tA: begin \n\t\t\t\tif(x==0)begin //Mealy machine\n\t\t\t\t\tnextState = A;\n\t\t\t\t\tz = 1'b0;\n\t\t\t    end else begin\n\t\t\t\t\tnextState = B;\n\t\t\t\t\tz = 1'b1;\n                end\n            end\n\t\t\tB: begin \n\t\t\t\tif(x==0)begin //Mealy machine\n\t\t\t\t\tnextState = B;\n\t\t\t\t\tz = 1'b1;\n\t\t\t    end else begin\n\t\t\t\t\tnextState = B;\n\t\t\t\t\tz = 1'b0;\n                end\n            end\n\t\t\tdefault: begin \n\t\t\t    nextState = A;\n\t\t\t\tz = 1'b0;\n            end\n\t    endcase\n\tend  \nendmodule\n\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\treg state;\n  \n\t//State Transition\n\talways @(posedge clk or posedge areset) begin\n    \tif(areset) \n        \tstate <= 1'b0; // reset to state A\n    \telse if (x == state)\n        \tstate <= !state;\n\tend\n  \n\t//Output Assignment\n\tassign z = state;\n\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n    \n    reg [1:0] state;\n\t\n\t// Synchronous reset into state A.\n\talways @(posedge clk or posedge areset) begin \n\t    if (areset) \n\t        state <= 2'b00; // State A\n        else \n            case (state) \n                2'b00: if (!x) state <= 2'b00; else state <= 2'b01; // State B\n                2'b01: if (!x) state <= 2'b01; else state <= 2'b11; // State B\n                2'b11: if (x)  state <= 2'b11; else state <= 2'b00; // States A and B\n                default: state <= 2'b00;\n            endcase\n    end\n\t\n\t// Output decoding.\n\tassign z = (state == 2'b11);\n    \nendmodule \n"}
{"task_id": "ece241_2014_q5b", "completion": "\nreg [1:0] state;\nwire [1:0] nextState; // Next State definition\nparameter A = 2'b00;\nparameter B = 2'b01;\nassign nextState = (state == A && x == 0) ? A : \n\t\t    (state == A && x == 1) ? B : \n\t\t    (state == B && x == 0) ? B : \n\t\t    (state == B && x == 1) ? B :\n\t\t    2'bzz; //Default case, don't change state if everything else fails.\nassign z = (state==B); // Output in state B is 1\nalways @(posedge clk or posedge areset) begin\n\tif (areset)\n\t\tstate <= A;\t// Asynchronous reset\n\telse\n\t\tstate <= nextState;\t// Regular operation\nend\t\t  \nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\n\n\treg [1:0] state;\n  \n\t// One-hot encoding for states A and B\n\tparameter [1:0] \n    \t\t\tA = 2'b00,\n      \t\t\tB = 2'b01;\n  \n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) state <= A;\n        else case (state)\n            A:  if (!x) state <= A; \n                else     state <= B; \n            B:  if (!x) state <= B; \n                else     state <= B;  \n        \tendcase\n    end\n\n\t// Output function\n\tassign z = (state == B);\n\t\t\nendmodule\n"}
{"task_id": "gates100", "completion": "\n\n\tassign out_and = &in; // 1 when all bits are high.\n\tassign out_or = |in; // 1 when at least one bit is high.\n\tassign out_xor = ^in; // 1 if number of '1's in the inputs is odd (parity).\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n  assign out_and = &in; // AND gate operation on all the inputs.\n  assign out_or = |in;  // OR gate operation on all the inputs.\n  assign out_xor = ^in; // XOR gate operation on all the inputs.\n  \nendmodule\n"}
{"task_id": "gates100", "completion": "\n    \n\tassign out_and = &in;\n\tassign out_or  = |in;\n\tassign out_xor = ^in;\n  \nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in;\n\tassign out_or  = |in;\n\tassign out_xor = ^in;\nendmodule \n\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in;\n\tassign out_or  = |in;\n\tassign out_xor = ^in; \nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\n\tassign out_and = &in;  // AND Gate with all inputs\n\tassign out_or  = |in;  // OR  Gate with all inputs\n\tassign out_xor = ^in;  // XOR Gate with all inputs\n\t\nendmodule\n"}
{"task_id": "gates100", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n     assign out_and = &in;\n     assign out_or  = |in; \n     assign out_xor = ^in;\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and =  &in;\n\tassign out_or  = |  in;\n\tassign out_xor = ^ in;\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n"}
{"task_id": "gates100", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\nendmodule\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\nassign out_and = &in;\nassign out_or  = |in;\nassign out_xor = ^in;\n\t\nendmodule \n"}
{"task_id": "gates100", "completion": "\n\n    assign out_and = &in; \n    assign out_or  = |in; \n    assign out_xor = ^in;\n    \nendmodule\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule \n"}
{"task_id": "gates100", "completion": "\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\t\nendmodule\n\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in; // AND operation is equivalent to bitwise AND here.\n    assign out_or  = |in;  // OR operation is equivalent to bitwise OR here.\n    assign out_xor = ^in;  // XOR operation is equivalent to bitwise XOR here.\nendmodule\n"}
{"task_id": "gates100", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in; \nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\treg d_sync; // Synchronized input to the clock domain\n\t\n\talways @(posedge clk) begin \n\t\td_sync <= d;\n\tend\n\t\n\t// Toggle output on both edges of the clock\n\talways @(posedge clk or negedge clk) begin  \n\t\tif (clk == 1'b0) // On falling edge, set q to input value\n\t\t\tq <= ~d_sync; \n\t\telse if (clk == 1'b1 && d_sync == 1'b1) // On rising edge and if synchronized input is high, toggle output\n\t\t\tq <= ~q;   \n\tend\n\t\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\treg q_sync;\n\t\n\t// synchronize inputs using a register chain\n\talways @ (posedge clk) begin\n\t    q_sync <= d;\n        q <= q_sync;\n    end\nendmodule\n\n"}
{"task_id": "dualedge", "completion": "\n    always @(posedge clk) begin\n        q <= d;\n    end\n\talways @(negedge clk) begin\n        q <= ~d;\n    end\nendmodule\n\n"}
{"task_id": "dualedge", "completion": "\n\treg oldClk;  // internal clock storage variable\n  \n\t// clock edge detecting flip flop\n\talways @(posedge clk or negedge clk) begin\n        oldClk <= clk;\n    end\n    \n    always @(*) begin\n        if (~oldClk & clk)  // on rising edge\n            q <= 1'b0;\n        else if (oldClk & ~clk)  // on falling edge\n            q <= d;\n        else   // hold last value when neither edges happen\n            q = q;\n    end\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\treg q_next;\n\talways @(posedge clk) begin\n\t\tq <= q_next;\n\t\tq_next <= ~q_next & d | q_next & ~d;\n\tend\nendmodule\n\n"}
{"task_id": "dualedge", "completion": "\n\treg old_clk;\n\n\t// synchronize the clock signal to avoid metastability\n\talways @(posedge clk or negedge clk) begin\n\t\tif (!clk)\n\t\t\told_clk <= 1'b0;\n\t\telse\n\t\t\told_clk <= clk;\n\tend\n\n\t// dual-edge triggered flip flop\n\talways @(posedge clk, posedge old_clk) begin\n\t\tif (old_clk && !clk) // if clock edge from 1 to 0\n\t\t\tq <= ~d;\n\t\telse if (!old_clk && clk) // if clock edge from 0 to 1\n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\treg q_sync; // Synchronous version of q\n\n\t// Double flopping the asynchronous input (d) and a single flopped clock signal\n\talways @(posedge clk or negedge clk) begin\n\t    if (!clk) begin \n\t\t\tq <= 1'b0;\n\t\t    q_sync <= d; // Synchronizing d on negative edge of the clock to avoid metastability\n\t\tend else begin\n\t\t    q <= q_sync;\n\t\tend\n\tend\n"}
{"task_id": "dualedge", "completion": "\n\treg q_next; // next state of the flip flop\n    always @(posedge clk) begin\n        if (q === 1'bx || q_next === 1'bx) \n            q <= 1'bX;\n        else\n            q <= q_next;\n    end\n\n\talways @(negedge clk, posedge d) begin // dual edge triggering\n    \tif (!$stable(d)) \n        \tq_next <= 1'bx;\n      \telse if ($changed(d)) \n         \tq_next <= d;\n    end\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\treg q_next;\n    \n\t// Next State Logic\n\talways @* begin\n\t  if (d == 1) \n\t    q_next = ~q;\n\t  else  \n\t    q_next = q;\n\tend\n\n\t// Output Logic\n\tassign q = q_next;\n    \n"}
{"task_id": "dualedge", "completion": "\n    always @(posedge clk) begin\n        if (q === 0 && d === 1 || q === 1 && d === 0) \n            q <= !d;\n        else  \n           q <= d;    \n\tend\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\treg temp; // Temporary register to hold the flipped value of 'q' during negedge clock\n\n\talways @(posedge clk) begin \n\t\ttemp <= d; \n\tend\n\n\tassign q = ~temp & d | temp & ~d;   // Functionally similar to a dual-edge triggered flip-flop. \nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\n\t// Two stages of synchronous D flip flops with the clock input toggling between posedge and negedge\n    always @(posedge clk or negedge clk) begin\n        if (~clk) \n            q <= 1'b0;\n        else if (clk) \n            q <= d;\n     end\t\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n    always @(posedge clk) begin\n        if (q != d)  // this line ensures the flip-flop is triggered on both edges.\n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "dualedge", "completion": "\n\n\t// Registered input for edge detection\n\treg in; \n\t\n\talways @(posedge clk) begin\n\t    in <= d;\n        if (in != d) // Detecting rising and falling edges\n            q <= ~q;   \n\tend\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\t\n\t// Registers to hold the state of q and q_next for one clock cycle lag\n    reg q_reg;\n    reg q_next;\n    \n    // Calculate next state\n    always @(posedge clk) begin \n        if (q_next != q_reg)\n            q_next <= ~q_next;   // Toggle the value of q_next if it's not same as current value. This makes it behave like a flip-flop that toggles every time there is a change in input d. \n        else \n            q_next <= d;       // If no change, keep old value of q_next or load new value (d) if enable is high.\n    end\n    \n\tassign q = q_reg;\t\t\t// Output q equals to the current state of flip-flop\n     \nendmodule \n"}
{"task_id": "dualedge", "completion": "\n\treg q_next;\n    \t\n\talways @(posedge clk) begin \n\t    q <= q_next;\n        end\n        \n\talways @(*) begin  \n            if (~clk) begin    //Negative edge triggered, as in real dual-edge flip flop.\n                q_next <= d;\n            end    \n        end\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\n\t// Use two single-bit flops connected with an OR gate to emulate dual edge triggering.\n\treg q_next; // next state flip-flop\n\talways @(posedge clk) begin\n\t    q <= q_next;\n\t    q_next <= d;\n\tend\n\t\t\nendmodule \n"}
{"task_id": "dualedge", "completion": "\n   // Implementing the D Flip Flop with two edge-triggered flip flops \n\treg q_next;\n\talways @(posedge clk) begin\n\t    q <= q_next;\n\t    q_next <= d;\n\tend\n\nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\t// Declare 2 internal signals for the data inputs to avoid glitches on synchronization\n\treg d1;\n\treg d0;\n\t\n\talways @(posedge clk) begin\n\t    // Synchronize d input with the clock\n\t    d0 <= d;\n\t    d1 <= d0;\n\t    \n\t    if (d1 == d0)\n\t        q <= d0;  \n    end \nendmodule\n"}
{"task_id": "dualedge", "completion": "\n\n\treg oldclk; // create a register to store the previous clock value\n    \n    always @ (posedge clk) \n        oldclk <= clk;\n        \n   always @(*) begin\n      if(!oldclk & clk) \n          q <= ~q;\n\tend\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n   assign out = sel ? b : a; \nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\nassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n  assign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a; \nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n  assign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "mux2to1v", "completion": "\nassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\nassign out = sel ? b : a;\n\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\nassign out = sel ? b : a;\n    \nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "mux2to1v", "completion": "\n\nassign out = sel ? b : a;\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\n\treg [7:0] last;  // used to store the input value from the previous clock cycle.\n\talways @(posedge clk) begin\n\t\tlast <= in;      // update the last register with current inputs.\n\tend\n\t// compare the current and last state of input bits. If a change is detected, set corresponding bit in anyedge to 1, else remain 0.\n\tassign anyedge = (~last & in);\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] last;\n\talways @(posedge clk) begin\n\t\tfor (int i = 0; i < 8; ++i) \n\t\t\tif (last[i] == 1'b0 && in[i] == 1'b1) \n\t\t\t\tanyedge[i] <= 1'b1;\n\t\t\telse \n\t\t\t\tanyedge[i] <= 1'b0;\n\t\t\t\t\n\t\tlast <= in;\n\tend\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\nreg [7:0] last;\n\n\talways @ (posedge clk) begin\n\t    anyedge <= (in & ~last);  // Detect rising edges by ANDing current and previous states.\n        last <= in;               // Update the state to be used on next clock cycle.\n    end\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] q;\n\n\talways @(posedge clk) begin\n\t\tq <= in;\n\tend\n\tassign anyedge = (in & ~q);\n\t\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] last;\n\talways @(posedge clk) begin\n\t    anyedge <= (in ^ last) & in; // detecting any edge transition.\n        last <= in; \n    end\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] last;\n\talways @(posedge clk) begin\n\t\tlast <= in;\n\t\tanyedge <= (in & ~last);\n\tend\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] old;\n\t\t \n\talways @(posedge clk) begin\n\t\tfor (integer i = 0; i < 8; i = i+1) begin\n\t\t\tif(old[i] == 1'b0 && in[i] == 1'b1)\n\t\t\t\tanyedge[i] <= 1'b1;\n\t\t\telse \n\t\t\t\tanyedge[i] <= 1'b0;\n\t\tend\n\t\told <= in;\n\tend\n\n"}
{"task_id": "edgedetect2", "completion": "\nreg [7:0] prev; // input at previous clock cycle\n  \n  always @ (posedge clk) begin\n    anyedge <= (in & ~prev); // detect edge by looking for bit transitions\n    prev <= in;               // update previous input register\n  end\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n   reg [7:0] in_reg;  // internal register to store input value from previous cycle.\n   \n   always @(posedge clk) begin\n       in_reg <= in;     // copy the current input values into a register for comparison with next clock edge.\n\t\tfor (integer i=0 ;i<8; i++)  // loop through each bit of the vector\n\t\t\tanyedge[i] <= in[i] ^ in_reg[i];   // XOR to detect transition from 0->1.\n    end\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] d;\n\talways @(posedge clk) begin\n\t\td <= in;\n\tend\n\tassign anyedge = in & ~d;\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\nreg[7:0] last;\nalways @ (posedge clk) begin\n  last <= in;\n  anyedge <= in & ~last;\nend\n"}
{"task_id": "edgedetect2", "completion": "\n    reg [7:0] d;\n    \n\talways @(posedge clk) begin\n\t    d <= in;\n\t    anyedge <= in & ~d; // Edge detection on each bit by detecting the change from 0 to 1 (in & ~d)\n\tend\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n    reg [7:0] previous; //register to store the value of input at previous clock cycle\n    \n\talways @(posedge clk) begin\n\t    anyedge <= (in & ~previous); \n        previous <= in; //update register with current inputs\n\tend\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n\treg[7:0] q;  //internal register to store previous state of input vector\n\n\talways @(posedge clk) begin\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tif ((q & in)[i])  \t//if both are 1 then edge has occurred\n\t\t\t\tanyedge[i] <= 1'b1; //set output bit to be high for one cycle after an edge occurs\n\t\t\telse\n\t\t\t\tanyedge[i] <= 1'b0; //else reset the output bit\n\t\t\t\t\n\t\tq <= in;  \t//update internal register with current state of input vector\n\tend\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] prev;\n    \n    always @(posedge clk) begin\n        prev <= in;\n        anyedge <= in & ~prev;\n    end \nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] old;\n\n\talways @ (posedge clk) begin\n\t\tanyedge <= in & ~old;\n\t\told <= in;\n\tend\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\n\treg [7:0] q;  // internal registers to hold the previous input values.\n  \n\talways @(posedge clk) begin\n\t  q <= in;     // update the value on clock edge.\n    anyedge <= ~q & in; // detect edges, set output if there was a 0->1 transition.\n  end\nendmodule\n\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] old;\n    \n    always @(posedge clk) begin\n        for (integer i=0; i<8; i++) \n            if (old[i] === 1'b0 && in[i] === 1'b1) anyedge[i] <= 1'b1;\n            else anyedge[i] <= 1'b0;\n        old <= in;    // Detecting changes at the end of the cycle.\n    end \nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] prev;\n\n\talways @(posedge clk) begin\n\t\tfor (integer i = 0; i < 8; i++) begin\n\t\t\tif (in[i] != prev[i])  // edge detected\n\t\t\t\tanyedge[i] <= 1'b1;  \n\t\t\telse\n\t\t\t\tanyedge[i] <= 1'b0; \n\t\tend\n\t\tprev <= in;\n\tend\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "\n\treg [7:0] in_prev;\n\n\t// Synchronize input to detect on next clock edge.\n\talways @(posedge clk) begin\n\t   in_prev <= in;\n\tend\n\n\t// Detect any edge.\n\tassign anyedge = (in ^ in_prev) & in;\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\t// Define 'a' and 'b', which are equivalent to {c,d}\n\twire a = c; \n\twire b = d; \n\t\n\t// Implement the Karnaugh map using a one-input multiplexer for each of four output bits\n\tassign mux_in[0] = ~(a | b); // Selected when ab=00 (dont care state in k-map)\n\tassign mux_in[1] = a;  // Selected when ab=01\n\tassign mux_in[2] = b;  // Selected when ab=11\n\tassign mux_in[3] = ~(a | ~b); // Selected when ab=10 (dont care state in k-map)\nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign mux_in = {~c & ~d, c & ~d, c & d, ~c & d};\nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n     assign ab = {c,d};\n     \n\t always @(*) begin\n\t\t\tcase (ab)\n\t\t\t\t2'b00: \tmex_in = 4'b0111;\n\t\t\t\t2'b01:  mux_in = 4'b1000;\n\t\t\t\t2'b11:  mux_in = 4'b1011;\n\t\t\t\t2'b10:  mux_in = 4'b1001;\t  \t\t\t  \n\t\t\tendcase\n    end\t\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\nassign {mux_in[2], mux_in[1], mux_in[0]} = {c & ~d, d, c, ~c | d};\nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n    assign a = c;\n    assign b = ~c;\n    assign ab = {b,a}; // Inverting because K-map is based on maxterms which are inverted in Verilog.\n    \n\tassign mux_in[0] = (ab == 2'b00)? 1 : 0;\n\tassign mux_in[1] = (ab == 2'b01)? 1 : 0;\n\tassign mux_in[2] = (ab == 2'b11)? 1 : 0;\n\tassign mux_in[3] = (ab == 2'b10)? 1 : 0;\n    \nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign mux_in = {c & ~d & ~(a&b) | a & b & ~d | ~c & d & ~(a&b) | c & (a^b) & d , \n\t\t\t\t\t  ~c & d & (a^b) | a & ~b & ~d, \n\t\t\t\t\t  ~c & ~(a^b),\n                      a & b & d};\nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\n\tassign {mux_in[2], mux_in[1]} = {c, d}; // 4-to-1 MUX selector\n\tassign mux_in[0] = ~(c & d); // Implementing the 'a' input of 00 state of Karnaugh map.\n\tassign mux_in[3] = ~((~c) & d); // Implementing the 'b' input of 10 state of Karnaugh map.\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\n\tassign {mux_in[1], mux_in[2], mux_in[3], mux_in[0]} = {c, d, ~d, ~c};  //implementing the k-map with 4 MUX inputs.\n\t\t\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\t// Multiplexers are implemented by assign statements in Verilog. \n\t// Here is a simple way to implement the circuit using only two multiplexers and one AND gate per input of the Karnaugh map. \n\tassign mux_in[0] = c & (~d); // This selects c when d=0 and all zeros otherwise. \n\tassign mux_in[1] = ~c & d; // This selects d when c=0 and all zeros otherwise. \n\tassign mux_in[2] = c & d; // This selects c+d=1 (i.e., when both c and d are 1) and all zeros otherwise. \n\t// The last input is selected based on whether or not either c or d are 0. \n\tassign mux_in[3] = ~(c | d); // This selects the negation of (c+d), i.e., when neither c nor d are 1 and all zeros otherwise.\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\t// Use 2-to-1 multiplexers to implement the 4-to-1 Karnaugh map.\n\tassign mux_in[0] = ~c & ~d;\n\tassign mux_in[1] = c & ~d;\n\tassign mux_in[2] = c & d;\n\tassign mux_in[3] = ~c & d;\n\nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign mux_in = {d, ~c & d, c & ~d, c & d}; \nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\n\tassign mux_in = {~c & ~d , c & ~d, c & d, ~c & d}; \n\nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n    \n    wire a;\n    wire b;\n    assign a = c ^ d;\n    assign b = c & d;\n    \n    always @(*) begin\n        case ({a,b})\n            2'b00: mux_in = 4'b0100;\n            2'b01: mux_in = 4'b1000;\n            2'b11: mux_in = 4'b0010;\n            default: mux_in = 4'b0001; // 2'b10\n        endcase\n    end    \nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign mux_in = {~c & ~d, c & ~d, c & d, ~c & d};\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign mux_in = {c&~d, ~c&d, c&d, ~c&~d};\nendmodule\n\n// 4-to-1 multiplexer is implemented using AND and NOT gates. The Karnaugh map tells us that the inputs connected to mux_in[0], mux_in[1] etc., are {c&~d, ~c&d, c&d, ~c&~d} which is exactly what we've done above.\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\nassign mux_in = {c&~d, ~c&d, ~c&~d, c&d}; \n\nendmodule\n\n// Verilog code for entire circuit would be something like this -\n\nmodule top_level (\n\tinput c,\n\tinput d,\n\toutput z\n);\n\nwire [3:0] mux_in;\ntop_module u1 (.c(c), .d(d), .mux_in(mux_in));  // Instantiation of top_module\n\nassign z = mux_in[0];  \nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\t// Implementing 4-to-1 MUX and 2-to-1 MUXs as per the Karnaugh map\n\tassign mux_in[0] = !c & !d;\n\tassign mux_in[1] = c & !d;\n\tassign mux_in[2] = c & d;\n\tassign mux_in[3] = !c & d;\n\t\nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\n\tassign mux_in[0] = c & ~d; // 0 if {a,b}=={0,0}, else 1\n\tassign mux_in[1] = ~c & d; // 0 if {a,b}=={0,1}, else 1\n\tassign mux_in[2] = c & d;  // 0 if {a,b}=={1,1}, else 1\n\tassign mux_in[3] = ~c & ~d;// 0 if {a,b}=={1,0}, else 1\n\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign mux_in = {~c&~d, ~c&d, c&d, c&~d};\nendmodule\n\n"}
{"task_id": "ece241_2014_q3", "completion": "\n\tassign mux_in[0] = ~c & ~d;  // not(c) AND not(d) -> equivalent to ab = \"10\" of K-map (mux input connected to \"cd\")\n\tassign mux_in[1] = c & ~d;   // c AND not(d)    -> equivalent to ab = \"01\" of K-map \n\tassign mux_in[2] = c & d;    // c AND d        -> equivalent to ab = \"11\" of K-map \n\tassign mux_in[3] = ~c & d;   // not(c) AND d    -> equivalent to ab = \"00\" of K-map (ab=\"00\", a and b are directly connected to the inputs 'c' and 'd')\nendmodule\n\n"}
{"task_id": "circuit10", "completion": "\n    reg q_reg;\n    \n\talways @(posedge clk) begin\n\t\tif(!a && !b)\n\t\t\tq_reg <= 0;\n        else if(a && b)\n            q_reg <= ~q_reg;\n        else if (a && !b)\n\t\t\tq_reg <= 1'b1;\n\t\telse  // a == 0 and b == 1\n\t\t\tq_reg <= 1'b0;\n\tend\n    \n    assign q = q_reg;\n    assign state = a | ~b;\n        \nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\n\treg s;\n\tassign state = s;\n\talways @(posedge clk) begin\n\t\tif(!a & !b) \n\t\t\ts <= 0;\n\t\telse if (a & !b) \n\t\t\ts <= 1;\n\t\telse if (!a & b) \n\t\t\ts <= !s;\n\tend\n\tassign q = s;\nendmodule\n\n"}
{"task_id": "circuit10", "completion": "\n\treg [1:0] prevState;\n\tassign state = prevState[1];\n\n\talways @(posedge clk) begin\n\t    if (~a & ~b)\n\t        prevState <= 2'b00; //state 0\n        else if (a & ~b)\n\t        prevState <= 2'b01; //state 1\n        else if (~a & b)\n            prevState <= 2'b10; //state 2\n        else if(a & b)\n          \tprevState <= 2'b11; //state 3\n       q <= prevState[0];\n    end\nendmodule\n"}
{"task_id": "circuit10", "completion": "\nreg [1:0] state;\n\talways @(posedge clk) begin\n\t\tcase ({a,b}) \n\t\t\t2'b00 : state <= 2'h0;\n\t\t\t2'b01 : state <= 2'h1;\n\t\t\t2'b10 : state <= 2'h2;\n\t\t\tdefault: state <= 2'h3;\n\t\tendcase\n\t\tcase (state) \n\t\t\t2'h0 : q <= a | b;\n\t\t\t2'h1 : q <= !a & b;\n\t\t\t2'h2 : q <= a ^ b;\n\t\t\tdefault: q <= ~(a&b);\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\treg q_next;\n\talways @(*) begin\n\t    if (!a && !b)\n\t        q_next = q;\n\t    else if (a && !b)\n\t        q_next = 1'b0;\n\t    else if (!a && b) \n            q_next = ~q;\n        state = a || b;\n\tend\n\n\talways @(posedge clk) begin\n\t    q <= q_next;\n\tend\n\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\treg tmp;\n    wire toggle = a ^ b;\n    \n\talways @(posedge clk) begin\n        if (toggle) \n            {tmp,q} <= {~q, tmp};\n\t    else // if not toggle just latch the inputs \n            \t{tmp, q} <= {a, b};   \n   end\n    \n\t// State is either A or B input state.\n\tassign state = a | b;\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\treg temp;\n\tassign state = temp;\n\talways @(posedge clk) begin\n\t\tif(!a && !b) \n\t\t\ttemp <= 0;\n\t\telse if (a && b) \n\t\t\ttemp <= ~temp;\n\tend\n\tassign q = temp;\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n    reg tmp;\n    \n    always @(posedge clk) begin\n        if (!a & !b) \n            tmp <= 1'b0;\n        else if (a & !b) \n            tmp <= 1'b1;\n        else if (!a & b) \n            tmp <= ~tmp;\n        \n        q <= tmp;\n    end\n    \n\tassign state = a | b;\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\n\treg [1:0] state;\n\talways @(posedge clk) begin\n\t\tcase (state) \n\t\t\t2'b00 : if (a==1 && b==0) state <= 2'b01; else if (a==0 && b==1) state <= 2'b10; else state <= 2'b00;\n\t\t\t2'b01 : begin q <= 1; if(a==1&&b==1) state <= 2'b00; else if(a==1&&b==0) state <= 2'b01;  end\n\t\t\t2'b10 : begin q <= 0; if(a==0&&b==1) state <= 2'b00; else if(a==0&&b==0) state <= 2'b10;  end\t\n\t\t\tdefault: state <= 'x; //undefined state\n\t\tendcase\n\tend\t\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\treg state;\n   always @(posedge clk) begin\n      if(!a && !b) \n         state <= 1'b0;\n      else if (a && !b) \n         state <= 1'b1;\n\t  else if (!a && b) \n         state <= ~state;\n   end\t\n   assign q = state;\nendmodule\n\n"}
{"task_id": "circuit10", "completion": "\n    reg temp; // Temporary variable to store the value of 'q' before it gets updated\n    \n    always @(posedge clk) begin\n        if (~a & ~b) \n            temp <= 1'b0;  \n        else if (a & ~b) \n            temp <= 1'b1;\n\t    else if (~a & b)\n\t\t\ttemp <= !temp; // Flip the value of 'q' when a=b=0, so we just need to negate the current state\n    \n    assign q = temp;       // Assigning the value of 'temp' to output 'q'\n    assign state = ~a & ~b;// State is 1 if both inputs are zero(x) i.e., all possible states in which q can be set as any input at time 0ns\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\treg [1:0] regState; // internal register to hold the state of the flip-flop\n\tassign state = regState[1]; // assign output state\n\n\t// synchronous process with posedge clock\n\talways @(posedge clk) begin\n\t\t  if (!a && !b) begin // when a=0, b=0 next state is 0\n\t\t\t regState <= 2'd0;\n\t\t\t q<= 1'b0; // output 'q' is 0\n\t\t end else if (a && !b) begin // when a=1, b=0 next state is 1\n\t\t\t regState <= 2'd1;\n\t\t\t q<= 1'b1; // output 'q' is 1\n\t\tend else if (!a && b) begin // when a=0, b=1 next state is 2\n\t\t\t regState <= 2'd2;\n\t\t\t q<= ~regState[1]; // flip the current state of q (toggle)\n\t\t end else begin // else for a and b both as '1', maintain the state\n\t\t\t regState <= regState;  \n\t\t\t q<=q; \n\tend\nend\nendmodule\n"}
{"task_id": "circuit10", "completion": "\nreg state;\nwire s;\n\nassign s = a ^ state;  // combinational logic to determine state of flip flop\n\nalways @(posedge clk) begin   // sequential part with flip-flop\n\tif (b == 1'b0)\n\t\tstate <= s;\n\telse if (b == 1'b1)\n\t\tstate <= ~s;\nend\nassign q = state;  // output observable through the q line\n"}
{"task_id": "circuit10", "completion": "\n\treg [1:0] flip;\n    \n    always @(posedge clk) begin\n        if(!a && !b) \n            flip <= 2'bxx;\n         else if (a && !b )\n             flip <= 2'b10;\n         else if (!a && b )\n             flip <= 2'b01;  \n    end \n     \n    assign q = flip[1];\n    assign state = flip[0];\n\t\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\t// Defining state and next_state as registers. \n    reg [1:0] currentState;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n\tassign q = (currentState == S1) || (currentState == S3);\n    assign state = currentState[0]; // MSB of current state will be observable. \n    \n\t// Combinational logic for next_state. \n\talways @(*) begin\n        case ({b, a})\n            2'b11 : if (currentState == S3)\n                        nextState = S0;\n                    else \n                        nextState = currentState + 1;\n                    \n            2'b10 : nextState = 2'b11; // If b is set and a isn\u2019t, next state will be S3.\n    \n            2'b01 : nextState = (currentState == S0) ? 2'b10: currentState - 1 ; //If a is set and b isn\u2019t, decrement state unless it was at state 0 then go to S2.\n   \n            default : nextState = 2'b00; // if both or neither are set, remain in state 0.\n        endcase        \t    \t\n    end  \t\n\t\n\t// Register for storing the current state and update it at posedge clock.\n    always @(posedge clk) begin\n\t    currentState <= nextState;\n\tend\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n    reg s;\n    \n    always @(posedge clk) begin\n        if (!a & !b) \n            s <= 0;\n        else if (a & !b) \n            s <= 1;\n        else if (!a & b) \n            s <= !s;\n        \n        q <= s;\n    end\n    \n    assign state = s;\nendmodule\n\n"}
{"task_id": "circuit10", "completion": "\n\n\treg state;\n\talways @(posedge clk) begin\n\t\tif (!a & !b)\n\t\t\tstate <= 0;\n\t\telse if (a & !b)\n\t\t\tstate <= 1;\n\t\telse if (!a & b) \n\t\t\tstate <= ~state;\n\tend\n\tassign q = state;\nendmodule\n\n"}
{"task_id": "circuit10", "completion": "\n\treg nextState;\n\twire xorOutput = a ^ b;  // XOR of the two inputs.\n\tassign state = nextState;  \n    \n\talways @(posedge clk) begin\n      \tnextState <= xorOutput;\n        q <= nextState;\n    end\nendmodule\n"}
{"task_id": "circuit10", "completion": "\n\t// Define the flip-flop and its states\n\treg ff;\n\tparameter IDLE = 2'b00, RUN = 2'b01, A_SET = 2'b10, B_SET = 2'b11; \n\treg [1:0] state = IDLE; // Initial state is idle\n\t\n\t// Synchronous process that will update the flip-flop and state when clock is high\n\talways @(posedge clk) begin\n\t\tcase (state)\n\t\t\tIDLE : if (a) \n\t\t\t        state <= A_SET;\n\t\t\t     else if (b)\n\t\t\t        state <= B_SET;\n\t\t\t     else \n\t\t\t        state <= RUN;\n\t\t\tRUN  : if (~(a|b))\n\t\t\t\t   state <= IDLE;\n\t\t\t     else \n\t\t\t\t   state <= RUN;\n\t\t\tA_SET: begin \n\t\t\t       ff <= 1'b1;\n\t\t\t       state <= RUN;\n\t\t\t      end\n\t\t\tB_SET: begin \n\t\t\t       ff <= 1'b0;\n\t\t\t       state <= RUN;\n\t\t\t      end\n\t\tendcase\n\t\tq <= ff; // update output q with the value of flip-flop\n\tend\n\t\nendmodule\n\n"}
{"task_id": "circuit10", "completion": "\n   reg out1;\n   \n\t//State Machine for transitioning between states\n\talways @(*) begin \n\t  if (a == 0 && b == 1) \n\t    state = 1'b0; //state 0\n\t  else if (a == 1 && b == 0) \n\t    state = 1'b0;//state 0\n\t  else if (a == 0 && b == 0 || a==1 && b ==1 )\n\t    state = 1'b1; //State 1\n\t  else  \n\t    state = 1'bx;//Undefined State\n\tend\n\t//D Flip flop for the output q\n\talways @(posedge clk) begin \n         if (state == 0)   \n            out1 <= ~out1; //Complimented Output\n         else  \n            out1 <= a;     //Input A is taken as output in State 1\n       end\n    assign q = out1;\nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\n\t// state encoding 1->waiting for byte with bit[3]=1 , 2->got first byte and waiting for bytes 2 & 3, 3->received last byte. \n\treg [1:0] state = 2'h0;\n\treg [7:0] temp_byte =8'hx ;\n\tassign out_bytes= {temp_byte[3:0],out_bytes[23:16], out_bytes[15:8], out_bytes[7:0]} ; //rotating the received byte \n\talways @(posedge clk or posedge reset) begin\n\tif (reset ==1'b1 )begin\n\t\t\tstate <= 2'h0; \n\t\t\ttemp_byte <=8'hx;\n\t\t\tend else if (in[3]==1'b1 && state == 2'h0) begin //check for first byte with bit [3] set.\n\t\t\t\tstate <= 2'h1 ;\n\t\t\t\ttemp_byte <= in ; \n\t\t\t\t end\n\t\t\telse if(state ==2'h1 )begin    // check for second byte  \n\t\t\t\tstate <= 2'h2; \n\t\t\t\ttemp_byte<={in[3:0], temp_byte[7:4]};      \n\t\t\t\tend\n\t\t\telse if ( state == 2'h2) begin //third byte received .\n\t\t\t\t\tdone <=1 ;  \n\t\t\t\t\tstate <= 2'h3; \n\t\t\t\t\ttemp_byte<={in[3:0], temp_byte[7:4]};   \n\t\t\t\tend\n\t\t\telse if ( done ==1 )begin     //after receiving third byte reset to initial state.\n\t\t\t\tdone <=0 ;  \n\t\t\t\tstate <= 2'h0; \n\t\t\t\t end\n\t\t\n\tend\nendmodule \n\n"}
{"task_id": "fsm_ps2data", "completion": "\nreg [23:0] bytes;\nreg [1:0] state = 2'b00; // States 00 = idle, 01 = waiting for byte[3]=1, 10 = collecting data until done, 11 = waiting for reset\n    \n    always @(posedge clk) begin\n        if (reset == 1) begin\n            state <= 2'b00;\n            bytes <= {8{1'b0}}; // Reset bytes to zero\n        end else begin\n            case(state) \n                2'b00: if (in[3]==1) state <= 2'b01; // Go to next state if byte with in[3]=1 is found\n                2'b01: begin \n                    bytes[7:0] <= in; // Store the first byte of the message\n                    state <= 2'b10;  // Go to next state\n                end \n                2'b10: if (&state) state <= 2'b11; // Once all 3 bytes have been collected, wait for reset signal\n                2'b11: if (!&state) state <= 2'b00; // Go back to idle state once reset is released\n            endcase  \n            \n            if (in[3] == 1 && &state != 1) begin \n                bytes <= {8{1'b0}};  // Reset the bytes when new message starts\n                state <= 2'b01;      // Start collecting data for the new message\n            end else if (!&state) begin \n                out_bytes <= bytes;   // Output bytes when done signal is asserted\n                done <= &state;     // Assert done signal once we have collected 3 bytes and are waiting for reset\n            end\n        end   \n    end \nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\n\n\t//define states of state machine\n\ttypedef enum {IDLE, READ1, READ2, READ3, DONE} statetype; \n\tstatetype state, nextstate; //current and next state variable declaration\n  \n\treg [7:0] byte1,byte2,byte3;//3 bytes of message\n    reg done_r; //done flag for one message\n    \n\t//State transition logic\n\talways @(posedge clk or posedge reset)  begin \n\tif (reset == 1'b1) \n\t    state <= IDLE;  \n\telse \n\t    state <= nextstate; \n\tend   \n\t\t      \n\t//Next State Logic - Moore Machine     \n\talways @(*)begin  //Moore machine. All outputs depend on current state\n\tcase (state) \n\t  IDLE : begin\n\t\t\tif (in[3]==1'b1)   nextstate = READ1;        \n            else                nextstate = IDLE;   \n        end          \n      READ1: if(in[3] == 1'b0) nextstate = READ2;  else nextstate=READ1;  \n      READ2: if(in[3] == 1'b0) nextstate = READ3;  else nextstate=READ2;      \n      READ3:                      nextstate = DONE;    //final state -> go to idle    \n\t  DONE :                       nextstate = IDLE;        \t  \t\t\n\tendcase\n\tend          \n\t//Output Logic - Mealy Machine   \n\talways @(posedge clk or posedge reset) begin  //Mealy machine. All outputs are dependent on current state and input\n\tif (reset == 1'b1)begin \n            done_r <= 0; byte1 <=8'hxx; byte2<=8'hxx; byte3<=8'hxx;   // Asynchronous reset\n\tend  else case(state)    \n        IDLE : begin done_r<= 0; end      \n      READ1:begin done_r<= 0 ;byte1 <= in[7:0];end         \n      READ2:begin done_r<= 0 ; byte1 <=in[7:0] ;end        \n      READ3:begin  done_r <= 1'b1; byte2 <= in[7:0]; end    \t  \t\t\n\t  DONE : begin out_bytes = {byte3,byte2,byte1};done_r<= 1'b1;end       \t   \t\t   \t         \n      default : ; //Default condition. Required because of the above case (default) statement syntax \n\tendcase             \n\tend    \n\t//assign output signals   \n\tassign done= done_r;// assign done signal to the done_r variable for timing analysis purpose  \n\n"}
{"task_id": "fsm_ps2data", "completion": "\n\treg [1:0] state;\n\treg [23:0] msg;\n\tlocalparam IDLE = 2'b00, SEARCHING = 2'b01, RECEIVED_FIRST = 2'b10, RECEIVED_SECOND = 2'b11;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tmsg <= 24'h0;\n\t\t\tdone <= 0;\n\t\tend \n\t\telse case (state) \n\t\t\tIDLE: if (in[3]==1) state <= SEARCHING;\n\t\t\t\n\t\t\tSEARCHING: begin\n\t\t\t\tif (~&msg[23:8]) msg <= {msg[15:0], in}; //Shift 24 bit message.\n\t\t\t\telse state <= RECEIVED_FIRST;\n\t\t\tend\n\t\t\t\n\t\t\tRECEIVED_FIRST, RECEIVED_SECOND: if (in[3]==1) begin\n\t\t\t\tstate <= SEARCHING;\n\t\t\t\tmsg <= 24'h0; //Reset message buffer.\n\t\t\tend \n\t\t\t\n\t\t\tdefault : state <= IDLE;\n\t\t\t\t\n\tendcase\n\tif(state == RECEIVED_SECOND) done <= 1'b1; else done <= 1'b0;\n\tout_bytes <= msg;\n\tend\nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\nreg [5:0] state;\nwire start = in[3];\nassign done = state == 6'b111111;\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tstate <= 0;\n\telse case (state)\n\t\t0: if (start) \n\t\t\t\tstate <= 1;\n\t       else \n\t\t\t\tstate <= state;\n    \t1,2,3: if (~start) \n\t\t\t\t    state <= state + 1;\n           else \n\t\t\t\t   state <= state;\n\t\t4: if(start) \n            state <= 5;\n      default: state <= 0;\n\tendcase\n\tif (done)\n\t    out_bytes <= {in,out_bytes[23:8]};\n\telse \n     out_bytes <= {out_bytes[15:0],8'b0};\nend\n"}
{"task_id": "fsm_ps2data", "completion": "verilog\n// States definition\nlocalparam IDLE     = 3'd0;\nlocalparam WAIT1    = 3'd1;\nlocalparam WAIT2    = 3'd2;\nlocalparam DONE     = 3'd3;\nreg [2:0] state, next_state;  // current state and next state\nreg done_next;\nwire boundary = in[3];\n// Sequential logic (register update)\nalways @(posedge clk or posedge reset) begin : seq_logic\n\tif (reset) begin\n\t\tout_bytes <= 24'b0;\n\t\tstate <= IDLE;\n        done <= 1'b0;\n\tend else begin\n\t\tstate <= next_state;\n        if(done == 1'b1) // Reset the output and FSM state after a message is detected.\n            out_bytes <= 24'b0;\n            state <= IDLE;\n        done <= done_next;\n\tend \nend : seq_logic\n// Combinational logic (state transitions and outputs)\nalways @* begin : comb_logic\n    done_next = 1'b0; // default value for done signal\n\tcase (state)\n\t\tIDLE: if(boundary) begin next_state = WAIT1;  end else next_state = IDLE;\n        WAIT1: if(boundary) begin next_state = DONE; done_next = 1'b0; end else next_state = WAIT2;\n\t\tWAIT2: if(boundary) begin next_state = DONE; done_next = 1'b0;  end else next_state = WAIT2;\n        DONE : begin next_state = IDLE; done_next = 1'b1; out_bytes <= {out_bytes[15:0], in[7:4]}; end // Shifting the input byte to the MSB of out_bytes.\n\tendcase\nend : comb_logic\nendmodule \n"}
{"task_id": "fsm_ps2data", "completion": "\n\n\t// Declaration of state type and variables\n\ttypedef enum {START, DATA1, DATA2, DATA3} states;\n\tstates currState, nextState;\n\treg [7:0] byteCount, inByte;\n\twire doneFlag;\n\t\t\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)\n\t\t\tcurrState <= START;\n\t\telse \n\t\t\tcurrState <= nextState;\n\tend\n\t\t\t\n\t// Next state and output logic\n\talways @(*) begin\n\t    inByte = in; // Data input to the FSM\n\t\tcase (currState) \n\t\t    START: begin\n\t\t        if (in[3] == 1'b1) begin\n\t\t\t        nextState = DATA1; \n\t\t\t        doneFlag = 0;\n\t\t\t    end else begin\n\t\t\t        nextState = START; \n\t\t\t        doneFlag = 0;\n\t\t\t    end\t    \n\t\t    end  \n\t   \tDATA1: begin\n\t\t        nextState = DATA2;\n\t\t\t    doneFlag = 0;\n\t\t       end\t \n\t\t    DATA2: begin\n\t\t        nextState = DATA3; \n\t\t\t    doneFlag = 0; \n\t\t     end     \n\t\t    DATA3: begin\n\t             nextState = START;\n\t\t\t\t doneFlag = 1;\n\t         end  \t     \n\t    default : begin\n\t           nextState = START; \n               doneFlag = 0; \n\t       end\t\n        endcase\t\t\n     end     \n\t// Output logic for out_bytes and done signals\n\tassign out_bytes[7:0]   = (currState == DATA1)? inByte : 'hx; // Byte 3\n    assign out_bytes[15:8]  = (currState == DATA2)? inByte : 'hx; // Byte 2\n\tassign out_bytes[23:16] = (currState == DATA3)? inByte : 'hx; // Byte 1  \n    assign done               = doneFlag ;\t\t\t\nendmodule\t    \n"}
{"task_id": "fsm_ps2data", "completion": "\n\t// FSM states\n\tlocalparam S1 = 2'd0; // Idle state\n\tlocalparam S2 = 2'd1; // First byte received\n\tlocalparam S3 = 2'd2; // Second byte received\n\tlocalparam S4 = 2'd3; // Third byte received and done = true\n\n\t// FSM registers\n\treg [1:0] state, next_state;\n\treg [7:0] out_bytes_r;\n\n\t// Output assignments\n\tassign out_bytes = {out_bytes_r[23:8], in}; // Shifted 8 bits are stored in the first 24 bits of out_bytes\n\tassign done = (state == S4); // When state is S4, done is true\n\n\t// State register\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset == 1'b1)\n\t\t\tstate <= S1;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic and output logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS1: if (in[3]==1'b1) next_state = S2; else next_state = S1;  // If the in bit is '1', move to the next state\n\t\t\tS2: next_state = S3;    // Move to third state as soon as first byte arrives\n\t\t\tS3: if (in[3]==1'b1) begin \n\t\t\t\t\t\tnext_state = S4;\t// If a second message starts, ignore it and keep in the same state\n\t\t\t\t\tend else next_state = S3; // If the third byte is not starting a new message, stay at this state\n\t\t\tS4: if (in[3]==1'b1) begin \n\t\t\t\t\t\tnext_state = S2;\t// If a new message starts, start accepting it\n\t\t\t\t\tend else next_state = S4; // If the third byte is not starting a new message, stay at this state\n\t\t\tdefault: next_state = S1;   // Default to idle when in unknown or erroneous state \n\t\tendcase\n\t\tif (next_state != S3 && next_state != S4) out_bytes_r <= 0; // Clear output byte register for states except third and fourth\n\t\telse if ((in[3]==1'b1 || in[7:4]==4'hE || state == S2)) out_bytes_r <= {out_bytes_r[23:8], in[7:0]}; // Store the incoming byte when a start bit or data bits arrive\n\tend\n\nendmodule \n"}
{"task_id": "fsm_ps2data", "completion": "\n\treg [81:0] message;\n    reg [9:0] index; //to keep track of the bytes received.\n\treg flag;\n\n\t// state definition \n\ttypedef enum {IDLE, WAIT_FOR_BYTE3} state_type;\n\tstate_type state, next_state;\n\n\t// next-state logic and outputs logic for each state\n\talways @(*) begin \n        case (state) \n            IDLE: begin \n                if (in[3]==1'b1 && flag == 0 ) begin\n                    out_bytes = 24'b0; // clear the output bytes on receiving a new message.\n                    index=0;\n\t\t\t\t\tflag<=1;\n                    next_state = WAIT_FOR_BYTE3; \n                end else if (reset==1) begin\n                    out_bytes = 24'b0;   // clear the output bytes on reset.\n                    next_state = IDLE;    \n                end  else begin\n                    next_state = IDLE; \n                end \n            end\n            \n            WAIT_FOR_BYTE3: begin       \n                if (index<9'd24) begin // add the bytes to output message while index is less than 24\n\t\t\t\t\tout_bytes <= {message[81-index:75], in}; \n                    next_state = WAIT_FOR_BYTE3; \n                end else if (reset==1'b1) begin   // on reset, clear the message and go to idle state.\n\t\t\t\t\tout_bytes = 24'b0;\n                    index <= 0;\n\t\t\t\t\tflag<=0;\n                    next_state = IDLE;   \n                end  else if (index==9'd24) begin // when all three bytes are received, go back to idle state and set done.\n                    next_state = IDLE;     \n                    flag <= 0;  \n\t\t\t\t\tdone = 1;         // raise done pulse on completion of message\n                end \n            end   \n        default: begin \n            next_state = IDLE;\n\t\t\tend   \n        endcase            \n    end    \n\n\t// state-transition logic and register to hold the current state.\n\talways @(posedge clk) begin\n\t\tif (in[3]==1'b1 && flag == 0 ) begin // capture byte only when in is 8'd128 or higher, as we are assuming our data starts from bit[7], which can be different for your design.\n            message <= {message[80:0],in};  \n\t\t\tindex<= index + 9'd1; // increment the index after every clock cycle to capture all 3 bytes of the input\n        end else if (reset == 1) begin    // asynchronous reset for clearing the register on reset\n            message <= 82'b0;\n\t\t\tflag <= 0;\n            index <= 9'b0;\n        end  \n\t\tstate <= next_state; \t// update current state.\n\tend     \n\tassign out_bytes = {message[75:0],24'b0}; // when done is low, output bytes will have the captured message else it should be zero\n    assign done = (state==IDLE)?1'b0:1'b1; \nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\n    reg [5:0] state = 6'h1f; // The initial state should be such that we are not processing any bytes yet.\n    \n\twire resetSync = reset; \n\treg [23:0] message;  \n\tassign out_bytes=message[23:0]; \n\talways @(posedge clk or posedge resetSync) begin\n\tif (resetSync) begin\n\t    state <= 6'h1f; // Reset the FSM to its initial state.\n        done<= 1'b0;   \n    end\n\telse begin\n        case (state) \n            6'h1f: if(in[3]==1'b1)begin// Searching for a boundary\n                        message <= {24{1'b0}};\n                        state <= 6'h1e; // The next state will be in the process of receiving the first byte.\n                    end else begin\n                         done<= 1'b0; \n                    end  \n            6'he:begin//Receiving First Byte \n                     message[7:0] <= in[7:0];   \n                     state <= 6'hd; //The next state is for the second byte.    \n                 end \n           6'hd: begin// Receiving Second Byte\n                    message[15:8]<=in[7:0];  \n                    state <= 6'hb; // The next state will be in the process of receiving the third byte.   \n                end  \n            6'hb:begin//Receiving Third Byte \n                    message[23:16] <= in[7:0];    \n                    done<= 1'b1; //The transmission is completed and done signal is asserted. \n                    state <= 6'h1f;//FSM returns to initial state for next transmission.  \n                end   \n            default :state <= 6'h1f; // If any other states, FSM goes back to the idle state.\n        endcase\n\tend \nend\nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\n\t// State encoding: 0-> Wait for start bit (in[3]==1)\n\t\t\t\t\t\t\t   //\t\t     1-> Receive first byte\n\t\t\t\t\t\t\t\t       //           2-> Receive second byte\n\t\t\t\t\t\t\t\t\t           //             3-> Receive third byte\n\treg [1:0] state; \n\treg [23:0] tmp_out_bytes;\n\tassign done = (state == 3);\n\t\n\t// State transition\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tstate <= 2'b00;\n\t\telse \n\t\t\tcase(state)\n\t\t\t\t2'b00: if(in[3] == 1'b1) state <= 2'b01; // transition to byte one\n\t\t\t\t\t\t else state <= 2'b00; // stay in the same state\n\t\t\t\t2'b01: state <= 2'b10; // transition to byte two\n\t\t\t\t2'b10: state <= 2'b11; // transition to byte three\n\t\t\t\t2'b11: state <= 2'b00; // back to initial state after 3 bytes are received.\n\t\t\tendcase\n\tend\n\t// Output logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\ttmp_out_bytes <= 24'h0;\n\t\telse case(state)\n\t\t\t\t2'b01: tmp_out_bytes[7:0] <= in[7:0]; // load first byte into register\n\t\t\t\t2'b10: tmp_out_bytes[15:8] <= in[7:0];  // load second byte into register\n\t\t\t\t2'b11: tmp_out_bytes[23:16] <= in[7:0];   // load third byte into register\n\t\t\tendcase\n\tend\n\t// Make output registers to latch data at the end of a clock cycle\n\talways @(posedge clk) begin\n\t\tif (done) \n\t\t\tout_bytes <= tmp_out_bytes;\n\tend\nendmodule\n\n"}
{"task_id": "fsm_ps2data", "completion": "\n\n\treg [159:0] byteStream; // Holds the received bytes\n\twire [159:0] shiftedIn = {in, byteStream[159:8]}; \n\treg startFlag = 0; // Signal indicating if a message is starting\n\treg doneFlag = 0; // Indicates completion of the current message\n\t// State machine to handle byte shifting and detection of packet boundaries.\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tbyteStream <= 160'b0;\n\t\t\tstartFlag <= 0;\n\t\t\tdoneFlag <= 0;\n\t\tend \n\t\telse if ((in[3] == 1 && startFlag == 0)) begin // Start of a message\n\t\t\tbyteStream <= shiftedIn;\n\t\t\tstartFlag <= 1;\n\t\tend\n\t\telse if (startFlag) begin // Continue shifting until the message is complete.\n\t\t\tbyteStream <= shiftedIn;\n\t\t\tif(startFlag && byteStream[7:0] == {8{in}} )begin \n\t\t\t\tdoneFlag <= 1'b1;\n\t\t\t\tstartFlag <= 0;\n\t\t\tend\n\t\tend\n\tend\n\t// Outputs the first 24 bits when a message has been received.\n\tassign out_bytes = byteStream[159:86]; // Extracts the first three bytes from stream, MSB aligned (MSBs are zeros).\n\tassign done = doneFlag;\nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\nenum {IDLE = 1'b0, RECEIVING = 1'b1} state;\nreg [7:0] bytes [2:0];\nreg [1:0] counter;\n    \nalways @(posedge clk or posedge reset) begin\n    if (reset == 1'b1) begin\n        state <= IDLE; \n        out_bytes <= 24'h0;\n        done <= 1'b0;\n        bytes[2] <= 8'd0;\n        bytes[1] <= 8'd0;\n        bytes[0] <= 8'd0;\n    end\n    else begin\n\t    case (state)\n\t\t    IDLE: \n\t\t\t   if(in[3]==1'b1){\n\t\t\t\t\tstate <= RECEIVING;\n                    counter <= 2'b00;\n                }\n    \t\tRECEIVING : begin\n                \t\tif(counter<3)begin\n                        \tbytes[counter+1]<=in;\n                       \t \tcounter <= counter + 1'b1;\n                    \tend \n\t\t\t\t\telse begin\n                     \t   state <= IDLE;\n                     \t    done <= 1'b1;\n                             out_bytes <= { bytes[2], bytes[1], bytes[0] };\n                    end   \n                end\n        endcase\n    end \nend    \nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "verilog\ntypedef enum logic[1:0]{S_IDLE = 2'b00, S_READ1=2'b01, S_READ2=2'b10, S_READ3=2'b11} state_t;\n\tstate_t state, next_state;\n\tlogic [7:0] bytes[0:2];  // Store last three received bytes.\n\tassign done = (state == S_READ3);\t// Set done when receiving the third byte of a message.\n\talways @(posedge clk or posedge reset) begin  \n\t\tif(reset) begin\n\t\t\tbytes[0] <= 8'h0;  // Initialize bytes to 0 upon reset.\n\t\t\tbytes[1] <= 8'h0;\n\t\t\tbytes[2] <= 8'h0;\n         state <= S_IDLE;    // Go back to IDLE state on reset.\n      end else begin\n\t\t\tcase(state)\n\t\t\t\tS_READ3:  if(!done && in[3]) begin  // If fourth bit is not set, go back to reading first byte of message.\n\t\t\t\t\t\tbytes[0] <= in;  \n            bytes[1] <= 8'h0;\t// Reset second and third bytes on new message start.\n\t\t\t\t\t\tbytes[2] <= 8'h0;  // They will be filled later if they were read.\n\t\t\t\t\t\tstate <= S_READ1;    \n\t\t\t\t\tend else begin  // If fourth bit is set or this byte was not part of a packet, continue reading current message.\n            state <= S_READ3;  \n          end     \n\t\t\t\tS_READ2: begin bytes[0]<=in;state<=S_READ3;}   // Store the second byte and wait for the third one. \n        S_READ1: begin bytes[0]<=in;state<=S_READ2;}          // Store the first byte and wait for the second one.\n\t\t\t\tdefault : if(in[3]) state <= S_READ1; else state <= S_IDLE;\t// If fourth bit is set, start reading a new message. Else stay in idle state.\n\t\t\tendcase      \n      end   \n\tend  // Always block\n\tassign out_bytes = {bytes[2], bytes[1], bytes[0]};\t// Output the current message when done signal is active.\n"}
{"task_id": "fsm_ps2data", "completion": "\nreg [5:0] state; \nlocalparam IDLE = 6'h00, BYTE1 = 6'h01, BYTE2 = 6'h02, BYTE3 = 6'h03, MESSAGE_END = 6'h04; \nwire [7:0] byte_shift = {in[0],out_bytes[23:8]};\nalways @(posedge clk or posedge reset) begin\n    if (reset == 1'b1) begin\n        state <= IDLE;\n\tdone <= 0;\n\tout_bytes <= 24'h000000;\n    end else case (state) \n      IDLE:       if(in[3]==1'b1){ state <= BYTE1; out_bytes[7:0]<=in;}\n      BYTE1:      if(in[3]==1'b1){ state <= BYTE2; out_bytes[15:8]<=in;}\n      BYTE2: \tif(in[3]==1'b1){state <= BYTE3;out_bytes[23:16]<=in;}\n      BYTE3:\tbegin state <= MESSAGE_END; done <= 1'b1;}\n      MESSAGE_END:if (done == 1'b1) begin state <= IDLE; done <= 0; end \n    endcase \nend\n"}
{"task_id": "fsm_ps2data", "completion": "\n\n// Internal registers\n\treg [23:0] bytes;\n\treg [1:0] count; // Counter to keep track of number of bytes received\n\twire byteStart = in[3]; // A byte starts when bit 3 is set\n\t\n\t// State machine definition\n\ttypedef enum {IDLE, RECEIVING} state_t;\n\tstate_t state, nextState;\n\t\n\t// Next-state logic and output decoding for FSM\n\talways @* begin\n\t\tcase (state)\n\t\t\tIDLE: if(byteStart) nextState = RECEIVING; else nextState = IDLE;\n\t\t\tRECEIVING: if(count == 2) nextState = IDLE; else nextState = RECEIVING;\n\t\tendcase\n\t\tcase (state)\n\t\t\tIDLE: begin done = 1'b0; out_bytes=24'bx; end\n\t\t\tRECEIVING: begin done = 1'b1; out_bytes=bytes; end\n\t\tendcase\n\tend\n\t\n\t// Synchronous update of state\n\talways @(posedge clk or posedge reset)\n\tif (reset) state <= IDLE; else state <= nextState;\n\t\n\t// Store bytes as they come in until we have a full message.\n\talways @(posedge clk) \n\tif (state == RECEIVING && ~byteStart) begin\n\t\t\tbytes[count*8+:8] = in;\n\t\t\tcount <= count + 1'b1;\n\tend else if(reset)begin bytes <= 24'h0; count <= 2'h0; end \n\t\nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\nreg [15:0] msg[2:0];  // message buffer with three bytes\nreg [1:0] state;     // FSM state\nreg [7:0] tmp;       // temporary register to shift in byte into msg[]\n\t\n// FSM state definitions\nlocalparam S_IDLE = 2'b00,   // idle state\n             S_RESET = 2'b01,  // reset state\n             S_SEARCH = 2'b10; // search for start bit in byte stream\n             \nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        tmp <= 8'h0;   // reset temporary register\n        out_bytes <= 24'h0;  // clear output bytes buffer\n        done <= 1'b0;      // reset done signal\n        state <= S_RESET;     // go to reset state\n    end else begin\n        case (state)\n            S_IDLE:   if(in[3]==1) begin tmp <= in; state <= S_SEARCH; end \n                      else begin done <= 1'b0; state <= S_IDLE; end // idle and wait for start bit\n                      \n            S_RESET : begin msg[2]<=tmp; msg[1]<=msg[2]; msg[0]<=msg[1]; state <= S_SEARCH; end \n            \n            S_SEARCH: if(in[3]==1) begin done <= 1'b0; tmp<= in; state <= S_IDLE; end // shift new byte and search for start bit again\n                      else begin msg[2] <= tmp; out_bytes <= {msg[2], msg[1], msg[0]}; done <= 1'b1; state <= S_RESET;  end // store last three bytes, signal done and reset FSM\n                      \n            default: state <= S_IDLE;    // go to idle if anything else\n        endcase\n     end  \nend\t\n"}
{"task_id": "fsm_ps2data", "completion": "\n    reg [8:0] state;  //use extra bit to indicate if the message is received or not.\n\treg [7:0] bytes[2:0]; //store 3 bytes of data\n\twire reset_sync; \n        wire [1:0] nextState;\n\tassign done = state[8];\n    \n\t// Synchronize reset signal with the clock\n    always @(posedge clk or posedge reset) begin\n      if (reset == 1'b1)\n         reset_sync <= 1'b1;  // active high synchronous reset\n      else\n        reset_sync <= 1'b0;  \n     end\n\t\n\t// State transition logic\n    always @(posedge clk or posedge reset_sync) begin\n       if (reset_sync == 1'b1)\n         state <= 9'h200;  //reset to idle state\n       else \n          case (state)  \n           9'h200: if (in[3]==1'b1)\n                        nextState <= 2'd1;\n                   else\n                        nextState <= 2'd0;     \n           9'h201: if (~|(state & 8'hff))\n                          nextState <= 2'd2;    // if all bits of state is zero, then message is received\n                    else  \n                         nextState <= 2'd1;\n           default : nextState <= 2'd0;\n          endcase    \n    assign out_bytes = { bytes[2], bytes[1], bytes[0] };  // output the byte stream\n\t\n\t// State storage logic\n       always @(posedge clk or posedge reset_sync) begin\n         if (reset_sync == 1'b1)\n           state <= 9'h200;  //reset to idle state\n        else   \n            case (nextState)  \n             2'd1: state <= { in[3], state[7:1] }; // right shift and store the byte if bit[3] is '1'\n             2'd2: state <= 9'h201;  // go to done state\n             default : state <= { 1'b0, state[8:1]};  // left shift otherwise\n            endcase  \n        end        \nendmodule \n"}
{"task_id": "fsm_ps2data", "completion": "\n\treg [159:0] byte_buffer; // 3 bytes * 64 bits = 288 bits\n\treg [2:0] state;\n\tparameter S0=3'b000, S1=3'b001, S2=3'b010, S3=3'b011, DONE=3'b100;\n\n\t// State machine for processing bytes\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= S0;\n\t\telse case(state)\n\t\t\tS0: if (in[3]) state <= S1;\n\t\t\tS1: state <= S2;\n\t\t\tS2: state <= S3;\n\t\t\tdefault: state <= S0; \n\t\tendcase\n\tend\n\n\t// Shift register for storing bytes\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tbyte_buffer <= 160'b0;\n\t\telse if ((state == S1) || (state == S2) || (state == S3)) \n\t\t\tbyte_buffer <= { byte_buffer[79:0], in };\n\tend\n\n\t// Output assignments based on state\n\tassign done = (state == DONE);\n\tassign out_bytes = (done)? byte_buffer[159:80] : 24'hxxxxx;\n"}
{"task_id": "fsm_ps2data", "completion": "\n    reg  [15:0] shift; // Shift register to collect the three bytes\n\treg   [1:0] state; // State of FSM\n\twire resetting = reset;\n    \n\t// Output assignments\n\tassign out_bytes = {shift[7:0],shift[15:8]}; \n    \n    parameter idle = 2'h0, wait3rdByte = 2'h1, doneState = 2'h2;\n      \n\talways @(posedge clk or posedge resetting) begin : state_machine  \n          if (resetting == 1'b1 ) begin  // Reset Processing\n             shift <= 0 ;               \n\t\t\t state <= idle;              \n\t\t  end                         \n\t\telse begin \n           case (state) \n              idle:       begin\n                             if(in[3]==1'b1) \n                               state<=wait3rdByte;       \n                            else        \n\t\t\t\t\t\t\t    shift <= 0 ;               \n                        end    \n             wait3rdByte:begin                        \n\t\t\t                   shift <= {shift[7:0], in}; // Shift in the byte. \n                             if(in[3]==1'b0)   begin     // The third byte received. Move to Done state.\n                                state<=doneState;\n\t\t\t\t\t\t\t end                      \n                          end   \n             doneState : begin                \n                              shift <= 0 ;               \n                              state <= idle;              \n                       \t   end \n              default: begin          \n                             state <= idle;        // Should never happen, but a safety net.\n\t\t\t\t\t      end  \n\t\t   endcase                    \n         end                   \n       end                      \n    assign done = (state == doneState);     // Assign 'done' based on FSM State\nendmodule \n\n"}
{"task_id": "edgedetect", "completion": "\n\n\treg [7:0] in_d;  // Delayed version of the input\n  \n\talways @(posedge clk) begin\n    \tin_d <= in;  // Shift in data into the delay register\n\tend\n      \n\t// Detect a positive edge (from 0 to 1) on an AND with the inverted version of what has been processed so far.\n\t// This effectively groups multiple 0-to-1 transitions into one pulse at the output.\n\tassign pedge = (~in_d & in);  \nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] old;\n\talways @(posedge clk) begin\n\t\told <= in;\n\t\tpedge <= (in & ~old);\n\tend\nendmodule \n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] last;\n\talways @(posedge clk) begin\n\t\tfor (integer i = 0; i < 8; i++) begin\n\t\t\tif (!last[i] & in[i])  // detect positive edge\n\t\t\t\tpedge[i] <= 1'b1;\n\t\t\telse\n\t\t\t\tpedge[i] <= 1'b0;\n\t\t\t\t\n\t\tend\n\t\tlast <= in;\t// store input for the next cycle\n\tend\nendmodule\n\n"}
{"task_id": "edgedetect", "completion": "\n    always @ (posedge clk) begin \n        for(int i=0;i<8;i++)begin\n            if(!in[i] && $changed(in[i])) // in[i] changed from 0 to 1, positive edge detected.\n                pedge[i] <= 1'b1; \n            else \n                pedge[i] <= 1'b0;  \t\t// Else clear the bit\n        end\n    end\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\treg[7:0] last; \n\n\talways @(posedge clk) begin\n\t\tlast <= in;\n\t\tfor (integer i = 0; i < 8 ;i++ )begin\n\t\t\tif (!in[i] && last[i])\n\t\t\t\tpedge[i] <= 1'b1;\n\t\t\telse \n\t\t\t\tpedge[i] <= 1'b0;\n\tend\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\n\treg [7:0] delayed;\n  \n\talways @(posedge clk) begin\n\t\tdelayed <= in;\n    \tpedge <= in & ~delayed;\n\tend\nendmodule\n\n"}
{"task_id": "edgedetect", "completion": "\n   always @ (posedge clk) begin\n      for (int i=0;i<8;i++) begin\n         if(~in[i] & in[i+1])  // Detects a positive edge\n            pedge[i] <= 1'b1;\n         else\n            pedge[i] <= 1'b0;\n      end   \n   end\nendmodule\n\n"}
{"task_id": "edgedetect", "completion": "\n\n\treg [7:0] in_old; // old value of input signal\n\talways @(posedge clk) begin\n\t\tin_old <= in;  // store current input state into the temporary variable at every positive edge clock.\n\tend\n\tassign pedge = in & ~in_old; // detect rising edge, using bit-wise AND operation to compare if both signal are high (rising edge)\n\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] d; // register to store previous input value\n\n\t// D Flip-flops with clocked reset synchronous to the falling edge of clk\n\talways @(negedge clk) begin \n\t\td <= in; \n\tend\n\n\t// Positive Edge Detection\n\tassign pedge = d & (~in);\n\t\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\treg[7:0] in_q;  // delayed version of the input signal.\n\talways @ (posedge clk or posedge in) begin  \n\t\tif(in)\n\t\t\tin_q <= 8'b1;     // if input is 1, delay it by one clock cycle to get a rising edge detecting register.\n\t\telse \n\t\t\tin_q <= 8'b0;    // else zero out the register when input is zero.\n\tend\n\tassign pedge = ~in & in_q;   // finally assign detected positive edges from input signal.\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] q;\t// intermediary register for flip-flops input \n\talways @(posedge clk) begin\n\t\tq <= in;\n\tend\n\n\tassign pedge = q & ~in;\t// Detect positive edge by anding the previous state with the negation of current state \n\t\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\n\treg [7:0] in_reg;\n\n\talways @(posedge clk) begin \n\t\tin_reg <= in;\n\tend\n\n\tassign pedge = in & ~in_reg;\nendmodule\n\n"}
{"task_id": "edgedetect", "completion": "\nalways @(posedge clk) begin\n  for (int i = 0; i < 8; ++i) begin\n    if (!in[i-1] && in[i]) // positive edge detection\n      pedge[i] <= 1'b1;\n    else\n      pedge[i] <= 1'b0;\n  end\nend\n  \nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] in_d; // Delayed version of the input signal \n\n\talways @(posedge clk) begin\n\t\t// Shift all inputs to the right by one step, and save the first (now previous cycle's last) bit in the new first position of `in_d`.\n\t\t{in_d[6:0], in_d[7]} <= {in[6:0], in[7]};\n\t\t\n\t\t// Check if the input signal changed from 0 to 1, and set pedge correspondingly\n\t\tpedge <= in & ~in_d;\n\tend\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\nalways @(posedge clk) begin\n    for (int i = 0; i < 8 ; ++i ) \n        if ((~in[i]) & in[i+1]) // Negation is used to detect positive edge\n            pedge[i] <= 1'b1;\n        else \n            pedge[i] <= 1'b0;\nend\t  \nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\n\treg [7:0] last;\n\talways @(posedge clk) begin\n\t    pedge <= in & ~last;\n\t    last  <= in;\n\tend\nendmodule \n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] q;\n\t\t\n\talways @ (posedge clk) begin \n\t\tq <= in;\n\tend\n\t\t\t  \n\tassign pedge = in & ~q;\n\t\nendmodule\n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] old;\n\n\talways @(posedge clk) begin\n\t    old <= in;\n\t    pedge <= in & ~old;\n\tend\nendmodule\n\n"}
{"task_id": "edgedetect", "completion": "\n\treg [7:0] prev;\n\t\n\talways @(posedge clk) begin\n\t\tprev <= in;\n\t\tpedge <= in & ~prev;\n\tend\n\nendmodule \n\n"}
{"task_id": "edgedetect", "completion": "\n\treg[7:0] last; //Last state of input register\n\talways @(posedge clk) begin \n\t\tlast <= in;\n\t\tpedge<= in & ~last;\n\tend\nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\n\treg q;\n    always @(*) begin\n        if (a)\n            q <= 1'b0;\n        else if (b)\n            q <= d;\n        else if (c)\n            q <= ~d;\n        else \n            q <= b | d;\n\tend\nendmodule\n"}
{"task_id": "circuit4", "completion": "\n\t// Declaration and initialization of the state machine register.\n\treg [3:0] state = 4'b0;\n\t \n\t// State transition table for the state machine\n\talways @(*) begin\n\t    case ({a, b, c, d}) \n\t\t    4'h0 : state <= 4'b0;\n\t\t    4'h1 : state <= 4'b0;\n\t\t    4'h2 : state <= 4'b1;\n\t\t    4'h3 : state <= 4'b1;\n\t\t    4'h4 : state <= 4'b1;\n\t\t    4'h5 : state <= 4'b1;\n\t\t    4'h6 : state <= 4'b0;\n\t\t    4'h7 : state <= 4'b0;\n\t\t    default: state <= 4'bz; // Invalid input\n\t    endcase\n\tend\n\t \n\t// Output Logic \n\tassign q = state[3];  // The output is the third bit of the state.\nendmodule\n"}
{"task_id": "circuit4", "completion": "\nwire [3:0] w;\nassign {w[3], w[2], w[1], w[0]} = {a, b, c, d};\nassign q = (|(~{b&d,c^d,a, ~(c^b)}));\nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\n\t// Using a multiplexor to generate the output 'q' based on inputs 'a', 'b', 'c', and 'd'.\n\tassign q = (~a & ~b & c & ~d) | (a & b & ~c & d); \nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\n    \n    assign q = ((~a & ~b & d) | (~c & ~d & b) | (~b & ~c & a)) & d;  \nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\n\n\tassign q = ((~a & ~b & ~c & d) | (~a & ~b & c ) | (~a & b & ~c & d) | (~a & b & c & d)) ;  // this is a NAND gate logic to make the desired waveforms.\nendmodule\n"}
{"task_id": "circuit4", "completion": "\n\tassign q = ((~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (a & ~b & ~c & d));\nendmodule\n"}
{"task_id": "circuit4", "completion": "\nassign #5ns q = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (a & ~b & ~c & ~d);\nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\n    assign q = ((~a & ~b & c) | (~c & ~d)) | ((~b & ~d) & a);\nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\nassign q = (~a & ~b & ~c & ~d) | (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & ~b & c & d) | \n           (~a & b & ~c & ~d) | (~a & b & ~c & d)  | (~a & b & c & ~d ) | (~a & b & c & d  );\n"}
{"task_id": "circuit4", "completion": "\nassign q = ((~a&b&c&d) | (a& ~b&c&d) | (a&b& ~c&d) | (a&b&c& ~d)) ; \nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\nwire ab;\nwire cd;\n\nassign ab = a&b;\nassign cd = c&d;\n\nassign q = (ab | cd) & !(a^c);\n\nendmodule\n"}
{"task_id": "circuit4", "completion": "\n   reg q;\n\n\talways @(*) begin\n\t\tif (a==1)\n\t\t\tq <= b;\n\t\telse if (c==1)\n\t\t\tq <= ~d;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "circuit4", "completion": "\n    \n    wire [3:0] anded;\n  \tassign anded[0] = a & ~b & ~c & ~d;\n  \tassign anded[1] = ~a & b & ~c & ~d;\n  \tassign anded[2] = ~a & ~b & c & ~d;\n  \tassign anded[3] = ~a & ~b & ~c & d;\n    assign q = |anded; // ORing all the AND results to get output\n    \nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\n    assign q = ((~a & ~b & ~c & d) | (a & b & ~c & ~d) | (a & ~b & c & ~d) | (~a & b & c & ~d));\nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\n\n    assign q = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (a & ~b & c & d);\n    \nendmodule \n\n"}
{"task_id": "circuit4", "completion": "\n// Define the combinational logic as a series of if-else statements.\nassign #1 q = ((~b & ~c & ~d) | (a & b & ~c & ~d) | (a & ~b & c & d) | (~a & b & ~c & d)) ? 1'b0:\n               ((~a & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & ~c & d) | (a & b & c & ~d)) ? 1'b1 : 1'bz;\nendmodule\n"}
{"task_id": "circuit4", "completion": "\n\tassign q = ((a & ~b & ~c & ~d) | (~a & b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & ~b & ~c & d));\nendmodule\n\n"}
{"task_id": "circuit4", "completion": "\nq = ((a & ~b) ^ (~c & d));\nendmodule\n"}
{"task_id": "circuit4", "completion": "\n\t// Implementing the circuit with a series of if-else statements\n\twire q1;\n\t\n\tassign q = (b == 0 && c==0) ? ((a & ~d) | (~a & d)) : \n\t           (c == 1 && b==0) ? ~d : \n\t\t\t   (c == 1 && a==0) ? d : \n\t\t       ~(a|b);\n\t           \nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n\treg [1:0] state;\n\twire start = in[3];\n\n\talways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tstate <= 2'b00;\n\telse case (state)\n\t\t2'b00: if (start) state <= 2'b01;\n\t\t2'b01: state <= 2'b10;\n\t\t2'b10: begin\n\t\t\tif(~start) \n\t\t\t\tstate <= 2'b11;\n\tend\n\t2'b11: if (start) state <= 2'b00;\n\tendcase\nend\n\n\tassign done = (state == 2'b11);\n\t\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\nreg[1:0] state; // 2 states needed: Waiting for first byte of message, looking for second and third bytes\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= 2'b00;\n        done   <= 1'b0;\n\tend else case (state)\n\t\t2'b00: if (in[3] == 1'b1) state <= 2'b01; // First byte of message found, start looking for 2nd and 3rd bytes.\n        2'b01: begin\n            if(in[3] == 1'b1) state <= 2'b10; else state <= 2'b01; // Waiting for third byte to be received (but it might not arrive yet, so stay in this state).\n        end\n        2'b10: begin \n            if(in[3] == 1'b1) state <= 2'b01; else state <= 2'b10; // Third byte has been received, waiting for the next message to start.\n\t\t\tdone   <= 1'b1;   // Indicate a complete message has been received\n        end\n    endcase \nend\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n\treg [2:0] state;\n\t\n\tparameter \n\tIDLE = 3'b001,\n\tGOT_FIRST = 3'b010,\n\tGOT_SECOND = 3'b100;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) \n\t\t\tstate <= IDLE;\n\t\telse \n\t\t\tcase (state)\n\t\t\t\tIDLE:   if (in[3] == 1'b1) state <= GOT_FIRST;\n\t\t\t\tGOT_FIRST: begin\n\t\t\t\t\t\tif(in[3] == 1'b0) state <= GOT_SECOND;\n\t\t\t\t\telse state <= GOT_FIRST;\n\t\t\t\tend\n\t\t\t\tGOT_SECOND: if (in[3] == 1'b1) state <= IDLE;\n\t\t\tendcase\n\tend\n\tassign done = (state == GOT_SECOND);\n\t\nendmodule \n"}
{"task_id": "fsm_ps2", "completion": "\nreg [1:0] state;\nwire byte_start = in[3];\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\tstate <= 2'b00;\n\telse \n\tcase (state)\n\t\t2'b00: if (byte_start) state <= 2'b10; // look for the start of a message\n\t\t2'b01, 2'b10: state <= 2'b11; // wait until we get byte 3 to signal completion\n\t\t2'b11: if (byte_start) begin done <= 1'b1; state <= 2'b00; end else state <= state + 1; // wait for the start of next message, and go back to looking for a message start.\n\tendcase\n\tif(state == 2'b11 && byte_start) \n\t\t   done <= 1'b1;\n\telse\n\t    done <= 1'b0;\nend\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\nreg [2:0] state; \nwire start = in[3]; // start of message is when bit 3 is set (in MSB)\nalways @(posedge clk or posedge reset) begin\n\tif(reset)\n\t\tstate <= 3'b000; // resetting the state to zero\n\telse\n\t\tcase(state)\n\t\t\t3'b000: state <= start ? 3'b001 : 3'b000; // if start of message, go to next state\n\t\t\t3'b001: state <= in[3] & ~start? 3'b010 : 3'b001; // check if the second byte has bit 3 set but not the start bit\n\t\t\t3'b010: state <= in[3] ? 3'b011 : 3'b000; // if third byte also has bit 3 set, we have a complete message so go to next state\n            3'b011: state <= 3'b100; // if third byte is complete and all bits are correct then move to next state which will make done high for one clock cycle only after the reset condition.\n\t\t\tdefault: state <= 3'b000; \n\t\tendcase\nend\nassign done = (state==3'b100); // assigning done as high when all three bytes are complete and correct.\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\nreg[1:0] state;\nwire start = in[3];\n\nalways @(posedge clk or posedge reset) begin \n\tif (reset)\n\t\tstate <= 2'b00;\n\telse begin\n\tcase(state)\n\t\t2'b00: if (start)\n\t\t\t\tstate <= 2'b01;\n\t\t2'b01: state <= 2'b10;\n\t\t2'b10: state <= 2'b11;\n\t\t2'b11: begin\n\t\t\tdone <= 1; \n\t\t\tstate <= 2'b00;\n\t\tend\n\tendcase\n\tend\nend\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\nreg state; // 0 - wait for sync byte, 1-2 - data bytes, 3 - done\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= 0;\n\t\tdone <= 0;\n\tend else begin\n\t\tcase (state)\n\t\t\t0: if (in[3]==1'b1) state <= 1;\n\t\t\t1: state <= 2;\n\t\t\t2: begin \n\t\t\t\t\tstate <= 3;\n\t\t\t\t\tdone <= 1;\n\t\t\t end\n\t\t\t3: done <= 0;\n\t\t\tdefault : state <= 0;\n\t\tendcase\n\tend\nend\n\t\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n\nreg [1:0] state;\nwire start = in[3];  // The start bit of a message is always at the third position.\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= 2'b00;\n    else\n        case (state)\n            2'b00: state <= start ? 2'b01 : 2'b00; // If we see a '1' in the third position, go to the next state. Otherwise stay at state 0.\n            2'b01: state <= 2'b10;                 // Go directly to state 1 if no start bit has been found.\n            2'b10: begin                           // Wait until a new message starts or we receive the last byte of the previous message.\n                done  <= 1'b1;                     // Signal that we have received a whole message.\n                state <= start ? 2'b01 : 2'b10;  \n            end\n        default: state <= 2'b00;                   // Reset the machine to state 0 if an unexpected state is reached.\n        endcase\nend\n\t\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n\treg [1:0] state;\n\tparameter IDLE = 2'b00, DATA1=2'b01, DATA2=2'b10, DONE=2'b11;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= IDLE;\n\t\telse case (state)\n\t\t\tIDLE: if (in[3] == 1'b1)\n\t\t\t\tstate <= DATA1;\n\t\t\tDATA1: state <= DATA2;\n\t\t\tDATA2: begin state <= DONE; done <= 1'b1; end\n\t\t\tDONE: done <= 1'b0;\n\t\t\tdefault : state <= IDLE; \n\tendcase\nend\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n\n\tfsm fsm1(.*);  // Instantiate Finite State Machine module.\nendmodule\n\n// Finite state machine definition.\nmodule fsm (clk, in, reset, done);\n\t// Input and output declarations.\n\tinput clk, reset;\n\tinput [7:0] in;\n\toutput reg done = 0;  // Initialize done to 0.\n\n\ttypedef enum {WAITING, FIRST_BYTE, SECOND_BYTE, THIRD_BYTE} state_t;  \t// Define states of the Finite State Machine (FSM).\n\tstate_t state;     // Declare variable for current state.\n\n\talways @(posedge clk or posedge reset) begin  // Asynchronous Reset\n\t\tif (reset == 1'b1) begin      \t  \t// If reset is active...\n\t\t\tdone <= 0;        \t        // ...set done to 0 and return to the WAITING state.\n\t\t\tstate <= WAITING;\n\t\tend else case(state)   \t  // Else, if not in the RESET state...\n\t\t\t WAITING: if (in[3] == 1'b1) begin\t// If a byte with in[3]=1 is received...\n\t\t\t\t  state <= FIRST_BYTE;        \t\t// ...go to the FIRST_BYTE state.\n\t\t        end else state <= WAITING;    \t  // Else stay in the WAITING state.\n\t\t\t FIRST_BYTE: if (in[3] == 1'b0) begin   // If a byte with in[3]=0 is received...\n\t\t\t\t  state <= SECOND_BYTE;       \t\t// ...go to the SECOND_BYTE state.\n\t\t         end else state <= WAITING;     \t  // Else stay in the FIRST_BYTE state and ignore the byte.\n\t\t\t SECOND_BYTE: if (in[3] == 1'b0) begin  // If a byte with in[3]=0 is received...\n\t\t\t\t  state <= THIRD_BYTE;        \t\t// ...go to the THIRD_BYTE state.\n\t\t          end else state <= WAITING;    \t  // Else stay in the SECOND_BYTE state and ignore the byte.\n\t\t\t THIRD_BYTE: done <= 1'b1;              // If a third byte arrives, set done to 1.\n\t\t\t\t\t// We must be sure that the message is complete before setting \"done\" back to 0 so we don't miss any data or start processing incomplete messages.\n\t\t\t   endcase\n\tend\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n\t// State 0: waiting for first bit of message to be set\n\t// State 1: second byte received, waiting for third\n\t// State 2: third byte received, wait until next message begins\n\treg [1:0] state = 0;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= 0;\n\t\t\tdone <= 0;\n\t\tend else case (state) \n\t\t\t2'b00 : if (in[3]) begin state <= 1; done <= 0; end // If first bit is set, move to state 1\n\t\t\t2'b01 : if (~in[3]) state <= 2; // If second bit isn't set, and third bit is, then we have a whole message received. Stay in this state until reset or next valid start of message.\n\t\t\t2'b10 : done <= 1; \n\t\t\tdefault: state <= (in[3] ? 1 : 0); // If not in these states, just wait for the first bit to be set.\n\tend\n"}
{"task_id": "fsm_ps2", "completion": "\n\treg [1:0] state;\n\twire start = in[3]; // check bit 3 of the byte for starting a message\n\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 2'b00;\n\t\telse case (state)\n\t\t\t2'b00: state <= start ? 2'b01 : 2'b00;\n\t\t\t2'b01: state <= start ? 2'b01 : 2'b10;\n\t\t\t2'b10: state <= start ? 2'b11 : 2'b00;\n\t\t\tdefault: state <= 2'b00; // default to the reset state if any other value is encountered.\n\tend\n\n\t// Output logic - done signaled when we have received all three bytes of a message (state == 2'b11)\n\tassign done = (state == 2'b11); \nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\nreg [1:0] state = 2'h0;\nwire message_start = state == 2'b01 && in[3];  // check for first byte of a new message\nassign done = state[0];   // signal completion of a message reception\n\t\nalways @(posedge clk or posedge reset) begin\n\tif (reset) state <= 2'h0;    // reset FSM\n\telse if (!message_start) \n\t\t\tcase(state)\n\t\t\t\t2'b00: ;   // wait for start of message, keep previous state when not a new message.\n\t\t\t\t2'b01: state <= 2'b10;   // first byte received\n\t\t\t\t2'b10: if (in[3]) state <= 2'b00; else state <= 2'b11;  // second byte received, go to done state or continue receiving.\n\t\t\t\t2'b11: ;    // third byte received, stay in the done state until reset.\n\t\t\tendcase\n\telse if (message_start) \n\t\t\tcase(state)\n\t\t\t\t2'b00: state <= 2'b01;   // start of new message, go to first byte received state\n\t\t\t\tdefault: ;   // when not in the beginning state, ignore any further messages.\n\t\t\tendcase\nend\n"}
{"task_id": "fsm_ps2", "completion": "\n\treg [1:0] state;\n\treg done_internal;\n\tparameter IDLE = 2'b00, SECOND_BYTE = 2'b01, THIRD_BYTE = 2'b10;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tdone_internal <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: if (in[3] == 1'b1) begin\n\t\t\t\t\tstate <= SECOND_BYTE;\n\t\t\t\tend \n\t\t\t\tSECOND_BYTE: if (in[3] == 1'b0) begin\n\t\t\t\t\tstate <= THIRD_BYTE;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\tend\n\t\t\t\tTHIRD_BYTE: state <= IDLE;\n\t\t\tendcase \n\t\t\tif (state == THIRD_BYTE) done_internal <= 1'b1;\n\t\t\telse if (!reset && ((state != SECOND_BYTE && in[3] == 1'b1) || state == IDLE)) begin\n\t\t\t\tdone_internal <= 0;\n\t\t\tend \n\t\tend\n\tend\n\tassign done = done_internal;\nendmodule \n"}
{"task_id": "fsm_ps2", "completion": "\nreg state; // 0 for idle, 1 for byte 1 of message, 2 for byte 2 of message, 3 for byte 3 of message.\nassign done = (state == 3);\nalways @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\tstate <= 0;\n\telse if (in[3]==1 && state == 0) // we're looking for first byte in a message \n\t\tstate <= 1;\n\telse if (in[3]==0 && state == 1) // next byte must be the second one, so ignore it and go back to idle.\n\t\tstate <= 0;\n\telse if (in[3]==0 && state != 2)  // skip this byte as it is not expected in message.\n\t\tstate <= state + 1; // increment state count only when third byte of the message arrives.\nend\n\t\t\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n    \n    reg [1:0] state;\n    parameter IDLE = 2'b00, MSG_STARTED = 2'b01, MSG_ENDED = 2'b10;\n        \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= IDLE;\n        else case (state)\n            IDLE:       if (in[3]) state <= MSG_STARTED; // Waiting for first message byte\n            MSG_STARTED: if (!in[3]) state <= MSG_ENDED; // Assuming second and third bytes were received when we've seen the start bit, go to done state\n            default:    state <= IDLE;  // Default case back to idle after a message is completed (done)\n        endcase  \n    end\n     \n    assign done = (state == MSG_ENDED); // Assign 'done' when third byte of the message has been received.\n    \t\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\n\treg [1:0] state;\n\twire msgStart;\n\tassign msgStart = state == 2'b01 && in[3];  // Message start condition\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= 2'b00;  // Reset state\n        else\n            case (state)\n                2'b00: state <= in[3] ? 2'b10 : 2'b00;  // Wait for start bit and check if it is set\n                2'b01, 2'b10, 2'b11: state <= state + 1; // If message started then increment the state\n                2'b11: state <= 2'b00; // reset to beginning after third byte received\n            endcase\n    end\n\tassign done = state == 2'b11;  // Signal completion of a message when state reaches 3\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\nreg [2:0] state;\nwire start = in[3];  // The first bit of the message is 1.\n\n// State transition diagram\nalways @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\tstate <= 3'b000;  // Reset state to idle\n\telse\n\t\tcase (state)\n\t\t\t3'b000: state <= start ? 3'b001 : 3'b000;  // Wait for first bit of message\n\t\t\t3'b001: state <= in[4] ? 3'b010 : 3'b000;  // Check second bit of message\n\t\t\t3'b010: state <= in[5] ? 3'b011 : 3'b000;  // Check third bit of message\n\t\t\t3'b011: state <= 3'b100;                    // Message received\n\t\t\t3'b100: state <= 3'b000;                    // Done receiving, wait for next message\n\t\t\tdefault: state <= 3'b000;  // Invalid state, reset\n\tendcase\nend\n\n// Output logic\nassign done = (state == 'b100);  // Set done to 1 when a complete message has been received\n"}
{"task_id": "fsm_ps2", "completion": "\n\treg [1:0] state; \n\tparameter [1:0] S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11; \n\n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset == 1) begin \n\t\t\tstate <= S0; \n\t\t\tdone <= 0; \n\t\tend else begin \n\t\t\tcase (state) \n\t\t\t\tS0: if (in[3]==1'b1) state <= S1; // If byte starts a message, go to next state.\n\t\t\t\tS1: if (in[3]==1'b0) state <= S2; // If second byte of the message is received and doesn\u2019t start it over, go to next state.\n\t\t\t\tS2: begin done <= 1; state <= S3; end  // Signal that a message was successfully completed once third byte has been found.\n\t\t\t\tS3: if (in[3]==1'b1) state <= S1;  // If a new message starts, go to the first state of the next cycle.\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "\nreg [1:0] state;\nwire start = in[3];\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tstate <= 2'b00;\n\telse begin\n\t\tcase(state)\n\t\t\t2'b00: if (start)\n\t\t\t\t\t\tstate <= 2'b01;\n\t\t        2'b01: state <= 2'b10;\n                    2'b10: begin \n                        state <= 2'b11;\n                        done <= 1'b1; // signal that a message has been received after the third byte.\n                    end\n            \tdefault : state <= 2'b00;\n       \tendcase\n    end  \nend\nendmodule\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'h0;\n\t\telse if (q == 4'hF) \n\t\t\tq <= 4'h0;\n\t\telse \n\t\t\tq <= q + 1;\n\tend\nendmodule\n"}
{"task_id": "count15", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t  if (reset == 1'b1)  // active high reset\n\t    q <= 4'h0;  \n      else  \n        q <= q + 4'h1;\n    end\nendmodule\n\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n  \tif (reset == 1'b1)\n    \tq <= 4'h0;\n \telse if (q == 4'hF)\n   \t\tq <= 4'h0;\n \telse\n    \tq <= q + 1;\n\tend\nendmodule\n\n"}
{"task_id": "count15", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 4'h0;\n\telse if (&q == 1'b1) \n\t\tq <= 4'h0;\n\telse \n\t\tq <= q + 1;\nend\nendmodule\n"}
{"task_id": "count15", "completion": "\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 4'b0;\n        else \n            q <= q + 1;\n    end\nendmodule\n"}
{"task_id": "count15", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 4'b0;\n\telse \n\t\tq <= q == 4'd15 ? 4'b0 : q + 1;\nend\n  \nendmodule\n"}
{"task_id": "count15", "completion": "\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 4'd0;\n        else \n            q <= q + 1;\n    end\nendmodule\n\n"}
{"task_id": "count15", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\tq <= 4'b0;\n\telse \n\t\tq <= q + 1;\nend\nendmodule\n\n"}
{"task_id": "count15", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 4'b0;\n\telse \n\t\tq <= q + 1;\nend\n\n"}
{"task_id": "count15", "completion": "\n    \n    always @ (posedge clk or posedge reset) begin\n        if (reset) \n            q <= 4'b0;\n        else \n            q <= q + 1;\n    end\nendmodule\n"}
{"task_id": "count15", "completion": "\n\n\talways @ (posedge clk or posedge reset) begin\n    if(reset)\n        q <= 4'b0;\n    else \n        q <= q + 1;\n\tend\n\nendmodule\n\n"}
{"task_id": "count15", "completion": "\nalways @ (posedge clk or posedge reset) begin\n\tif(reset) \n\t\tq <= 4'b0;\n\telse\n\t\tq <= q + 1;\nend\n\t\nendmodule\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t    q <= 4'd0;\n        else \n\t\t    q <= q + 1;\n\tend\n\nendmodule\n\n"}
{"task_id": "count15", "completion": "\n\t// Define states for the state machine\n\tparameter S0 = 4'b0000;\n\tparameter S1 = 4'b0001;\n\tparameter S2 = 4'b0010;\n\tparameter S3 = 4'b0011;\n\tparameter S4 = 4'b0100;\n\tparameter S5 = 4'b0101;\n\tparameter S6 = 4'b0110;\n\tparameter S7 = 4'b0111;\n\tparameter S8 = 4'b1000;\n\tparameter S9 = 4'b1001;\n\tparameter SA = 4'b1010;\n\tparameter SB = 4'b1011;\n\tparameter SC = 4'b1100;\n\tparameter SD = 4'b1101;\n\tparameter SE = 4'b1110;\n\tparameter SF = 4'b1111;\n\t\t  \n\t// State register\n\treg [3:0] state_register;\n\t    \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate_register <= S0; // Reset to 0 on active high reset\n\t\telse \n\t\t\tcase (state_register)\n\t\t\t\tS0: state_register <= S1;\n\t\t\t\tS1: state_register <= S2;\n\t\t\t\tS2: state_register <= S3;\n\t\t\t\tS3: state_register <= S4;\n\t\t\t\tS4: state_register <= S5;\n\t\t\t\tS5: state_register <= S6;\n\t\t\t\tS6: state_register <= S7;\n\t\t\t\tS7: state_register <= S8;\n\t\t\t\tS8: state_register <= S9;\n\t\t\t\tS9: state_register <= SA;\n\t\t\t\tSA: state_register <= SB;\n\t\t\t\tSB: state_register <= SC;\n\t\t\t\tSC: state_register <= SD;\n\t\t\t\tSD: state_register <= SE;\n\t\t\t\tSE: state_register <= SF;\n\t\t\t\tSF: state_register <= S0; // Wrap to 0 on counter overflow\n\t\t\tendcase\n\tend\n\tassign q = state_register;\nendmodule\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'b0;\n\t\telse if (q < 4'd15) \n\t\t\tq <= q + 1;\n\t\telse \n\t\t\tq <= 4'b0;\n\tend\nendmodule\n"}
{"task_id": "count15", "completion": "\n\t\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t    q <= 4'b0;\n        else\n            q <= q + 1'h1 == 4'b1111 ? 4'b0 : q+1'h1;\n\tend\n\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset) \n        \tq <= 4'b0;\n    \telse if (&q == 1'b1)  // check if the counter has reached its maximum value of 15.\n\t\t\tq <= 4'b0;\n\t\telse \n        \tq <= q + 1;\n    end\nendmodule\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n    if (reset == 1'b1) \n        q <= 4'b0;\n    else \n        q <= q + 4'd1; // Increment by one for every clock cycle\n   end\nendmodule\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n    if (reset) \n        q <= 4'b0;\n    else \n        q <= q + 1;\n\tend\nendmodule\n\n"}
{"task_id": "count15", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 4'd0;\n\t\telse if (&q)\n\t\t\tq <= 4'd0;\n\t\telse \n\t\t\tq <= q + 1;\n\tend\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\n\t// State declaration\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\t// Output assignment\n\tassign out = (state == D);\n\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tstate <= A;\n\t\telse \n\t\t\tcase(state)\n\t\t\t\tA: state <= in ? B : A;\n\t\t\t\tB: state <= in ? C : B;\n\t\t\t\tC: state <= in ? D : C;\n\t\t\t\tD: state <= in ? A : D;\n\t\t\tendcase\n\tend \nendmodule\n\n"}
{"task_id": "fsm3s", "completion": "\n\n\t// Declare the state registers and assign initial states.\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\tassign out = (state == D); // Output is 1 when in state D.\n    \n\t// Synchronous process with active high reset.\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)\n\t\t    state <= A; // Reset to state A.\n        else case(state)  \n            A: \tif (!in) state <= B; \n                else state <= C;\n            B:\t\tif (!in) state <= B;\n                else state <= D;    \n            C: \tif (!in) state <= A; \n                else state <= D;\n            D:\t\tif (!in) state <= C; \n                else state <= B;   \n        endcase  \n\tend\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\nreg [1:0] state; // Two bits to hold the current state\nwire [3:0] nextState; // Four different states A=2'b00, B=2'b01, C=2'b10 and D=2'b11\nassign out = (state == 2'b10);\nalways @(posedge clk or posedge reset) begin \n\tif (reset) state <= 2'b00; // Reset to A on a rising clock edge if reset is active\n\telse state <= nextState[state];\nend\nassign nextState = {in ? state[1] : ~state[1], ~state[0], in ? ~state[1] : state[1], state[0]}; // Compute the next state based on the current input value and the current state \n\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\twire [3:0] nxt_state;\n\tassign out = state[1]; // Assign output as the second bit of our state register\n\t\n\t// Next State Logic\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t2'b00 : if (in==0) nxt_state = 4'b01; else nxt_state = 4'b10; // A -> B / A if in=0, C if in=1\n            2'b01 : if (in==0) nxt_state = 4'b00; else nxt_state = 4'b11; // B -> A / B if in=0, D if in=1\n\t\t\t2'b10 : if (in==0) nxt_state = 4'b10; else nxt_state = 4'b01; // C -> B / B if in=0, A if in=1\n\t\t\t2'b11 : if (in==0) nxt_state = 4'b11; else nxt_state = 4'b00; // D -> C / C if in=0, B if in=1\n\t\tendcase\n\tend \n\t\n\t// State Register\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) state <= 2'b00; // Reset to A on high active synchronous reset\n\t\telse state <= nxt_state[1:0]; // Transition states\n\tend \nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n  \n\talways @(posedge clk or posedge reset) begin\n      \tif (reset) \n          \tstate <= A;\n        else case (state)\n            A: if (!in) \n                   state <= B;\n               else \n                   state <= C;\n            \n            B: if (!in) \n                   state <= B;\n               else \n                   state <= D;\n                      \n            C: if (!in) \n                   state <= A;\n               else \n                   state <= D;\n         \n            D: if (!in) \n                   state <= C;\n               else \n                   state <= B;\n        endcase\n    end\t  \n      \n     assign out = (state == D);     \nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n    reg [1:0] state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= A;\n        else \n            case (state)\n                A:begin\n                    out <= 0;\n                    if (in == 0)\n                        state <= A;\n                    else\n                        state <= B;\n                  end \n                B: begin\n                    out <= 0;\n                    if(in==0)\n                      state<=B;\n                    else\n                    \tstate<=C;  \n                 end \n             C:begin\n                   out<=0;\n                   if (in == 1)\n                      state <= D;\n                 \telse\n                       state<=A;\n               end \n            D:begin\n                    out <= 1;\n                    if(in==0)\n                    \tstate <= B;\n                    else\n                        state <= C; \n             end  \n        endcase\n    end\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [2:0] state;\n\tparameter A = 3'b001;\n\tparameter B = 3'b010;\n\tparameter C = 3'b100;\n\tparameter D = 3'b011;\n\t\n\talways @(posedge clk or posedge reset) begin \n\t\tif (reset)\n\t\t    state <= A;\n\t\telse\n\t\t    case(state)\n\t\t\t     A: if (in == 0) \n\t\t\t\t         state <= B;\n\t\t\t\t\t else\n\t\t\t\t         state <= C;\n\t\t\t     B: if (in == 0)  \n\t\t\t\t\t      state <= A;\n\t\t\t\t     else\n\t\t\t\t\t\t  state <= B;\n\t\t\t     C: if (in == 0) \n\t\t\t\t          state <= D;\n\t\t           else\t\n\t\t           \t  state <= C;\n\t\t         D: if(in == 0)\n                  state <= A;\n              else\n                state <= B;\n\t\t\t    endcase  \n\tend\n\t\nassign out = (state == D);\n\t\nendmodule \n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\tparameter A=2'h0, B=2'h1, C=2'h2, D=2'h3;\n\t\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) \n\t\t\tstate <= A;\n\t\telse case (state)\n\t\t\tA: if (!in) \n\t\t\t    begin \n\t\t\t     state<=B;\n\t\t\t     out <= 1'b0;\n                            end\n                           else \n                            begin \n                             state<=C;\n                             out <= 1'b0;\n                            end\n                   B: if (!in) \n                      begin \n                       state<=B;\n                       out <= 1'b0;\n                      end\n                     else \n                      begin \n                       state<=D;\n                       out <= 1'b0;\n                      end  \t    \n                  C: if (!in) \n\t\t      begin \n\t\t       state<=A;\n\t\t       out <= 1'b0;\n                      end\n                     else \n                      begin \n                       state<=D;\n                       out <= 1'b0;\n                      end  \t    \n                  D: if (!in) \n\t\t      begin \n\t\t       state<=C;\n\t\t       out <= 1'b1;\n                      end\n                     else \n                      begin \n                       state<=B;\n\t\t       out <= 1'b0;\n                      end  \t    \n        \t  default: state <= A; //Default condition to prevent latching of FSM in case any other values than defined above are inputted\n                endcase\n\tend\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= A;\n\t\telse \n\t\t\tcase (state)\n\t\t\t\tA: state <= in ? B : A;\n\t\t\t\tB: state <= in ? C : B;\n\t\t\t\tC: state <= in ? D : C;\n\t\t\t\tD: state <= in ? A : D;\n\t\t\tendcase\n\tend\n\t\n\tassign out = (state == D);\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state; // we only need two bits to store the current and next states\n\twire a = (state == 2'b00) & ~in; \n\twire b = (state == 2'b01) | in;  \n\twire c = (state == 2'b10) & ~in; \n\twire d = (state == 2'b11) | ~in;  // output is the third bit of the state\n\n\t// State transition table\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t    state <= 2'b00;  \n        else        \n            case (state) \n                2'b00: if (in == 0) state <= 2'b00; else state <= 2'b10; // out = 0\n                2'b01: if (in == 0) state <= 2'b00; else state <= 2'b11; \n                2'b10: if (in == 0) state <= 2'b00; else state <= 2'b01; // out = 0\n                2'b11: if (in == 0) state <= 2'b00; else state <= 2'b10; \n            endcase\n\tend\n\n\t// Output logic\n\tassign out = state[1];  \n    \nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\treg [1:0] next_state;\n\twire [3:0] new_out = {2'b00, state == 'b01 || state == 'b11}; // to convert binary (0 or 2) into one-hot\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 'b00; // initial state: A\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// combinational logic to compute new states and outputs from current states and inputs\n\talways @(*) begin \n\t\tcase (state)\n\t\t\t'b00 : if (!in) {next_state, out} = 'b01; else {next_state, out} = 'b01; // A -> B\n\t\t\t'b01 : if (!in) {next_state, out} = 'b10; else {next_state, out} = 'b00; // B -> C\n\t\t\t'b10 : if (!in) {next_state, out} = 'b00; else {next_state, out} = 'b11; // C -> A\n\t\t\t'b11 : if (!in) {next_state, out} = 'b11; else {next_state, out} = 'b01; // D -> B\n\t\tendcase\n\tend \nendmodule\n"}
{"task_id": "fsm3s", "completion": "\nreg [1:0] state;\n\twire [3:0] next_state;\n\tassign {out,next_state} = reset ? 4'b01 : ({in, state} == 2'd0) ? 4'h8 : ({in, state} == 2'd1) ? 4'h9 : 4'he;\n   always @(posedge clk) begin\n\tstate <= next_state[1:0];\n   end\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n    reg [3:0] nextstate;\n  \n    // State encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n\talways @(posedge clk or posedge reset) begin\n        if (reset) state <= A;  // Reset to state A on synchronous active high reset signal\n        else state <= nextstate;\n    end\n      \n   assign out = state[0];\n   always@(*) begin\n         case(state) \n           A: begin if (!in) nextstate = A; else nextstate = B; end  // In this state, the output is '0' and we go to state B if input is '1'. Otherwise stay at current state.\n           \n           B: begin if (!in) nextstate = C; else nextstate = B; end  // In this state, the output is '0' and we go to state C if input is '0'. Otherwise stay at current state.\n            \n           C: begin if (!in) nextstate = A; else nextstate = D; end  // In this state, the output is '0' and we go to state A if input is '0'. Otherwise go to state D.\n           \n           default: begin if(!in) nextstate = B; else nextstate = C;end   // In this state, the output is '1', and we go to state B if input is '0' otherwise go to state C. \n          endcase \n     end      \nendmodule\n"}
{"task_id": "fsm3s", "completion": "\nreg [1:0] state;\n    reg [1:0] nextState;\n    reg outputSignal;\n    \n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\t\n\t// State transition function\n\talways @(state or in) begin\n        case (state)\n            A: begin \n                nextState = in ? B : A; // If input is 0 go to state A, if it's 1 go to state B.\n                outputSignal = 1'b0;   // Output is 0 for all states except D.\n            end\n            \n            B: begin \n                nextState = in ? C : B;\n                outputSignal = 1'b0;\n            end\n          \n            C: begin \n                nextState = in ? A : C;\n                outputSignal = 1'b0;   \n            end\n            \n            D: begin \n                nextState = in ? B : D; // If input is 0 go to state D, if it's 1 go to state B.\n                outputSignal = 1'b1;   // Only on this state output signal goes high (1).\n            end\n        endcase\n    end\n    \n\t// Synchronous state register\n\talways @(posedge clk or posedge reset) begin\n       if (reset) \n           state <= A; // If the reset is active, go to initial state.\n       else\n           state <= nextState; // Otherwise proceed with the next state determined by our state transition function.\n    end\n\t\n\t// Output assignment\n\tassign out = outputSignal;\n    \nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\treg [1:0] next_state;\n\treg output_value;\n\n\t// State transition and outputs\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t2'h0 : begin\n\t\t\t\t\t\tif (in == 0) begin\n\t\t\t\t\t\t\tnext_state <= 2'h0; \n\t\t\t\t\t\t\toutput_value <= 1'b0;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tnext_state <= 2'h1;\n\t\t\t\t\t\t\toutput_value <= 1'b0;\n\t\t\t\t\t\tend\n\t\t\t\t   end\t\t    \n\t\t\t2'h1 : begin \n\t\t\t\t\t\tif (in == 0) begin\n\t\t\t\t\t\t\tnext_state <= 2'h2; \n\t\t\t\t\t\t\toutput_value <= 1'b0;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tnext_state <= 2'h3;\n\t\t\t\t\t\t\toutput_value <= 1'b0;\n\t\t\t\t\t\tend\n\t\t\t\t    end\n\t\t\t2'h2 : begin\n\t\t\t\t\t\tif (in == 0) begin\n\t\t\t\t\t\t\tnext_state <= 2'h0; \n\t\t\t\t\t\t\toutput_value <= 1'b0;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tnext_state <= 2'h3;\n\t\t\t\t\t\t\toutput_value <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t    end\n\t\t\t2'h3 : begin \n\t\t\t\t\t\tif (in == 0) begin\n\t\t\t\t\t\t\tnext_state <= 2'h2; \n\t\t\t\t\t\t\toutput_value <= 1'b0;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tnext_state <= 2'h1;\n\t\t\t\t\t\t\toutput_value <= 1'b0;\n\t\t\t\t\t\tend\n\t\t\t\t    end\n\t\t\tdefault : begin\n\t\t\t\t\t   next_state <= 2'h0; \n\t\t\t\t\t   output_value <= 1'b0;\n\t\t\t\t\t  end\n\t\tendcase\n\tend\n\t// State register\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 2'h0;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\tassign out = output_value;\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [2:0] state; // 3 bits for the states A, B, C and D. 001 is equivalent to A, 010 is B etc..\n\n\t// State transition table implementation\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 2'b00; // Reset state back to A when the reset input goes high.\n\t\telse\n\t\t\tcase(state)\n\t\t\t\t3'b00: if (!in) state <= 3'b00; else state <= 3'b01; // Next state for in=0 is A, next state for in=1 is B.\n\t\t\t\t3'b01: if (!in) state <= 3'b00; else state <= 3'b10; \n\t\t\t\t3'b10: if (!in) state <= 3'b10; else state <= 3'b11;\n\t\t\t\t3'b11: if (!in) state <= 3'b01; else state <= 3'b11;\n\t\t\tendcase\n\tend \n\n\t// Output logic, depends on the current state.\n\tassign out = (state == 3'b11); // The output is 1 when in D state otherwise its 0.\nendmodule\n\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\twire [3:0] nextState;\n\tparameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;\n\tassign out = (state==D)? 1 : 0; // output is set according to state D\n  \n\talways @(posedge clk or posedge reset) begin \n\t  if (reset) state <= A; \t// synchronous reset\n\t  else state <= nextState;\t\t// update the state\n\tend\n\t\n\talways @(*) begin\t\t\t// combinational part that determines the next state based on current and input state\n    case(state)\n       A: nextState = in ? B : A;  // if input is 0 then stay at state A, else move to state B\n       B: nextState = in ? C : B; \t// if input is 0 then stay at state B, else move to state C\n       C: nextState = in ? D : C;\t\t// if input is 0 then stay at state C, else move to state D\n       D: nextState = in ? A : D;\t\t// if input is 0 then stay at state D, else move to state A\n    endcase\n\tend\n  \nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\tparameter A = 2'h0, B = 2'h1, C = 2'h2, D = 2'h3;\n\tassign out = (state == D) ? 1'b1 : 1'b0; // Output is 1 when in state D\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= A; // Reset to state A\n\t\telse\n\t\t\tcase (state) \n\t\t\t\tA: state <= in ? B : A;\n\t\t\t\tB: state <= in ? C : B;\n\t\t\t\tC: state <= in ? D : A;\n\t\t\t\tD: state <= in ? B : C;\n\t\t\t\tdefault: state <= A; // Default to state A\n\t\t\tendcase\n\tend \nendmodule\n"}
{"task_id": "fsm3s", "completion": "\n\treg [1:0] state;\n\twire [3:0] nextState;\n\tassign nextState = 4'b1011 << ((state << ~in) + (state[2] & in)); // Next State calculation based on the current state and input\n\t// Synchronous reset to clear out any glitches at power-up\n\talways @(posedge clk or posedge reset) \n        if (reset) begin\n            state <= 0;\n\t    end else \n        \tstate <= nextState[1:0]; // Only take the bottom two bits of Next State as current state\n\t// Output assignment, based on the current state\n    assign out = state == 2'b11 ;  // Moore machine - output is in the same state for both inputs. In this case it will be '1' only when we are at D state (4th).\nendmodule \n"}
{"task_id": "fsm3s", "completion": "\n\t// Declare states as enum type\n\ttypedef enum {A,B,C,D} state_type;\n\tstate_type state, nextState; // Current and Next state declarations \n\treg outputVal; // Output Value\n\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t    state <= A; // Asynchronous Reset\n\t    else \n\t\t    state <= nextState; // Synchronous State Update\n\tend\n\n\t// Next state and output logic\n\talways @(*) begin  \n\t  case (state)\n\t     A: begin\n\t        if(!in) begin out = 0; {nextState,outputVal} = {A,1'b0}; end \n\t\t    else begin out = 0; {nextState,outputVal} = {B,1'b0}; end  // For in=0 and in=1 cases respectively.\n\t     end\n\t     B: begin \n\t        if(!in) begin out = 0;{nextState,outputVal} = {C,1'b0}; end\n\t\t    else begin out = 0; {nextState,outputVal} = {B,1'b0}; end  \n\t     end\n\t     C: begin \n\t        if(!in) begin out = 1; {nextState,outputVal} = {A,1'b1}; end\n\t\t    else begin out = 1; {nextState,outputVal} = {D,1'b1}; end  \n\t     end\n\t     D: begin \n\t        if(!in) begin out = 0;{nextState,outputVal}= {C,1'b0}; end \n\t\t    else begin out = 1; {nextState,outputVal} = {B,1'b1}; end  \n\t    end\n\t  endcase \n\tend\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @(*) begin \n\t\t\tcase(state) \n\t\t\t\t4'b0001 : begin \n\t\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\t\t\tnext_state = 4'b0010; //Go to state B if input is 0\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tnext_state = 4'b0001; //Stay in state A if input is 1\n\t\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t4'b0010 : begin \n\t\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\t\t\tnext_state = 4'b0100; //Go to state C if input is 0\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tnext_state = 4'b0010; //Stay in state B if input is 1\n\t\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t4'b0100 : begin \n\t\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\t\t\tnext_state = 4'b0001; //Go to state A if input is 0\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tnext_state = 4'b1000; //Go to state D if input is 1\n\t\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t4'b1000 : begin \n\t\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\t\t\tnext_state = 4'b0100; //Go to state C if input is 0\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tnext_state = 4'b0010; //Go to state B if input is 1\n\t\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\tend\n\tassign out = (state == 4'b0010) | (state == 4'b1000); //Output is set high when we are in either B or D states.\nendmodule\n\n"}
{"task_id": "fsm3onehot", "completion": "\n\t\n\t// State transition logic\n\talways @(*) begin \n\tcase (state)\n\t\t4'b0001 : if(!in) begin next_state <= 4'b0001; end else next_state <= 4'b0010;\n\t\t4'b0010 : if(!in) begin next_state <= 4'b0010; end else next_state <= 4'b0100;\n\t\t4'b0100 : if(!in) begin next_state <= 4'b0100; end else next_state <= 4'b1000;\n\t\t4'b1000 : if(!in) begin next_state <= 4'b1000; end else next_state <= 4'b0001;\n\tendcase\n\tend \n\t// Output logic\n\tassign out = (state==4'b0100); // In state D, the output is set to 1. Otherwise it is set to 0. \nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\tassign out = state[3];\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t4'b0001 : if (in == 0) begin next_state <= 4'b0010; end else begin next_state <= 4'b0001; end \n\t\t\t4'b0010 : if (in == 0) begin next_state <= 4'b0110; end else begin next_state <= 4'b0001; end  \n\t\t\t4'b0100 : if (in == 0) begin next_state <= 4'b0001; end else begin next_state <= 4'b1000; end \n\t\t\t4'b1000 : if (in == 0) begin next_state <= 4'b0100; end else begin next_state <= 4'b0010; end \n\t\t\tdefault: next_state <= state;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\t\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t4'b0001: begin \n\t\t\t\t\t   if (!in) begin \n\t\t\t\t\t\t\tnext_state = 4'b0001;  // Stay in state A\n\t\t\t\t\t\t end \n\t\t\t\t\t\t else begin \n\t\t\t\t\t\t\t next_state = 4'b0010;  // Go to state B\n\t\t\t\t\t\t end \n\t\t\t\t    out = 1'b0; // Output 0 for both cases \n\t\t\t\t\t\tend \n\t\t\t\n\t\t\t4'b0010: begin \n\t\t\t\t\t\tif (!in) begin \n\t\t\t\t\t\t\t next_state = 4'b0010; // Stay in state B\n\t\t\t\t\t\t end \n\t\t\t\t\t\t else begin \n\t\t\t\t\t\t\t next_state = 4'b0100; // Go to State C\n\t\t\t\t\t\t end \n\t\t\t\t\t\tout = 1'b0; // Output 0 for both cases \n\t\t\t\t\t\tend  \n\t\t\t\n\t\t   4'b0100: begin \n\t\t\t\t\t\tif (!in) begin \n\t\t\t\t\t\t\t next_state = 4'b0100;// Stay in state C\n\t\t\t\t\t\t end \n\t\t\t\t\t\t else begin \n\t\t\t\t\t\t\t next_state = 4'b1000; // Go to State D\n\t\t\t\t\t\t end  \n\t\t\t\t\t\tout = 1'b0; // Output 0 for both cases \n\t\t\t\t\t    end \n\t\t   \n\t\t\t4'b1000: begin \n\t\t\t\t\t\tif (!in) begin \n\t\t\t\t\t\t\t next_state = 4'b1000;// Stay in state D\n\t\t\t\t\t\t end \n\t\t\t\t\t\t else begin \n\t\t\t\t\t\t\t next_state = 4'b0001; // Go to State A\n\t\t\t\t\t\t end  \n\t\t\t\t\t\tout = 1'b1; // For input=1, Output is 1 from state D\n\t\t\t\t\t    end \n\t\t\tdefault: begin \n\t\t\t\t\t\tnext_state = state;// Stay in current state if no match\n\t\t\t\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\nalways @(*) begin\n\tcase (state) \n\t\t4'b0001 : begin // state A\n\t\t\t\tnext_state = in ? 4'b0010 : 4'b0001; // Transition to B on input 1, stay at A otherwise.\n\t\t\t\tout = 0; // Output is always 0 for state A\n\t\t\tend\n\t\t4'b0010 : begin // state B\n\t\t\t\tnext_state = in ? 4'b0100 : 4'b0010; // Transition to C on input 1, stay at B otherwise.\n\t\t\t\tout = 0; // Output is always 0 for states B and C\n\t\t\tend\n\t\t4'b0100 : begin // state C\n\t\t\t\tnext_state = in ? 4'b1000 : 4'b0001; // Transition to D on input 1, transition back to A otherwise.\n\t\t\t\tout = 0; // Output is always 0 for states B and C\n\t\t\tend\n\t\t4'b1000 : begin // state D\n\t\t\t\tnext_state = in ? 4'b0100 : 4'b0010; // Transition to B on input 1, transition back to C otherwise.\n\t\t\t\tout = 1; // Output is 1 for state D\n\t\t\tend\n\tendcase\nend\n\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @(*) begin\n\tcase (state) \n\t\t4'b0001 : //State A\n\t\t\tif (!in) {next_state = 4'b0001;out=0;}//Stay at A\n\t\t\t else   {next_state = 4'b0010;out=0;}//Move to B\n\t\t4'b0010 : //State B\n\t\t\tif (!in) {next_state = 4'b0010;out=0;}//Stay at B\n\t\t\t else   {next_state = 4'b0100;out=0;}//Move to C\n\t\t4'b0100 : //State C\n\t\t\tif (!in) {next_state = 4'b0100;out=0;}//Stay at C\n\t\t\t else   {next_state = 4'b1000;out=0;}//Move to D\n\t\t4'b1000 : //State D\n\t\t\tif (!in) {next_state = 4'b1000;out=1;}//Stay at D\n\t\t\t else   {next_state = 4'b0001;out=0;}//Move to A \n\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "fsm3onehot", "completion": "\n\tassign out = state == 4'b1000; // Output is '1' only when the current state is D.\n\talways @(*) begin \t\t\t// Combinational logic portion for state transition and output.\n\t\tcase (state) \t\t\t\n\t\t\t4'b0001: next_state = in ? 4'b0001 : 4'b0010; // If input is '0', stay at A, if input is '1', go to B.\n\t\t\t4'b0010: next_state = in ? 4'b0010 : 4'b0100; // If input is '0', stay at B, if input is '1', go to C.\n\t\t\t4'b0100: next_state = in ? 4'b0100 : 4'b1000; // If input is '0', stay at C, if input is '1', go to D.\n\t\t\t4'b1000: next_state = in ? 4'b1000 : 4'b0001; // If input is '0', stay at D, if input is '1', go back to A.\n\t\t\tdefault: next_state = 4'b0000;\t\t\t    // Default state when not in any valid states.\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\n\t// State transition and output logic equations\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t4'b0001: //State A\n\t\t\tbegin \n\t\t\t\tnext_state = in ? 4'b0001 : 4'b0010;  \n\t\t\t\tout = 1'b0;\n\t\t\tend \n\t\t\t4'b0010: //State B\n\t\t\tbegin \n\t\t\t\tnext_state = in ? 4'b0100 : 4'b0010;\n\t\t\t\tout = 1'b0;\n\t\t\tend  \n\t\t\t4'b0100: //State C\n\t\t\tbegin \n\t\t\t\tnext_state = in ? 4'b1000 : 4'b0001;\n\t\t\t\tout = 1'b0;\n\t\t\tend\n\t\t\t4'b1000: //State D\n\t\t\tbegin  \n\t\t\t\tnext_state = in ? 4'b0100 : 4'b0010;\n\t\t\t\tout = 1'b1;\n\t\t\tend   \n\t\t\tdefault: ;\n\t\tendcase    \n\tend \n\t\nendmodule\n\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @(*) begin\n\t\tcase(state) \n\t\t\t4'b0001: // State A\n\t\t\tbegin\n\t\t\t\tnext_state = in ? 4'b0001 : 4'b0010; // Next state for input 0 is A, for input 1 is B\n\t\t\t\tout = 1'b0; // Output for this state is 0\n\t\t\tend\n      \n\t\t\t4'b0010: // State B\n\t\t\tbegin\n\t\t\t\tnext_state = in ? 4'b0100 : 4'b0010; // Next state for input 0 is C, for input 1 is B\n\t\t\t\tout = 1'b0; // Output for this state is 0\n\t\t\tend\n      \n\t\t\t4'b0100: // State C\n\t\t\tbegin\n\t\t\t\tnext_state = in ? 4'b0001 : 4'b1000; // Next state for input 0 is A, for input 1 is D\n\t\t\t\tout = 1'b0; // Output for this state is 0\n\t\t\tend\n      \n\t\t\t4'b1000: // State D\n\t\t\tbegin\n\t\t\t\tnext_state = in ? 4'b0100 : 4'b0010; // Next state for input 0 is C, for input 1 is B\n\t\t\t\tout = 1'b1; // Output for this state is 1\n\t\t\tend\n      \n\t\tdefault: begin\n\t\t\t\tnext_state = 4'b0001; // Default state A\n\t\t\t\tout = 1'bx; // No defined output, hence setting as undefined.\n\t\t\tend\n\t\tendcase\n\tend\nendmodule \n"}
{"task_id": "fsm3onehot", "completion": "\n\t// Combinational logic for the Moore machine. \n\talways @(*) begin\n\t\tcase (state)\n\t\t\t4'h1: begin next_state = in ? 4'h2 : 4'h1; out = 0; end // A -> B, B -> B\n\t\t\t4'h2: begin next_state = in ? 4'h3 : 4'h2; out = 0; end // B -> C, C -> B\n\t\t\t4'h3: begin next_state = in ? 4'h1 : 4'h4; out = 0; end // C -> A, D -> B\n\t\t\t4'h4: begin next_state = in ? 4'h2 : 4'h3; out = 1; end // D -> C, B -> B\n\t\tendcase\n\tend\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @* begin\n\tcase(state) \n\t\t4'b0001: //State A\n\t\t\tif (!in) begin \n\t\t\t\tnext_state = 4'b0010; //Go to B\n\t\t\t\tout = 0; //Output 0\n\t\t\tend else begin \n\t\t\t\tnext_state = 4'b0001; //Stay in A\n\t\t\t\tout = 0; //Output 0\n\t\t\tend\n\t\t4'b0010: //State B\n\t\t\tif (!in) begin\n\t\t\t\tnext_state = 4'b0100; //Go to C\n\t\t\t\tout = 0; //Output 0\n\t\t\tend else begin\n\t\t\t\tnext_state = 4'b0010; //Stay in B\n\t\t\t\tout = 0; //Output 0\n\t\t\tend\n\t\t4'b0100: //State C\n\t\t\tif (!in) begin \n\t\t\t\tnext_state = 4'b1000; //Go to D\n\t\t\t\tout = 0; //Output 0\n\t\t\tend else begin\n\t\t\t\tnext_state = 4'b0001; //Go to A\n\t\t\t\tout = 0; //Output 0\n\t\t\tend\n\t\t4'b1000: //State D\n\t\t\tif (!in) begin \n\t\t\t\tnext_state = 4'b0100; //Go to C\n\t\t\t\tout = 1; //Output 1\n\t\t\tend else begin \n\t\t\t\tnext_state = 4'b0010; //Go to B\n\t\t\t\tout = 0; //Output 0\n\t\t\tend\n\tendcase\nend\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\t// State transition logic\n\talways @(*) begin\n\tcase (state)\n\t\t4'b0001: \n\t\t\tif(!in) \n\t\t\t    next_state = 4'b0010; // B when in=0\n\t\t\telse \n\t\t\t   next_state = 4'b0001; // A when in=1\n\t    4'b0010: \n\t\t\tif(!in) \n\t\t\t    next_state = 4'b0010; // B when in=0\n\t\t\telse \n\t\t\t   next_state = 4'b0100; // C when in=1\n\t    4'b0100: \n\t\t\tif(!in) \n\t\t\t    next_state = 4'b0100; // C when in=0\n\t\t\telse \n\t\t\t   next_state = 4'b1000; // D when in=1\n\t    4'b1000: \n\t\t\tif(!in) \n\t\t\t    next_state = 4'b1000; // D when in=0\n\t\t\telse \n\t\t\t   next_state = 4'b0001; // A when in=1\n\t\tdefault: next_state = state; // Default case to hold current state\n\tendcase\n\tend\n\t// Output logic\n\tassign out = (state==4'b0100); \n"}
{"task_id": "fsm3onehot", "completion": "\n\tassign out = (state == 4'b1000) ? 1'b1 : 1'b0; // Output logic\n\t\t\n\talways @(*) begin\t// State transition logic\n\t\tcase(state) \n\t\t\t4'b0001 : next_state = in ? 4'b0010 : 4'b0001;\n\t\t\t4'b0010 : next_state = in ? 4'b0100 : 4'b0010;\n\t\t\t4'b0100 : next_state = in ? 4'b1000 : 4'b0001;\n\t\t\t4'b1000 : next_state = in ? 4'b0001 : 4'b0100;\t\t\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @(*) begin\n\tcase (state) \n\t\t4'b0001 : // State A\n\t\t\tif (!in) \n\t\t\t\t{next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'b0010; // Next state B\n\t\t\telse \n\t\t\t\t{next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'b0001; // Stay at A\n\t\t\tout <= 0; // Always have output zero in this case.\n\t\t\n\t\t4'b0010 : // State B\n\t\t\tif (!in) \n\t\t\t\t{next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'b0100; // Next state C\n\t\t\telse \n\t\t\t\t{next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'b0010; // Stay at B\n\t\t\tout <= 0;\n\t\t\t\t\n\t\t4'b0100 : // State C\n\t\t\tif (!in) \n\t\t\t\t{next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'b0001; // Next state A\n\t\t\telse \n\t\t\t\t{next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'b1000; // Next state D\n\t\t\tout <= 0;\n\t\t\t\t\n\t\t4'b1000 : // State D\n\t\t\tif (!in) \n\t\t\t\t{next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'b0100; // Next state C\n\t\t\telse \n\t\t\t\t{next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'b0011; // Next to B and C simultaneously\n\t\t\tout <= 1; // Only output one when in is 1 from state D.\n\t\t\n\t\tdefault: {next_state[3], next_state[2], next_state[1], next_state[0]} <= 4'bxxxx; // Error state.\n\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t4'b0001 : begin \n\t\t\t\tnext_state = in ? 4'b0010 : 4'b0001; // Transitions to B on input '1', stays at A otherwise.\n\t\t\t\tout = 1'b0; // Always output \u20180\u2019, as per the state table.\n\t\t\tend\n\t\t\t\n\t\t\t4'b0010 : begin \n\t\t\t\tnext_state = in ? 4'b0100 : 4'b0010; // Transitions to C on input '1', stays at B otherwise.\n\t\t\t\tout = 1'b0; // Always output \u20180\u2019, as per the state table.\n\t\t\tend\n\t\t\t\t\n\t\t\t4'b0100 : begin \n\t\t\t\tnext_state = in ? 4'b1000 : 4'b0001; // Transitions to D on input '1', transitions back to A otherwise.\n\t\t\t\tout = 1'b0; // Always output \u20180\u2019, as per the state table.\n\t\t\tend\n\t\t\t\t\n\t\t\t4'b1000 : begin \n\t\t\t\tnext_state = in ? 4'b0001 : 4'b0100; // Transitions back to A on input '1', transitions to C otherwise.\n\t\t\t\tout = 1'b1; // On transitioning from D, output changes state and is '1'.\n\t\t\tend\n\t\t\t\t\n\t\tdefault: begin \n\t\t\t\tnext_state = in ? 4'b0001 : 4'b0001; // If any other state occurs. Stay at A on input '1', stay at A otherwise.\n\t\t\t\tout = 1'b0; // Always output \u20180\u2019, as per the state table.\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t4'b0001 : if (!in) {next_state[3:2], next_state[0]} <= {1'b0, state[3]}; // A to B on in = 0\n\t\t\t\t\t\telse {next_state[3:1]} <= ~{1'b0, state[3:1]}; // A to C on in = 1 \n\t\t\t4'b0010 : if (!in) {next_state[3:2], next_state[0]} <= {state[3], 1'b0}; // B to C on in = 0\n\t\t\t\t\t\telse {next_state[3:1]} <= ~{state[3:1]}; // B to B on in = 1  \n\t\t\t4'b0100 : if (!in) {next_state[3:2], next_state[0]} <= {1'b0, state[3]}; // C to D on in = 0\n\t\t\t\t\t\telse {next_state[3:1]} <= ~{1'b0, state[3:1]}; // C to A on in = 1 \n\t\t\t4'b1000 : if (!in) {next_state[3:2], next_state[0]} <= {state[3], 1'b0}; // D to B on in = 0\n\t\t\t\t\t\telse {next_state[3:1]} <= ~{state[3:1]}; // D to C on in = 1   \t\t\n\t\tendcase  \n\t\tif(state == 4'b0001) out = 0;\n\t\telse if((state==4'b0010&&in==1)||(state==4'b0100)) out = 0;\n\t\telse if (state==4'b1000) out = 1;\n\t\telse  out = 'x; // If we are in state C & input is 0 or in state A & Input is 1, Output remains undefined.  \n\tend \nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\n// State transition logic equations by inspection assuming a one-hot encoding.\n\talways @* begin\n\t\tcase(state) \n\t\t\t4'b0001: if(!in) {next_state = 4'b0001; next_state[3:1] = state[2:0];} else {next_state = 4'b0010; next_state[3:1] = state[2:0];} \n\t\t\t4'b0010: if(!in) {next_state = 4'b0010; next_state[3:1] = state[2:0];} else {next_state = 4'b0100; next_state[3:1] = state[2:0];} \n\t\t\t4'b0100: if(!in) {next_state = 4'b0100; next_state[3:1] = state[2:0];} else {next_state = 4'b1000; next_state[3:1] = state[2:0];}\n\t\t\t4'b1000: if(!in) {next_state = 4'b1000; next_state[3:1] = state[2:0];} else {next_state = 4'b0001; next_state[3:1] = state[2:0];}\n\t\tendcase\n\tend\n// Output logic equations by inspection assuming a one-hot encoding.\n\tassign out = (state == 4'b0001) | (state == 4'b1000); \n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @* begin\n\tcase(state)\n\t\t4'b0001: // A\n\t\t\tif(!in) {next_state = 4'b0001; out=0;} \t// stays in A for in=0\n\t\t\telse {next_state = 4'b0010; out=0;}\t  \t// to B for in=1\n\t\t4'b0010: // B\n\t\t\tif(!in) {next_state = 4'b0010; out=0;} \t// stays in B for in=0\n\t\t\telse {next_state = 4'b0100; out=0;}\t  \t// to C for in=1\n\t\t4'b0100: // C\n\t\t\tif(!in) {next_state = 4'b0100; out=0;} \t// stays in C for in=0\n\t\t\telse {next_state = 4'b1000; out=0;}\t  \t// to D for in=1\n\t\t4'b1000: // D\n\t\t\tif(!in) {next_state = 4'b0001; out=1;} \t// back to A for in=0\n\t\t\telse {next_state = 4'b0100; out=0;}\t  \t// stays in C for in=1\n\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "fsm3onehot", "completion": "\n\talways @(*) begin\n\t\t\n\t\tcase(state) \n\t\t\t4'b0001 : //State A\n\t\t\t\tif (in==0) begin \n\t\t\t\t\tnext_state <= 4'b0001; \n\t\t\t\tend else if (in==1) begin \n\t\t\t\t\tnext_state <= 4'b0010; //To state B\n\t\t\t\tend\n\t\t\t4'b0010 : //State B\n\t\t\t\tif (in==0) begin \n\t\t\t\t\tnext_state <= 4'b0010; //Remain in State B\n\t\t\t\tend else if (in==1) begin  \n\t\t\t\t\tnext_state <= 4'b0100;//To state C\n\t\t\t\tend\n\t\t\t4'b0100 : //State C\n\t\t\t\tif (in==0) begin \n\t\t\t\t\tnext_state <= 4'b0001; //To state A\n\t\t\t\tend else if (in==1) begin  \n\t\t\t\t\tnext_state <= 4'b1000;//To state D\n\t\t\t\tend\n\t\t\t4'b1000 : //State D\n\t\t\t\tif (in==0) begin \n\t\t\t\t\tnext_state <= 4'b0100;//To State C\n\t\t\t\tend else if (in==1) begin  \n\t\t\t\t\tnext_state <= 4'b0010; //to State B\n\t\t\t\tend\n\t\t\tdefault : next_state <= state ; \n\t\tendcase\n\t\t\n\t\tcase(state) \n\t\t\t4'b0001: out <= 0;\n\t\t\t4'b0010: out <= 0;\n\t\t\t4'b0100: out <= 0;\n\t\t\t4'b1000: out <= 1; //Only in state D output is high\n\t\t\tdefault: out<= 0; \n\t\tendcase \n\tend\n\n"}
{"task_id": "fsm3onehot", "completion": "\n\n\t// State transition and output logic equations by inspection assuming a one-hot encoding.\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t4'b0001 : begin next_state = in ? 4'b0010 : 4'b0001; out = 0; end\n\t\t\t4'b0010 : begin next_state = in ? 4'b0001 : 4'b0010; out = 0; end\n\t\t\t4'b0100 : begin next_state = in ? 4'b1000 : 4'b0001; out = 0; end\n\t\t\t4'b1000 : begin next_state = in ? 4'b0100 : 4'b0010; out = 1; end\n\t\t\tdefault: begin next_state = 4'b0001; out = 0; end\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q4a", "completion": "\n    \n    always @(posedge ena) begin\n        if (ena == 1'b1) \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\nalways @(*) begin\n\tif (ena)\n\t\tq <= d;\nend\nendmodule\n"}
{"task_id": "m2014_q4a", "completion": "\n\talways @(*) begin\n\t\tif(ena) \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n\nalways @(*) begin\n\tif (ena) \n\t    q = d;\nend\n\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n\talways @(*) begin\n    \tif(ena) \n        \tq <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n\n\talways @(*) begin\n        if (ena) \n\t\t    q <= d;\n\tend\n  \nendmodule\n"}
{"task_id": "m2014_q4a", "completion": "\n\n\talways @(*) begin\n\tif (ena) \n\t    q = d;\n    end\nendmodule\n"}
{"task_id": "m2014_q4a", "completion": "\n\talways @(*) begin\n\t\tif (ena) \n\t\t    q <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n    always @(*) begin\n        if (ena) \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\nalways @(*) begin\n\tif (ena) \n\t\tq <= d;\nend\nendmodule\n"}
{"task_id": "m2014_q4a", "completion": "\n\talways @(*) begin\n\t\tif (ena)\n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n\n\talways @(*) begin\n\t\tif (ena)\n\t\t\tq <= d;\n\tend\n\t\nendmodule \n\n"}
{"task_id": "m2014_q4a", "completion": "\nalways @(*) begin\n\tif (ena) \n\t\tq <= d;\nend\n\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n\talways @(*) begin\n\t\tif (ena) \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n    always @(posedge ena) begin\n        if (ena == 1'b1)\n            q <= d;\n    end\nendmodule \n\n"}
{"task_id": "m2014_q4a", "completion": "\n\n\talways @(*) begin\n\tif (ena) \n\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n    always @(*) begin\n        if(ena) \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\n\talways @(*) begin\n\t\tif (ena) \n\t\t\tq = d;\n\tend\n\n"}
{"task_id": "m2014_q4a", "completion": "\n\n\talways @(*) begin\n\t\tif (ena) \n\t\t    q <= d;\n   end\nendmodule\n\n"}
{"task_id": "m2014_q4a", "completion": "\nalways @(*) begin \n    if (ena) \n        q <= d; \nend\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n    \n    reg [31:0] dff; // internal flip flops to capture the changes from previous state. \n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 0;  \n\t\t\tdff <= in; // Capture the current input value when resetting\n        end else begin\n            out <= dff & ~in; // Check for any changes from previous state and inverting the new value.\n\t\t\tdff <= in; // Update D flip flops with new inputs\n        end \n    end\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\nreg [31:0] last;\n  \nalways @(posedge clk or posedge reset) begin  // synchronous reset\n\tif (reset) begin\n\t\tlast <= 0;\n\tend else begin\n\t\tout <= in & ~last;\n\t\tlast <= in;\n\tend\nend\n   \nendmodule\n\n"}
{"task_id": "edgecapture", "completion": "\n\n\treg [31:0] q; // temporary storage for previous value of 'in'\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 32'h0;  // Asynchronous reset, all bits are zero.\n            out <= 32'h0;\n\tend else begin\n\t    q <= in;\n            for (integer i = 0; i < 31; i++) begin: DETECT_CHANGE\n                if ((q[i] == 1'b1) && (in[i] == 1'b0)) // If the bit was 1 and now is 0, set output to 1.\n\t\t    out[i] <= 1'b1;\n\t\telse\t// Else, reset the output to 0.\n\t\t    out[i] <= 1'b0;\n            end: DETECT_CHANGE\n\t    if (in == 32'hFFFF_FFFF) // Special case where all bits are flipping from 1 to 0 at the same time. Set 'out' also to all ones.\n\t\tout <= 32'hFFFF_FFFF;  \n        end\n    end\nendmodule\n\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] q;\n\talways @ (posedge clk or posedge reset) begin\n\t    if(reset) \n\t\t    q <= 32'h0; // Reset to zero on synchronous active high reset\n        else      \n            q <= in;     // Store the input signal on positive clock edge\n    end\n\talways @ (posedge clk or posedge reset) begin\n\t    if(reset) \n\t\t    out <= 32'h0; // Reset to zero on synchronous active high reset\n        else      \n            out <= q ^ in;   // Output is the stored signal xor with input. Captures when the input changes from 1 to 0 the next cycle.\n    end\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n  always @(posedge clk or posedge reset) begin\n    if (reset)\n      out <= 32'b0;\n    else\n      out <= in & ~out;\n  end\nendmodule\n\n"}
{"task_id": "edgecapture", "completion": "\n    \n    reg [31:0] previous;  // register to store the value of input at last clock cycle.\n    \n    always @(posedge clk or posedge reset) begin \n        if (reset) begin  \n            out <= 0;\n\t    previous <= in;       // reset 'previous' register with current input values\n\tend\n\telse begin\n\t    for (integer i=0; i<32; ++i) begin\n\t        if ((in[i] == 1) && (previous[i] == 0))  // capture edge case\n\t\t    out[i] <= 1;     // set output bit to 1 in the clock cycle that input changes from 0->1\n\t\telse\n\t\t    out[i] <= 0;     // keep output bits at 0 otherwise\n\t    end  \n            previous <= in;      // shift current values into 'previous' register for comparison on next rising edge of clock.\n        end\n    end \nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] registeredInput;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t  if (reset == 1'b1) begin\n\t\t  registeredInput <= 32'h0;\n\t    out <= 32'h0;\n\t  end else begin\n        registeredInput <= in;\n      \tout <= in & ~registeredInput;\n      end\n    end\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] in_q; // input signal delayed by one clock cycle\n   \n\t// Delayed input \n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t   in_q <= 0;\n        else \n           in_q <= in;\n\tend\n   \n\t// Output capture on rising edge of clock for bits where the input changes from 1 to 0\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t   out <= 0;\n        else \n           out <= (~in & in_q); // change from 1 to 0\n\tend\n   \nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] in_prev;  // register to store previous value of input vector.\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin\n            out <= 32'b0;   // async reset, clear all output bits when active high\n\t\t\tin_prev <= in;  // update prev register after reset\n        end else begin\n            out <= in & ~in_prev;  // detect transition from 1 to 0\n            in_prev <= in;       // update prev register after each clock edge\n        end\n    end\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] prev;\n\talways @ (posedge clk or posedge reset) begin\n\t    if(reset) begin\n\t        prev <= 32'b0;\n\t\t    out  <= 32'b0;\n        end\n        else begin\n            prev <= in;\n            out   <= in & ~prev;\n\t\tend \n\tend\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] q;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 0;\n\t\telse \n\t\t\tq <= in;\n\tend\n\tassign out = (in & ~q);\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n    always @ (posedge clk or posedge reset) begin\n        if (reset == 1'b1) \n            out <= 32'b0;\n        else \n            out <= in & ~out;\n    end\t\nendmodule\n\n"}
{"task_id": "edgecapture", "completion": "\nreg [31:0] old;\n    \nalways @ (posedge clk or posedge reset) begin\n\tif(reset) \n\t    old <= 32'b0;   // Asynchronous active high reset\n\telse \n\t    old <= in;    // Maintains the previous state\nend\nassign out = (~old & in);\n    \nalways @ (posedge clk or posedge reset) begin\n\tif(reset)\n\t    out <= 32'b0;   // Asynchronous active high reset\n\telse \n\t    out <= (~old & in);    // Maintains the previous state\nend\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] q; // internal register to store the input signal from last clock cycle\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin  // resetting the output and internal register\n            out <= 32'h0;\n\t\t\tq <= 32'h0;\n        end else begin  \n        \t// updating internal register with input signal\n            q <= in;  \n            \n            for (integer i=0; i<32; i++) begin // loop through each bit of the 32-bit vector\n                if ((q[i] == 1'b1) && (in[i] == 1'b0)) begin // checking if input signal changed from 1 to 0 in one clock cycle\n                    out[i] <= 1'b1;  // capturing the transition and setting output bit corresponding to that input bit to be high.\n                end else begin\n                    out[i] <= 1'b0;  // for other cases, keep output bit low.\n                end \n            end \n        end \n    end\nendmodule\n\n"}
{"task_id": "edgecapture", "completion": "\n    \n    reg [31:0] d;\n  \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            out <= 32'b0;\n        else        \n            out <= in & ~d;\n      \n        d <= in;\n    end\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] ff;  // internal flip flops to keep track of changes.\n\t\n\t// synchronous process block for DFFs and reset\n\talways @(posedge clk or posedge reset) begin\n\t  if (reset) begin   // reset condition, set output register and the flip-flop as well\n\t    ff <= 32'b0;\n\t    out <= 32'b0;\n\t  end \n\t  else begin         // clocked conditions\n\t     ff <= in;        // update flip flops with input\n\t     out <= (in & ~ff);  // set output to be the AND of the current and previous states of inputs. \n\t  end  \n\tend  \nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n\n\treg [31:0] last_in;  // internal register to hold last cycle's inputs\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin   // if reset is high, zero out both input and output registers\n\t\t\tout <= 32'h0;\n\t\t\tlast_in <= 32'h0;\n\t\tend else begin  // otherwise perform the operation on this cycle's inputs\n\t\t\tfor (integer i = 0; i < 32; i++) begin\n\t\t\t\tif ((in[i] == 1'b1) && (last_in[i] == 1'b0)) begin   // if this bit changed from 0 to 1, set the corresponding output bit to 1\n\t\t\t\t\tout[i] <= 1'b1;\n\t\t\t\tend else begin   // otherwise keep the corresponding output bit at its previous state (or zero for first cycle)\n\t\t\t\t\tout[i] <= out[i];\n\t\t\t\tend\n\t\t\tend\n\t\t\t// remember these inputs for next cycle\n\t\t\tlast_in <= in;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "edgecapture", "completion": "\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            out <= 32'b0;\n        else  \n            out <= in & ~out;\n    end\nendmodule\n\n"}
{"task_id": "edgecapture", "completion": "\n\treg [31:0] in_d; // Input flopped register.\n \n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\t// Reset all outputs to 0 when the reset is active.\n\t\t\tout <= 32'b0;\n\t\tend\n\t\telse begin\n\t\t\tin_d <= in; // Flop input signal.\n\t\t\t\n\t\t\tfor (integer i = 0 ; i < 32 ; i++) begin\n\t\t\t\t// Detect an edge from 1 to 0 on the current bit, set out[i] accordingly.\n\t\t\t\tif ((~in_d[i]) & in[i]) \n\t\t\t\t\tout[i] <= 1'b1;\n\t\t\tend\n\t\tend\n\tend\n\n"}
{"task_id": "edgecapture", "completion": "\n\t// Create 2-bit flip flops to capture the changes\n\treg [1:0] ff_in;\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tff_in <= 2'b00;\n\t\telse if (clk == 1'b1 && in[i] == 1'b1) // Capture when going from 1->0\n\t\t\tff_in <= {in[i], ff_in[0]};\n\tend\n\t// Assign the outputs with the flipped bits\n\tassign out = ~{2{ff_in}};\n\n"}
{"task_id": "always_nolatches", "completion": "\n\talways @* begin \n\t    left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n        \n        case(scancode)\n            16'he06b : left = 1; //left arrow scancode\n            16'he072 : down = 1; //down arrow scancode\n            16'he074 : right = 1; //right arrow scancode\n            16'he075 : up = 1;   //up arrow scancode\n        endcase \n\tend\nendmodule \n"}
{"task_id": "always_nolatches", "completion": "\n\talways @(*) begin\n\t\tcase (scancode) \n\t\t\t16'he06b : {left,down,right,up} = 4'b0100; // left arrow key pressed\n\t\t\t16'he072 : {left,down,right,up} = 4'b0010; // down arrow key pressed\n\t\t\t16'he074 : {left,down,right,up} = 4'b0001; // right arrow key pressed\n\t\t\t16'he075 : {left,down,right,up} = 4'b1000; // up arrow key pressed\n\t\t\tdefault:   {left,down,right,up} = 4'b0000; // no arrows keys are pressed\n\t\tendcase\n\tend \nendmodule \n"}
{"task_id": "always_nolatches", "completion": "\n\n\talways @(*) begin \n\t\tcase({scancode[15:0]})\n\t\t\t16'he06b : {left,down,right,up} = 4'b0100; // left arrow key pressed\n\t\t\t16'he072 : {left,down,right,up} = 4'b0010; // down arrow key pressed\n\t\t\t16'he074 : {left,down,right,up} = 4'b0001; // right arrow key pressed\n\t\t\t16'he075 : {left,down,right,up} = 4'b1000; // up arrow key pressed\n\t\t\tdefault: {left,down,right,up} = 4'b0000;    // no arrow keys are pressed\n\t\tendcase \n\tend\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\nalways @(*) begin\n\tcase(scancode)\n\t\t16'he06b:  {left, down, right, up} = 4'b0100; // left arrow\n        16'he072:  {left, down, right, up} = 4'b0010; // down arrow\n        16'he074:  {left, down, right, up} = 4'b0001; // right arrow\n\t\t16'he075:  {left, down, right, up} = 4'b1000; // up arrow\n\t\tdefault :   {left, down, right, up} = 4'b0000; // none\n    endcase\nend\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n\n\talways @(*) begin\n\t\tcase (scancode)\n\t\t\t16'he06b: begin // Left arrow key\n\t\t\t    left <= 1;\n\t\t\t    down <= 0;\n\t\t\t    right <= 0;\n\t\t\t    up <= 0;\n\t\t\tend\n\t\t\t\n\t\t\t16'he072: begin // Down arrow key\n\t\t\t    left <= 0;\n\t\t\t    down <= 1;\n\t\t\t    right <= 0;\n\t\t\t    up <= 0;\n\t\t\tend\n\t\t\t\n\t\t\t16'he074: begin // Right arrow key\n\t\t\t    left <= 0;\n\t\t\t    down <= 0;\n\t\t\t    right <= 1;\n\t\t\t    up <= 0;\n\t\t\tend\n\t\t\t\n\t\t\t16'he075: begin // Up arrow key\n\t\t\t    left <= 0;\n\t\t\t    down <= 0;\n\t\t\t    right <= 0;\n\t\t\t    up <= 1;\n\t\t\tend\n\n\t\t\tdefault: begin  // None of the specified keys are pressed, deassert all outputs\n\t\t\t    left <= 0;\n\t\t\t    down <= 0;\n\t\t\t    right <= 0;\n\t\t\t    up <= 0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\nalways @(*) begin\n\tcase (scancode) \n\t\t16'he06b : {left ,down ,right,up} = 4'b0100; // left arrow pressed\n\t\t16'he072 : {left ,down ,right,up} = 4'b0010; // down arrow pressed\n\t\t16'he074 : {left ,down ,right,up} = 4'b0001; // right arrow pressed\n\t\t16'he075 : {left ,down ,right,up} = 4'b1000; // up arrow pressed\n\t\tdefault  : {left ,down ,right,up} = 4'b0000; // no arrows pressed or other scancode\n\tendcase\nend\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n\n\talways @(*) begin\n\t\t\tcase (scancode) \n\t\t\t\t16'he06b: begin //left arrow\n\t\t\t\t\t\tleft = 1;\n\t\t\t\t\t\tdown = 0;\n\t\t\t\t\t\tright = 0;\n\t\t\t\t\t\tup = 0;\n\t\t\t\tend\n\t\t\t\t16'he072: begin // down arrow\n\t\t\t\t\t\tleft = 0;\n\t\t\t\t\t\tdown = 1;\n\t\t\t\t\t\tright = 0;\n\t\t\t\t\t\tup = 0;\n\t\t\t\tend\n\t\t\t\t16'he074: begin // right arrow\n\t\t\t\t\t\tleft = 0;\n\t\t\t\t\t\tdown = 0;\n\t\t\t\t\t\tright = 1;\n\t\t\t\t\t\tup = 0;\n\t\t\t\tend\n\t\t\t\t16'he075: begin // up arrow\n\t\t\t\t\t\tleft = 0;\n\t\t\t\t\t\tdown = 0;\n\t\t\t\t\t\tright = 0;\n\t\t\t\t\t\tup = 1;\n\t\t\t\tend\n\t\t\t\tdefault: begin // none of the four arrows are pressed\n\t\t\t\t\t\tleft = 0;\n\t\t\t\t\t\tdown = 0;\n\t\t\t\t\t\tright = 0;\n\t\t\t\t\t\tup = 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n\n    always @(scancode) begin\n        case (scancode) \n            16'he06b : {left,down,right,up} <= 4'b1000; // Left arrow key pressed\n            16'he072 : {left,down,right,up} <= 4'b0100; // Down arrow key pressed\n            16'he074 : {left,down,right,up} <= 4'b0010; // Right arrow key pressed\n            16'he075 : {left,down,right,up} <= 4'b0001; // Up arrow key pressed\n            default  : {left,down,right,up} <= 4'b0000; // None pressed\n        endcase\n    end\n    \nendmodule\n\n"}
{"task_id": "always_nolatches", "completion": "\nalways @* begin\n\tcase(scancode) \n\t\t16'he06b : begin // Left Arrow\n\t\t\tleft = 1;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\t\t\t\n\t\t16'he072 : begin // Down Arrow\n\t\t\tleft = 0;\n\t\t\tdown = 1;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\t\t\t\t\t \n\t\t16'he074 : begin // Right Arrow\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 1;\n\t\t\tup = 0;\n\t\tend\n\t\t\t  \t \n\t\t16'he075 : begin // Up Arrow\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 1;\n\t\tend\n\t\t\t \n\t\tdefault : begin // No arrow key is pressed, deassert all the outputs\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\tendcase\nend\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n\talways @* begin\n\t\t\n\t\tcase(scancode)\n\t\t\t16'he06b : \n\t\t\t\tbegin\n\t\t\t\t\tleft = 1;\n\t\t\t\t\tdown = down;\n\t\t\t\t\tright = right;\n\t\t\t\t\tup = up;\n\t\t\t\tend\n\t\t\t16'he072 : \n\t\t\t\tbegin\n\t\t\t\t\tleft = left;\n\t\t\t\t\tdown = 1;\n\t\t\t\t\tright = right;\n\t\t\t\t\tup = up;\n\t\t\t\tend\n\t\t\t16'he074 : \n\t\t\t\tbegin\n\t\t\t\t\tleft = left;\n\t\t\t\t\tdown = down;\n\t\t\t\t\tright = 1;\n\t\t\t\t\tup = up;\n\t\t\t\tend\n\t\t\t16'he075 : \n\t\t\t\tbegin\n\t\t\t\t\tleft = left;\n\t\t\t\t\tdown = down;\n\t\t\t\t\tright = right;\n\t\t\t\t\tup = 1;\n\t\t\t\tend\n\t\t\tdefault:  \n\t\t\t\tbegin\n\t\t\t\t\tleft = 0;\n\t\t\t\t\tdown = 0;\n\t\t\t\t\tright = 0;\n\t\t\t\t\tup = 0;\n\t\t\t\tend\n\t\tendcase \n\tend\nendmodule\n\n"}
{"task_id": "always_nolatches", "completion": "\n\n\talways @* begin\n    \t// Default values for the outputs\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n        \n        case (scancode)\n            16'he06b: left = 1; // Left arrow key scancode\n            16'he072: down = 1; // Down arrow key scancode\n            16'he074: right = 1; // Right arrow key scancode\n            16'he075: up = 1; // Up arrow key scancode\n            default: ; // Default, do nothing for any other scancodes\n        endcase \n    end\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n    always @(*) begin  // combinational logic\n        case(scancode)\n            16'he06b : begin  // Left arrow key\n                left = 1;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n            16'he072: begin  // Down arrow key\n                left = 0;\n                down = 1;\n                right = 0;\n                up = 0;\n            end\n            16'he074 : begin  // Right arrow key\n                left = 0;\n                down = 0;\n                right = 1;\n                up = 0;\n            end\n            16'he075 : begin  // Up arrow key\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 1;\n            end\n            default: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n        endcase  // case (scancode)\n    end  // always @ (*)\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\ninteger lc, dc, rc, uc;\n\talways @(*) begin\n\t\tleft = 0;\n\t\tdown = 0;\n\t\tright = 0;\n\t\tup = 0;\n\t\t\n\t\tif (scancode == 16'he06b)  // Left arrow\n\t\t\tleft = 1;\n\t\telse if (scancode == 16'he072)  // Down arrow\n\t\t\tdown = 1;\n\t\telse if (scancode == 16'he074)  // Right arrow\n\t\t\tright = 1;\n\t\telse if (scancode == 16'he075)  // Up arrow\n\t\t\tup = 1;\n\t\t\t\n\tend\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n\n\talways @(*) begin\n\t\tcase(scancode)\n\t\t\t16'he06b : {left, down, right, up} = 4'b1000; // left arrow\n\t\t\t16'he072 : {left, down, right, up} = 4'b0100; // down arrow\n\t\t\t16'he074 : {left, down, right, up} = 4'b0010; // right arrow\n\t\t\t16'he075 : {left, down, right, up} = 4'b0001; // up arrow\n\t\t\tdefault:   {left, down, right, up} = 4'b0000;  // none (reset all outputs)\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n\talways @(*) begin\n\t\tcasex({scancode[15:0]}) \n\t\t\t16'he074: begin //right arrow\n\t\t\t\t\tleft = 0;\n\t\t\t\t\tdown = 0;\n\t\t\t\t\tright = 1;\n\t\t\t\t\tup = 0;\n\t\t\tend\n\t\t\t16'he06b: begin //left arrow\n\t\t\t\t\tleft = 1;\n\t\t\t\t\tdown = 0;\n\t\t\t\t\tright = 0;\n\t\t\t\t\tup = 0;\n\t\t\tend\n\t\t\t16'he072: begin // down arrow\n\t\t\t\t\tleft = 0;\n\t\t\t\t\tdown = 1;\n\t\t\t\t\tright = 0;\n\t\t\t\t\tup = 0;\n\t\t\tend\n\t\t\t16'he075: begin // up arrow\n\t\t\t\t\tleft = 0;\n\t\t\t\t\tdown = 0;\n\t\t\t\t\tright = 0;\n\t\t\t\t\tup = 1;\n\t\t\tend\n\t\t\tdefault: begin \n\t\t\t\t\tleft = 0;\n\t\t\t\t\tdown = 0;\n\t\t\t\t\tright = 0;\n\t\t\t\t\tup = 0;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n  always @(scancode) begin\n    case ({scancode[15:0]})\n      16'he06b : {left,down,right,up} <= 4'b1000; // Left arrow key pressed.\n      16'he072 : {left,down,right,up} <= 4'b0100; // Down arrow key pressed.\n      16'he074 : {left,down,right,up} <= 4'b0010; // Right arrow key pressed.\n      16'he075 : {left,down,right,up} <= 4'b0001; // Up arrow key pressed.\n      default  : {left,down,right,up} <= 4'b0000; // No keys pressed.\n    endcase\nend\n\t\nendmodule\n\n"}
{"task_id": "always_nolatches", "completion": "\n    \n    always @* begin\n        if(scancode === 16'he06b) //left arrow key\n            {left, down, right, up} = 4'b0100; \n        else if (scancode === 16'he072) //down arrow key\n            {left, down, right, up} = 4'b0010; \n        else if (scancode === 16'he074) //right arrow key\n            {left, down, right, up} = 4'b0001;\n        else if(scancode === 16'he075) //up arrow key\n            {left, down, right, up} = 4'b1000; \n        else //other keys are not pressed\n            {left, down, right, up} = 4'b0000;   \n    end    \nendmodule\n"}
{"task_id": "always_nolatches", "completion": "\n    always @(*) begin\n        case({scancode[7:0], scancode[15:8]})\n            16'he06b : {left, down, right, up} = 4'b0100;  // left arrow key pressed\n            16'he072 : {left, down, right, up} = 4'b0010;  // down arrow key pressed\n            16'he074 : {left, down, right, up} = 4'b0001;  // right arrow key pressed\n            16'he075 : {left, down, right, up} = 4'b1000;  // up arrow key pressed\n            default  : {left, down, right, up} = 4'b0000;  // no arrow keys pressed\n        endcase\n    end  \t\nendmodule\n\n"}
{"task_id": "always_nolatches", "completion": "\n\n\t// Declaring all outputs as 0 initially. This is a good practice to avoid latches in the circuit.\n\tinitial begin\n\t\tleft = 1'b0;\n\t\tdown = 1'b0;\n\t\tright = 1'b0;\n\t\tup = 1'b0;\n\tend\n\n\t// Case statement which assigns outputs depending on scancode\n\talways @(*) begin\n\t\t\tcase (scancode) \n\t\t\t\t16'he06b : left = 1'b1; // Left Arrow\n\t\t\t\t16'he072 : down = 1'b1; // Down Arrow\n\t\t\t\t16'he074 : right = 1'b1; // Right Arrow\n\t\t\t\t16'he075 : up = 1'b1; // Up Arrow\n\t\t\t\tdefault  : begin left=1'b0; down=1'b0; right=1'b0; up=1'b0; end // No key pressed or other scancode\n\t\t\tendcase\n\tend\n  \n"}
{"task_id": "always_nolatches", "completion": "\n\talways @* begin\n\t\tcase(scancode)\n\t\t\t16'he06b:  begin left = 1; down = 0; right = 0; up = 0; end //left arrow key\n\t\t\t16'he072:  begin left = 0; down = 1; right = 0; up = 0; end //down arrow key\n\t\t\t16'he074:  begin left = 0; down = 0; right = 1; up = 0; end //right arrow key\n\t\t\t16'he075:  begin left = 0; down = 0; right = 0; up = 1; end //up arrow key\n\t\t\tdefault :   begin left = 0; down = 0; right = 0; up = 0; end //none or other keys\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n    assign out = in;\nendmodule \n\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;  // The output is assigned to the same value of the input signal combinatively\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n\n\t// Combinationally assigning inputs to outputs\n\tassign out = in;\n\t\nendmodule \n\n"}
{"task_id": "m2014_q4h", "completion": "\n\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n    \n    assign out = in; \n\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\nassign out = in;\nendmodule\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "m2014_q4h", "completion": "\nassign out = in;\nendmodule \n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule \n\n"}
{"task_id": "m2014_q4h", "completion": "\n\n\tassign out = in;\n\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in; \nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\nassign out = in;\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\nassign out = in;\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule\n\n"}
{"task_id": "m2014_q4h", "completion": "\n\tassign out = in;\nendmodule \n\n"}
{"task_id": "popcount3", "completion": "\n\tassign out[0] = |in; // OR operation indicates if any bit is 1.\n\tassign out[1] = &~{3'b0, in}; // AND NOT operation indicates if all bits are 0. The extra {3'b0} is to make sure there's at least one '0'. Otherwise, for the case of 3'b000, it would return 2'b1, which doesn't indicate a population count of 0.\n\t\nendmodule\n"}
{"task_id": "popcount3", "completion": "\n\tassign out = sum; // output is the total number of 1's in the input vector\n\twire [1:0] sum;   // temporary variable to hold the sum of bits\n\n\t// Using a case statement to calculate population count (sum)\n\tcasex(in)\n\t\t3'b000: sum = 2'h0;\n\t\t3'b001: sum = 2'h1;\n\t\t3'b010: sum = 2'h1;\n\t\t3'b011: sum = 2'h2;\n\t\t3'b100: sum = 2'h1;\n\t\tdefault: sum = 2'hX;  // If not in above case statements, it is an 'x'.\n\tendcase\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n\tassign out[0] = |in; // checks if any bit is 1\n\tassign out[1] = &~in; // checks if all bits are 0 (equivalent to negation of population count)\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n    assign out[0] = |in; // If any bit is 1, out[0] = 1.\n\tassign out[1] = &in; // If all bits are 1, out[1] = 1.\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n\tassign out[0] = |in; // OR operation\n\t// Counting '1's using sum of products\n    assign out[1] = ~(~in[2]&~in[1]&~in[0]) & ~(~in[2]& in[1]& in[0]) \n                    & ~( in[2]&~in[1]& in[0]) &  ~(in[2]& in[1]&~in[0]);\nendmodule\n"}
{"task_id": "popcount3", "completion": "\n\tassign out = {~in[0] & ~in[1] & ~in[2], ~in[0] & in[1] & ~in[2] | in[0] & ~in[1] & in[2] | in[0] & in[1] & ~in[2] | in[0] & in[1] & in[2];\nendmodule \n"}
{"task_id": "popcount3", "completion": "\n\n\tassign out = {~in[0] & ~in[1] & in[2], \n\t\t      ~in[0] & in[1] & ~in[2], \n\t\t      ~in[0] & in[1] & in[2], \n\t\t      in[0] & ~in[1] & ~in[2], \n\t\t      in[0] & ~in[1] & in[2], \n\t\t      in[0] & in[1] & ~in[2], \n\t\t      in[0] & in[1] & in[2]};\n\t      \nendmodule\n"}
{"task_id": "popcount3", "completion": "\n\n\t// There are two ways to implement the population count: using conditional statements or lookup table. Here we use a more readable method that uses 4 basic arithmetic operations (+,-,* and <<) instead of any kind of looping/conditional logic.\n\tassign out = in[0] + (in[1] << 1) + (in[2] << 2); \n\t// The above statement basically does: in[0] + 2 * in[1] + 4 * in[2], which counts the number of set bits in 'in'.\n\t\nendmodule\n"}
{"task_id": "popcount3", "completion": "\n\tassign out = {~in[0] & ~in[1] & ~in[2], \n\t\t     ~in[0] & ~in[1] & in[2],\n                     ~in[0] & in[1] & ~in[2],  \n                  \t   ~in[0] & in[1] & in[2], \n                       in[0] & ~in[1] & ~in[2], \n\t\t      in[0] & ~in[1] & in[2], \n                      in[0] & in[1] & ~in[2],  \n                  \t   in[0] & in[1] & in[2]};\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n\tassign out = sum(in[2]) + sum(in[1]) + sum(in[0]);\n\t\n\tfunction reg [1:0] sum;\n\t\tinput bit inp;\n\t\t begin \n\t\t\tsum =  {~inp, inp}; //converts binary number to decimal (1 for 1's and 0 for 0's)\n\t\t end\n\tendfunction\n\n"}
{"task_id": "popcount3", "completion": "\n\tassign out = {~in[0] & ~in[1] & ~in[2], ~in[0] & ~in[1] & in[2] | ~in[0] & in[1] & ~in[2] | in[0] & ~in[1] & ~in[2] | \n\t            ~in[0] & in[1] & in[2] | in[0] & ~in[1] & in[2] | in[0] & in[1] & ~in[2] | in[0] & in[1] & in[2]};\nendmodule \n"}
{"task_id": "popcount3", "completion": "\n\tassign out = {~in[0]&~in[1]&~in[2], ~in[0]&~in[1]&in[2] , in[0]&~in[1]&~in[2], in[0]&in[1]&~in[2] , in[0]&in[1]&in[2]};\n\t\nendmodule\n"}
{"task_id": "popcount3", "completion": "\n\t// using a truth table to map binary to bcd conversion for a 3-bit binary number.\n\tassign out = in[2] ? in[1] & ~in[0] : in[1]; // if MSB is set, count should be between 1 and 2\n\t                   in[1] &  in[0];// if MSB is not set but the second bit is, then count will be either 0 or 3 based on LSB\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n    assign out[0] = |in; // OR gate\n\tassign out[1] = &{in}; // AND gate, equivalent to NAND (not and) \n\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n    assign out = {~in[2], ~(in[1]) & in[0]} + {~in[1], ~in[0]};\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n    assign out = {~in[2], ~(in[1]) & in[0]} + {~in[1], ~~(in[0])};\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n\n\tassign out = {~in[2], ~(in[1]^in[0])};\n\t\nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n\nassign out[0] = |in; // OR gate to count the number of '1's \nassign out[1] = ~|~&in; // Using DeMorgan\u2019s Theorem to calculate population count, this line counts number of zeros. \n\t\t\t\t\t\t// For a given bit in vector \"out\" is set to one if all bits from \"in\" are zero else it's set to zero. \n\t\t\t\t\t  \nendmodule\n\n"}
{"task_id": "popcount3", "completion": "\n\tassign out = {~in[2], ~(in[1] | in[0])};  // Count number of '1's. Population count is equivalent to summing all bits and subtracting the total from 3 (size of input). For a 3-bit input, it would be: out = 3 - (in[2] + in[1] + in[0]);\nendmodule\n"}
{"task_id": "popcount3", "completion": "\n\t// Bitwise XOR operator is used to get the parity of 3-bit input\n\tassign out = {~^in, ^in};\nendmodule\n\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};  // or use the reverse function for more readability and brevity, like this: assign out = in.reverse();\nendmodule\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule \n\nor you can do it this way, using for loop and array slicing:\n\nmodule top_module (\n\tinput [7:0] in,\n\toutput reg [7:0] out\n);\n\tgenvar i;\n\tgenerate\n\tfor(i=7; i>=0; i--) begin : reverse\n\t    assign out[i] = in[7-i];\n\tend\n\tendgenerate\nendmodule \n"}
{"task_id": "vectorr", "completion": "\n\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\t\nendmodule \n"}
{"task_id": "vectorr", "completion": "\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule \n"}
{"task_id": "vectorr", "completion": "\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};  // or you can use the reverse function to generate it.\nendmodule\n\nOR \n\nmodule top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n"}
{"task_id": "vectorr", "completion": "\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n"}
{"task_id": "vectorr", "completion": "\n\t// Reverse bit order using concatenation and slicing\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\n// OR \n\nmodule top_module (\n\tinput [7:0] in,\n\toutput reg [7:0] out);\n\t\n\t// Reverse bit order using loop\n\tgenvar i;\n\tgenerate\n\tfor(i = 0; i < 8; i++) begin : reverse\n\t   assign out[i] = in[7-i]; \n        end\n    endgenerate \nendmodule\n"}
{"task_id": "vectorr", "completion": "\n\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule \n// Or simply use the built-in function reverse. \n\t// assign out = in.reverse();\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule \n"}
{"task_id": "vectorr", "completion": "\n\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n"}
{"task_id": "vectorr", "completion": "\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\n// OR You can also use bit reversing method which is more universal and works for any size of input.\nassign out = in[7:0];  //Reverses the bits as you would expect, but only if the input is a single byte (8-bit).\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\n"}
{"task_id": "vectorr", "completion": "\n\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\t\nendmodule \n\nor simply by using bit reversal operation\n\nmodule top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\nassign out = {<<{in}}; // This is a built-in Verilog construct that shifts all bits of 'in' 1 position to the right. It repeats this operation for all positions, effectively reversing the bit order.\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\n"}
{"task_id": "vectorr", "completion": "\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\n"}
{"task_id": "vectorr", "completion": "\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\t\tif (reset == 1'b1)\n\t\t\t\tq <= 8'd0;  // Reset all D flip flops to zero on rising edge of reset\n\t\t\telse\n\t\t\t\tq <= d;      // Else store the data 'd' in flipflop on positive edge of clock cycle.\n\tend\nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\talways @(posedge clk or posedge reset) begin\n  \tif (reset) \n    \tq <= 8'b0;\n   \telse \n    \tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset) \n        \tq <= 8'b0;\n    \telse\n        \tq <= d;\n    end\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n    \n\talways @(posedge clk or posedge reset) begin  // asynchronous reset\n  \t\tif (reset == 1'b1)\n    \t\t\tq <= 8'd0;\n  \t\telse\n   \t \t\tq <= d;\n\tend\n\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n\tfor (genvar i=0; i<8; i++) begin : gen_loop\n\talways @(posedge clk or posedge reset) begin\n\t\t\tif (reset) \n\t\t\t\tq[i] <= 1'b0;\n\t\t\telse \n\t\t\t\tq[i] <= d[i];\n\tend\nend:gen_loop\n\nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n    \tif (reset) \n        \tq <= 8'b0;\n    \telse \n        \tq <= d;\n\tend\n\t\t  \nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1)\n\t\t\tq <= 8'h0;\n\t\telse \n\t\t\tq <= d;\n\tend\n\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n\tfor (genvar i = 0; i < 8; i++) begin : flipflops \n  \t\t\n    \talways @(posedge clk or posedge reset) begin\n      \t\tif(reset == 1'b1) // active high reset\n        \t\tq[i] <= 1'b0;\n      \t\telse\n       \t \t\tq[i] <= d[i]; \t\t  \n    \tend\t\t\t     \t\t\t\t\t\n\tend\nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\talways @ (posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tq <= 8'b0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n    if (reset) \n       q <= 8'b0;\n   else\n       q <= d;\nend\nendmodule\n"}
{"task_id": "dff8r", "completion": "\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tq <= 8'b0;\n\telse \n\t\tq <= d;\nend\n\nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\tfor (genvar i = 0; i < 8; i++) begin : eachDff \n\t\t always @(posedge clk or posedge reset) begin : eachAlways \n\t\t\t if (reset)  \n\t\t\t\t  q[i] <= 1'b0; \n\t\t\t else  \n\t\t\t\t  q[i] <= d[i]; \n\t\t end\t  \n\tend \nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1)\n\t\t  q <= 8'h0;\n\telse\n\t  q <= d;\n\tend\n\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\nalways @ (posedge clk or posedge reset) begin\n\tif (reset == 1'b1) \n\t\tq <= 8'd0;\n\telse \n\t\tq <= d;\nend\nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1)  // active high synchronous reset\n            q <= 8'd0;\n        else\n            q <= d;\n\tend\nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)  // Asynchronous active high reset.\n\t\t    q <= 8'h0;\n\t    else  \n            q <= d;\t// Synchronous write.\n\tend\n\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n    always @ (posedge clk or posedge reset) begin  //synchronous reset \n      if(reset)  \n        q <= 8'b0;     //resets to all zeroes on the rising edge of clock\n      else\n      \tq <= d;          //regular flip flop behavior\n    end  \nendmodule\n"}
{"task_id": "dff8r", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 8'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n\n"}
{"task_id": "dff8r", "completion": "\n\talways @(posedge clk or posedge reset) begin \n\t    if (reset) \n\t       q <= 8'b0; // Resets the value to zero\n         else  \n            q <= d;    // Loads data on rising edge of clock\n      end\nendmodule \n"}
{"task_id": "dff8r", "completion": "\n\t\n\t// 8 D flip flops with synchronous reset.\n\tfor (genvar i = 0; i < 8; i++) begin : each_dff\n\talways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1)\n\tq[i] <= 1'b0;  // Reset condition, active high.\n\telse\n\tq[i] <= d[i];   // D flip flop, normal operation.\n\tend\n\tend : each_dff\n\n"}
{"task_id": "2013_q2bfsm", "completion": "\n    reg [1:0] state;\n    reg [2:0] cnt;\n    \n    assign f = (state == 2'b01); //f is 1 when in state A and B.\n  \t\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state <= 2'b00;\n            cnt <= 3'b000;\n\t\t      g <= 1'b0; //g is 0 at reset.\n        end else begin\n\t       case(state)\n            2'b00: begin\n                if (!f && x) begin  //if f=0 and x=1, go to state A.\n                    state <= 2'b01;\n\t\t\t\t         cnt <= 3'b000;\n                end else begin\n\t\t              g <= 1'b0;\t//else remain in state B.\n                end\t  \t\t\t \t   \t \n            end\n            2'b01: if (cnt == 3'b011) begin //if x=1 for 3 consecutive clock cycles, go to state C and reset counter cnt.\n\t\t         state <= 2'b10;\n                 cnt <= 3'b000;\n\t             end else begin\t//else increase the count.\n\t\t\t       cnt <= cnt + 1;\n                     g <= 1'b0; //and remain in state A.\n\t            end \t   \t \n\t         2'b10: if (cnt < 3 && y) begin   //if y=1 for at most two clock cycles, maintain g=1.\n\t\t             cnt <= cnt + 1;\n                 g <= 1'b1;\t//and remain in state C.\n               end else if(y) begin //if x=0 and y=1, set counter to 1 and go back to state B.\n\t\t\t       cnt <= 3'b001;  \n\t\t         state <= 2'b00;\t\n                g<= 1'b1;//and maintain g = 1.\n               end else begin\t//else reset the count and go back to state A.\n                 cnt <= 3'b000; \n\t\t           state <= 2'b00;\t \n                     g <= 1'b0; //and set g=0.\n                end   \t  \t\t\t \t   \n            default: begin \n                  state <= 2'b00;\n\t              cnt<= 3'b000; \n\t\t           g <= 1'b0;\t\n             end\n        endcase\n     end\nendmodule\n\n"}
{"task_id": "2013_q2bfsm", "completion": "\n    reg [1:0] count;\n    reg [2:0] state = 2'b00; \n    \n    assign f = (state == 2'b01) ? 1 : 0; // if state is 01, f=1 else f=0\n    \n\talways @(posedge clk or negedge resetn) begin\n\t    if (!resetn) begin // synchronous reset\n\t        state <= 2'b00; // back to state A when reset\n            count <= 2'b00; \n        end else case (state)\n            2'b00: begin   // state A, f=1 for one clock cycle\n                if (!x & !y) g <= 0;\n                state <= 2'b01; // proceed to next state B\n            end\n\t        2'b01: begin   // state B, wait x 1, 0, 1 in three consecutive clock cycles\n\t\t        count <= {x,count[1]};\n\t\t        if (&count) begin // when count becomes \"000\", set g=1 and remain in this state\n                    g <= 1; \n                end else if (!resetn) begin// reset, back to A \n                    state <= 2'b00;\n                    count <= 2'b00;  \n\t\t        end\n\t        end\n            2'b10: begin   //state C, wait y 1 within at most two clock cycles\n                g <= y;          // set g to the value of y and remain in this state\n            end\n\t        2'b11: if (!resetn) state <= 2'b00; // back to A when reset\n\t    endcase\n    end\nendmodule\n\n"}
{"task_id": "2013_q2bfsm", "completion": "\n    reg [1:0] counter;\n    reg prev_x;\n    assign f = (~resetn) | ((counter == 3'b010) & (prev_x == x));\n    \n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin \n            g <= 1'b0;\n\t    counter <= 2'b00;\n\t    prev_x <= 'd0;\n\tend else begin\n          if (counter == 3'b010 & x == 1 )\n\t      counter <= counter + 1'b1;\n\t  else \n              if (x != prev_x)  \n\t\t  counter <= 2'b00;\n              else\n                  if(y == 1 & counter < 2'b10)\n\t\t      g <= 1'b1;\n                     \n          if ((counter < 3'b010) | (prev_x != x))\n\t      f <= 1'b1;\n\t  else \n              f <= 1'b0;  \n\tend\n    end\n\n"}
{"task_id": "2013_q2bfsm", "completion": "\nreg [1:0] counter = 2'b0; // Two bit counter\ntypedef enum {A, B} state_type;\nstate_type state = A; \n\nalways @(posedge clk or negedge resetn) begin\n\tif (!resetn) begin\n\t\tcounter <= 2'b0;\n        state <= A;\n    end else begin\n    \tcase (state) \n        \tA: begin\n            \tf = 1; // Set f on the next clock cycle and go to B\n                counter <= 2'b0;\n                if (!resetn) state <= A;\n                else state <= B;\n            end\n\t\t    B: begin \n\t\t\t\tif(x && (counter==1)) \n\t\t\t\t\tbegin\n\t\t\t\t\t g = 1; // Set g on the next clock cycle and increment counter when x is high\n                    counter <= counter + 2'b1;\n                end else if (!x) begin\n                    counter <= 2'b0;\n            \tend\n                 if (counter >= 3) state <= A; \n            end\n        \tdefault: ; // Do nothing\n       \tendcase\n    end\nend\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\n    reg [1:0] state;\n   //define the states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n  assign f = (state == B);\n    \n\talways @(posedge clk or negedge resetn) begin\n        if (!resetn) state <= A; //reset condition\n        else case (state)\n            A: begin\n                g <= 0;\n\t\t\t\tf <= 0; \n                if (!resetn) state <= A;\n                else state <= B;\n            end\n            B: begin  \n                g <= 0;    \n\t\t\t\tif(!x && !y) state <= C; //when x and y are both zero\n              \telse state <= D; \n\t\t\tend\n           C: if(x) state <= D; //waiting for three successive ones of X, then go to next state\n            else begin\n\t\t\t\tf <= 0;\n                g <= 0;\n                state <= B;  \n            end\n          D: begin   \n                f <= 1;\n              \tif(y) state <= D;// when y is one in less than two cycles. \n              \telse state <= A; // else go back to state A after setting g = 0 for at least 2 clock cycles.  \n\t\t\tend\t\t\t\n        endcase      \n    end         \nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\treg [1:0] count;\n\treg nextStateA;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (resetn == 0) begin\n\t\t\tf <= 1'b0;\n\t\t\tg <= 1'b0;\n\t\t\tcount <= 2'b00;\n\t\t\tnextStateA <= 1'b1; \n\t\tend else begin\n\t\t\t\tcase(nextStateA)\n\t\t\t\t\tA: begin f <= 1'b0; count <= x ? B : A; nextStateA <= A; end // set to state B if x=1, remain in state A otherwise\n\t\t\t\t\tB: begin f <= 1'b0; count <= (count==2'd2) && x ? C : (x ? B : A);  nextStateA <= x ? B : A; end // stay in state C when count =2 and x=1, transition to state B or remain at state A if x = 0\n\t\t\t\t\tC: begin f <= 1'b1; g<= 1'b1; count <= (count==2'd1) && y ? D : (y ? C : A);  nextStateA <= y ? C : A; end // set f to 1,g=1 on the clock edge when count =1 and y = 1. transition state to D or remain at state A if y = 0\n\t\t\t\t\tD: begin f <= 1'b1; g<= 1'b1; count <= (count==2'd2) && y ? C : (y ? D : A);  nextStateA <= y ? D : A; end // transition to state C when count =2 and y=1, remain at state D or transition back to A if y = 0\n\t\t\t\tendcase\n\t\t\tend  \n\t\tend\n\tendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\n\treg [1:0] count;\n\treg state_a;\n\twire state_b;\n\twire setg;\n\t\n\t//State A definition \n\tassign state_a = ~resetn;\n\t\n\t//Next State Logic\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) //Reset is active low\n\t\t\tstate_b <= 1'b0;\n\t\telse if (count == 2'b01 || count == 2'b11) \n\t\t\tstate_b <= 1'b1;\n\tend\n\t\n\t//State Transition Logic: Set f for one clock cycle after reset is de-asserted \n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) //Reset is active low\n\t\t\tf <= 1'b0;\n\t\telse if (state_a == 1'b1 && state_b ==1'b0)\n\t\t\tf <= 1'b1;\n\t\telse \n\t\t\tf <= 1'b0;\n\tend\n\t\n\t//Counter logic to count x input pulses in sequence of 1, 0, 1 \n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) //Reset is active low\n\t\t\tcount <= 2'b00;\n\t\telse if (x && state_a == 1'b1 && state_b ==1'b0 )\n\t\t\tcount <= count + 2'b01; \n\t\telse if(!x && state_a == 1'b1 && state_b==1'b1) // reset the counter when x input is 0 and we are in state B\n\t\t\tcount <= 2'b00;\n\tend\n\n\t//Set g output based on y input for at most 2 clock cycles. When y has the value 1 within at most two clock cycles, then g should be set to 1 (maintained). But if y does not become 1 within two clock cycles, then g should be set to 0.\n\tassign setg = (y && state_a == 1'b1 && state_b ==1'b1) ;//if Y is asserted and we are in State B\n\n\t//Output Logic : G maintains its value until y becomes zero or reset de-asserts\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) //Reset is active low\n\t\t\tg <= 1'b0;\n\t\telse if (setg == 1'b1 || count != 2'b00 ) \n\t\t\tg <= 1'b1;\n\t\telse \n\t\t\tg <= 1'b0;\n\tend\nendmodule \n"}
{"task_id": "2013_q2bfsm", "completion": "\n    reg [1:0] counter;\n    reg [2:0] state; \n    \n    parameter A = 2'h0, B = 2'h1, C = 2'h2, D = 2'h3;\n\tassign f = (state == B);\n\tassign g = ((state == D) || (state == C)) ? 1 : 0 ;\n    \n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state <= A;\n            counter <= 2'h0;\n        end else case (state)\n        \n        A: begin f <= 1'b0; \n             if(!x) state <= B;  \n          end     \n              \n        B: begin counter <= counter + 1; \n              if(counter == 2) state <= C; \n           end      \n           \n        C: begin counter <= 2'h0; \n              if (x && !y ) state <= D; \n             else if (!x) state <= B;  \n            end    \n                  \n        D: begin f<= 1'b1; \n               if(y) state <= D; \n              else state <= A;\n           end   \n        \n        endcase\n\tend\nendmodule\n\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\n    reg [1:0] x_reg;  // Register for the last two values of x\n    reg count;     // Counter for the number of clock cycles since the last change in y value\n\n    always @(posedge clk or negedge resetn) begin\n        if (resetn == 0) begin\n            f <= 1'b0;       // Reset state and outputs\n            g <= 1'b0;\n            x_reg <= 2'b00;  // Reset register\n            count <= 3'd0;   // Reset counter\n        end else begin\n            if (f == 1'b0) begin    // If f is not yet set\n                f <= 1'b1;           // Set it for one clock cycle and move to state B\n            end \n\t\t\tif(x_reg == 2'b11 && x == 1'b1)begin // if last two inputs are 1,0,1 and new input is 1\n\t\t\t\tg <= 1'b1;           // Set g to 1 for one clock cycle\n                count <= 3'd0;   // Reset counter\n\t\t\tend else begin\n\t\t\t\tif (x == 1'b1)begin // if the new x value is 1\n\t\t\t\t\tx_reg <= {x, x_reg[1]};// Shift in the last two values of x\n                end   \n            end     \n          \n\t\t\tif(y == 1'b1 && count < 3'd2)begin // If y=1 within at most two cycles\n\t\t\t\tg <= 1'b1;                    // Maintain g=1\n                 count <= count + 1;         // Increase the counter \n            end else if (count >= 3'd2 && y == 1'b0) begin//if no transition in y for two cycles and y is downward\n\t\t\t\tg <= 1'b0;                    // Set g=0\n                count <= 3'd0;               // Reset counter\n            end  else if (y== 1'b1 && x_reg == 2'b11) begin// If y remains 1 and last two inputs are 1,0,1\n\t\t\t\tg <= 1'b1;                   // Maintain g=1\n                 count <= count + 1 ;        // Increase the counter\n            end  else if(y== 1'b1 && x_reg != 2'b11) begin// If y remains 1 but last two inputs are not 1,0,1\n\t\t\t\tg <= 1'b0;                    // Set g=0\n                count <= 3'd0;               // Reset counter\n            end  \n        end   \n    end      \nendmodule\n\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\treg [1:0] count = 2'b0;\n\treg lastx;\n\twire stateA = !resetn; // reset is active low\n\tassign f = (!stateA && (count == 3)); // set f to 1 in one clock cycle after x produced values 1, 0, 1 for the first three consecutive clk cycles\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\t// Reset state\n\t\t\tcount <= 2'b0;\n\t\t\tlastx <= '0;\n\t\t\tg <= '0;\n\t\tend else if (stateA) begin\n\t\t\t// State A, do nothing\n\t\tend else begin\n\t\t\tif (x != lastx && x) // If x has changed and is now 1\n\t\t\t\tcount <= count + 2'b1; // Increment the counter\n\t\t\telse if (!resetn && f) \n\t\t\t\tg <= 1'b1; // set g to 1 as long as not reset signal is active after setting f for one clock cycle\n\t\t\telse if (y || (count == 3))\n\t\t\t\t// If y has become 1 within at most two clk cycles or x has produced values 1,0,1 in three successive clocks then keep g = 1. Else set g=0\n\t\t\t\tg <= 1'b1;\n\t\t\telse \n\t\t\t\tg <= 1'b0; // Set g to 0 otherwise\n\t\t\tlastx <= x; // Update lastx for comparison next clock cycle\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n    reg [2:0] state;\n    \n    parameter [2:0] A = 3'b001, B = 3'b010, C = 3'b011, D = 3'b100, E = 3'b101;\n\t assign f = (state == C);\n    \n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) \n\t\t\tbegin state <= A; g <= 1'b0; end  \n        else \n            case (state)\n                A: begin g <= 1'b0; if(!x) state <= B; end  \n                B: begin g <= 1'b0; if(x && x_d) state <= C; end  \n                C: begin f <= 1'bx; g <= 1'b1; if (!x) state <= D; else state <= E; end  \n                D: begin g <= 1'b1; if (y) state <= D; else state <= A; end \n                E: begin g <= 1'b1; if(!y && !y_d2) state <= D; end    \n            default : state <= A;   \n            endcase  \n        x_d <= x; y_d <= y; y_d2 <= y_d; \n    end\nendmodule \n\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\treg [2:0] x_buf;\n\treg [1:0] y_ctr;\n\t\n\t// state A is equivalent to resetn == 0\n\tassign f = (resetn == 0) ? 1 : ((x_buf[1] && ~x_buf[2]) && ~(y_ctr > 0)); // for three x's, g becomes one clock cycle after f\n\tassign g = resetn ? ((~y_buf[1] || y_ctr > 0) ? 1 : 0) : 0;\t// while in state A or when y is not stable for 2 cycles, g should be 1. When y is stable and equal to 1, g should stay one. In state A g should always be zero.\n\t\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin // synchronous active low reset\n\t\t\tx_buf <= 0;\n\t\t\ty_ctr <= 0;\n\t\tend else begin\n\t\t\tx_buf <= {x, x_buf[2:1]};\t// shift register for the last three x's\n\t\t\tif ((~y_buf[1]) && y)  // if y is equal to one and has not been stable before or it was not equal to one previously\n\t\t\t\ty_ctr <= y_ctr + 1;\t// count how long y is equal to one\n\t\t\t\t\n\t\t\tif (y_ctr > 0 && ~y) // reset the counter when y becomes 0, i.e., the motor stops moving\n\t\t\t\ty_ctr <= 0;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\n\t// internal states of the state machine\n\tlocalparam [1:0] A = 2'b00, B = 2'b01, C = 2'b10;\n\treg [1:0] state = A; // initial state\n\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin  // synchronous active low reset\n            f <= 1'b0;     // set f to 0 at beginning of state machine operation\n            g <= 1'b0;     // set g to 0 at beginning of state machine operation\n            state <= A;    // go to initial state A\n        end else begin\n\t\t\tcase (state) \n\t\t\t\tA: begin\n\t\t\t\t\tf <= 1'b1;   // f is always 1 in state A\n                    g <= 1'b0;    \n                    if (!x && !y) state <= B;   // stay in state A if x and y are both 0\n                end\n\t\t\t\tB: begin\n\t\t\t\t\tf <= 1'b0;   \n                    g <= 1'b0;\n                    if (x && !y) state <= C;   // go to state C if x is 1 and y is 0\n                end\n\t\t\t\tC: begin\n\t\t\t\t\tf <= 1'b0;   \n                    g <= 1'b1;     // set g to 1 in all states other than A when x = 1\n                    if (!x && !y) state <= B;   // go back to state B if both x and y are 0\n                end\n\t\t\tendcase\n        end\n    end\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\treg [1:0] cnt;\n\treg stateA;\n\twire transition;\n\t\n\t// FSM State Transition Detection Logic\n\tassign transition = (stateA & ~resetn) | (cnt == 2'b10 & x);\n\t\t\n\t// Sequential Logic\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin // Reset State\n\t\t\tf <= 1'b0;\n\t\t\tcnt <= 2'b00;\n\t\t\tstateA <= 1'b1;\n\t\tend else if (transition) begin // Transition State\n\t\t\tf <= 1'b1;\n\t\t\tif (!stateA) cnt <= cnt + 2'b01; // Count x=1,x=0,x=1 inputs\n\t\tend else begin // Maintenance State\n\t\t\t// If more than 2 clock cycles have passed since f was asserted or if y has not been asserted within the last 2 cycles\n\t\t\tif (cnt >= 2'b10 || ~y) g <= 1'b0; \n\t\t\telse g <= 1'b1; // Otherwise, keep g asserted\n\tend\n\t\n\t// Combinational Logic for Outputs f and g\n\tassign f = stateA & ~resetn ? 1 : (cnt == 2'b10 && x) ? 1 : 0;\n\tassign g = cnt >= 2'b10 || ~y ? 0 : 1; //g will be asserted if y has been 1 within the last 2 cycles, else it will remain unasserted. If f is not asserted in any state, g should also be 0.\n\t\nendmodule\n\n"}
{"task_id": "2013_q2bfsm", "completion": "\nreg [1:0] state;\nwire [1:0] nextState;\n\n// State definitions\nlocalparam A = 2'h0, B = 2'h1, C = 2'h2, D = 2'h3;\n\nalways @(posedge clk or negedge resetn) begin \n\tif (!resetn) state <= A; // Reset condition\n\telse state <= nextState; // Update state on clock edge\nend\n\n// State transition logic\nalways @(*) begin\n\tcase (state)\n\t\tA: if (!resetn) nextState = A; else nextState = B;\n\t\t   \n\t\tB: nextState = C; \n\t\t   \n\t\tC: if ((x & ~state[0]) == 2'h3 ) nextState = D; // x must have produced 1,0,1 in 3 clock cycles. If not, stay at state C.\n\t\t   else nextState = B;\n\t\t\t\n\t\tD: if (y) nextState = D; else nextState = A; // y can remain 1 for up to 2 cycles, then return to A.\n\tendcase\nend\n\n// Output logic\nassign f = (state == B);\nassign g = ((state == C) || (state == D)) && !y; // If x produces 1,0,1 in the previous states and y has not been 1 yet.\n\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n    reg [2:0] state; // State register to keep track of 3 successive x values.\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 1'bz;\n            state <= 0;\n        end\n        else begin\n            case (state)\n                3'd0: begin // Beginning State\n                    if (!f)\n                        f <= 1;\n                    if (x) \n                        state <= state + 1;\n                end\n                3'd1, 3'd2: begin // x = 1 in first two clock cycles\n                    if(x && !g) \n                        g <= 0;\n                    else if(!x && g)\n                        g<= 1;\n                    if (x) \n                        state <= state + 1;                    \n                end                \n                3'd3: begin // x = 1 for third clock cycle. \n                    f <= 0;\n                    g <= 0;\n                    state <= 0;  \n                    if (!y && !g )\n                       g<= 0;   \n                   else if(!x) \n                      state <= state + 1 ;                       \n                end                \n            endcase\n        end\n    end\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\n\treg [1:0] state;\n\treg [1:0] count_x;\n\treg [23:0] count_y;\n\twire x_sync;\n\tassign #5 x_sync = x; // Synchronize the input x using a flip-flop with a 5 ns delay\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tf <= 0;\n\t\t\tstate <= 2'b00;\n\t\t\tcount_x <= 2'b00;\n\t\t\tg <= 0;\n\t\t\tcount_y <= 24'd0;\n\t\tend else if (f == 1'b0) begin // State A\n\t\t\t\tf <= 1'b1;\n\t\tend else begin\n\t\t\tcase(state)\n\t\t\t\t2'b00: if (x_sync)  state <= 2'b01;   // Go to the next clock edge when x changes\n\t\t\t\t2'b01: if (!count_x[1]) count_x <= {~count_x[0], 1'b0}; else begin count_x<=2'b00; state <= 2'b10; end // Count x for three clock cycles, then go to the next state\n\t\t\t\t2'b10: if (!g) g <= 1;         // Set g = 1 on each rising edge of clk when g = 0 and y = 0 or 1\n\t\t\tendcase\n\t\t\t\n\t\t\tif (y == 1 && !count_y[23]) count_y <= count_y + 1'b1; else if(state == 2'b10) begin // Count y for two clock cycles, then go back to state A\n\t\t\t\t\tg <= 0; \n\t\t\t\t\tf <= 0; \n\t\t\t\t\tcount_x <= 2'b00; \n\t\t\t\t\tcount_y <= 24'd0; \n\t\t\tend  \n    end\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\treg [2:0] count; //count the number of 1s in three successive cycles.\n\treg set_g; //flag to decide if we should set g=1 or not.\n\tassign f = resetn ? (resetn & ~set_g) : 1'b1;\n\tassign g = resetn ? ((~count[2] && set_g)? 1'b1: count[0]) : 1'b0;\n\t\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin //reset condition\n\t\t\tset_g <= 1'b0;\n\t\t\tcount <= 3'b0;\n\t\tend else if (x && ~set_g && count != 3'd2 )begin\n            count <= count + 1;//increase the count if x is 1 and g isn't set yet.\n        end else begin //if y has value 1 within at most two cycles, then keep count as it is for one cycle, otherwise reset count.\n\t\t\tcount <= (y && ~set_g) ? {1'b0 ,~(|count[2:1])} : 3'd0; \n        end\n\t\tset_g <= ~(~(x&~(count == 3'd2)) | y); //if x has produced the values 1, 0, 1 in three successive clock cycles then set g=1.\n    end  \nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n    reg [2:0] state; // state 1 = x=1,x=0,x=1; state 2 = g = 1\n    \n    always @(posedge clk or negedge resetn) begin\n        if(!resetn) begin\n            f <= 1'b0;\n            g <= 1'b0;\n            state <= '0; // idle state\n        end else begin\n          case (state) \n              3'd0 : begin    // start from A State, asserting f for one clock cycle  \n                  f <= 1'b1;\n                  g <= 1'b0;\n              end\n              3'd1 : begin     // Monitor x if it is in state 1\n                  f <= 1'b1;\n                  if (x == 1)\n                    state <= 2;\n                else  \n                  state <= '0;   \n              end\n              3'd2 : begin        // If three successive x = 1 occur, assert g for one clock cycle and move to State 4\n                 f <= 1'b1;\n                 if (x == 1)      // This is the third occurrence of x=1. Move to state 4.\n                    state <= 3;  \n                else               // Reset to start from A as we didn't have three occurrences of x = 1\n                     state <= '0;   \n              end \n              3'd3 : begin        \n                 g <= 1'b1;        // In State 4, keep asserting g. Monitor y\n                  if (y == 1)       // If y is set to 1 within two clock cycles, maintain g = 1 forever\n                    state <= 3;    \n                else               // Reset to start from A as we didn't have three occurrences of x = 1 and y has not stayed at '1' for maximum two clk cycle\n                     state <= '0;  \n              end \n          default : begin    // To avoid any unintended output, return everything to initial value after a reset is de-asserted\n             f <= 1'b0;       \n             g <= 1'b0;        \n             state <= '0;     \n           end    \n        endcase  \n       end \n    end\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\n\t// State Declaration \n    localparam A = 2'b00; //Begin state  \n    localparam B = 2'b01; //State after reset deassertion  \n    localparam C = 2'b10; //State for monitoring x input.\n    \n    reg [1:0] curr_state, next_state; \n\treg f_next, g_next;\n\treg [1:0] count;\n    \n\t// State transition logic\n\talways @(posedge clk or negedge resetn) begin  \n      \tif (resetn == 1'b0)\n            curr_state <= A;  \n        else \n        \tcurr_state <= next_state; \n    end    \n    \n\t// Output logic based on the state \n\talways @(*) begin \n\t\tcase (curr_state) \n\t\t\tA: begin  // Initial state \n\t\t\t\tf_next = 1'b0;  \n            \tg_next = 1'b0;   \n                if (!resetn)\n                    next_state = A;\n                 else \n\t\t\t\t\tbegin\n\t\t\t\t\t\tf_next=1'b1;\n                        count <=2'd0;\n                        next_state = B;  \n\t\t\t\t\tend\n            end            \n\t\t\tB: begin // State after reset de-assertion\n\t\t\t\tif (f_next) begin \n                    f_next = 1'b0;  \n                    g_next = 1'b0;    \n                    next_state = C;                    \n                end  else begin\n\t\t\t\t\tf_next=1'b1;\n                \tg_next = 1'b0;   \n\t\t\t\tend\n            end            \n\t\t\tC: begin // Monitor the x input.  \n\t\t\t\tif(x == 1)  begin \n                    count <= count + 2'd1;    \n                end else if (count < 3)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tf_next=1'b0;\n                    \tg_next = 1'b0;   \n                        next_state = C;  \n\t\t\t\tend\n              \telse  begin \n                    f_next=1'b0;\n                \tg_next = 1'b0;     \n\t\t\t\t\tif (y == 1) \n                    \tnext_state <= B;   //If y becomes 1 within at most two clock cycles then maintain g as 1.   \n                end  \n            end          \n        endcase        \n     end      \n\t// Output Assignment \n    assign f = f_next;  \n    assign g = g_next | (count < 2); //Maintain g=1 for y==1 until the count reaches two clock cycles. If y does not become 1 within two cycles, then set it to 0.\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\twire signed [8:0] sum;   // Need 9 bits to hold the potential overflow bit\n\n\tassign sum = a[7] ? ~({1'b0,a} + b) : {1'b0,a}+{1'b0,b};\n\ts <= sum[7:0];           // Store only lower 8 bits in s\n\toverflow <= sum[8];      // Detect overflow by checking bit 9 (upper bit of sum)\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\twire signed [8:0] sum;   // 9 bit wide for carry\n\tassign sum = {{1'b0},a} + {{1'b0},b};    // add with sign extension and zero extension to avoid the x in verilog.\n\tassign s = sum[7:0];    // LSB 8 bits of the sum.\n\tassign overflow = sum[8] ^ a[7] ^ b[7] ^ s[7];   // XOR of carry bit and sign bits to detect overflow.\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\tassign {overflow, s} = a + b;\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\n    wire signed [8:0] sum; // 9-bit wide to capture the carry\n    \n    assign sum = {1'b0, a} + {1'b0, b};\n  \n    assign s = sum[7:0];\n    \n    assign overflow = (sum[7] != sum[8]) ? 1 : 0; // if the sign of the sum changes then there was an overflow\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\treg signed [8:0] sum;  // 9-bit for carry and sign extension\n\tassign s = sum[7:0];   // The result is the least significant 8 bits of the 9-bit sum\n\tassign overflow = sum[8];    // If the most significant bit (carry) has changed, an overflow occurred\n\n\talways @(*) begin\n\t    {overflow, sum} = a + b;  // Addition and carry calculation in one operation\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\t// Implementing two's complement addition and check for signed overflow.\n\tassign {overflow, s} = a + b;\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\twire signed [8:0] sum;\n\tassign sum = {1'b0,a} + {1'b0,b}; // Convert to 9 bit for the sign extension\n\tassign s = sum[7:0];\n\tassign overflow = (sum[8] != a[7]) && (sum[8] != b[7]); // compare MSB of two sums\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n  reg signed [8:0] sum;\n  \n  always @(*) begin\n    sum <= a + b;\n    overflow <= ((a[7] == b[7]) && (sum[7] != a[7])) ? 1'b1 : 1'b0; // if sign of a and b are same but the result has different sign, then overflow occurred.\n  end\n  \n  assign s = sum[7:0];\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\n\t// Assign sum\n\tassign s = a + b;\n\t\t \n\t// Assign Overflow bit\n\tassign overflow = (a[7] == b[7]) && (s[7] != a[7]); // If two input numbers have same sign and output number has different sign then it's an overflow.\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\treg signed [8:0] sum;\n\tassign sum = {1'b0,a} + {1'b0,b};\n\tassign s = sum[7:0];\n\tassign overflow = sum[8];\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\tassign {overflow,s} = a + b;\nendmodule \n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\twire signed [8:0] sum;\n   assign sum = {1'b0,a} + {1'b0,b}; \n\tassign s=sum[7:0];\n\tassign overflow = (sum[8] !== a[7]) && (sum[8] !== b[7]);\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\twire signed [8:0] sum;  // using signed to accommodate for the extra bit of carry generated by addition\n\tassign sum = {1'b0, a} + {1'b0, b};  \n    assign s = sum[7:0];\n\tassign overflow = (sum[7] != sum[8]) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\treg signed [8:0] temp; // To avoid overflow in addition operation. 9th bit is for carry out.\n\tassign s = temp[7:0];\n\tassign overflow = (temp[8] != temp[7]) ? 1'b1 : 1'b0; // If sign of result changes, it means we have an overflow.\n\talways @(*) begin\n\t\ttemp = a + b;\n\tend\n\t\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\n\treg signed [8:0] sum;  // to check for overflow\n\talways @(*) begin\n\t\tsum = a + b;\n\t\tif (sum[7] != a[7])\n\t\t\toverflow = 1'b1;\n\t\telse\n\t\t\toverflow = 1'b0;\n\t\ts = sum[7:0];\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\twire signed [8:0] sum;  // 1 bit more than needed to handle potential overflow.\n   wire           a_sign = a[7];\n   wire           b_sign = b[7];\n   wire           s_sign = s[7];\n   \n\tassign sum = {a_sign, a} + {b_sign, b};\n\tassign s    = sum[7:0];  // Most significant bit of the sum is not relevant here.\n\tassign overflow = (a_sign == b_sign) && (a_sign != s_sign);\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\treg signed [8:0] sum;\n\tassign sum = {1'b0, a} + {1'b0, b}; //extend the sign bit for addition\n\tassign s = sum[7:0]; \n\tassign overflow = (sum[7] == ~a[7] && sum[8] == a[7]) || (sum[7] == ~b[7] && sum[8] == b[7]);\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\t// Overflow is true if the sign bit of the sum is different from either of the operands. \n\t// In a signed addition, it happens when we have both positive inputs and get a negative output (vice versa).\n\tassign s = a + b;\n\tassign overflow = ~(a[7] ^ b[7]) & (a[7] ^ s[7]);\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\n\t// 2's complement addition of signed integers. Overflow is indicated if the result sign changes from positive to negative or vice versa.\n\tassign {overflow, s} = a + b;\n\t\nendmodule\n\n"}
{"task_id": "ece241_2014_q1c", "completion": "\n\n\treg signed [8:0] sa; // Sign-extended sum\n\tassign s = sa[7:0]; \n\tassign overflow = sa[8];\n\n\talways @(*) begin\n\t\tsa <= a + b;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "ece241_2013_q2", "completion": "\n// SOP Form of Boolean Equation:\n// (a AND NOT(b) AND c AND d)' \n// OR \n// ('NOT(a) AND b AND NOT(c) AND NOT(d))' \n// OR\n// ('NOT(a) AND 'NOT(b) AND c AND NOT(d))' \n// OR\n// (a AND b AND NOT(c) AND d)' \n\n\tassign out_sop = ((~(a | (~b & ~c & d)))|((~a & b & c & ~d)))|((~a & ~b & c & ~d))|(a & b & ~c & d));\n    \n// POS Form of Boolean Equation:\n// ('NOT(a) OR NOT(b) OR c OR d)' \n// AND \n// (a OR 'NOT(b) OR c OR 'NOT(d))' \n// AND\n// (a OR b OR 'NOT(c) OR d)' \n// AND\n// ('NOT(a) OR b OR 'NOT(c) OR NOT(d))' \n\n\tassign out_pos = ((~a | ~b | c | d) & (a | ~b | c| ~d) & ( a | b| ~c| d)&(~a | b| ~c| ~d));\n"}
{"task_id": "ece241_2013_q2", "completion": "\n//The sum-of-product form is calculated using the truth table of the SOP function and the product-of-sum form is done by inverting the truth table. So we calculate both forms as below. \n\tassign out_sop = (a && !b && c) || (!c && d); // This is equivalent to sum-of-products form.\n    \tassign out_pos = ~((~a || b) && (c || ~d)); // Inverted version of SOP gives product-of-sums. \nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\n// In sum-of-products form\n// out = (!a && !b && c && d) || ( a &&  b && !c && !d) || (!a &&  b && !c &&  d) || ( a &&  b &&  c && !d);\n// Which is equivalent to the following in product-of-sums form:\n// out = ((a+b)*(-c+d)*(-a+b)*(a+b))'\n\n\tassign out_pos = ~(((a+b)*(1-c+d)*(1-a+b)*(a+b)) - 4'h8); // Subtract by 8 to convert from minimum sum of products form to positional notation (since the max sum is 8, which can be represented using 3 bits).\n\tassign out_sop = ~(((!a || b || !c) && d) || ((a || !b || c) && !d)); // Convert from positional to min-sum of products form.\nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\nIn sum-of-products form for minimum terms, 15 occurs when all inputs are set to 1 (a = 1, b = 1, c = 1, d = 1). The remaining conditions translate as follows:\n0 -> a=b=c=d=0,\n2 -> a=b=d=0, c=1 or a=c=d=0, b=1,\n7 -> a=c=0, b=d=1 or a=d=0, b=c=1,\n14 -> a=d=0, b=c=1 or a=b=0, c=d=1.\nSo the sum-of-products form for out_sop is:\nout_sop = (a'.b'.c'd') + (a'.b'c'd) + (ab'cd) + (ac'bd) + d --> 3 + 2*c + 4*b + 5*a + e \n\nIn product-of-sums form for minimum terms, a logic 0 output occurs when all inputs are set to 1. The remaining conditions translate as follows:\n0 -> (a=b=c=d=0),\n2 -> (a=b=d=0) + (c = 1 or b = d = 0),\n7 -> (a=c=0, b=d=1) + (a=d=0, b=c=1),\n14 -> (a=d=0, b=c=1) + (a=b=0, c=d=1).\nSo the product-of-sums form for out_pos is:\nout_pos = a'b'cd' + ab'cd + acbd' + abcd + e --> -2*c + 4*b + 6*a - 5*e\n"}
{"task_id": "ece241_2013_q2", "completion": "\n\t// Minimum Sum-of-Products Form.\n\tassign out_sop = (~a & ~b & d) | ( a & b & c ) | ( a & ~c & ~d );\n\t\n\t// Minimum Product-of-Sums Form.\n\tassign out_pos = ~(~a | ~b | c ) & ~(~a | b | d ) & ~(a | b | ~c ); \nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\nImpossible to determine the SOP and POS formats without known function behavior. It is not possible for only 4 input conditions (2,7,15,0-14 except 3,8,11,12) with no \u201cor\u201d between them to generate a logic-1 output without specifying exactly which combinations would produce what outputs.\n\n"}
{"task_id": "ece241_2013_q2", "completion": "\n\twire [15:0] inputs = {a,b,c,d};\n\tassign out_sop = ~((inputs == 4'h2) || (inputs == 4'h7) || (inputs == 4'hE)); \n\tassign out_pos =  ((inputs == 4'h0) || (inputs == 4'h1) || (inputs == 4'h4) || \n\t\t\t   (inputs == 4'h5) || (inputs == 4'h6) || (inputs == 4'h9) || \n\t\t\t   (inputs == 4'hA) || (inputs == 4'hD) || (inputs == 4'h13)); \nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\n\tassign out_sop = (~a & ~b & ~c &  d) | // 2\n                    ( a & ~b & ~c & ~d) | // 7\n                    (~a &  b &  ~d) ;     // 15\n                    \n    assign out_pos = (~a |  b ) &   // 0,4,6,8,9,10,12,13,14 are inverted to make it pos form. 2,7,15 have been handled above hence no need of considering them again\n                    ( a | ~b | c) ;     // 1,3,5,11 are or-ed together so that they can become sum term of output function.\n"}
{"task_id": "ece241_2013_q2", "completion": "\nThe output can be expressed as follows:\nout_sop = a'b'c'd + abcd + ac'd' + abc'd  (Minimum sum-of-products form)\nout_pos = (a+b+c+d)*(a+b+c+d')*(a+b+c'+d)*(a+b'+c+d) (Minimum product-of-sums form) \n\nmodule top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\nassign out_sop = (!a && !b && !c && d ) || (a && b && c && d) || (a && c && !d );\nassign out_pos =  ((a + b + c + d) * \n\t\t\t\t   (a + b + c + (!d)) * \n\t               (a + b + (!c) + d)*\n                   (a + (!b) + c + d));\nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\n\n\tassign out_sop = ((~a & ~b & ~c & ~d) | (~a & ~b & ~c & d) | (~a & b & c & ~d) | (~a & ~b & c & d) \n\t\t\t\t\t| (a & b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (~a & b & c & ~d));\n\tassign out_pos = ((a | b | c | d) & (~(a&c) | ~b&d)) | a & c;  // Sum-of-products form and product-of-sums form are equivalent for this particular circuit.\n\t\nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\n\tassign out_sop = ((~a&~b&c&d)|(~a&b&~c&d)|(~a&b&c&~d)); //min. sum-of-products form\n\tassign out_pos = ~((~a|~b) & (~c|~d)) & ~((~a|c) & (~b|~d)) & ~((~a|~b) & c & d);  // min. product-of-sums form\nendmodule\n\n"}
{"task_id": "ece241_2013_q2", "completion": "\n// The sum of products form is 2 + (2 * 8) + (4 * 5) + (16 * 9). So in sop it will be a'bcd + abcd' + ~a~bcd + abc~d'. \n// Similarly for product of sums the formula is (a + b)(c + d)(ac + bd)(ad + cb) which equals 1*0*1*(0+2) = 0. Hence, out_sop = a'bcd + abcd' + ~abc~d'.\n// And for pos form it will be a*b*c + b*c*d + c*d*a + d*a*b which equals (1 + 3*(2 + 4)) = 8. Hence, out_pos = abc + bcd + cad + dad. \n\tassign out_sop = !(a && (!b || !c || d) && ((b && c) || (!c && d)));\n\tassign out_pos = (a && b && c) || (b && c && d) || (c && d && a) || (d && a && b);\nendmodule\n\n"}
{"task_id": "ece241_2013_q2", "completion": "\n\n\t// Minimum sum-of-products form -> OR gates followed by AND gate.\n    assign out_sop = (((a | b) & (c | d)) | ((a | c) & (b | d))) & ((a | b) | (c | d));  \n    \n\t// Minimum product-of-sums form -> OR gates followed by NAND gate. \n\tassign out_pos = ((((a & b) | c) & d) | (a & (b & d)) | ((a | c) & (b | d))) | (~((a & b) & c & d));  \n   \nendmodule \n\n"}
{"task_id": "ece241_2013_q2", "completion": "\nIn sum-of-products form of Boolean algebra, 2(abc+abd+acd) + ac + ab is used to represent the output. In product-of-sums form, it's represented as (a+b)(c+d)(a+c)(b+d).\n\n\tassign out_sop = a && b && c || a && b && d || a && c && d || b && c && d; //Sum of products form \n\tassign out_pos = (a || b) && (c || d) && (a || c) && (b || d); // Product of sums form\nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\n// out_sop is the output of this system in sum-of-products form. \nassign out_sop = (~a&b&c&d) | (a&~b&c&d) | (a&b&~c&d) | (a&b&c&~d);\n\t  \n// out_pos is the output of this system in product-of-sums form. \nassign out_pos = ~(a|b|c|d) | (a&~b&~c&d) | (~a&b&c&~d) | (~a&~b&c&d);\nendmodule\n\n"}
{"task_id": "ece241_2013_q2", "completion": "\nThe sum-of-products form of the expression is: \nout_sop = ((a + b'c)'(b + cd)'(c + d')' + 1)((a + b + c)'(a + b + d)' (b+ c + d)')'+ 1)'.\nThe product-of-sum form of the expression is: \nout_pos = a . b . c . d + a . b . c' . d' + a . b' . c . d'  + a' . b.c.d+a'.b.c'.d' + 1;\n\t\nendmodule\n\n"}
{"task_id": "ece241_2013_q2", "completion": "\nThe minimum sum-of-products form of the output will be:\n\nout_sop = (a & ~b & c) | (~d & ~c) | a;\n\nThe minimum product-of-sums form of the output will be:\n\nout_pos = ~(~(a | b) | c);\n"}
{"task_id": "ece241_2013_q2", "completion": "\n    //SOP form - sum of products \n\tassign out_sop = (((~a & ~b & ~c & d) | (~a & b & ~c & ~d) | \n                        (a & ~b & c & ~d) |(a & b & ~c & d)) ^ 1'b0);\n\t                    \n    //POS form - product of sums \n\tassign out_pos = ((~a | ~b | ~c | d) & (~a | b | c | ~d )& \n                       (a | ~b | c | ~d) & (a | b | ~c | d)) ^ 1'b0;   \nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\n// sum-of-products form \nassign out_sop = (a | b) & (c | d) & ((~a | ~b) | (a & c)) & ((~a | ~d) | (a & ~b));\n\n// product-of-sums form \nassign out_pos = ~(((~a | b) & (~c | d)) | ((a | ~b) & (c | ~d)));\n  \nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\n// Sum of Products Form \n// ab + bc + cd = 15   ->  a'b'cd + ab'cd + abc'd = d\n// Product of Sums Form\n// (a+b)*(b+c)*(c+d)*(d+a) = 0   ->   ac + bc + cd + da = 1 \n\tassign out_sop = a & ~b | c & ~d; // ab'cd + ab'cd = 0 -> 0\n\t// Converting to sum-of-products form\n\t// Since all terms are not negated, we just need to flip the bits of 'out_sop'. \n\tassign out_pos = ~out_sop;  \n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = ((~y[3]&y[2]&~y[1]) | (~y[3]&~y[2]&y[1])) ^ w;\n\tassign Y4 = ((~y[6]&~y[5]&~y[4]&y[3])|(y[6]&~y[5]&~y[4]&~y[3]) | (~y[6]&y[5]&~y[4]&~y[3]) | (y[6]&y[5]&~y[4]&y[3])) ^ w;\nendmodule \n\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = ((~y[5]&~y[3]&w)|(y[2]&~y[6]&~y[1])|(~y[2]&y[1])); \n    \n\tassign Y4 = ((~y[5]&y[4])|(y[3]&~y[4]&w)|(y[2]&y[6])|(y&y[3]&~y[6]&~y[1])); \n"}
{"task_id": "m2014_q6c", "completion": "\n\n\tassign Y2 = ((y[3]) ? ((w) ? ~(y[5]) : ~(y[4])) : (~(y[1]) & y[6]));\n\tassign Y4 = ((y[5]) ? ((w) ? ~(y[1]) : ~(y[2])) : (~(y[3]) & ~(y[2]))); \nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\t// A (0) --0--> B\n\t// A (0) --1--> A\n\t// B (0) --0--> C\n\t// B (0) --1--> D\n\t// C (0) --0--> E\n\t// C (0) --1--> D\n\t// D (0) --0--> F\n\t// D (0) --1--> A\n\t// E (1) --0--> E\n\t// E (1) --1--> D\n\t// F (1) --0--> C\n\t// F (1) --1--> D\n\tassign Y2 = ((y == 6'b000001)?(w):((y == 6'b000100 || y == 6'b001000)?(!w):(y[3])));  // Signal y[2]\n\tassign Y4 = ((y == 6'b000001)?(w):((y == 6000 ||  y == 6'b010000 || y == 6'b000100 || y==6'b000010)?(!w):(y[4])));  // Signal y[4]\n\t\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = (y[1]) ? ((w) ? 0 : 1) : ((y[5]) ? 0 : 1);\n\tassign Y4 = (y[3]) ? ((~w) ? 0 : 1) : ((y[6]) ? 0 : 1);\n\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\n\tassign Y2 = ((y[5]) ? (!w && y[3]) : (w && !y[1])) || \n\t           ((y[6] && !y[5] && w) || (y[4] && y[6] && !w)) || \n\t           ((y[6] && !y[5] && !w) || (!y[4] && y[6]));\n\n\tassign Y4 = ((y[3]) ? (!w && y[1]) : (w && !y[2])) || \n               ((y[6] && w && !y[2]) || (y[5] && y[6] && !w) )|| \n               ((y[6] && !w && !y[3]) || (!y[5] && y[4]));\n\t               \nendmodule\n\n"}
{"task_id": "m2014_q6c", "completion": "\n\twire A = y[1];\n    wire B = y[2];\n    wire C = y[3];\n    wire D = y[4];\n    wire E = y[5];\n    wire F = y[6];\n    \n\tassign Y2 = (~B & ~D) | ((A|C)&w);\n\tassign Y4 =  B&D&E;\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n   assign Y2 = ((y == 7) & w | (~y[5]) & ~w | (y == 3 | y == 6 | y== 7) & w)?1'b1:1'b0;\n\tassign Y4 = ((y == 6 | y == 7) & w | (~y[5] & ~y[2])& ~w | (y == 3 | y == 6 | y== 7 ) & w)?1'b1:1'b0;\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = ((y[5]) ? (!w & !y[3]) : ((y[4] & !y[3]) | (y[1] & y[6])));\n\tassign Y4 = ((y[5]) ? w & y[1] : (!y[6] & (((y[2]&y[5]&w) | (!y[2]&w))));\nendmodule \n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = ((y[3] & ~y[5] & ~w) | (~y[2] & y[6]) | (y[1] & y[6]));\n\tassign Y4 = (y[1] & w);\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\n\t// Deriving the next state signals using one-hot encoding and inspection.\n\tassign Y2 = ((~y[1] & ~w) | (y[3] & y[6]) | (y[5] & w));\n\tassign Y4 = ((~y[4] & ~w) | (y[6] & y[2]) | (y[1] & w));\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = w ? ((y[5] ~^ y[3]) ^ 1'b1) : y[2];\n\tassign Y4 = w ? (y[6] ^ y[4]) : y[4];\nendmodule\n\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = (y[3] & !w) | (!y[5] & y[4] & !w) | (y[6] & y[1] & w) | (!y[4] & w) ; \n\tassign Y4 = (!y[4] & !w) | (y[3] & y[2] & !w) | (y[5] & y[4] & w);\n\nendmodule\n\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = y[3] | (y[1] & !w) | (y[5] & w);\n\tassign Y4 = (!y[6] & y[2]) | (y[6] & ((y[3] & !w) | (y[5] & w)));\nendmodule \n"}
{"task_id": "m2014_q6c", "completion": "\n\t// Assuming that the states are represented in a one-hot encoding scheme, we can map the state to its index using \n\t// (state_index = binary2gray(y)) as follows :\n\t// A = 000001 => Index = 5;\n\t// B = 000010 => Index = 4;\n\t// C = 000100 => Index = 3;\n\t// D = 001000 => Index = 2;\n\t// E = 010000 => Index = 1;\n\t// F = 100000 => Index = 0;\n\t\n\tfunction [5:0] binary2gray; // function to convert the binary number into gray code \n    \tinput [5:0] bin_num;\n    \treg  [5:0] gray_num;\n  \tbegin\n    \tgray_num[5:1] = bin_num[4:0];\n    \tgray_num[0]   = bin_num[0];\n   \t \treturn gray_num;\n  \tend\n\tendfunction\n\t\t\n\tassign state_index = binary2gray(y);\n\t// Since we're dealing with a one-hot encoding scheme, every bit will only have 1 in its place and zeroes elsewhere. Therefore the index of 'y' which is equal to 1 gives us the current state.\n\n\tassign Y2 = ~w & (state_index==3 | state_index==4); // for y[2] \n\t// A,B -> go to C or D states based on input w. F goes back to E.\n  \t\n\tassign Y4 = w & ~(state_index==1) ;//for y[4] \n\t// For state E we stay in the same state if w=0 and transition to D when w=1. Other states go to C or B based on input w. F stays at itself because w does not affect it.\n\t\nendmodule\n\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = w?(y[3]|~y[5]):((y[1])|(y[2]&~y[4])) ;   //Y2 =  w ? (Y0 or ~Y1) : ((Y0 and not Y1) or (not Y1 and Y2)) \n\tassign Y4 = w?(~y[5]):((y[3])|(y[2]&~y[4])) ;   //Y4 =  w ? ~Y1 : ((not Y0) or (Y1 and not Y2));\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = ((y[1] & ~w) | (~y[3] & w)) ^ 1'b1; // xor inverted due to one-hot encoding\n\tassign Y4 = ((y[5] & ~w) | (~y[6] & y[3])) ^ 1'b1; // xor inverted due to one-hot encoding\nendmodule\n\n"}
{"task_id": "m2014_q6c", "completion": "\n  \n\tassign Y2 = (~y[0]&w) | (~y[5]&y[3]) | (~y[4]&y[1]);\n\tassign Y4 = ~(y[6]|(~y[0]&y[2])|(~y[3]&y[5])) & (~y[1]&w) | y[5]; \n  \nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\tassign Y2 = !w ? (!y[5]&&(y[3]||y[4])) : ((y[6] && (~y[1] || y[2]) ) || (y[3] && ~y[2])) ;  //for state A: w=0, y[6] and (not y[1] or y[2]); for states B,C,D: w = 1;\n\tassign Y4 = !w ? ((~y[5] || y[4]) && ~y[3]) :  ((y[6] && y[2])  || (y[4] && ~y[1])) ;   //for state A: w=0, not y[5] or y[4]; for states B,C,D: w = 1;\n\t\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\n\nassign Y2 = ((~y[3] & ~y[5]) | (w & y[6])) & ~y[1];\nassign Y4 = (((~y[3] & y[5]) | (w & y[6])) ^ y[1]);\nendmodule\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in; // This will give us an even parity bit if there are odd number of 1's in the input. If you want it for odd parity, just switch to '|' operator instead of '^'.\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\nassign parity = ^in; //'^' is a xor operator.\nendmodule \n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in; //XOR gate will give us even parity.\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in; //Even Parity\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\nassign parity = ^in;\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\nassign parity = ^in;\n\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\n\tassign parity = ^in;\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\n\tassign parity = ^in[7:0]; // xor gate used to compute parity bit for 8-bit input.\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\nassign parity = ^in; // computes \"even\" parity by computing XOR of all 8 data bits.\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\nassign parity = ^in; // Compute the XOR of every bit in input 'in' and assign it to output 'parity'. This will yield a 9th bit.\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n   assign parity = ^in; // The '^' operator is the xor operation for all inputs \nendmodule\n"}
{"task_id": "reduction", "completion": "\nassign parity = ^in;\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\nassign parity = ^in;\nendmodule\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in;\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\n\t// Compute parity using XOR gate operation for each bit\n\tassign parity = ^in[0];\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in;\nendmodule\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in; // Computes even parity bit.\nendmodule\n"}
{"task_id": "reduction", "completion": "\n\n\tassign parity = ^in;\nendmodule\n\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in;\nendmodule\n"}
{"task_id": "reduction", "completion": "\n\tassign parity = ^in;\nendmodule\n\n"}
{"task_id": "gates", "completion": "\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor =  ~(a ^ b);\n\tassign out_anotb = a & ~b; \nendmodule\n\n"}
{"task_id": "gates", "completion": "\n    assign out_and = a & b;\n\tassign out_or  = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b; \nendmodule\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a && b;  //AND gate\n\tassign out_or =  a || b;  //OR gate\n\tassign out_xor = a ^ b;   //XOR gate\n\tassign out_nand = ~(a & b); //NAND gate\n\tassign out_nor = ~(a | b); //NOR gate\n\tassign out_xnor =  ~(a ^ b);  //XNOR gate\n\tassign out_anotb = a && ~b;   //AND NOT gate\nendmodule\n"}
{"task_id": "gates", "completion": "\n    assign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule\n\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = (~a & ~b) | (a & b);\n\tassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "gates", "completion": "\n   assign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule \n\n"}
{"task_id": "gates", "completion": "\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor =  ~ (a ^ b); \n\tassign out_anotb = a & ~b;\n\t\nendmodule\n\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;\n\tassign out_or  = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "gates", "completion": "\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = a ~^ b;\n\tassign out_anotb = a & ~b; \n\t\nendmodule\n\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = a ~^ b;\n\tassign out_anotb = a & ~b; \nendmodule\n"}
{"task_id": "gates", "completion": "\n    assign out_and = a && b;\n\tassign out_or =  a || b; \n\tassign out_xor = a ^^ b; \n\tassign out_nand = ~(a && b); \n\tassign out_nor = ~(a || b); \n\tassign out_xnor =  ~(a ^^ b); \n\tassign out_anotb= a && ~b; \nendmodule\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;  // Outputs the AND result of inputs a and b.\n\tassign out_or = a | b;   // Outputs the OR result of inputs a and b.\n\tassign out_xor = a ^ b;  // Outputs the XOR result of inputs a and b.\n\tassign out_nand = ~(a & b);  // Outputs the NAND result of inputs a and b.\n\tassign out_nor = ~(a | b);   // Outputs the NOR result of inputs a and b.\n\tassign out_xnor = (~a ^ b) ;// Outputs the XNOR result of inputs a and b.\n\tassign out_anotb = a & ~b;  // Outputs the AND-NOT result of inputs a and not b.\nendmodule\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "gates", "completion": "\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule\n\n"}
{"task_id": "gates", "completion": "\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor =  ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule \n"}
{"task_id": "gates", "completion": "\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\nendmodule\n\n"}
{"task_id": "gates", "completion": "\n\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = a ~^ b;\n\tassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "gates", "completion": "\n    assign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor =  ~((a ^ b));\n\tassign out_anotb = a & ~b; \nendmodule  \n"}
{"task_id": "wire_decl", "completion": "\n    wire w1; // Declare the intermediate wires \n    wire w2;\n    \n    assign w1 = a & b;   // Connect the first layer of AND gates to `w1` and `w2`.\n\tassign w2 = c & d;\n\tassign out = w1 | w2;\t// The OR gate connects these outputs to 'out'.\n\tassign out_n = ~out;  // The NOT gate connects the output of 'out' to 'out_n'.\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\t// Intermediate wires\n\twire w1; \n\twire w2;\n  \n\tassign w1 = a & b; // AND gate (connected to 'a' and 'b')\n\tassign w2 = c & d; // AND gate (connected to 'c' and 'd')\n\tassign out = w1 | w2;  // OR gate connected to the two AND outputs.\n\tassign out_n = ~out;   // NOT gate for inverted output.\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n  \n\twire and1;\n\twire and2;\n\t\n\tassign and1 = a & b;  // first AND gate\n\tassign and2 = c & d;  // second AND gate\n\t\n\tassign out = and1 | and2;  // OR of the two AND outputs\n\tassign out_n = ~out;  // inverted output\n\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\t// Intermediate wires are not necessary in this case as the circuit can be directly constructed without them. \n\tand_gate1 and_gate (\n\t\t.a(a),\n\t\t.b(b),\n\t\t.out(wire1)\n\t);\n  \n\tand_gate2 and_gate (.a(c), .b(d), .out(wire2));\n\t\t\n\t// OR gate.\n\tor_gate or_gate (.a(wire1), .b(wire2), .out(out));\n\n    // NOT gate to get inverted output. \n   not_gate not_gate (.in(out), .out(out_n));\n\t\t\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n  wire and1;\n  \n  assign and1 = a & b; // first AND gate\n  \n  assign out = ~(and1 & c & d); // second AND gate then NOT\n    \n  assign out_n = ~out; // inverted output\nendmodule\n\n"}
{"task_id": "wire_decl", "completion": "\n\twire wire1; //any name for intermediate wire\n    \n    assign wire1 = a & b;\n    assign out = wire1 & c & d;\n    assign out_n = ~out; \nendmodule\n\n"}
{"task_id": "wire_decl", "completion": "\nwire w1;\n\nassign w1 = a & b; // First AND gate\n\nout <= (c & d) | w1;  // Second AND and OR gates with inverted output\n\nassign out_n = ~(a & b);  \nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\twire w1; // intermediate wire\n    \n    assign w1 = a & b;       // First AND gate connected to inputs a and b\n    assign out = c & d;      // Second AND gate connected to inputs c and d. Output is OR of the two AND outputs. \n    assign out_n = ~(w1 | out);   // NOT gate on OR output\n    \nendmodule\n\n"}
{"task_id": "wire_decl", "completion": "\n\twire w1;\n\twire w2;\n\n\t// First layer of gates \n\tand (w1, a, b); // first AND gate\n\tand (w2, c, d); // second AND gate\n\n\t// Second layer of gates\n\tor (out, w1, w2); // OR gate\n    assign out_n = ~out; // NOT gate\nendmodule \n"}
{"task_id": "wire_decl", "completion": "\n    \n\twire ab; //intermediate wire\n    wire cd; //intermediate wire\n    \n    assign ab = a & b;  // First AND gate\n    assign cd = c & d;  // Second AND gate\n    assign out = ab | cd ;  // OR gate\n  \n    assign out_n = ~out;  // NOT gate on 'out'\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\twire w1; // First intermediate wire\n\twire w2; // Second intermediate wire\n\t\n\t// Layer one - two AND gates connected to a and b as well as c and d. \n\tassign w1 = a & b;\n\tassign w2 = c & d;\n\t\n\t// The output is the OR of these two AND outputs, also the inverted output.\n\tassign out = w1 | w2;\n\tassign out_n = ~(w1 | w2);\nendmodule \n"}
{"task_id": "wire_decl", "completion": "\n\t// Declare the intermediate wire to connect AND and OR gates\n\twire inter; \n  \n\t// First layer of the circuit composed of two AND gates\n\tassign inter = a & b; // AND gate 1\n\n\twire final_and = c & d; // AND gate 2\n\t\n\t// Second layer: OR gate to OR the first AND outputs, connected the output 'out'\n\tassign out = inter | final_and; \n  \n\t// Inverted output 'out_n'\n\tassign out_n = ~out;\n"}
{"task_id": "wire_decl", "completion": "\n  wire and1; // declare first intermediate wire\n  wire and2; // declare second intermediate wire\n  \n  assign and1 = a & b; // calculate first AND gate\n  assign and2 = c & d; // calculate second AND gate\n  assign out = and1 | and2; // calculate OR gate from the results of two AND gates\n  assign out_n = ~out;      // NOT operation on 'out' is given by `out_n`\n  \nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\t// intermediate wires\n\twire ab;\n\twire cd;\n\t\n\tand #50 a1 (ab, a, b); //AND gate for inputs a and b\n\tand #50 c2 (cd, c, d); //AND gate for inputs c and d\n\tor  #50 o1 (out, ab, cd); //OR gate to combine the two AND outputs\n\tnot #50 n1 (out_n, out); //NOT gate to invert 'out'\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\twire wire1;\n\tassign out = wire1 & (c | d);\n\tassign out_n = ~out;\n\tand AND1(wire1, a, b); \nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\twire w1; // intermediate wire\n\twire w2; // other intermediate wire\n\n\t// define the gates and their connections\n\tassign w1 = a & b;   // first AND gate\n\tassign w2 = c & d;   // second AND gate\n\tassign out = w1 | w2;  // OR gate\n\tassign out_n = ~out;  // NOT gate, connects to the output of the OR gate\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\t// declaring intermediate wire\n\twire inter;\n    \n    // assigning values to intermediate wires based on the given circuit\n\tassign inter = (a & b) | (c & d);\n     \n    // final output signals\n\tassign out = inter;\n\tassign out_n = ~out; \n\n"}
{"task_id": "wire_decl", "completion": "\n\n\t// Declare the intermediate wires\n\twire ab;\n\twire cd;\n\t\n\t// Implement the first layer of AND gates and OR gate.\n\tassign ab = a & b;\n\tassign cd = c & d;\n\tassign out = | (ab,cd);  // Use parantheses to denote multiple inputs to OR gate.\n\tassign out_n = ~out;     // This is the NOT gate for 'out' output.\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\n\t//Declare intermediate wires to connect AND and OR gates together. \n\twire wire1; // Intermediate wire for the first layer of AND gates.\n\twire wire2; // Intermediate wire for the second layer of AND gate and OR gate.\n\t\n\t//Create the two layers: Two AND gates connected in a row, followed by an OR gate.\n\tassign wire1 = a & b; \n\tassign wire2 = c & d;  \n\tassign out = wire1 | wire2; // Output 'out' is OR of first and second layer.\n\t\n\t//Inverted output 'out_n'. It inverts the output of the circuit i.e., NOT(out). \n\tassign out_n = ~out;  \nendmodule \n"}
{"task_id": "wire_decl", "completion": "\n\t// Declare the intermediate wires.\n\twire ab; // AND of a and b\n\twire cd; // AND of c and d\n\t\n\t// Implement the first layer (AND gates)\n\tassign ab = a & b; \n\tassign cd = c & d;\n\t\t\n\t// Implement the second layer (OR gate, NOT gate)\n\tassign out = ab | cd;\n\tassign out_n = ~out; // The output is inverted.\n\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire and1;\n\twire and2;\n\twire and3;\n\twire and4;\n\n\tassign and1 = p1a & p1b & p1c;\n\tassign and2 = p1d & p1e & p1f;\n\tassign and3 = p2a & p2b;\n\tassign and4 = p2c & p2d;\n\t\n\tassign p1y = and1 | and2;\n\tassign p2y = and3 | and4;\nendmodule\n"}
{"task_id": "7458", "completion": "\n\t// declaring intermediate wires for use in internal AND/OR gates.\n\twire w1;\n\twire w2;\n\twire w3;\n\twire w4;\n\n\t// calculating output 'p1y' using the logic expression of 7458 IC\n\tassign p1y = (w1 | ((p1a & p1b & p1c) | (p1d & p1e & p1f)));\n\t\n\t// calculating intermediate signal 'w1' for use in internal AND/OR gates.\n\tassign w1 = p2a | p2b;\n\t\n\t// calculating output 'p2y' using the logic expression of 7458 IC\n\tassign p2y = (w3 | ((p2c & p2d) | w4));\n\t\n\t// calculating intermediate signals 'w2', 'w3', and 'w4' for use in internal AND/OR gates.\n\tassign w2 = p1a & p1b & p1c;\n\tassign w3 = p2c & p2d;\n\tassign w4 = w2 | (p1d & p1e & p1f);\n\t\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire p1_temp1; // wire between AND gate outputs and OR output\n\twire p1_temp2;\n\t\n\t// defining inputs for first group of AND gates (p1a - p1f)\n\tassign p1y = ((((p1a & p1b) & p1c) | ((p1d & p1e) & p1f)) == 1'b1); // OR gate between 2 AND groups for p1y\n\t\n\t// defining inputs for second group of AND gates (p2a - p2d)\n\tassign p2y = ((((p2a & p2b) | ((p2c & p2d)) == 1'b1)); // OR gate between 2 AND groups for p2y\n\t\nendmodule\n"}
{"task_id": "7458", "completion": "\nwire p1ab;\nwire p1cd;\nassign p1ab = p1a & p1b & p1c;\nassign p1cd = p1d & p1e & p1f;\nassign p1y = p1ab | p1cd;\n\nwire p2ab;\nwire p2cd;\nassign p2ab = p2a & p2b;\nassign p2cd = p2c & p2d;\nassign p2y = p2ab | p2cd;\nendmodule \n"}
{"task_id": "7458", "completion": "\n    wire a; // intermediate wire for the AND operation in p1y\n\twire b; // intermediate wire for the AND operation in p2y\n\n\tassign a = (p1a & p1b & p1c) | (p1d & p1e & p1f); \n   assign p1y = p1a | p1b | p1c | a; // output of the first AND gate and its OR operation\n\tassign b = (p2a & p2b) | (p2c & p2d);\n   assign p2y = p2a | p2b | b; // output of second AND gate and its OR operation\nendmodule\n\n"}
{"task_id": "7458", "completion": "\n\twire p1_and1;\n\twire p1_and2;\n\twire p1_or1;\n\t\n\tassign p1y = p1_or1; // OR gate for first set of inputs\n\tassign p1_and1 = p1a & p1b & p1c; \n\tassign p1_and2 = p1d & p1e & p1f; \n\tassign p1_or1 = p1_and1 | p1_and2; // OR gate for second set of inputs\n\t\t\n\twire p2_and1;\n\twire p2_and2;\n\twire p2_or1;\n\t\n\tassign p2y = p2_or1;  // OR gate for first set of inputs\n\tassign p2_and1 = p2a & p2b; \n\tassign p2_and2 = p2c & p2d; \n\tassign p2_or1 = p2_and1 | p2_and2; // OR gate for second set of inputs\n\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire p1_and1, p1_and2; //intermediate wire declaration for AND gates.\n\tassign p1_and1 = (p1a & p1b & p1c);\n\tassign p1_and2 = (p1d & p1e & p1f); \n\n\twire p2_and1, p2_and2; //intermediate wire declaration for AND gates.\n\tassign p2_and1 = (p2a & p2b);\n\tassign p2_and2 = (p2c & p2d);\n\t\t\n\t//Output assignment using OR gate operation on intermediate signals\n\tassign p1y = p1_and1 | p1_and2; \n\tassign p2y = p2_and1 | p2_and2; \nendmodule\n\n"}
{"task_id": "7458", "completion": "\n\twire w1,w2; //declaring intermediate wires\n\n\tassign w1 = (p1a & p1b & p1c) | (p1d & p1e & p1f); \n\tassign p1y = w1;  \n\t\t\n\tassign w2 = (p2a & p2b) | (p2c & p2d);  \n\tassign p2y = w2; \nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire p1_and1;\n\twire p1_and2;\n\tassign p1_and1 = p1a & p1b & p1c;\n\tassign p1_and2 = p1d & p1e & p1f;\n\tassign p1y = p1_and1 | p1_and2;\n\t\n\twire p2_and1;\n\twire p2_and2;\n\tassign p2_and1 = p2a & p2b;\n\tassign p2_and2 = p2c & p2d;\n\tassign p2y = p2_and1 | p2_and2;\nendmodule\n"}
{"task_id": "7458", "completion": "\nwire g1, g2; // intermediate signals\n  \nassign g1 = p1a & p1b & p1c;\nassign g2 = p1d & p1e & p1f; \n\nassign p1y = ~(g1 | g2); \n\nassign g1 = p2a & p2b;\nassign g2 = p2c & p2d;\n  \nassign p2y = ~(g1 | g2);\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire p1x, p2x;\n\t\n\t//p1y = (p1a AND p1b AND p1c) OR (p1d AND p1e AND p1f)\n\tassign p1x = p1a & p1b & p1c | p1d & p1e & p1f; \n\tassign p1y = p1x; // No need for an extra AND gate here. The output is directly connected to the input of another AND gate.\n\t\n\t//p2y = (p2a AND p2b) OR (p2c AND p2d)\n\tassign p2x = p2a & p2b | p2c & p2d; \n\tassign p2y = p2x; // No need for an extra AND gate here. The output is directly connected to the input of another AND gate.\n\t\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire p1ab, p1cd, p1ef; // intermediate wires for the two AND gates in p1y.\n\tassign p1ab = p1a & p1b & p1c; \n    assign p1cd = p1d & p1e & p1f;\n    assign p1y = p1ab | p1cd; // final output of first AND gate and second\n    \n\twire p2ab, p2cd;       // intermediate wires for the two AND gates in p2y.\n\tassign p2ab = p2a & p2b; \n    assign p2cd = p2c & p2d;\n    assign p2y = p2ab | p2cd; // final output of first AND gate and second\n    \nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire w_p1ab,w_p1cd;\n\tassign w_p1ab = p1a & p1b & p1c;\n\tassign w_p1cd = p1d & p1e & p1f;\n\tassign p1y=w_p1ab | w_p1cd;\n\n\twire w_p2ab,w_p2cd;\n\tassign w_p2ab = p2a & p2b;\n\tassign w_p2cd = p2c & p2d;\n\tassign p2y=w_p2ab | w_p2cd;\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire and_out1;\n\twire and_out2;\n\twire and_out3;\n\twire and_out4;\n\t\n\t// 7458 AND Gate outputs for p1\n\tassign and_out1 = p1a & p1b & p1c;\n\tassign and_out2 = p1d & p1e & p1f;\n\t\n\t// 7458 OR Gates for p1y\n\tassign p1y = and_out1 | and_out2;\n\t\n\t// 7458 AND Gate outputs for p2\n\tassign and_out3 = p2a & p2b;\n\tassign and_out4 = p2c & p2d;\n\t\n\t// 7458 OR Gates for p2y\n\tassign p2y = and_out3 | and_out4;\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire a;\n\tassign a = (p1a & p1b & p1c) | (p1d & p1e & p1f);\n\tassign p1y = a;\n\t\n\twire b;\n\tassign b = (p2a & p2b) | (p2c & p2d);\n\tassign p2y = b;\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire temp_and1;\n    wire temp_and2;\n    \n    assign temp_and1 = p1a & p1b & p1c;\n    assign temp_and2 = p1d & p1e & p1f;\n    assign p1y = temp_and1 | temp_and2;  // OR of two ANDs\n    \n    wire temp_and3;\n    wire temp_and4;\n    \n    assign temp_and3 = p2a & p2b;\n    assign temp_and4 = p2c & p2d;\n    assign p2y = temp_and3 | temp_and4;  // OR of two ANDs\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire wp1, wp2;\n    \n    assign wp1 = (p1a & p1b & p1c) | (p1d & p1e & p1f); \n    assign p1y = wp1;\n     \n    assign wp2 = (p2a & p2b) | (p2c & p2d);\n    assign p2y = wp2;\t\nendmodule\n"}
{"task_id": "7458", "completion": "\n\twire p3;\n\twire p4;\n\t\n\t// First AND gate is for inputs (p1a, p1b and p1c)\n\t// Second AND gate is for inputs (p1d, p1e and p1f)\n\tassign p3 = p1a & p1b & p1c;\n\tassign p4 = p1d & p1e & p1f;\n\t\n\t// Output from the first OR gate is AND of outputs of the above 2 AND gates\n\tassign p1y = ~(p3 | p4); // Using ~ as XOR Gate. Because output should be HIGH only when exactly one of the inputs are TRUE (not both) for NAND to OR logic circuit to work.\n\n\t// First AND gate is for inputs (p2a and p2b)\n\t// Second AND gate is for inputs (p2c and p2d)\t\n\tp3 = ~(p2a & p2b);\n\tp4 = ~(p2c & p2d);\n\t\n\t// Output from the second OR gate is AND of outputs of the above 2 AND gates\n\tassign p2y = ~(p3 | p4); // Using ~ as XOR Gate. Because output should be HIGH only when exactly one of the inputs are TRUE (not both) for NAND to OR logic circuit to work.\nendmodule\n"}
{"task_id": "7458", "completion": "\n\t// Wires for intermediate signals in the 7458 logic function.\n\twire temp_1;\n\twire temp_2;\n\twire temp_3;\n\twire temp_4;\n\t\t\n\tassign temp_1 = p1a & p1b & p1c;\n\tassign temp_2 = p1d & p1e & p1f;\n\tassign temp_3 = p2a & p2b;\n\tassign temp_4 = p2c & p2d;\n\t\t\n\t// Output assignments.\n\tassign p1y = temp_1 | temp_2; \n\tassign p2y = temp_3 | temp_4; \nendmodule\n"}
{"task_id": "7458", "completion": "\n\n\twire w1,w2; // intermediate wires for AND operations.\n\t\t\n\t//First Group of ANDs\n\tassign w1 = (p1a & p1b & p1c) | (p1d & p1e & p1f); \n\t\n\t//Output gate \n\tassign p1y = w1; \n\t\t  \n    //Second Group of ANDs\n\tassign w2 = (p2a & p2b) | (p2c & p2d);\n\t\t  \n    // Second Output gate\n\tassign p2y = w2; \n\t\nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\n\t// Define states as follows: A = 3'b001, B = 3'b010, C = 3'b011, D = 3'b100, E = 3'b101 and F = 3'b110.\n\treg [2:0] state;\n\twire [2:0] nxt_state;\n\t\n\t// State flip-flops\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1) \n\t\t\tstate <= 3'b001; // Reset into A state\n\t\telse\n\t\t\tstate <= nxt_state;\n\tend\n\t\n\t// State table\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t3'b001: if (!w) nxt_state <= 3'b001; else nxt_state <= 3'b010;  // A to B when w=0, or stay at A when w=1\n\t\t\t3'b010: if (!w) nxt_state <= 3'b010; else nxt_state <= 3'b001;  // B to A when w=0, or stay at B when w=1\n\t\t\t3'b011: if (!w) nxt_state <= 3'b011; else nxt_state <= 3'b100;  // C to E when w=0, or stay at C when w=1\n\t\t\t3'b100: if (!w) nxt_state <= 3'b100; else nxt_state <= 3'b101;  // D to F when w=0, or stay at E when w=1\n\t\t\t3'b101: if (!w) nxt_state <= 3'b101; else nxt_state <= 3'b010;  // E to B when w=0, or stay at D when w=1\n\t\t\t3'b110: if (!w) nxt_state <= 3'b110; else nxt_state <= 3'b001;  // F to A when w=0, or stay at C when w=1\n\t\t\tdefault: nxt_state <= 3'b001; // Default back to A (Reset state)\n\t\tendcase\n\tend\n\t\n\t// Assigning z output based on the current state. For instance: \n\t// State A is 0, B is 2 and all other states have arbitrary values as per description given in question.\n\tassign z = (state == 3'b001) ? 1'b0 :  // State A is 0\n\t\t   (state == 3'b010) ? 1'b2 :  // State B is 2\n\t\t   (state == 3'b011) ? 1'b4 :  // State C is 4 and so on...\n\t\t   (state == 3'b100) ? 1'b8 :\n\t\t   (state == 3'b101) ? 1'b6 :\n\t\t   (state == 3'b110) ? 1'b5 : 1'bx; // 'x' for undefined states\n\t\nendmodule\n\n"}
{"task_id": "2012_q2fsm", "completion": " \n\treg [2:0] state; // State Flip-flop\n    reg       _z;   // Output Z\n    \n\t//State Table & flip flops\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 3'b000;\n        else \n            case ({w, state[2:1]}) //Concatenation for 4-State encoding \n                4'h0 : if(!state[0])   state <= 3'b000; else state <= 3'b000; // A -> 000 when w=0 \n                4'h1 : if(state[0])    state <= 3'b001; else state <= 3'b010; // B -> 001 when w=1\n                4'h2 : if(!state[0])   state <= 3'b010; else state <= 3'b011; // A -> 010 when w=0 \n                4'h3 : if(state[0])    state <= 3'b011; else state <= 3'b100; // B -> 011 when w=1\n                4'h4 : if(!state[0])   state <= 3'b100; else state <= 3'b101; // A -> 100 when w=0 \n                4'h5 : if(state[0])    state <= 3'b101; else state <= 3'b110; // B -> 101 when w=1\n                4'h6 : if(!state[0])   state <= 3'b110; else state <= 3'b111; // A -> 110 when w=0 \n                4'h7 : if(state[0])    state <= 3'b111; else state <= 3'b000; // B -> 111 when w=1\n            endcase\n\tend\n    \n\t//Assigning output Z based on current state\n\tassign _z = (state == 3'b111); \n    assign z = _z; \nendmodule\n\n"}
{"task_id": "2012_q2fsm", "completion": "\nreg [2:0] state;  //State flip-flops\n\n// State table\nalways @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\tstate <= 3'b001;   // Reset into A, which is represented by '001' in a 3 bit state space.\n\telse\n\t\tcase ({w, state})\t \t// The concatenation of input w and the current state gives us a unique case for every possible combination.\n\t\t\t5'b1_001: state <= 3'b001; // A ->  A from 0\n\t\t\t5'b0_001: state <= 3'b010; // A ->  B from 0\n\t\t\tdefault : state <= state;  \n\t\t\t5'b1_010: state <= 3'b010; // B ->  B from 0\n\t\t\t5'b0_010: state <= 3'b011; // B ->  C from 0\n\t\t\t5'b1_011: state <= 3'b011; // C ->  C from 0\n\t\t\t5'b0_011: state <= 3'b100; // C ->  D from 0\n\t\t\t5'b1_100: state <= 3'b100; // D ->  D from 0\n\t\t\t5'b0_100: state <= 3'b101; // D ->  E from 0\n\t\t\t5'b1_101: state <= 3'b101; // E ->  E from 1\n\t\t\t5'b0_101: state <= 3'b110; // E ->  D from 0\n\t\t\t5'b1_110: state <= 3'b110; // F ->  F from 1\n\t\t\t5'b0_110: state <= 3'b001; // F ->  A from 0\n\t\tendcase\nend\n\n// Output function\nassign z = (state == 3'b011);   // z is True when the current state is C. You can change this condition as per your needs.\n\nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\n\treg [2:0] state; // 3-bit flip flop to represent states A, B, C, D, E, F\n\n\t// State table\n\talways @(state or w) begin\n\t  case ({w,state}) \n\t\t  4'b1000 : z <= 1'b0; // state E when w = 1 -> output z = 0\n\t\t  4'b1001 : z <= 1'b0; // state E when w = 0 -> output z = 0\n\t\t  default: z <= 1'b1;\n\t  endcase\t\n\tend\n\n\t// State flip-flops\n\talways @(posedge clk or posedge reset) begin  \n\t    if (reset == 1) \n\t        state <= 3'b000; // Reset state into A = 000\n    \telse case (state) \n        \t3'b000 : state <= w ? 3'b001 : 3'b000; // From A to B if w == 0, stay in A if w == 1\n        \t3'b001 : state <= w ? 3'b010 : 3'b000; // From B to C if w == 0, stay in A if w == 1\n        \t3'b010 : state <= w ? 3'b011 : 3'b001; // From C to D if w == 0, go to E if w == 1\n        \t3'b011 : state <= w ? 3'b100 : 3'b010; // From D to E if w == 0, go back to B if w == 1\n        \t3'b100 : state <= w ? 3'b101 : 3'b011; // From E to F if w == 0, go back to C if w == 1\n        \tdefault: state <= w ? 3'b010 : 3'b000; // From F to A if w == 0, stay in B if w == 1\n      \tendcase  \n    end  \n    \nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\n\n\treg [2:0] current_state; // 3-bit state registers.\n    reg next_reset;\n\n\t//State Table and State flip flops (sequential logic)\n\talways @(posedge clk or posedge reset) begin\n\t    if(reset) \n            current_state <= 3'b001; // go to state A on reset.\n        else  \n\t\t    case({w,current_state[2:1]}) //input concatenated with MSBs of the current state.\n\t\t\t    4'b00_00 :  current_state <= 3'b001;// A --0--> A\n\t\t\t\t4'b00_01 :  current_state <= 3'b001; // A --0--> B (wrong state change, back to A)\n\t\t\t    4'b00_10 :  current_state <= 3'b001;// A --0--> C (wrong state change, back to A)\n\t\t\t\t4'b00_11 :  current_state <= 3'b010; // A --0--> D\n\t\t\t    4'b01_00 :  current_state <= 3'b001;// B --0--> A (wrong state change, back to A)\n\t\t\t\t4'b01_01 :  current_state <= 3'b001; // B --0--> B (wrong state change, back to A)\n\t\t\t    4'b01_10 :  current_state <= 3'b011; // B --0--> C\n\t\t\t\t4'b01_11 :  current_state <= 3'b010; // B --0--> D\n\t\t\t    4'b10_00 :  current_state <= 3'b100;// C --0--> A (wrong state change, back to E)\n\t\t\t\t4'b10_01 :  current_state <= 3'b001; // C --0--> B (wrong state change, back to A)\n\t\t\t    4'b10_10 :  current_state <= 3'b100;// C --0--> C (correct state stay at E)\n\t\t\t\t4'b10_11 :  current_state <= 3'b101; // C --0--> D\n\t\t\t    4'b11_00 :  current_state <= 3'b110;// D --0--> A (correct state change to F)\n\t\t\t\t4'b11_01 :  current_state <= 3'b010; // D --0--> B (wrong state change, back to C)\n\t\t\t    4'b11_10 :  current_state <= 3'b110;// D --0--> C (correct state stay at F)\n\t\t\t\t4'b11_11 :  current_state <= 3'b111; // D --0--> D (wrong state change, back to F)\n\t\t\tendcase\n    end  \n\t//Output logic: continuous assignment statements.\n\tassign z = (current_state == 3'b110);// 1 if current state is 'F', else 0. \n    \nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\nreg [2:0] state; // State register 3 bit for 6 states\nwire [1:0] nextState; \n\n// Next-state logic (combinational)\nalways @(*) begin \n\tcase (state)\n\t\t3'b000: if (!w) nextState = 2'b00; else nextState = 2'b01; // A ->  B / A\n\t\t3'b001: if (!w) nextState = 2'b00; else nextState = 2'b10; // B -> C / D \n\t\t3'b010: if (!w) nextState = 2'b11; else nextState = 2'b10; // C -> E / D\n        3'b011: if (!w) nextState = 2'b01; else nextState = 2'b10; // D -> F / A \n\t\t3'b100: if ( w) nextState = 2'b10; else nextState = 2'b11; // E -> E / D\n        3'b101: if ( w) nextState = 2'b01; else nextState = 2'b11; // F -> C / D\n\t\tdefault: nextState = 2'b00; \n\tendcase\nend\n\n// State flip-flop with synchronous reset\nalways @(posedge clk or posedge reset) begin \n\tif (reset) state <= 3'b000; // Reset to A\n\telse state <= nextState; // Otherwise, go to next state\nend\n\t\n// Output logic (combinational)\nassign z = (state == 3'b100 || state ==  3'b101); //z is '1' if in states E or F else '0'. \n\nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\n\treg [1:0] state;  // State flip-flop\n    \n\t// State table\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) \n\t\t    state <= 2'b00; // Reset state is A = 2'b00\n        else case ({state, w})  \n            4'b0001: state <= 2'b01; // A to B on 0\n            4'b0000: state <= state; // A to A on 0\n            4'b0101: state <= 2'b10; // B to C on 0\n            4'b0100: state <= 2'b11; // B to D on 0\n            4'b1001: state <= 2'b10; // C to E on 0\n            4'b1000: state <= 2'b11; // C to D on 0\n            4'b1101: state <= 2'b00; // D to F on 0\n            4'b1100: state <= 2'b00; // D to A on 0\n            4'b0011: state <= state; // E to E on 1\n            4'b0010: state <= 2'b11; // E to D on 0\n            4'b0111: state <= 2'b00; // F to C on 1\n            4'b0110: state <= 2'b11; // F to D on 0\n            default : state <= state;\n        endcase\n\tend\n    \n\t// Output logic\n    assign z = (state == 2'b10); // Z is true when in state C, i.e., 2'b10\n\t\nendmodule\n\n"}
{"task_id": "2012_q2fsm", "completion": "\n\treg [1:0] state;\n\twire [2:0] next_state; // 3-bit for states A(0), B(1) and C(2). Similarly add D(3), E(4), F(5).\n\tassign z = (state == 2'b00) || (state == 2'b01);\n\t\n\t// State table\n\talways @(*) begin\n\t\tcase (state) \n\t\t\t2'b00: next_state = w ? 3'b00 : 3'b01; // A to A when w=0 or remain A when w=1\n\t\t\t2'b01: next_state = w ? 3'b00 : 3'b00; // B to A when w=0 or remain B when w=1\n\t\t\t2'b10: next_tate = w ? 3'b11 : 3'b01; // C to D when w=0 or E when w=1\n\t\t\t2'b11: next_state = w ? 3'b10 : 3'b01; // D to B when w=0 or F when w=1\n\t\t\tdefault: next_state = 3'b00;             // default state A.\n\t\tendcase\n\tend\n\t\n\t// State flip-flops\n\talways @(posedge clk) begin \n\t\tif (reset) \n\t\t\tstate <= 2'b00; // Reset to A\n\t\telse \n\t\t\tstate <= next_state[1:0]; // Update the state. We use only last two bits of 'next_state'.\n\tend\n\t\nendmodule\n\n"}
{"task_id": "2012_q2fsm", "completion": "\n\t// Define states\n\tlocalparam [1:0] A = 2'b00;\n\tlocalparam [1:0] B = 2'b01;\n\tlocalparam [1:0] C = 2'b10;\n\tlocalparam [1:0] D = 2'b11;\n\t// Output state\n\treg [1:0] current_state, next_state;\n\n\t// State Flip-Flops\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tcurrent_state <= A;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase ({w, current_state}) \n\t\t\t2'b00: next_state = B; // From State A when w = 0 to State B\n\t\t\t2'b01: next_state = A; // From State A when w = 1 stays in state A\n\t\t\t2'b10: next_state = C; // From State B when w = 0 to State C\n\t\t\t// And so on for other transitions\n\t\tendcase\n\tend \n\n\t// Output logic - z\n\tassign z = (current_state == D); // If in state D, z is asserted. Change this line as per the requirement.\nendmodule\n\n"}
{"task_id": "2012_q2fsm", "completion": "\n\t// Define states using enum data type for better readability\n    typedef enum logic [2:0] {A = 3'b001, B = 3'b000, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101} state_t;\n    state_t state, next_state;  // current and next state declaration\n    \n\t // State table: Implemented with combinational logic using case statement\n    always_comb begin\n        unique case ({w, state})\n            {1'b0, A}: next_state = B;\n            {1'b0, B}: next_state = A;\n            {1'b0, C}: next_state = D;\n            {1'b0, D}: next_state = E;\n            {1'b0, E}: next_state = F;\n            {1'b0, F}: next_state = A;\n            {1'b1, A}, {1'b1, B}: next_state = state; // remain in current state if w=1 in states A and B\n\t\t\tdefault: next_state = A;   // default to A when anything else is encountered\n        endcase\n    end\n    \n\t// Flip-flops: Implemented with sequential logic using always block\n    always @(posedge clk or posedge reset) begin\n\t\tif (reset)  state <= A;  // active high synchronous reset, returning to initial/default state upon asserting reset.\n        else        state <= next_state;   // non-blocking assignment of the next state\n    end\n    \n\t// Output logic: Assuming 'z' as output when in states E and F i.e., if current state is either E or F then z = 1 otherwise z = 0\n\tassign z = (state == E || state == F);  \nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\nreg [1:0] state; // State flip-flops\nwire a = (state==2'b00) && !w;\nwire b = (state==2'b00) &&  w;\nwire c = (state==2'b01) && !w;\nwire d = (state==2'b01) &&  w;\nwire e = (state==2'b10) && !w;\nwire f = (state==2'b10) &&  w;\nreg [1:0] next_state; // Next state logic\n\n// State table\nassign z = (state == 2'b00) || (state == 2'b11);\n\nalways @(*) begin\n\tif      (a) next_state = 2'b00; \n\telse if (b) next_state = 2'b00; \n\telse if (c) next_state = 2'b01; \n\telse if (d) next_state = 2'b10;  \n\telse if (e) next_state = 2'b10; \n\telse if (f) next_state = 2'b11; \nend\n\nalways @(posedge clk or posedge reset) begin // State flip-flops\n\tif (reset) state <= 2'b00;\n\telse       state <= next_state;\nend\n\t\nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\nreg [2:0] state; // define three bit register for the current state\n\n// State table \nalways @(*) begin\n\tcase (state)\n\t\t3'b001: if (!w) state <= 3'b001; else state <= 3'b010; // A --0--> A\n\t\telse if (w) state <= 3'b011; // A --1--> B\n\n\t\t3'b010: if (!w) state <= 3'b010; else state <= 3'b001; // B --0--> D\n\t\telse if (w) state <= 3'b100; // B --1--> C\n\n\t\t3'b011: if (!w) state <= 3'b011; else state <= 3'b100; // C --0--> E\n\t\telse if (w) state <= 3'b010; // C --1--> D\n\n\t\t3'b100: if (!w) state <= 3'b100; else state <= 3'b011; // D --0--> F\n\t\telse if (w) state <= 3'b001; // D --1--> A\n\n\t\t3'b101: if (!w) state <= 3'b101; else state <= 3'b001; // E --0--> A\n\t\telse if (w) state <= 3'b011; // E --1--> B\n\n\t\t3'b110: if (!w) state <= 3'b110; else state <= 3'b001; // F --0--> A\n\t\telse if (w) state <= 3'b010; // F --1--> D\n\n\tendcase \t\t\nend  \n\n// State flip flops\nalways @(posedge clk or posedge reset) begin\n\tif(reset)\n\t\tstate <= 3'b001;\t// reset to state A\nend\n\nassign z = (state == 3'b010 || state == 3'b100); // Outputs 'z' when in states B or D\n"}
{"task_id": "2012_q2fsm", "completion": "\n\t// Define the states as wire data type with 3 bits wide. \n\twire [2:0] state;\n  \n\t// Flip flop for storing the state information\n\talways @ (posedge clk or posedge reset) begin\n\t  if(reset) // reset signal is high\n\t    state <= 3'b0; // go to initial state A\n      else \n        case ({state, w}) // based on current state and input w define next state\n          3'b001: state <= 3'b100; // from state A to B if w is 0\n          3'b000: state <= state;  // stick at same state A if w is also 0\n          3'b011: state <= 3'b101; // from state B to C if w is 0\n          3'b101: state <= 3'b110; // from state D to E if w is 1\n          3'b100: state <= 3'b011; // from state A to B if w is 1\n          3'b010: state <= 3'b111; // from state B to C if w is 1\n          3'b110: state <= 3'b001; // from state E to A if w is 0\n          default: state <= 3'b0;   // for any other combination go back to initial state A.\n        endcase\n\tend\n    \n    assign z = (state == 3'b111); // FSM Output is high when in State F\n      \nendmodule \n"}
{"task_id": "2012_q2fsm", "completion": "\n    reg [3:0] state; // 4-bit flip flop for the states\n    \n    parameter A = 4'b0000, B = 4'b0001, C = 4'b0010, D = 4'b0011, E = 4'b0100, F = 4'b0101; // State codes\n    \n    always @(posedge clk or posedge reset) begin  // Synchronous state flip flop with asynch. reset\n        if (reset == 1'b1)\n            state <= A;\n        else case(state)\n            \tA: if (w == 1'b0) state <= B;\n               \telse state <= A;\n            \tB: if (w == 1'b0) state <= D;\n              \t \telse state <= C;\n            \tC: if (w == 1'b0) state <= E;\n                \telse state <= D;\n             \tD: if (w == 1'b1) state <= F; \n                \telse state <= A;\n           \tE: if (w == 1'b1) state <= E;\n               \telse state <= D;\n            \tF: if (w == 1'b1) state <= C;\n              \t \telse state <= D;\n         endcase\n     end \n     \n    // Continuous Assignment for the output z. Depending on current state, it gives either 0 or not 0.\n    assign z = ((state == E) || (state == F)) ? 1'b1 : 1'b0;  \nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\nreg [1:0] state; // Two bit flip flops for the states A-E and F \n\n// State Table\nalways @(*) begin\n\tcase (state)\n\t\t2'b00: if (!w) state <= 2'b00; else state <= 2'b01; //A to B, or stay in A\n\t\t2'b01: if (!w) state <= 2'b00; else state <= 2'b10; //B to C, or A \n\t\t2'b10: if (!w) state <= 2'b01; else state <= 2'b11; //C to E, or B\n\t\t2'b11: if (!w) state <= 2'b01; else state <= 2'b00; //D to F, or C \n\tendcase\nend\n\n// Output z is defined as the second bit of the state code (0 indexed). \nassign z = state[1];\n\n// Reset State Register on reset signal.\nalways @(posedge reset) begin\n\tstate <= 2'b00; //Back to A\nend\n\nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\n\t// Declare the states \n\ttypedef enum {A=0,B=1,C=2,D=3,E=4,F=5} state_type;\n\tstate_type current_state, next_state; // State flip-flops\n\t\n\t// State table\n\talways @(*) begin \n\t\tcase (current_state)  \n\t\t\tA: if (w == 0)    next_state = A; \n\t\t\t\telse         next_state = B;     \n\t\t\tB: if (w == 0)    next_state = A;     //go back to state A when input is '0' and stay at B when it's '1'.\n\t\t\t\telse         next_state = C;  \n\t\t\tC: if (w == 0)    next_state = D; \n\t\t\t\telse         next_state = E;     \n\t\t\tD: if (w == 1)    next_state = F; \n\t\t\t\telse         next_state = A;     //go to state F when input is '1' and go back to A when it's '0'.\n\t\t\tE: if (w == 1)    next_state = E;\n\t\t\t\telse         next_state = D;     \n\t\t\tF: if (w == 1)    next_state = C; \n\t\t\t\telse         next_state = D;       //go to state C when input is '1' and go back to A when it's '0'.\n\t\t\tdefault :          next_state = A;   //to avoid any unwanted behaviour, we assign a default case.\n\t\tendcase \n\tend\n\t\n\t// Output Logic\n\tassign z = (current_state == E || current_state == F);// output '1' when in state E or F\n\t\n\t// Synchronous Reset logic\n\talways @(posedge clk, posedge reset) begin \n\t\tif(reset == 1)     // Asynchronous active high reset\n\t\t\tcurrent_state <= A;   //go back to initial state on reset\n\t\telse                // Else continue with the next state\n\t\t\t current_state <= next_state;      \n\tend\nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\n\t// State Codes\n\tparameter A = 3'b001;\n\tparameter B = 3'b010;\n\tparameter C = 3'b011;\n\tparameter D = 3'b100;\n\tparameter E = 3'b101;\n\tparameter F = 3'b110;\n\t\t\n\t// State Flip-Flops and output\n\treg [2:0] state, next_state;\n\tassign z = (state == E)? 1 : 0;\n\n\t// Next State Logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA : next_state = w? B : A;\n\t\t\tB : next_state = w? C : D;\n\t\t\tC : next_state = w? E : D;\n\t\t\tD : next_state = w? F : A;\n\t\t\tE : next_state = w? E : D;\n\t\t\tF : next_state = w? C : D;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\t\t\n\t// State Register\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= A;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\nendmodule\n\n"}
{"task_id": "2012_q2fsm", "completion": "\n\treg [2:0] current_state; // 3-bit state flip-flops to represent the states A, B, C,..., F. We can use binary codes or hexadecimal codes for more clarity. For instance, we could define A as '3'hA, B as '3'hB and so forth upto '3'hF\n\treg [2:0] next_state;\n\n\t// State table\n\talways @(*) begin\n\t\tcase (current_state) \n\t\t\t'b010 : if (!w) next_state = 'b100; else next_state = 'b011; // A ->  B when w = 0, A -> A when w = 1\n\t\t\t'b011 : if (!w) next_state = 'b000; else next_state = 'b100; // B -> C when w = 0, B->D when w=1 \n\t\t\t...  similarly define all other states and transitions ...\n\t\t\t'b111 : if (!w) next_state = 'b110; else next_state = 'b100; // F -> E when w = 0, F->D when w=1\n\t\t\tdefault: next_state = 'b010; \t// default to state A for reset and any other unrecognized states.\n\t\tendcase\n\tend\n\n\t// State flip-flops with synchronous reset\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) current_state <= 'b010; // reset to state A\n\t\telse current_state <= next_state; \n\tend\n\n\t// Output logic for z which depends on the current state only. We can write this in a single continuous assignment statement or an always block. For instance, we could define that if we are at state E or F then '1' otherwise '0'.\n\tassign z = (current_state == 'b110) | (current_state == 'b111);  // z = 1 when current state is E or F\nendmodule\n\n"}
{"task_id": "2012_q2fsm", "completion": "\n\treg [3:0] q;\t// state flip-flops\n\tassign z = ((q == 4'b111) || (q== 4'b0)) ? 1 : 0; //z is set if the state is either '111' or '000'\n    \n    always @(posedge clk or posedge reset) begin \n        if (reset) \n            q <= 4'b0;\t// reset to A\n        else begin\t\n\t\t\tcase (q) \n\t\t\t\t4'b000:   if (w == 1'b0) q <= 4'b001; // state B if w is 0\n                4'b001:   if (w == 1'b1) q <= 4'b011; else q <= 4'b000; // state A if w is 1\n\t\t\t\t4'b011:\tif(w==1'b0)\tq<=4'b100;\telse q<=4'b010;\t// C or D depending on w\n                4'b010:\tif (w == 1'b1) q <= 4'b100; else q <= 4'b001; // state B if w is 1, A if w is 0\n\t\t\t\t4'b100:   if(w==1'b1)\tq<=4'b101;\telse q<=4'b011;\t// E or F depending on w\n                4'b101:\tif (w == 1'b0) q <= 4'b110; else q <= 4'b010; // D if w is 0, B if w is 1\n\t\t\t\t4'b110:   if(w==1'b1)\tq<=4'b111;\telse q<=4'b001;\t// F or A depending on w\n                4'b111:\tif (w == 1'b0) q <= 4'b000; else q <= 4'b010; // D if w is 0, C if w is 1\n\t\t\tendcase \n        end \n    end \nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\n\t// Define states\n\tlocalparam [1:0] A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] state; // State flip-flop\n  \n    always @(posedge clk or posedge reset) begin  // Synchronous state flip-flop with asynchronous reset\n    \tif (reset)\n      \tstate <= A;\n        else\n        \tcase(state)\n            \tA: if (!w) state <= B;\n                \telse state <= A;\n                B: if (!w) state <= C; \n                   \telse state<=D;\n              \tC: if (!w) state <= E;\n                  \telse state <= D;\n              \tE: if (w) state <= E;  \n                    else state <= D;\n              \tF: if (w) state <= F;\n                \telse state <= D;\n          endcase\n    end\n    \n\t// Define output z based on the current state \n\tassign z = (state == C || state == E || state == F)? 1'b1 : 1'b0; // If in states C,E or F then 'z' is high else it's low.  \nendmodule\n"}
{"task_id": "count_clock", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\thh <= 8'd1;\n\t\t\tmm <= 8'h00;\n\t\t\tss <= 8'h00;\n\t\t\tpm <= 1'b0;\n\t\tend else if (ena) begin\n\t\t\t\tss <= ss + 1;\n\t\t\t\tif(ss == 8'h59)begin\n\t\t\t\t\tss <= 8'h00;\n\t\t\t\t\tmm <= mm + 1;\n\t\t\t\t\tif(mm == 8'h59)begin\n\t\t\t\t\t\tmm <= 8'h00;\n\t\t\t\t\t\thh <= hh + 1;\n\t\t\t\t\t\tif(hh == 8'd12 ) begin\n\t\t\t\t\t\t\thh <= 8'd1;\n\t\t\t\t\t\t\tpm <= ~pm;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\tend\nendmodule\n"}
{"task_id": "count_clock", "completion": "\n\treg [25:0] counter;\n\n\talways @(posedge clk or posedge reset) begin\n\t\t if (reset == 1'b1) begin \n\t\t\t hh <= 8'd1;  //Reset to 12 AM.\n      mm <= 8'd0;  \n      ss <= 8'd0;   \n      pm  <= 1'b0; \n      counter <= {5{6{1'b0}}};// All counters are reset to zero.\n\t\tend\n\t\telse begin\n\t\t\tif (ena == 1'b1)begin\n\t\t\t\tcounter <= counter + 26'd1; // Increment the counter each second by 1.\n    end\n\t\t   hh <= 5'd0+(counter[23:17] % 8'd12);//Update Hour every 420 secs (=420 clk cycles).\n      mm <= {4{6{(ss >= 8'd59)}} , ss[7:4]} + 8'd0 +(counter[23:17] % 8'd12) ;//Update Minute every 60 secs (=60 clk cycles).\n      ss <= {4{6{(mm >= 8'd59)}} , mm[7:4]} + 8'd1; //Increment seconds each second.\n      pm  <= ~pm; //Toggle AM/PM every minute change. \n\t\tend\n\tend\nendmodule\n"}
{"task_id": "count_clock", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin\n            pm <= 1'b0;\n            hh <= 8'd1;\n            mm <= 8'd2;\n            ss <= 8'd0; \n        end\n        else if(ena == 1'b1) begin\n             ss <= (ss==45)?8'd0:{1'b0,ss[7:0]+1};  \n             if(ss==45) begin\n                mm <= {1'b0,mm[7:0] + 1}; \n                 if(mm == 45 && hh < 2#1100) begin  // hour should be less than 12 (16d) to make sure it doesnt go over 2 digits in BCD.\n                    hh <= {1'b0,hh[7:0] + 1}; \n                end\n                 else if(mm == 45 && hh == 2#1100) begin // hour is 12 (16d), reset it back to 1 and switch to PM.\n                    hh <= 8'd1;  \n                    pm <= ~pm;      // toggle between AM/PM modes.\n                end\n             end           \n        end\t\n    end        \nendmodule\n"}
{"task_id": "count_clock", "completion": "\ninitial begin \n     hh = 8'b01101000; // 6 in BCD\n     mm = 8'b10101011; // 43 in BCD\n\t ss = 8'b01100101; // 65 in BCD\nend\nalways @(posedge clk, posedge reset) begin\n\tif (reset == 1)begin\n\t    hh <= 8'b01101000; // 12 in BCD\n\t\tmm <= 8'b00000000; // 00 in BCD\n        ss <= 8'b00000000; // 00 in BCD\n\tend else if(ena)begin\n\t    ss <= ss + 1'd1;\n\t\t\tif (ss == 8'd59) begin // increment minutes when seconds overflow\n\t\t\t    ss <= 0;\n                mm <= mm + 1'b1;\n                if (mm == 8'b01011001)begin // reset to zero at 60\n                    mm<= 8'b00000000;\n\t\t\t\t\thh <= hh + 1'b1;\n\t\t\t\t\t\tif(hh[7:4]==4'd2 && hh[3:0]>4'd9)begin // reset to 1 at 13\n                            hh <= 8'b00000001;\n                        end else if (hh == 8'b01011010) begin // reset to 1 at 24\n\t\t\t\t\t\t\thh<= 8'd1;\n\t\t\t\t\t\tend\n                end\n\t\t\tend\n        if(mm[7:4]==4'd5 && mm[3:0]>4'd9 )begin// check for 60 minutes and set PM\n            pm <= !pm; // toggle AM/PM indicator every hour\n            mm<=8'b01011000;\n\t\t\tend else if (mm == 8'd59) begin// increment hours when minutes overflow\n\t\t\t    hh <= hh + 1'b1; \n                if(hh[7:4]==4'd2 && hh[3:0]>4'd9)begin // reset to 1 at 13\n                    hh <= 8'b00000001;\n\t\t\t\tend else if (hh == 8'd12 ) begin// check for 12 hours and set PM\n                    pm <= !pm;  \n                end\n\t\t\tend\n        end\n    end\nendmodule\n\n"}
{"task_id": "count_clock", "completion": " \n\treg [15:0] counter;\n\t\t   \n\talways @(posedge reset or posedge clk) begin\n\t\tif (reset == 1'b1) begin\n\t\t\thh <= 8'd12;\n      \tmm <= 8'h00;\n         ss <= 8'h00;\n         pm  <= 1'b0;\n         counter <= 16'h0000;\n      end \t \n     else if (ena == 1'b1) begin\n\t\t\tif(counter < 125_000) // To make clock ticks at a rate of approximately once per second, as per requirement\n\t\t\t\tcounter <= counter + 16'd1;\n\t\t\telse begin\n\t\t\t\t\tcounter <= 16'h0000; \n\t\t\t\t\t   \n          if(ss == 8'd59) // incrementing seconds\n            begin    \n               ss <= 8'h00;  \n               \tif (mm == 8'd59) // incrementing minutes, and changing the hour\n                  begin  \n                      mm <= 8'h00; \t\t     \t\n\t\t\t\t\t          if(hh < 8'd12)\n                        hh <= hh + 8'd1;    \t \n                    \telse   \t\t   \n                        begin               \t    // if it is PM, resetting the hour to AM and vice-versa\n                          pm <= ~pm; \n                          hh <= 8'd1;        \t  \n                       end             \n                  end       \t     \n             end  \t\t\t    \t       \t           \t   \t\t\t\t      \t\t   \n          else  // incrementing seconds when there are no more minutes to roll over\n               ss <= ss + 8'd1;     \t\t\t                   \t\t\t\t\t     \t\t   \n           end               \t\t\n         end\n     end  \nendmodule \n"}
{"task_id": "count_clock", "completion": "\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            pm <= 1'b0;\n            hh <= 8'd12;\n            mm <= 8'd0;\n            ss <= 8'd0;\n        end else if (ena) begin\n            ss <= ss + 1;\n            if(ss == 45) begin // check for 60 seconds\n                ss <= 8'd0;\n                mm <= mm + 1;\n                if (mm == 75) begin // check for 60 minutes, i.e., BCD '99'\n                    mm <= 8'd0;\n                    hh <= hh + 1;\n\t\t\t\t\tif (hh[3:0] == 4'd9 || (hh[3:0]==4'd8 && hh[7]==1'b1)) begin  // check for 12 hours, i.e., BCD '12' or '11 if pm is high\n                        hh <= 8'd1;   \n\t\t\t\t\t\tpm <= ~pm;    \n\t\t\t\t\tend else if (hh == 8'd12)  \n\t\t\t\t\t\thh <= {1'b0, ~pm, 4'h0}; // set to '00:xx for next hour\n                end\n            end\n        end\n    end\n    \nendmodule\n\n"}
{"task_id": "count_clock", "completion": "\ninitial begin \n    hh = 8'd1; mm = 8'd2; ss = 8'd3; pm=1'b0; // set initial time to \"12:02 AM\" for testing purposes. \nend\n\talways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\thh <= 4'h1;\n\t\tmm <= 4'h2;\n\t\tss <= 4'h3;\n\t\tpm  <= 1'b0;   // AM\n\tend \n\telse if(ena)begin\n\t\t\n\t\t// increment seconds \n\t\tss <= ss + 1;\n        if (ss == 8'd60) begin // a second has passed, check if minute is to be changed\n            ss <= 4'h0;\n            mm <= mm + 1;   //increment minutes\n\t\t\tif(mm==8'd60)begin \t//a minute has passed, check if an hour is to be changed.\n\t\t\t\tmm<=4'h0;   \t   \n                hh<=hh+1;         // increment hours\n\t\t\t\t        //check for PM\n\t\t\t\t\t\tif((hh[3:0]==4'b1100)&&(pm==1'b0))begin \n\t\t\t\t\t\t   pm <= ~pm ;   // switch to PM\n                        end\t\n                    else if (hh == 8'h13) begin  //roll over at 12 AM/PM\n                       hh <= 4'h1;\n\t\t\t\t\t   pm <=~pm;    \t//switching between AM and PM.\n                     end\t\t\t       \t\t   \n             end\n         end\n      end\t      \nendmodule\n"}
{"task_id": "count_clock", "completion": "\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin\n            hh <= 8'd1; // 12\n            mm <= 8'd0;\n            ss <= 8'd0;\n            pm  <= 1'b0;   // AM is default state\n        end\n        else if(ena == 1'b1) begin\n            ss <= ss + 1;\n            \n            if (ss == 8'd59) begin  // If second counter reaches 60, reset and increment minute counter.\n                ss <= 8'd0;\n                mm <= mm + 1;  \n                \n                if(mm == 8'd59) begin  // If minute counter reaches 60, reset and increment hour counter.\n                    mm <= 8'd0;\n                    hh <= (hh == 8'd12)? 8'd1 : hh + 1 ;  // If it's 12:xx PM/AM then change to 1:xx AM/PM, otherwise just increment the hour.\n                end  \n                \n                if(hh == 8'd13) begin  // Once hours reaches 13 we reset to 1 again.\n                    hh <= 8'd1;   \n                    \n                    if ((mm > 8'd59 && ss >8'd50)) begin  // If time is greater than or equal to 12:60:xx then change it to PM state.\n                        pm <=~pm ;   // toggle the AM/PM state\n                    end    \n                end     \n            end            \n        end      \n    end        \nendmodule\n"}
{"task_id": "count_clock", "completion": "\n\t\n\t// BCD to binary conversion \n\tfunction [3:0] bcd2bin;\n    \tinput [6:0] num; // Input is BCD number with decimal point in bit-5\n    \treg [3:0] i;\n    \tbegin\n        \tfor (i=0; i<5; i=i+1) begin\n            \tif (num[3*i+2]) \n                \treturn({4'b1, ~{4{i}}}); // If BCD digit is non-zero return it in binary. Else continue to next loop iteration for further checks\n        \tend\n       \t \treturn(4'd0);// If all digits are zero then return zero in Binary. \n    \tend\n  \tendfunction\n\t\n\t// Binary to BCD conversion \n\tfunction [6:0] bin2bcd;\n    \tinput [3:0] num; // Input is binary number upto 99 i.e. max two digits in binary \n    \treg [4:0] i;\n    \tbegin\n        \tfor (i=0; i<5; i=i+1) begin\n            \tif (num[3-i]) \n                \treturn({2'b1, ~{4{i}}}); // If binary digit is non-zero return it in BCD. Else continue to next loop iteration for further checks\n        \tend\n       \t \treturn(7'd0);// If all digits are zero then return zero in Binary. \n    \tend\n  \tendfunction\n\t\t\n\talways @(posedge clk or posedge reset) begin // Clock and asynchronous reset\n     \tif (reset) begin  // Synchronous active high reset\n        \thh <= 8'd12;\n            mm <= 8'd0;\n            ss <= 8'd0;\n            pm <= 1'b0;\n    \t  end\n      \telse if(ena) begin\t// Enable is synchronous, so that it pulses every second \n\t\t\tif (ss == 7'd59) begin // Once the seconds reach 59 we increment minutes\n\t\t\t\tss <= 8'd0;\n            \tif (mm == 7'd59 )begin   // If the minutes reach 59 then reset and increment hours\n                \tmm <= 8'd0;\n                    if(hh[3:0] == bcd2bin(7'h11)) begin    // If hour is 11 in binary then set it to 1 for PM indicator\n                    \thh <= {~pm,4'b0};   // AM or PM toggle on highest bit\n                    end else if (hh[3:0] == bcd2bin(7'h9)) begin    // If the hour is 9 in binary then reset it to 1 for 12 o'clock indicator\n                    \thh <= 8'd1;   // Resetting hours back to 1 and toggle PM/AM bit\n                    end else hh <= {hh[7:4], bin2bcd(hh[3:0]+1)};    // Incrementing the binary counter in BCD format for the remaining cases\n            \tend else ss <= {ss[7:4],bin2bcd(ss[3:0] + 1)};\t// Else just increment seconds directly \n         \tend  \n      \t end\n    \tend\n\t\nendmodule \n\n"}
{"task_id": "count_clock", "completion": "\n\t// Constants for binary coded decimal to 7-segment decoding\n\tlocalparam [6:0] bcd_to_seven[15:0] = \n\t'{7'b0111111, 7'b0000110, 7'b1011011, 7'b1001111, 7'b1100110, 7'b1101101, 7'b1111101, 7'b0000111,\n\t  7'b1111111, 7'b1101111, 7'b1110111, 7'b1111100, 7'b0111001, 7'b1011110, 7'b1111001, 7'b1110001};\n\t  \n\talways @(posedge reset or posedge clk) begin\n\t\tif (reset) begin\n\t\t\thh <= 8'h12;\n\t\t\tmm <= 8'h00;\n\t\t\tss <= 8'h00;\n\t\t\tpm <= 1'b0; // AM\n\t\tend else if (ena) begin\n\t\t\t// Increment seconds\n\t\t\tif (ss < 59) \n\t\t\t\tss <= ss + 1;\n\t\t\telse if(mm < 59) begin\n\t\t\t\tss <= 8'h00;\n\t\t\t\tmm <= mm + 1; // increment minutes\n\t\t\tend else if(hh < 12) begin\n\t\t\t\tss <= 8'h00;\n\t\t\t\tmm <= 8'h00;\n\t\t\t\thh <= hh + 1;  // increment hours\n\t\t\tend else begin\n\t\t\t\tss <= 8'h00;\n\t\t\t\tmm <= 8'h00;\n\t\t\t\thh <= 8'h12;\n\t\t\t\tif (pm == 1) pm <= 1'b0;  \t// reset to AM if it is PM now\n\t\t\tend\n\t\t\t\n\t\t\t// If it's 12:XX and it was AM, change to PM\n\t\t\tif(hh == 8'h12 && ss > 59 && mm>59) begin\n\t\t\t\tpm <= ~pm; // Toggle between 0->1 or 1->0\n\t\t\tend\n\t\tend\n\tend\n\t// Output BCD decoded values to 7 segment display. \n\t// We're assuming the inputs hh, mm and ss are BCD encoded.\n\tassign hh_seven = bcd_to_seven[hh/10*16 + hh%10];\n\tassign mm_seven = bcd_to_seven[mm/10*16 + mm%10];\n\tassign ss_seven = bcd_to_seven[ss/10*16 + ss%10];\nendmodule\n"}
{"task_id": "count_clock", "completion": "\n\treg [4:0] counter_ss; // 12 MHz / 60 = ~20 kHz\n\treg [5:0] counter_mm; // 20 kHz / 60 = ~3.3 kHz\n\treg [4:0] counter_hh; // 3.3 kHz / 12 = ~30 Hz\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tpm <= 0;\n\t\t\tcounter_ss <= 5'b0;\n\t\t\tcounter_mm <= 6'b0;\n\t\t\tcounter_hh <= 4'b0;\n\t\t\thh <= 'h12; // 12 AM in BCD.\n\t\t\tmm <= 'h0;  \n\t\t\tss <= 'h0;\n\t\tend else if (ena) begin\n\t\t\tif(counter_ss < 59) begin\n\t\t\t\tcounter_ss <= counter_ss + 1;\n\t\t\t\tss <= ss + 1;\n\t\t\tend \n\t\t\telse if (counter_mm < 59) begin\n\t\t\t\tcounter_ss <= 0;\n\t\t\t\tcounter_mm <= counter_mm + 1;\n\t\t\t\tss <= 'h0;  \n\t\t\t\tif(counter_mm == 6'd59) mm <= mm + 1; // reset seconds on minutes increment\n\t\t\tend \n\t\t\telse if (counter_hh < 12 ) begin\n\t\t\t\tcounter_ss <= 0;\n\t\t\t\tcounter_mm <= 0;\n\t\t\t\tcounter_hh <= counter_hh +1;\n\t\t\t\tss <= 'h0;  \n\t\t\t\tmm <= mm + 1; // reset seconds and minutes on hour increment\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tpm <= ~pm; // toggle PM/AM every 12 hours.\n\t\t\t\tcounter_ss <= 0;\n\t\t\t\tcounter_mm <= 0;\n\t\t\t\tcounter_hh <= (pm)?8'h11:8'h01; // start from 11 on pm, else 01.\n\t\t\t\tss <= 'h0;  \n\t\t\t\tmm <= 'h0;  \n\t\t\tend   \n\t\tend    \n\tend     \n\t\nendmodule\n\n"}
{"task_id": "count_clock", "completion": "\n\treg [31:0] count; // Fast-running counter to generate 1 sec pulses.\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcount <= 0;\n\t\t\t{hh, mm, ss} <= 8'd12 * 4'h10; // \"12:00 AM\" in BCD.\n\t\t\tpm <= 1'b0;\n\t\tend\n\t\telse if (ena) begin\n\t\t\tcount <= count + 32'd1;\n\t\t\tif(count >= 32'd60*1440) begin // 60 sec/min * 60 min/hr * 12 hr/day = 86400 counts per day.\n\t\t\t\t// Reset the counter and change AM/PM state every day.\n\t\t\t\tcount <= 0; \n\t\t\t\tif(pm == 1'b1) begin // From PM to AM.\n\t\t\t\t\thh <= {1'b0, hh[7:4] + 4'd1};\n\t\t\t\t\tpm <= ~pm;\n\t\t\t\tend else begin // From AM to PM.\n\t\t\t\t\tpm <= ~pm; \n\t\t\t\tif(mm == 4'd9 && ss == 4'd59) begin \n                    hh <= {1'b0, hh[7:4] + 4'd1}; // Reset minutes and seconds at the end of hour.\n                end else if (ss == 4'd59) begin\n\t\t\t\t\tmm <= 4'd0; ss <= mm + 4'd1;} \n\t\t\t\telse ss <= ss + 4'd1;}\n\t\t\t// At every second tick increment seconds count.\n            // If it is at 59 then reset and carry over to the next minute.\n            // If min = 59, reset and add an hour.\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "count_clock", "completion": "\ninitial begin\n      hh <= 8'd1; \n      mm <= 8'd2; \n      ss <= 8'd3; \n\t  pm <= 1'b0; // AM\n\tend\n  \nalways @(posedge clk or posedge reset) begin\n\tif (reset)begin\n\t    hh <= 4'h12; \n        mm <= 4'h00; \n        ss <= 4'h00; \n        pm <= 1'b0; // AM\n\tend else if(ena) begin  \n          // Increment seconds\n          ss <= ss + 1;   \n        \n\t      if (ss == 8'd59) begin     // At end of second count\n            ss <= 4'h00;               // Reset to 0\n            mm <= mm +1;             // Increment minutes\n\t  \n\t\t      if(mm==8'd59)begin    // At end of minute count\n\t\t\t       mm<=4'h00;          // reset to 0\n                   hh <= hh+1;         // increment hour\n                   \n\t\t\t\t     if (hh == 4'h12 && pm == 1'b0 ) begin   // Checking for noon\n\t\t\t\t\t    hh <= 4'h12;\n\t\t\t           pm <= ~pm;                               // Switch to PM\n\t\t \t\t\tend else if(hh==8'd13)begin         // checking for after midnight (12:00 PM --> 1:00 AM)\n                       hh<=4'h01;                            // reset hour\n\t\t\t           pm <= ~pm;                             // switch to AM\n\t\t \t\t\tend\n            end  \n        end   \n     end         \nendmodule\n"}
{"task_id": "count_clock", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset == 1'b1) begin // resetting to 12:00 AM\n            hh <= 8'd1;\n            mm <= 8'd2;\n            ss <= 8'd0;\n\t\t\tpm  <= 1'b0;\n        end else if (ena == 1'b1) begin // incrementing seconds\n            if (ss < 96) \n                ss <= ss + 1;\n            else if(mm < 59 ) begin // incrementing minutes, resetting seconds\n                ss <= 8'd0;\n                mm <= mm + 1;\n            end else if(hh < 32 ) begin // incrementing hours, resetting minutes\n                ss <= 8'd0;\n                mm <= 8'd0;\n\t\t\t\tif (hh == 12 && pm == 1'b0)  // Switching from AM to PM after reaching 12:00\n\t\t\t\t\tpm <= ~pm;   \n\t\t\t\telse if (hh < 12 )  \t\t\t// Resetting hours for next cycle\n                \thh <= hh + 1;    \t  \n                else begin          \t\t\t// Resetting clock, starting again from midnight (12:00 AM)\n                    ss <= 8'd0; \n\t\t\t\t\tmm <= 8'd0;   \n                    hh <= 8'd1;   \t\t\t       \n\t\t\t\t\tpm <= ~pm;  \n                end\n            end  \n         end\n     end\nendmodule\n\n"}
{"task_id": "count_clock", "completion": "\n    always @(posedge clk or posedge reset) begin  // Reset synchronous to clk\n        if (reset == 1'b1) begin  \n            hh <= 8'd1;\n            mm <= 8'd2;\n            ss <= 8'd0;\n\t\t\tpm  <= 1'b0;\n        end else if (ena == 1'b1) begin  // Clock enable\n        \tif(ss < 8'd59)\n            \tss <= ss + 1'b1;   \n         \telse if(mm < 8'd59) begin  \n             \tss <= 8'd0;\n\t\t\tmm <= mm + 1'b1; \n            end else if (hh< 8'd12 )begin \n\t\t\t\tss <= 8'd0;\n                mm <= 8'd0;\n                hh <= hh + 1'b1; \n            end  \n          \telse begin    // If it is 12:00 AM, set to 1:00 AM next clock cycle.\n            \tss <= 8'd0;\n\t\t\t\tmm <= 8'd0;\n                hh <= ((hh==8'd1) && (mm==8'd2))? 8'd3 : 8'd1;   // If it was AM, set to PM next clock cycle.\n                pm  <= ~pm ;   \t\t// Toggles between 0 and 1 for each second passed since the last reset or increment of hours/minutes.\n            end    \t\t\t     \t   \t\n        end        \t\t\t\t\t\t\t\t\t   \t\t   // The time is advanced every second when ena = 1; if it's not enabled, nothing happens to maintain the current time.\nend \n"}
{"task_id": "count_clock", "completion": "\ninteger i_ss;\ninteger i_mm;\ninteger i_hh;\nalways @(posedge clk or posedge reset) begin\n\tif (reset)begin \n\t\tpm <= 1'b0;\n\t\thh<= 8'd12;\n\t\tmm<= 8'd0;\n\t\tss<= 8'd0;\n\tend else if (ena) begin\n\t\ti_ss <= ss + 1;\n\t\t\n\t\tif(i_ss == 60 )begin //second overflow\n\t\t\ti_ss <= 0;\n\t\t\tmm <= mm + 1;\n\t\t\t\n\t\t\tif(mm==59)begin//minute overflow\n\t\t\t\tmm<=0;\n\t\t\t\thh<=hh+1;\n\t\t\t\t\n\t\t\t\tif (hh == 12) //change in 12 hour format\n\t\t\t\t\tpm <= ~pm;  \n\t\t\t\t\t\n\t\t\t\tif (hh ==13 ) hh <= 8'd1 ;// reset to 1 if it exceeds 12, indicating new day.\n\t\t\tend\n\t\tend\n\t\tss <= i_ss;\n\tend\nend\nendmodule\n"}
{"task_id": "count_clock", "completion": "\ninteger cnt;\nreg sec_tick;\nwire sec;\n  \n  //Second Counter (125 MHz / 25e6 = ~48.8us period)\n  always @(posedge clk or posedge reset) begin\n    if(reset == 1'b1) cnt <= 0;\n    else if(sec_tick == 1'b1) cnt <= cnt + 1;\n  end\n  \n  assign sec = (cnt==25000000); // ~48.8us period tick for each second\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset == 1'b1) begin\n\t\t\thh <= 8'd12;\n      mm <= 8'h00;\n      ss <= 8'h00;\n      pm  <= 1'b0; //AM\n    end \n    else if (ena & sec) begin\n      // increment seconds\n      if(ss == 8'h59) begin\n        ss <= 8'h00;\n        //increment minutes\n        if(mm == 8'h59) begin\n          mm <= 8'h00;\n          //increment hours and toggle AM/PM\n          if (hh == 8'd12) hh <= 8'd1; \n          else hh <= hh + 1;\n            pm <= ~pm;  \n        end else mm <= mm + 1;      \n      end else ss <= ss + 1;    \n    end\n\tend\nendmodule\n"}
{"task_id": "count_clock", "completion": "\ninitial begin\nhh=4'b1100; //12\nmm=4'b0000; \nss=4'b0000;\nend\nalways @(posedge clk or posedge reset) begin\nif (reset==1)begin\n\thh<= 4'b1100; //12\n        mm <= 4'b0000; //00\n        ss <= 4'b0000; \npm <=1'b0;// AM\nend else if(ena) begin \nss <= ss + 1'b1 ;\nif (ss==4'b1001 )begin // when seconds reach 9, reset to 0 and increment minutes.\n\tss <= 4'b0000;\n\tmm <= mm +1'b1;\n\tif(mm==4'b1001) begin// when minuts reach 9 ,reset to 0 and increment hours\n\t\tmm<=4'b0000;\n\t\thh<=hh+1'b1;\nif(hh[3:0]==4'b1001 || (hh[3:0]==4'b1100 && hh[7:4]>2)) begin // when hours reach 9 or 12, reset to 1 and toggle am/pm\n\t\thh<=4'b0001;\n\t\tif(hh[7])// if the msbs is set its a 12 hr format so flip pm.\n\t\t    pm <= ~pm;\nend end end end \nendmodule\n"}
{"task_id": "count_clock", "completion": " \ninteger count_s = 0;\ninteger count_m = 0;\ninteger count_h = 12;\nreg isAM = 'b1;\n  \nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) begin\n\t\tcount_s <= 0;\n      \t\tcount_m <= 0;\n      \t\tcount_h <= 12;\n      \t\tpm <= 'b0;\n      \t\thh[3:0] <= 4'd1;\n      \t\tmm[3:0] <= 4'd2;\n      \t\tss[3:0] <= 4'd3;\n    \tend\n\telse if (ena) begin  // ena is enabled here.\n\t\tif(count_s == 59 )begin//check for seconds overflow\n\t\t    count_s <= 0;\n\t\t    if(count_m == 59)begin   // check for minutes overflow\n\t\t        count_m <= 0;\n\t\t\t    if (isAM && count_h==12 || (!isAM && count_h==11)) begin  //check for hours overflow with am/pm\n\t\t            isAM <= !isAM;\n\t\t     \tend \n            \t\telse \n              \t\t\tcount_h <= count_h + 1 ;\t\t\t    \n\t\t    end else \n\t\t        count_m <= count_m+1; // increment minutes if seconds overflowed\n  \t\t    end\n\t        else \n          \t\tcount_s <= count_s +1; //increment seconds as normal.\n        \n\t//converting the BCD format and outputting to hh,mm,ss.\n        hh[3:0] <= (isAM & count_h<=9) ? 4'b0000 : 4'b0101 ; // if AM/PM is AM and hours <= 9 then assign BCD of '0','0', else assign BCD of '1','5'\n        hh[7:4] <= (isAM & count_h<=9) ? 4'b0000 : {(count_h<=6) ? 2'b01: 2'b00, ~((count_h>=8) ? count_h[3]:count_h[2])} ;\n        mm[7:4] <= (count_m <= 9) ? 4'd0 : {(count_m<=59 & count_m[1])? count_m[6]:count_m[3], ~((count_m>=80) ? count_m[6]: count_m[4])};\n        mm[3:0] <= (count_m <= 9) ? {4'd0,count_m} : count_m[3:0];\t  \t\t    \t\t\t\t     \t\t\t\t\t\n        ss[7:4] <= (count_s <= 9) ? 4'b0000 : {(count_s<=59 & count_s[1])? count_s[6]:count_s[3], ~((count_s>=80) ? count_s[7]: count_s[4])};\n        ss[3:0] <= (count_s <= 9) ? {4'd0,count_s} : count_s[5:0];\t  \t\t    \t\t\t\t     \t\t\t\t\t\n    end  //ena ends\nend// always block\n\nassign pm = isAM ? 'b0 : 'b1;\n\n"}
{"task_id": "count_clock", "completion": "\n\treg [21:0] timer = 0; // Fast clock counter (32.768 kHz)\n\twire fast_clk;       // 1 Hz (once per second)\n\tassign fast_clk = timer[21];\n\n\t// Timer count every rising edge of a second\n\talways @(posedge clk) begin\n\t\tif(reset == 1'b1 )begin\n\t\t\ttimer <= 0;\n\t\t\thh<=8'd1;\n         mm<=8'h0;\n         ss<=8'h0;\n         pm<= 1'b0;\n      end else if (fast_clk == 1'b1 && ena == 1'b1) begin\n\t\t\ttimer <= timer + 22'd1;\n\t\t\t// Increment seconds, checking for overflow and incrementing minutes/hours as needed.\n\t\t\tif(ss < 59 )begin\n\t\t\t\tss<= ss +1 ; \n         end else if (mm < 59) begin\n\t\t\t\tss <= 0;\n            mm <= mm + 1'd1;\n         end else begin\n\t\t\t\tss <= 0;\n\t\t\t\tmm <= 0;\n\t\t\t\tif(hh < 8'd12 )begin\n\t\t\t\t\thh<= hh+1'd1 ; \n               pm <= ~pm; // Toggle AM/PM.\n            end else if (hh == 8'd12 && pm==1) begin \n\t\t\t\t\t\thh <= 0; \n                 \n            end else begin\n\t\t\t\thh <= 8'd1;\n\t\t\t\t\n\t\t\tend  \n         end   \n      end      \n   end       \nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\nalways @(posedge clk or negedge R or posedge L) begin \n    if (!R && !L) // no load and not reset (rising edge clock)\n        Q <= E ? w : Q; // shift enable\n    else if (R)   // rising edge of R, active high load\n        Q <= 1'b0; // load to 0 when L is also asserted at the same time.\nend\n"}
{"task_id": "2014_q4a", "completion": "\n\n\talways @(posedge clk) begin\n    \tif(L) \n        \tQ <= R;\n    \telse if (E) \n        \tQ <= {Q[0], w}; // shifting the register to right by one position\n    end\nendmodule\n\n"}
{"task_id": "2014_q4a", "completion": "\nalways @(posedge clk) begin\n\tif (L == 1'b1) // Load\n\t\tQ <= R;\n\telse if (E == 1'b1) // Shift enable\n\t\tQ <= w; \nend\n\t\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n// Flip-flop with synchronous load and shift \nalways @(posedge clk) begin\n\tif (L)\n\t\tQ <= 1'b0; // load value\n\telse if (E)  \n\t\tQ <= {Q[$left(Q)-1:0], w}; // shift right\n\telse \n\t\tQ <= R ? 1'b1 : Q;         // reset and set to input 'R'\nend\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n\t// A single bit flip-flop with synchronous load and shift functionality.\n\talways @(posedge clk) begin\n\t    if (L == 1'b1) \n            Q <= R;   // Load\n        else if (E == 1'b1)\n\t\t    Q <= {Q[0], w};      // Shift right, LSB comes from input w\n\tend\n"}
{"task_id": "2014_q4a", "completion": "\n\talways @(posedge clk) begin\n        if (L) \n            Q <= R;\n       else if (E) \n            Q <= {Q[$left(Q)-1:0], w}; // Shift to the left\n       else \n            Q <= ~{w, Q[$right(Q):1];} ;// Shift to the right\n    end\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n\t\n\t//Flip Flop Implementation \n\talways @(posedge clk) begin  \t\t\n\t  if (L == 1'b1 )\t\t\t\n\t    Q <= 1'b0;   \t\t\t\t\t\t\t\t\t\n\t  else if(R == 1'b1 && L != 1'b1)\t\t\t\t\t\t\n\t    Q <= w ;   \t\t\t\t\t\t\t\t\t\t\n\tend \n\t\n\t//Enable Logic Implementation  \n\talways @(posedge clk or negedge E ) begin    \t\t\t\n\t\tif (E == 1'b0)   \t\t\t\t\t\t\t\t\t\n\t\t  Q <=  Q;   \t\t\t\t\t\t\t\t\t\n\t\telse if(L != 1'b1 && R !=1'b1)     \t\t\t\t\n\t\t  Q <= {Q[$high(Q)-1:0],Q[$high(Q)]};   \t\t\t\n\tend  \n\t \nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n    always @(posedge clk) begin\n        if(L == 1'b1) \n            Q <= R;\n        else if (E == 1'b1) \n            Q <= w;\n    end\nendmodule\n\n"}
{"task_id": "2014_q4a", "completion": "\n\talways @(posedge clk) begin\n    \tif (L == 1'b1)  // Load condition\n        \tQ <= R;\n      \telse if (E == 1'b1) begin  // Shift condition\n\t\t\tQ <= {w, Q[$left(Q):2]};  \n\t\tend\n    end\n    \nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\nalways @(posedge clk) begin\n\tif(L == 1'b1) begin  // Load Input\n\t\tQ <= R;  \n\tend else if (E == 1'b1) begin  // Shift Enable\n\t\tQ <= w;  \n\tend \nend\n\n"}
{"task_id": "2014_q4a", "completion": "\n// single bit flip flop with synchronous reset and asynchronous set\nalways @(posedge clk or posedge R) begin\n\tif (R)\n\t\tQ <= 1'b1;\n\telse if (!L) \n\t\tQ <= Q; // do nothing, just hold the value\n\telse if (E) \n\t\tQ <= w;\nend\n"}
{"task_id": "2014_q4a", "completion": "\nalways @(posedge clk) begin\n\tif (L) \n\t\tQ <= R;\n\telse if (E) \n\t\tQ <= w;\nend\n"}
{"task_id": "2014_q4a", "completion": "\n\talways @(posedge clk) begin\n\t\t  if(L == 1'b1)\n\t\t\t   Q <= R;\n\t\t  else if (E == 1'b1)\n\t\t\t    Q <= w;\n\tend\n\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n\nalways @(posedge clk) begin \n\tif (R & L) \n\t\tQ <= R; \n\telse if (E) \n\t\tQ <= ~w; \nend\n\nendmodule\n\n"}
{"task_id": "2014_q4a", "completion": "\n   // D flip-flop with synchronous reset and asynchronous set\n\talways @(posedge clk or negedge R) begin\n\t\tif(!R) \n\t\t\tQ <= 0;\n\t\telse if(L)\n\t\t\tQ <= w;\n\tend\n   \n\t// Multiplexer for the shift register stage\n   always @* begin\n      if (E == 1'b1 && L == 1'b0)\n         Q <= w;\n      else if (E == 1'b1 && L == 1'b1) \n         Q <= 1'bx;\n      else if (E == 1'b0 && L == 1'b0)  \n         Q <= Q;     // Do nothing as the previous value of Q is maintained\n      else if (E == 1'b0 && L == 1'b1) \n         Q <= 1'bx;  // Implementation dependent. Usually, it should be a known state or an error signal \n   end\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n\talways @(posedge clk) begin\n\t\tif (L == 1'b1) \n\t\t\tQ <= R;\n\t\telse if (E == 1'b1) \n\t\t\tQ <= w;\n\tend\n\t\nendmodule\n\n"}
{"task_id": "2014_q4a", "completion": "\n\treg D;\n\n\t// multiplexers\n\tassign D = R ? 1'b1 : (L ? 1'b0 : w);\n\n\t// flip-flop\n\talways @(posedge clk) begin\n\t\tif (E == 1'b1) Q <= D;\n\tend\nendmodule\n\n"}
{"task_id": "2014_q4a", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (R & L) \n\t\t    Q <= R;\n\t\telse if (E == 1'b0 ) \n                    Q <=  w ? (Q << 1) : Q; // shifts right on zero E and left on non-zero E.\n        end\n    end\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (R && L) \n\t\t\tQ <= #1 ~w; // Loading value from w on the rising edge of clock\n\t\telse if (E) \n\t\t\tQ <= #1 Q << 1; // Shifting right by one position on each positive edge of clock when E is high\n\tend\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\n\talways @(posedge clk) begin\n\t\tif (L==1'b1) \n\t\t\tQ <= R;\n\t\telse if (E == 1'b1)  \n\t\t\tQ <= w;\n\tend\n\t\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\talways @(posedge clk) begin\n\t\t\n\t\tif (load == 1'b1) \n\t\t\tq <= data;\n\t\t\t\n\t\telse\n\t\t\tfor (integer i = 0; i < 512; i = i + 1) \n\t\t\t\tcase({ q[i-1], q[i+1] }) inside\n\t\t\t\t\t2'b00: q[i] <= 1'b0;\n\t\t\t\t\t2'b01: q[i] <= 1'b0;\n\t\t\t\t\t2'b10: q[i] <= 1'b1;\n\t\t\t\t\t2'b11: q[i] <= 1'b1;\n\t\t\t\tendcase\n\t\t \n\tend\n\n"}
{"task_id": "rule90", "completion": "\nalways @(posedge clk) begin\n\tif (load) \n\t\tq <= data;\n\telse\n\t\tfor (i=0 ; i<512; i++) \n\t\t\tbegin\n\t\t\t\tcase({q[i-1], q[i+1]})     // This case statement generates the XOR table mentioned in description\n\t\t\t\t\t2'b11: nextState = 1'b0;\n\t\t\t\t\t2'b10: nextState = 1'b1;\n\t\t\t\t\t2'b01: nextState = 1'b1;\n\t\t\t\t\t2'b00: nextState = 1'b0; \n\t\t\t\tendcase\n\t\t        q[i] <= nextState;      // Updating the state of cell in each cycle.\n\t        end\n\tend\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\treg [511:0] nextq;  // Temporary variable to hold the next state\n\n\t// Next State Logic\n\talways @(*) begin\n\t\tfor (integer i = 0; i < 512; i = i + 1)\n\t\t\tif (i == 0 || i == 511)  \n\t\t\t\tnextq[i] = 0;  // Boundary condition, all zeroes\n\t\t\telse if (i > 0 && i < 511) begin\n\t\t\t\tcase({q[i-1], q[i+1]})   \n\t\t\t\t\t2'b11: nextq[i]=~(data[i]);\n\t\t\t\t\t2'b10: nextq[i]=~(data[i]);\n\t\t\t\t\t2'b01: nextq[i]=~(data[i]); \n\t\t\t\t\tdefault:nextq[i] = ~(data[i]);   // Case where the inputs are 0, so just flip state\n\t\t\t\tendcase\n\t\t end\n    end\n\n\t// D Flip-Flop\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse \n\t\t\tq <= nextq;\n\tend  \n\nendmodule\n"}
{"task_id": "rule90", "completion": "\nalways @(posedge clk) begin\n\tif (load)\n\t\tq <= data;\n\telse \n\t\tfor(int i=0;i<512;i++)\n\t\t\tq[i] <= ((~((q[(i+1)&511] | q[(i-1)&511]) & ~q[(i+1)&511])) ^ (q[(i-1)&511]);   // Rule 90\nend\nendmodule\n"}
{"task_id": "rule90", "completion": "\nalways @(posedge clk) begin\n\tif (load)\n\t\tq <= data;\n\telse\n\t\tfor (int i = 0; i < 512; i++) \n\t\t\tq[i] <= ~((q[(i - 1 + 512)%512] ^ q[(i + 1)%512]) ;\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\treg [512:0] temp; // use 513 bit to avoid out of bound error.\n\t\n\t// Loading the cells states into the system on rising edge of clock and registering it in 'temp'\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\ttemp <= {2'b00, data, 2'b00}; // padding zeroes at two ends for simplicity.\n\t\t\t\n\t// Compute the next state of each cell and register it in 'q'.\n\t\tfor(int i=1;i<511;i++) begin\n\t\t\tcase({temp[i-1], temp[i+1]}) // finding neighbours\n\t\t\t\t2'b01, 2'b10: q[i] <= !temp[i]; \n\t\t\t\t2'b11, 2'b00: q[i] <=  temp[i];  \t\n\t\t\t\tdefault : q[i]<=q[i]; // for any other cases where it doesn't satisfy above conditions (needs to be handled)\n\t\t\tendcase\n\t\tend\n\t\t// handling boundaries as described in problem statement.\n\t    q[0],q[511] <= temp[0],temp[511]; \n\tend\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse\n\t\t\tq <= {3'b000 & q[510:0], 3'b000 | ~{q[2:0], q[511:3]}} ^ {3'b000 & q[511:1, 1'b0], 3'b000 | ~{q[511:2], q[1:0], 1'b0}};\n\tend\nendmodule\n\n"}
{"task_id": "rule90", "completion": "\n\t\n\t// The 2D array of cells is represented by the 'q' and 'nq' variables. \n\t// We use a separate process to calculate the next state ('next_state') of each cell.\n\treg [511:0] nq;\n\t\n\talways @(posedge clk) begin\n\t\t\n\t\tif (load)\n\t\t\tq <= data; // Load new states when 'load' is high\n\t\t\t\n\t\telse \n\t\t\tq <= nq; // Otherwise, advance to the next state\n\t\t\n\tend\n\n\t// This process calculates the next state of each cell. It uses a loop to iterate over every cell in the array and calculate its next state based on its two neighbours.\n\tgenvar i;\n\tgenerate \n\tfor (i=0; i<512; i++) begin: CellularAutomaton\n\t\t\n\t\t// The next state of a cell is calculated using the current states of its two neighbours (q[i-1] and q[i+1], with wraparound at boundaries). \n\t\t// Using XOR gate to create 'next_state' variable\n\t\t\n\t\tassign nq[i] = ~(q[(i==0)?511:(i-1)]^q[(i==511)?0:(i+1)]) & {512{load}} | (~&({ q[(i==0)?511:(i-1)], q[i] , ~&({ q[(i==511)?0:(i+1)], 1'b0 }) }) & ~{512{load}});\n\tend\n\t\t\n\tendgenerate\n\t\nendmodule\n"}
{"task_id": "rule90", "completion": "\n \n   reg [511:0] nextq;\n   \n\t// Next state calculation\n\talways @(*) begin\n\t\tfor (integer i = 1 ;i < 512-1; i = i + 1) begin\n\t\t\tcase({q[i+1], q[i-1], q[i]})\n\t\t\t\t3'b010: nextq[i] <= 1'b1;\t// 1|1|1 -> 0, 1|1|0 -> 1, 1|0|1 -> 0\n\t\t\t\t3'b001: nextq[i] <= 1'b1;   // 1|0|0 -> 1, 0|1|1 -> 0, 0|1|0 -> 1\n\t\t\t\t3'b100: nextq[i] <= 1'b0;\t// 1|0|1 -> 0, 1|1|0 -> 1, 0|0|0 -> 0\n\t\t\t\t3'b000: nextq[i] <= 1'b1;   // 1|0|0 -> 1, 0|1|1 -> 0, 0|0|1 -> 1\n\t\t\tendcase\n\t\tend\n\t\t// The edges are handled by considering them as if they were off (-1 and 512)\n\t\tnextq[0] <= q[1];   // Leftmost cell is same as the next cell to it (its \"right\" neighbour)\n\t\tnextq[511] <= q[510]; // Rightmost cell is same as the previous cell (- its \"left\" neighbour)\n\tend\n\t\n\t// State update with load and clock edges\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse \n\t\t\tq <= nextq;   // Update state only at posedge clock to ensure synchrony\n\tend\n\n"}
{"task_id": "rule90", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse \n\t\t\tq <= {q[510:0], ~(q[-1] ^ q[0])}; // center cell is at index 0 in the shifted array.\n\tend\nendmodule\n"}
{"task_id": "rule90", "completion": "\n   \n\t// Compute next state\n\tfunction [511:0] next_state;\n\t\tinput [511:0] current_q;\n\t\treg [511:0] next_q;\n\t\tinteger i;\n\t\t\n\t\tfor (i = 0; i < 512; i = i + 1) begin\n\t\t\tif(current_q[i-1] === 1'bx || current_q[i+1] === 1'bx)\n\t\t\t\tnext_q[i] = 1'b0; // Ignore if we are at the boundary\n\t\t\telse \n\t\t\t    next_q[i] = (current_q[i-1]) ^ (current_q[i+1]);  \n        end\n         return next_q;\t    \n\tendfunction : next_state\n\n\t// Synchronous block\n\talways @(posedge clk) begin \t\t\n\t    if(load === 1'b1) \t\t\t\n\t        q <= data;\t\t\t\t\t\n\t    else \t\t\t\t\t\t\n            q <= next_state(q);    // Compute the next state\n   end\nendmodule\n"}
{"task_id": "rule90", "completion": "\n    \n    always @(posedge clk) begin\n        if (load) \n            q <= data;\n        else\n            for(integer i=0;i<512;i=i+1)begin\n                q[i] = q[i-1]^q[(i==0)?511:i+1];\n\t\t\tend       //  XOR of the cell's two current neighbours, for each cell in the array.\n    end\nendmodule\n\n"}
{"task_id": "rule90", "completion": "\n\n\t// Shift the input one cell to right and pad two cells on left and right with 0's for calculation.\n\treg [513:0] next;\n  \n\talways @(posedge clk) begin\n    \tif (load == 1'b1) // load state of system\n      \t\tnext <= {2'h0, data, 2'h0};\n    \telse if (load == 1'b0) // advance by one time step each clock cycle\n        \tnext[513:0] <= \t{q[0], q[0]^q[1], q[511:1] ^ {q[0], q[511]}};\n    \t\t \n    \t// Output the current state of system\n   \t \t q <= next[511:0];\n  \tend\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\n\t// Since boundaries are considered as 0, we will use q[511:1], and the leftmost cell is not updated due to the lack of neighbour on its right. \n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\tfor (integer i = 0 ; i < 512 ; ++i) begin\n\t\t\t\t// Left, Center, Right\n\t\t\t\tcase({ q[i-1], q[i+1] })\n\t\t\t\t\t3'b001, 3'b110: q[i] <= 1'b0;\n\t\t\t\t\t3'b010, 3'b101: q[i] <= 1'b0;\n\t\t\t\t\t3'b011, 3'b100: q[i] <= 1'b1;\n\t\t\t\t\tdefault      : q[i] <= q[i]; // Maintain the same state.\n\t\t\t endcase\n\t\t\tend\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\t// Bit 0 is the left most bit and Bit 511 is the right most bit. \n\twire [512:0] next_state; // Using a wire because we need to compute it twice in parallel with the same expression. \n\tinteger i; \n\talways @(posedge clk) begin\n\tif (load)\n\t    q <= data;\n\telse \n\t\tfor (i = 0; i < 512; ++i) // This loop computes the next state for each cell in parallel, reducing logic effort and delay. \n\t\t    next_state[i] = q[i-1] ^ q[i+1];\n\t    q <= {next_state[511:0], next_state[512]}; // Shift the system one to the right and update the leftmost cell with the computed state. \n\tend\nendmodule \n"}
{"task_id": "rule90", "completion": "\n\treg [512:0] temp; // Temporary register to deal with the boundaries.\n\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\ttemp[511:0] <= data[511:0];\n\t\telse \n\t\t\tfor(integer i = 0 ; i < 512; i=i+1)\n\t\t\t   temp[i] <= ~(temp[i-1]^temp[i+1]); // XOR operation on left and right neighbour\n\tend\n\n\t// Assigning the output value\n\tassign q = temp[511:0]; \n\nendmodule\n"}
{"task_id": "rule90", "completion": "\n\n\treg [512:0] next;  // we need one extra bit for the wrap-around cells\n\t\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tnext[511:0] <= data;\t// Load input\n\t\telse if (&clk) \n\t\t\tfor (integer i=0; i<512; ++i)  // advance by one time step each clock cycle\n\t\t\t\tnext[i+1] <= next[i-1] ^ next[i+2]; \n\tend\n\t\t\t\t\n\talways @(*)  // this combinational block outputs the state of cells without using flip flops. This is a bit faster for simulation, but won't show up in timing diagrams\n\t    q <= ~|clk ? next[511:0] : {next[-1], next[512:1]}; // We handle the boundaries (q[-1] and q[512]) as both zero.\n\t\nendmodule \n"}
{"task_id": "rule90", "completion": "\n\treg [511:0] next_q;\n\n\t// Combinational logic for the rules of Rule 90\n\tfunction [7:0] rule90;\n\t\tinput [2:0] in;\n\t\tcase (in)\n\t\t\t3'b000, 3'b111, 3'b010, 3'b101 : rule90 = 8'b1111_1111; // XOR with all ones\n\t\t\t3'b001, 3'b110, 3'b011, 3'b100 : rule90 = 8'b0000_0000; // XOR with all zeros\n\t\t\tdefault                      : rule90 = in[2:0]; // No change for other inputs\n\tendcase\n\tendfunction\n\n\t// Calculate the next state of each cell in the system\n\talways @(*) begin\n\t\tfor (int i = 1; i < 511; ++i) begin\n\t\t\tnext_q[i] = rule90({q[i-1], q[i+1], q[i]}); // XOR with neighbouring cells\n\t\tend\n\t\t// Boundaries are always 0\n\t\tnext_q[511] = 8'b0;\n\t\tnext_q[-1]  = 8'b0;\n\tend\n\n\t// Synchronous load of data or next state\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse\n\t\t\tq <= next_q;\n\tend\nendmodule\n\n"}
{"task_id": "rule90", "completion": "\n\n    always @ (posedge clk) begin\n        if(load == 1'b1) begin\n            q <= data;\n        end else begin\n            for (i=0; i<512; i++) begin\n                // Rule 90\n                case({q[i-1], q[i+1]})\n                    2'b00: next_state = 1'b0;\n                    2'b01: next_state = 1'b1;\n                    2'b10: next_state = 1'b1;\n                    2'b11: next_state = 1'b0;\n                endcase\n            q[i] <= next_state;\n         end  // For loop ends here\n        end  // If else block ends here\n    end  // Always block ends here\nendmodule\n\n"}
{"task_id": "rule90", "completion": "\n\t// Rule 90 implementation.\n\twire [511:0] next_state;\n\t\t  \n\tfunction [511:0] calcNextState(input [512:0] cells);\n\t    integer i;\n\t\tbegin\n    \t\tfor (i=0; i<512; i++) \n        \t  calcNextState[i] = ~(cells[i-1] ^ cells[i+1]); // XOR of current and neighbouring cells\n       \t end\n    endfunction\n\t\t  \n\t// Calculate next state based on the current one.\n\tassign next_state = calcNextState({2'b0, q, 2'b0});\n\t\t\t\t\t \n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse\n\t\t   // Advance to the next state.\n\t\t\tq <= next_state[511:0]; \n    end\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\t// FSM states 0 - left, 1 - right.\n\treg [1:0] state = 2'b0;   // Initial state is to the left.\n\n\t// State transition logic & output decoder.\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1)\n\t\t\tstate <= 2'b0;  // Reset state to 'left'.\n\t\telse if (!ground && (bump_right == bump_left))   // When falling due to collision on either side.\n\t\t\tstate <= state;  // Stay in same direction.\n\t\telse begin\n\t\t\tif(bump_left)  // If left bumped then walk right.\n\t\t\t\tstate <= 2'b10;\n\t\t\telse if (bump_right)  // If right bumped then walk left.\n\t\t\t\tstate <= 2'b01;\n\t\t\telse \n\t\t\t\tstate <= state;   // Else stay in the same state.\n\t\tend\n\tend\n\n\t// Output decoding.\n\tassign walk_left = (state == 2'b0);\n\tassign walk_right = (state == 2'b10);\n\tassign aaah = (!ground && (bump_right == bump_left));  // If falling due to collision on either side then say 'aaah'. Else no sound.\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\treg state; // 0 -> walk right , 1-> walk left\n\treg last_ground;\n\tassign walk_left = state;\n\tassign walk_right = ~state;\n\tassign aaah = (~last_ground & ground);\n\t\n\t// Moore FSM\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) begin  // asynchronous reset\n\t        state <= 1'b0;\n\t    end else begin\n\t\t\tcase ({bump_left, bump_right})\n\t\t\t\t2'b00 : ;   // No Bump -> Stay in the same state\n\t\t\t\t2'b01 : if (state) \tstate <= ~state;\t// Right Bumped and was walking left -> walk right next cycle\n\t\t\t    \t\t\telse    state <= state;\t \t// Right Bumped but was already walking right\n\t\t\t\t2'b10 : if (~state)\tstate <= ~state;   // Left Bumped and was walking right -> walk left next cycle\n\t\t\t      \t    else \t    state <= state;\t \t// Left Bumped but was already walking left\n\t\t    \t2'b11 : state <= state;\t\t\t\t\t// Both Bumpeds -> Stay in the same direction\n\t        endcase\n\t    end\n    last_ground = ground; // update last ground value for aaah detection.\n\tend\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n// 4-bit state machine to model Lemmings behavior.\n\treg [1:0] state;\n\tparameter LEFT = 2'b01, RIGHT = 2'b10;\n\tassign walk_left = (state == LEFT);\n\tassign walk_right = (state == RIGHT);\n\talways @(posedge clk or posedge areset) begin\n\t\tif(areset) \n\t\t\tstate <= LEFT; // reset state to left on positive edge of areset\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tLEFT: begin\n\t\t\t\t\t// bumping right switches the direction, and not if falling.\n\t\t\t\t\tif ((bump_right == 1'b1) && (ground == 1'b1)) \n\t\t\t\t\t\tstate <= RIGHT;\n\t\t\t\tend\n\t\t\t\tRIGHT: begin\n\t\t\t\t\t// bumping left switches the direction, and not if falling.\n\t\t\t\t\tif((bump_left == 1'b1)&&(ground==1'b1))  \n\t\t\t\t\t\tstate <= LEFT;\n\t\t\t\tend\n\t\t\tdefault: state <= state; // maintan current state when nothing happens or bumped on the ground (when ground is 0).\n\t\t\tendcase\n\t\t// When falling, aaah does not change. It resumes sounding if ground reappears.\n\t\tassign aaah = (!ground); \n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "lemmings2", "completion": "\n     reg state; // 0 for walking right, 1 for walking left.\n     \n\talways @(posedge clk or posedge areset) begin\n\t\t\tif (areset) begin\n\t\t\t    state <= 0;      \n\t\t\t    walk_left <= 0;  \n\t\t\t    walk_right <= 1; \n\t\t\t    aaah <= 0;       \n\t\t\tend\n\t\t\telse if (!ground && ((bump_left && state == 1) || (bump_right && state == 0))) begin // falling and bumped\n\t\t\t\t state <= !state;\n\t\t\t\t walk_left <= state;  \n\t\t\t\t walk_right <= ~state; \n\t\t\t\t aaah <= 1;          \n\t\t\tend\n\t\t\telse if ((ground && ground != old_ground) || (bump_right == bump_left && bump_left == 0)) begin // rising and stable or no bump\n\t\t\t     state <= !state;  \n                 walk_left <= state; \n                 walk_right <= ~state;\n                 aaah <= 0;        \n\t\t\tend\n             old_ground <= ground;\n\tend\n endmodule\n"}
{"task_id": "lemmings2", "completion": "\n\treg [1:0] state;\n\tparameter ST_LEFT = 2'b01, ST_RIGHT = 2'b10;\n    \n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= ST_LEFT;\n\t\telse\n\t\t\tcase (state)\n\t\t\t\tST_LEFT:  if (bump_right) state <= ST_RIGHT;\n\t\t\t\t\t  else if(ground==0 & ~aaah) aaah <= 1'b1;\n\t\t\t\t\t  else aaah <= 1'b0;\n\t\t\t\tST_RIGHT: if (bump_left) state <= ST_LEFT;\n\t\t\t\t\t  else if(ground==0 & ~aaah) aaah <= 1'b1;\n\t\t\t\t\t  else aaah <= 1'b0;\n\t\t\tendcase\n\tend\n    \n\tassign walk_left = (state == ST_LEFT);\n\tassign walk_right = (state == ST_RIGHT);\n   \nendmodule\n"}
{"task_id": "lemmings2", "completion": " \ntypedef enum reg [1:0] {LEFT = 2'b10, RIGHT = 2'b01} state_t;\nstate_t state, next_state;\nreg bump;\n  \nalways @(posedge clk or posedge areset) begin \n\tif (areset)\n\t\tstate <= LEFT;\n\telse \n\t\tstate <= next_state;\nend\n\nassign walk_left = state[0];\nassign walk_right = state[1];\nassign bump = bump_left | bump_right;\n  \nalways @* begin\n\tcase (state)\n\t\tLEFT: \tif(bump && ground == 1'b1) next_state = RIGHT;\n\t\t\t\telse if (bump) next_state = LEFT;\n\t\t\t\telse if (!ground) next_state = state;\n\t\t\t\telse next_state = LEFT;\n\t\t   \t  \t\n\t\tRIGHT: \tif(bump && ground == 1'b1) next_state = LEFT;\n\t\t\t\telse if (bump) next_state = RIGHT;\n\t\t\t\telse if (!ground) next_state = state;\n\t\t\t\telse next_state = RIGHT;\t\t  \t  \t \t  \n\tendcase\n\tif(bump && ground == 1'b0) aaah = 1'b1; else aaah = 1'b0; \nend\n\n"}
{"task_id": "lemmings2", "completion": "\n\treg state; // 0 -> Walk left; 1 -> Walk right\n\tassign walk_left = ~state;\n\tassign walk_right = state;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 0;\n        else if (!ground || ((bump_left && !state) || (bump_right && state))) \n            state <= ~state; // change direction\n    end\n    \n\tassign aaah = ground & ~(bump_left | bump_right); // the Lemmings \"aaah\" when falling\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\ntypedef enum {LEFT, RIGHT} direction; // Define the states of our FSM. \ndirection currentState, nextState;  \nreg falling;                         // Flag for whether Lemming is in the middle of falling.\n\n// State Machine\nalways @(posedge clk or posedge areset) begin\n\tif (areset)\n\t\tcurrentState <= LEFT;      // Asynchronous reset to initial state. \n\telse \n\t\tcurrentState <= nextState; // Update current state on each clock tick.\nend\n\n// Next State Logic\nalways @(*) begin \n\tcase (currentState)  \n\t\tLEFT:\n\t\t\tif (!ground && bump_right) begin\n\t\t\t\tnextState = RIGHT; falling = 1'b0; // When bumped while falling, direction does not change. \n\t\t\tend \n\t\t\telse if (ground && !falling) nextState = LEFT; // If ground returns, but Lemming is still falling then stay in same state. \n\t\t\telse begin falling = 1'b1; nextState = currentState; end // Otherwise fall and do not change direction.\n\t\tRIGHT:  \n\t\t\tif (!ground && bump_left) begin\n\t\t\t\tnextState = LEFT; falling = 1'b0; \n\t\t\tend\n\t\t\telse if (ground && !falling) nextState = RIGHT; // If ground returns, but Lemming is still falling then stay in same state. \n\t\t\telse begin falling = 1'b1; nextState = currentState; end// Otherwise fall and do not change direction.  \t\n\tendcase\nend\n\n// Output Logic\nassign walk_left = (currentState == LEFT) && !falling; // When in the \"LEFT\" state, set output to 1 and when falling then keep it at 0.\nassign walk_right = (currentState == RIGHT)&& !falling;// Similarly for \"RIGHT\".\nassign aaah = falling;                                 // Say \"aaah!\" while falling.\nendmodule\t\n"}
{"task_id": "lemmings2", "completion": "\n\treg state; // 0 for left, 1 for right\n   reg falling;\n\n   always @(posedge clk or posedge areset) begin\n      if (areset) begin\n         state <= 0; // Start in left walk mode.\n\t\t\twalk_left <= 1'b1;\n         walk_right <= 1'b0;\n\t\t\tfalling <= 'd0;\n\t\tend \n\telse if (!falling && ground == 1'b0) begin\n            falling <= 1'b1; // Start Falling.\n\t\t\t\taaah = 1'b1;\n         end\n      else if (falling && ground == 1'b1 ) begin\n            falling <= 1'b0; // Stop Falling and resume walking in current direction.\n\t\t\twalk_left <= state; \n         walk_right <= ~state;  \n\t\t\taaah = 1'b0;      \n      end\n      else if (bump_left && ground) begin\n            state <= 1'b0; // change to left walking when bumped on the right.\n         end   \n      else if (bump_right  && ground) begin\n            state <= 1'b1; // change to right walking when bumped on the left.\n         end  \t      \t       \t\t\n   end\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\treg state; // 0 - walking left, 1 - walking right.\n    reg falling;\n    \n    assign walk_left = (state == 0) & ~falling;\n    assign walk_right = (state == 1) & ~falling;\n    \n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            state <= 0; // reset to walking left.\n            falling <= 0;\n            aaah <= 0;\n        end else begin\n          if (ground == 0 && falling == 0) begin\n              falling <= 1'b1;\n              aaah <= 1'b1;  // say \"aaah!\".\n          end else if(ground == 1) begin\n              falling <= 0;\n              aaah <= 0; // stop saying \"aaah\".\n          end\n            \n            if (bump_left && bump_right) \n                state <= state; // stay in the same direction.\n            else if (bump_left)\n                state <= 1'b1; // walk right.\n            else if (bump_right)\n                state <= 1'b0; // walk left.    \n        end         \n    end      \nendmodule\n\n"}
{"task_id": "lemmings2", "completion": "\n\t//State definitions\n\tlocalparam [1:0] LEFT = 2'b01;\n\tlocalparam [1:0] RIGHT = 2'b10;\n\treg [1:0] current_state, next_state;\n\t\n\t//State transition logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1)\n\t\t    current_state <= LEFT;\n\t\telse \n\t\t     current_state <= next_state;\n        end\n\t\n\talways @(bump_left, bump_right, ground, current_state)* begin\n\t\tcase(current_state)\n\t\t\tLEFT:begin  \n\t\t\t\tif(!ground && (bump_left || bump_right)) \n\t\t\t\t    next_state = LEFT;\n\t\t\t\telse if (!bump_right && ground) \n\t\t\t\t    next_state = RIGHT;\n\t\t\t\telse \n\t\t\t\t    next_state = LEFT;\n\t\t\tend    \n\t\t\tRIGHT:begin  \n\t\t\t\tif(!ground && (bump_left || bump_right))\n\t\t\t\t    next_state = RIGHT;\n\t\t\t\telse if (!bump_left && ground) \n\t\t\t\t    next_state = LEFT;\n\t\t\t\telse \n\t\t\t\t    next_state = RIGHT;  \n\t\t\tend    \n\t\t\tdefault:next_state = current_state;\n\t\tendcase\n        end\n        \n\t//output logic\n\tassign walk_left = (current_state == LEFT);\n\tassign walk_right = (current_state == RIGHT);\n\tassign aaah = ~ground & ((bump_left || bump_right) && !(current_state==next_state)); \nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\treg state; // 0 for right, 1 for left\n    reg falling;\n    \n\t// Reset state machine\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) begin\n\t\t\tstate <= 1'b1;\n            falling <= 1'b0;\n\t\tend \n    end\n\n\t// State transition logic\n\talways @(posedge clk) begin\n\t    if(!falling && ground==1'b0)begin // Fall condition\n\t        falling <= 1'b1;\n\t\t    aaah <= 1'b1;\n        end\n\t    else if (falling && ground == 1'b1) begin \t// Ground reappears while still falling, do nothing and continue walking state.\n            falling <= 1'b0;\n\t\t    aaah <= 1'b0;\n\t\tend  \n\t\telse if(bump_left || (state==1'b1 && bump_right)) begin // Change direction on left or right bumps when grounded\n\t\t\tstate <= ~state;\n            falling <= 1'b0;\n\t\t    aaah <= 1'b0; \n        end\n\tend\n    \n\t// Output logic\n    assign walk_left = state;\n\tassign walk_right = ~state;\n    \nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\treg walk_left_r, walk_right_r;\n\treg [1:0] state;\n\tparameter PARK = 2'b00, WALKLEFT = 2'b01, WALKRIGHT = 2'b10, FALL = 2'b11;\n\t\n\t//Reset asynchronous \n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= PARK;\n\t\t\twalk_left_r <= 1'b1;\n\t\t\twalk_right_r <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tcase(state)\n\t\t\t\tPARK: \n\t\t\t\t\tif (ground == 1) \n\t\t\t\t\t\tstate <= WALKLEFT;\n\t\t\t\tWALKLEFT:\n\t\t\t\t\tif ((bump_left == 1)) begin\n\t\t\t\t\t\twalk_left_r <= 1'b0;\n\t\t\t\t\t\twalk_right_r <= 1'b1;\n\t\t\t\t\t\tstate <= FALL;\n\t\t\t\t\tend else if(bump_right == 1)  begin\n\t\t\t\t\t\twalk_left_r <= 1'b1;\n\t\t\t\t\t\twalk_right_r <= 1'b0;\n\t\t\t\t\t\tstate <= WALKRIGHT;\n\t\t\t\t\tend,\n\t\t\t\tWALKRIGHT:\n\t\t\t\t\tif(bump_left == 1) begin\n\t\t\t\t\t\twalk_left_r <= 1'b1;\n\t\t\t\t\t\twalk_right_r <= 1'b0;\n\t\t\t\t\t\tstate <= WALKLEFT;\n\t\t\t\t\tend else if (bump_right == 1) begin\n\t\t\t\t\t\twalk_left_r <= 1'b0;\n\t\t\t\t\t\twalk_right_r <= 1'b1;\n\t\t\t\t\t\tstate <= FALL;\n\t\t\t\t\tend,\n\t\t\t\tFALL: \n\t\t\t\t\tif(ground == 1) \n\t\t\t\t\t\tstate <= (walk_left_r)? WALKLEFT : WALKRIGHT;\n\t\t\tendcase\n\t\tend\n\tend\n\nassign walk_left = walk_left_r;\nassign walk_right = walk_right_r;\nassign aaah = state == FALL && ground == 0 ? 1'b1:1'b0;  \n\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\treg [1:0] state;\n\tparameter LEFT = 2'b01, RIGHT = 2'b10;\n    \n    //State Machine\n\talways @(posedge clk or posedge areset) begin\n        if (areset == 1) \n\t\t\tstate <= LEFT;\n\t\telse\n            case(state)\n                LEFT: \n                    if(!ground && (bump_left || bump_right)) //fall and bumped on something\n                        state <= RIGHT; //change direction to right\n                    else if(ground && (bump_left || bump_right)) //ground comes back and bumped\n                        state <= LEFT;  //remains in same direction\n                RIGHT:\n                    if(!ground && (bump_left || bump_right))  //fall and bumped on something\n                        state <= LEFT;   //change to left direction\n                    else if(ground && (bump_left || bump_right))  //ground comes back and bumped\n                        state <= RIGHT;    //remains in same direction\n                default: state <= LEFT;\n            endcase\n\tend\n    \n\t//Outputs\n\tassign walk_left = (state == LEFT);  \n\tassign walk_right = (state == RIGHT); \n\tassign aaah = (!ground && ((bump_left || bump_right))); //fall and bumped on something\n"}
{"task_id": "lemmings2", "completion": "\n\treg left; // internal state \n\twire change; \n\n\t// State transition logic. \n\tassign change = (bump_left & ~ground) | (bump_right & ~ground);\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin // asynchronous reset\n\t\t\twalk_left <= 1'b1;\n\t\t\twalk_right <= 1'b0;\n\t\t\taaah <= 1'b0;\n\t\t\tleft <= 1'b1; \n\t\tend else if ((ground & ~change) | (~ground)) begin // staying in the same direction or falling, so no change.\n\t\t\twalk_left <= left;\n\t\t\twalk_right <= ~left;\n\t\t\taaah <= ground;\n\t\tend else if(change & bump_left) begin // changing to right due to a left bump, but not falling on the way\n\t\t\twalk_left <= 1'b0; \n\t\t\twalk_right <= 1'b1; \n\t\t\taaah <= 1'b0;\n\t\t\tleft <= 1'b0;\n\t\tend else if(change & bump_right) begin // changing to left due to a right bump, but not falling on the way\n\t\t\twalk_left <= 1'b1; \n\t\t\twalk_right <= 1'b0; \n\t\t\taaah <= 1'b0;\n\t\t\tleft <= 1'b1;\n\tend\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\treg [1:0] state; // 2 bits state machine\n\tparameter STATE_LEFT = 2'b00, STATE_RIGHT = 2'b01;\n\n\t// Synchronous reset to left\n\talways @(posedge clk or posedge areset) begin\n\tif (areset == 1) \n\t\tstate <= STATE_LEFT;\n\telse case(state)\n\t\tSTATE_LEFT: if(!ground && bump_right) state <= STATE_RIGHT;\n\t\tSTATE_RIGHT: if(!ground && bump_left) state <= STATE_LEFT;\n\tendcase \n\tend\n  \n\t// Moore output decoding (walk left/right or fall aaah)\n\tassign walk_left = (state == STATE_LEFT);\n\tassign walk_right = (state == STATE_RIGHT);\n\tassign aaah = ground;\n \nendmodule\n"}
{"task_id": "lemmings2", "completion": "\ntypedef enum {LEFT, RIGHT} direction;\ndirection state, next_state;\n  \nalways @(posedge clk or posedge areset) begin\n  if (areset)\n    state <= LEFT;\n  else\n    state <= next_state;\nend\n\n// State transition logic\nalways @(*) begin\n  case (state)\n    LEFT : begin\n      if (ground==0 || (bump_left && bump_right)) begin\n        next_state = RIGHT; // Fall and change direction when bumped or ground is off.\n      end else if ((bump_left & !bump_right) || (!bump_left & bump_right)) begin \n        next_state = LEFT; // Continue walking left when only bumped on one side.\n      end else begin \n        next_state = LEFT; // Maintain the same state if no bumps.\n      end\n    end  \n    \n    RIGHT : begin\n      if (ground==0 || (bump_left && bump_right)) begin\n        next_state = LEFT; // Fall and change direction when bumped or ground is off.\n      end else if ((bump_left & !bump_right) || (!bump_left & bump_right)) begin \n        next_state = RIGHT; // Continue walking right when only bumped on one side.\n      end else begin \n        next_state = RIGHT; // Maintain the same state if no bumps.\n      end\n    end  \n    \n    default : next_state = LEFT; // Default to left, just in case.\n  endcase\nend\n\n// Output logic\nassign walk_left  = (state==LEFT);\nassign walk_right = (state==RIGHT);\nassign aaah       = !ground;   // The Lemming says 'aaah!' when on the floor.\n\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\n    reg state; //0 is left, 1 is right\n    assign walk_left = (state == 0) ? 1'b1 : 1'b0;\n    assign walk_right = (state == 1) ? 1'b1 : 1'b0;\n    \n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= 0; // start from left state by default\n\t\telse if(!ground) \n\t\t\taaah <= 1; // says \"aaah!\" while falling\n\t\telse\n\t\t\taaah <= 0; \n\t\t\t\n        else if(bump_left && bump_right || !bump_left && !bump_right ) // If bumped on both sides, still switch directions.\n            state <= state;   \n        else if(bump_left)   // Bumped on the left side, walk right.\n            state <= 1'b1; \n        else if(bump_right) // Bumped on the right side, walk left.\n            state <= 1'b0;    \t\t   \t\n    end\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\ntypedef enum {LEFT=2'b01, RIGHT=2'b10} direction; // Define states.\ndirection state; \t\t\t\t\t\t\t\t\t// Initialize current state to be LEFT initially.\n\nalways @(posedge clk or posedge areset) begin    // Asynchronous reset on rising edge of clock.\n\tif (areset == 1'b1)  \n\t\tstate <= LEFT;\t\t\t                 \n\telse begin\n\t\tcase (state) \n\t\t\tLEFT:  walk_left <= 1'b1;\n\t\t\t       if(ground==0 && bump_right==0) begin // Lemming falls.\n\t\t\t\t    aaah <= 1'b1;\n\t\t\t\t\t state <= RIGHT;         // Transition to right state.\n\t\t\t   end else if (ground == 1 || (bump_left & ~bump_right)) begin \n\t\t\t\t\t walk_left <= 1'b0;      // Lemming comes back up, keep walking left.\n\t\t\t\t end \t\t\n\t\t\t   \t      \n\t\t\tRIGHT: walk_right <= 1'b1;\n\t\t\t       if(ground==0 && bump_left==0) begin // Lemming falls.\n\t\t\t\t\t aaah <= 1'b1;\n\t\t\t\t\t state <= LEFT;          // Transition to left state.\n\t\t\t\t end else if (ground == 1 || (bump_right & ~bump_left)) begin \n\t\t\t\t\t walk_right <= 1'b0;     // Lemming comes back up, keep walking right.\n\t\t\t\t end  \t        \n\t\t\t       \t\t   \t   \n\t\tendcase\n\tend\nend\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\n\treg state; // 0 = walk left, 1 = walk right.\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 0;  \n\t\t\twalk_left <= 1'b0;\n        \twalk_right <= 1'b0;\n        \taaah <= 1'b0;\n        end \n    \telse case(state)\n            0: begin // walk left.\n                walk_left <= 1'b1;\n\t\t\t    walk_right <= 1'b0;\n\t\t        if (ground == 1 && bump_left) begin  \n                    state <= 1; // change to walk right and fall. \n\t\t\t\t\twalk_left <= 1'b0;\n                \taaah <= 1'b1; // said \"aaah!\".\n            \tend\n\t\t        else if (ground == 1 && bump_right) begin  \n                    state <= ~state; // change to walk left and fall. \n\t\t\t\t    walk_left <= 1'b1;\n                \taaah <= 1'b1; // said \"aaah!\".\n            \tend \n\t\t\t\telse if (ground == 0 && bump_right) begin  \n                    state <= state; // still walking left and falling. \n\t\t\t\t    walk_left <= 1'b1;\n                \taaah <= 1'b1; // said \"aaah!\".\n            \tend \n\t\t\t\telse if (ground == 0 && bump_left) begin  \n                    state <= state; // still walking right and falling. \n\t\t\t\t    walk_right <= 1'b1;\n                \taaah <= 1'b1; // said \"aaah!\".\n            \tend else begin\n\t\t\t        state <= state;\n\t\t            aaah <= 1'b0; // did not say anything.\n\t\t       end \n             end\n             \n        \t1: begin // walk right.\n                walk_right <= 1'b1;\n\t\t\t    walk_left <= 1'b0;\n    \t        if (ground == 1 && bump_right) begin  \n                    state <= state; // still walking right and fall. \n\t\t\t\t    walk_right <= 1'b1;\n                \taaah <= 1'b1; // said \"aaah!\".\n            \tend\n\t\t        else if (ground == 1 && bump_left) begin  \n                    state <= 0; // change to walk left and fall. \n\t\t\t\t    walk_right <= 1'b0;\n                \taaah <= 1'b1; // said \"aaah!\".\n            \tend \n\t\t\t\telse if (ground == 0 && bump_left) begin  \n                    state <= state; // still walking right and falling. \n\t\t\t\t    walk_right <= 1'b1;\n                \taaah <= 1'b1; // said \"aaah!\".\n            \tend \n\t\t\t\telse if (ground == 0 && bump_right) begin  \n                    state <= state; // still walking left and falling. \n\t\t\t\t    walk_left <= 1'b1;\n                \taaah <= 1'b1; // said \"aaah!\".\n            \tend else begin\n\t\t\t        state <= state;\n\t\t            aaah <= 1'b0; // did not say anything.\n\t\t       end \n        \tend   \n     \tendcase  \n     end\nendmodule \n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\t//state declarations\n    localparam [1:0] S0 = 2'b00;\n    localparam [1:0] S1 = 2'b01;\n    localparam [1:0] S2 = 2'b10;\n    localparam [1:0] S3 = 2'b11;\n\t\n\t//state register \n    reg [1:0] state = S0;\n    \n    //output z is the complement of x\n    assign z = ~x;\n        \n    always @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) \n            state <= S0;\n            \n       else begin \n\t\tcase (state) \n\t\t\tS0: if (x==1'b0)\n                    state <= S1;  \n                else \n                    state <= S2;\n                \n\t\t    S1: state <= S3;         //When x is 0, stay in state 1.\n\t\t    \n            S2: state <= S3;         //When x is 1, go to state 3.\n\t\t\t\t\n\t\t\tS3: if (x==1'b0)  \n                    state <= S1;   \n                else \n                    state <= S0;       \n                \n          endcase      \n      end    \nend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n// Moore state machine to generate 2's complement output from serial input.\nparameter [1:0] S0 = 2'b00; // reset state\nparameter [1:0] S1 = 2'b01; // first bit of number received, output set based on x\nparameter [1:0] SR = 2'b10; // subsequent bits of a number, outputs remain same except z which becomes x\ntypedef enum logic[1:0]{S0, S1, SR} state_type;\nstate_type state, next_state;\nlogic z, nz;\n\t  \nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1) // reset condition\n\t\tstate <= S0;\n\telse \n\t\tstate <= next_state; \nend\n\t\t    \n// State transition logic and output decoding \nalways @(*) begin\n\tcase(state)\n\t\tS0: begin  \n\t\t\tz <= 1'b0; // reset condition, set z as 0\n\t\t\tif (x == 1'b0) // if the input is '0', next state remains S0 and Z is 0. If x = 1 then the next state changes to S1 and Z stays same because it should be 2's complement of only one bit which is zero so output will be negative\n\t\t\t\tnext_state = S0;  \n\t\t\telse begin\n\t\t\t    nz <= ~x; // calculate negation if input x=1, as we are getting 2's complement this would be the first bit\n\t\t\t\tnext_state = S1;\n            end\n        end\n\t\tS1: begin  // state when only one bit is received. Output will be negative of this single bit number.\n\t\t\tz <= nz;   \n\t\t\tif (x == 1'b0) begin // if next input x=0, then the next state remains S1 and Z same because we are getting another bit for 2's complement. If x = 1, then z becomes negation of this bit as it will be part of our 2's complement\n\t\t\t\tnz <= nz; // if next input is '0', next state remains S1 and z same\n                next_state = S1;  \n\t\t    end\n\t\t\telse begin\n\t\t\t    nz <= ~x;// calculate negation for the second bit because we are getting another bit to make 2's complement. Z will be negation of this new incoming x bit.\n\t\t\t\tnext_state = SR; // transition to next state after two bits input is received, it will continue receiving subsequent bits and updating z in each cycle as per calculation in else part of the code\n            end\n        end \n\t\tSR: begin   // State for all subsequent bits other than first bit.\n\t\t    z <= nz;// Z remains same because we are just continuously updating nz with negation of x at each state transition.\n\t\t\tif (x == 1'b0) // if next input is 0, then the current output will be still same as previous and the next state remains SR. If input = 1, then z becomes negation of this bit as it will make up part of our final 2's complement number.\n\t\t\t\tnext_state = SR;  \n\t\t\telse begin\n                nz <= ~x;// calculate negation if next input x=1 for subsequent bits because we are getting more bits to form the complete 2's complemented number\n\t\t\t\tnext_state = SR; // remain in state SR as long as there is more input bits to receive and process. Output z remains same as previous state.\n            end\n        end\t\t   \n\t\tdefault: next_state = S0;  \n\tendcase\nend\nendmodule \n"}
{"task_id": "ece241_2014_q5a", "completion": "\n    reg [31:0] shift_reg;  //32 bit register to hold input data\n    wire msb;              //Most Significant Bit of the shift_reg\n    \n    assign msb = shift_reg[31];  //Extracting MSB\n  \n    always @(posedge clk or posedge areset) begin  //Synchronous reset on positive edges\n        if (areset)\n            shift_reg <= 0;\n        else\n            shift_reg <= {shift_reg[30:0], x};  //Right shifting the register by one bit and inputting x at MSB position\n    end\n  \n    assign z = ~msb & shift_reg[31];  //2's complement is obtained by inverting msb if it's '1' else leave as it is.\nendmodule\n\n"}
{"task_id": "ece241_2014_q5a", "completion": "\nreg [15:0] state;\nassign z = state[15];\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1) \n\t\tstate <= 16'h0;\n\telse if (x != state[15]) \n\t\tstate <= {state[14:0], ~state[15]};\nend\n\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n// Moore machine state definitions\nlocalparam S0 = 2'b00; // Start State -> Shift/Negate State if 'x' is 1\nlocalparam SN = 2'b01; // Shift State -> Negate State if 'x' is 0\nlocalparam NZ = 2'b10; // Negate State -> Output State if 'x' is 1\nlocalparam OT = 2'b11; // Output State -> Start State if 'x' is 0 and Reset is not asserted\n\n// Declare state register and next_state signal\nreg [1:0] state, next_state;\n\n// Declare output Z\nwire z = (state == NZ);\n\n// Synchronous reset part of Moore machine\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tstate <= S0;\n\telse\n\t\tstate <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n\tcase (state)\n\t\tS0: if (!x) next_state = SN; else next_state = NZ; // If 'x' is 0, move to Negate State. Otherwise, stay at Start and move to Output State when x changes to 1\n\t\tSN: if (!x) next_state = S0; else next_state = state; // If 'x' is 0, return to start. Otherwise, stay in shift state.\n\t\tNZ: if (x) next_state = SN; else next_state = OT; // If 'x' is 1, move to Negate State and output value. Otherwise, go to Output state when x changes to 0\n\t\tOT: if (!x && !areset) next_state = S0; else next_state = state; // If 'x' is 0 and Reset is not asserted, return to start state. Otherwise, stay at output state\n\tendcase\nend\n\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\n\t//State defination\n    localparam [1:0] S0 = 2'b00; //initial state\n    localparam [1:0] S1 = 2'b01; //first bit received & first bit processed\n\tlocalparam [1:0] SF = 2'b10; //final state after last bit of number is processed. \n    \n\t//State Registers\n\treg [1:0] state_reg,state_next;\n\n    output reg z ;// Output variable Z\n\n    // FlipFlop for storing the data\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state_reg <= S0;  \t//reset to start\n\telse      \n\t    state_reg <= state_next;     \t\n     end\n            \n    // Next State logic for FSM\n    always @(state_reg or x) begin\n\tcase (state_reg)\n          \n        S0:  if (!x)  \t\t\t// if the reset is not asserted and data is valid, go to state 1.\n\t\tstate_next = S1;\n\telse state_next = S0;   // else remain in state 0.\n    \n       S1:  if(~x)      //if we are already processing the number and still more bits come, continue to process further bits.\n            state_next = S1; \n        else \t\t   \t//once a zero bit is received, go to final state.\n\t    state_next = SF;  \n        \n       SF: state_next = S0; // once the last bit of number is processed and reseted back to start state.\n\tendcase\n     end\n     \n  assign z = ~((state_reg == SF) ^ x);// Output Z - if we are in final state then output will be 2's complement else zero.  \n     \nendmodule\n\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\n\treg [23:0] q; // 16 bit register for holding the result of complementing. The size can be any arbitrary number based on your requirements.\n\tassign z = q[23]; // The MSB is outputted as Z\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\t\tif (areset) \n\t\t\t\tq <= 24'b0; \t// Asynchronous reset to zero. Any number based on your requirements.\n\t\t\telse \n\t\t\t\tq <= {q[22:0], ~x}; // Shifts the existing register and adds in the new bitwise complement of x\n\tend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\treg [31:0] state;  // to handle arbitrary length numbers\n\tassign z = state[31];  \t// output the most significant bit as Z\n\n\talways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tstate <= 32'b0;   \t// reset state to zero when reset is asserted\n\telse \n\t\tstate <= {state[30:0],x}; // on each rising edge of the clock, shift all bits one step right and put x as the new most significant bit\nend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\n    reg [31:0] state;  // Adjust the size of the register according to your requirement.\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) \n            state <= 0;  // Resets all bits on synchronous active high reset.\n        else \n            state <= {x, state[31:1]};  \n    end\n    \n    assign z = ~state[0] & |state[31:1]; // Calculates the 2's complement of the input number.\n\t\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": " \n\t// Declare the states of our Moore Machine  \n    localparam [1:0] S0 = 2'b00; // Initial state\n    localparam [1:0] S1 = 2'b01; // First stage - take the first bit and set Z to it\n\tlocalparam [1:0] SR = areset;  // Reset State, if reset is active go back to S0 else move onwards.  \n    \n    reg [1:0] state_reg, state_next;  \n    reg z_reg, z_next;  \n      \n    // Update the flip flops (state and output) \n    always @(posedge clk or posedge areset) begin\n        if(areset)begin\n            state_reg <= SR;  // Asynchronous reset to S0\n\t\t\tz_reg <= 1'b0;   // Reset the z register to zero.\n        end\n         else begin\n           state_reg <= state_next;\n\t\t\tz_reg<= z_next;  \n      end\n    end\n      \n    \n  // Next-state logic and output decode\n    always @(*) begin\n        case (state_reg)\n            S0 : begin  \n                if(!x)begin  \n                    state_next = S1; \n\t\t\t\t\tz_next = 1'b0;  \n                end else begin  \n                     state_next = S0;   \n\t\t\t\t\t z_next= 1'b0;\n                 end\n            end            \n\t\t\tS1 :begin    \n\t\t\t\tif(!x) begin  \n                    state_next = S0; \n\t\t\t\t\tz_next = ~z_reg;   // Flip the Z bit if X is not equal to zero\n                end else begin  \n                     state_next = S1;   \n\t\t\t\t\t z_next= z_reg;\n                 end        \n\t\t\t end            \n            SR :begin    \n                    state_next = S0; \n\t\t\t\t\tz_next = 1'b0;  // Reset the Z bit.\n                end  \n            default: begin\n                 state_next = S0;   \n\t\t\t\t z_next= 1'b0;\n             end                 \n        endcase\n     end  \n      assign z= z_reg;        \nendmodule      \n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\t// define state variables for the Moore machine\n\ttypedef enum {S0, S1} statetype;\n\tstatetype state, nextstate;\n\n\t// State transition logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) \n\t\t\tstate <= S0; // Asynchronous reset to state 0 on the rising edge of clock.\n\t\telse \n\t\t\tstate <= nextstate; // State transition\n\tend\n\n\t// Next state logic and output decode\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: begin\n\t\t\t\tif(x == 1'b0) begin  \n\t\t\t\t\tnextstate = S0; z = 1'b0; // If x is 0, remain in State 0 and Z=0.\n\t\t\t\tend\n\t\t\t\telse if (x == 1'b1) begin\n\t\t\t\t\tnextstate = S1; z = 1'b1; // If x is 1, move to State 1 and Z=1.\n\t\t\t\tend\t\t\n\t\t\tend\n\t\t\tS1: begin  \n\t\t\t\tif(x == 1'b0) begin\n\t\t\t\t\tnextstate = S1; z = 1'b1; // If x is 0, remain in State 1 and Z=1.\n\t\t\t\tend\n\t\t\t\telse if (x == 1'b1) begin\n\t\t\t\t\tnextstate = S0; z = 1'b0; // If x is 1, move to State 0 and Z=0.\n\t\t\t\tend\t\t  \n\t\t\tend\n\t\t\tdefault: ; // Default case, do nothing.\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\treg [31:0] state;\n\tassign z = state[31];  // Output is the MSB of the state register.\n\t\n\t// State transition function\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= 32'h0;\n\t\telse if (~areset)\n\t\t\tstate <= {x, state[31:1]}; // Shift right by one and put 'x' at LSB.\n\tend \nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\t//Moore state machine\n\treg [15:0] state; //This is arbitrary as long as it can handle the maximum number of bits\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) \n\t\t\tstate <= 16'b0;\n\t\telse if(areset == 1'b0) begin\n\t\t\tcase (state[15:0]) //This is the current state of the state machine, it will change depending on the input x\n\t\t\t\t16'h0 : state <= x ? 16'hFFFF : 16'h7FFF; //If x == 0 then stay at FFFF (for negative numbers) else go to 7FFF(For positive numbers).\n\t\t\t\tdefault: state <= {state[14:0], ~state[15]}; //shift right and invert the sign bit.\n\t\t\tendcase\n\t\tend\n\tend\n\t//Output is just the MSB of our state machine (Z)\n\tassign z = state[15];\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\treg [31:0] regs;\n\tassign z = regs[0]; // The most significant bit is the output\n\t\t\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t        regs <= 32'b0; \n\t    else  \n    \t    regs <= {regs[30:0], ~regs[31] ^ x}; // Rotate left and negate the most significant bit XORed with new input.\n\tend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n    reg [31:0] shift;   // Register to store the 2s complement of number.\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            shift <= 32'b0;\n        end \n\t\telse begin\n\t\t\t// Shift register and take one bit from input x.\n            shift <= {x,shift[31:1]};   \n        end\n    end  \n    \n    // Output Z is the MSB of shifted value.\n    assign z = shift[31]; \nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n  reg [31:0] state;\n  \n  always @(posedge clk or posedge areset) begin\n    if (areset)\n      state <= 32'd0;\n    else\n      state <= {state[30:0], x};\n  end\n  \n  assign z = state[31];\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\nreg [2:0] state;\nwire start, done;\n\nassign start = ~state[0];\nassign done = state[1];\n\n// State transitions\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= 3'b100; // reset to idle state\n    else \n        case (state) \n            3'b100: if (start)   state <= 3'b011; // go to input stage\n            3'b011: if (done)    state <= 3'b110; // output first bit of 2s complement\n            3'b110: if (~areset) state <= 3'b100; // start again on release of reset\n            default: state <= state;\n        endcase\nend\n\n// Output assignment based on the current state\nassign z = (state == 'b110) ? ~x : 1'b0;\n\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\treg [15:0] state; // Assuming we are dealing with 2's complement of 16-bit numbers\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) begin\n\t\t\tstate <= 0;\n\t\tend else begin\n\t\t\t// The most significant bit will always be the same as x since it is being fed in serially. \n            // Therefore, we only need to take into account lower bits for calculation.\n\t\t\tstate[14:0] <= {state[13:0], x}; \n\t\tend\n\tend\n    \n\t// The output (Z) will be the negation of the most significant bit\n\tassign z = ~ state[15];\n\nendmodule\n\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n    reg [2:0] state; // we need 3 bits to represent our states\n    \n    parameter [2:0] S_START = 3'b001; //initial state\n    parameter [2:0] S_ZERO  = 3'b010; //state where z should be driven as 'x' when x is '0' (since 2's complement of '0' remains '0')\n    parameter [2:0] S_ONES  = 3'b100; //state where we are flipping the bits since x is '1', starting from the least significant bit\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset == 1'b1) state <= S_START; // asynchronous reset, returns to start state on rising clock edge\n        else case (state) \n            S_START: state <= x ? S_ONES : S_ZERO; //if input is '0', stay in start and set output to '0'. if input is '1', go to ONES state.\n            S_ZERO: state <= x ? S_ONES : S_ZERO; //if another 0, stays at ZERO until there's a change, else flips bits.\n            S_ONES: state <= x ? S_START : S_ONES ; //once an '1' is detected it goes to start (completion). if 'x' is still '1', it keeps in the ONES state\n        endcase\n    end \n    \n    assign z = state == S_ZERO; //output Z drives as '0' when we are in the ZERO state, else '1'\n\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\n\treg [15:0] state; // Assuming max 2^16 - 1 number of bits. Adjust as needed.\n\tassign z = state[15]; // MSB is the output (Z) which will be the 2's complement.\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) begin\n\t\t\t// Reset state to initial values, here 0.\n\t\t\tstate <= 16'h0;\n\t\tend else begin\n\t\t\tstate <= {x, state[15:1]}; // Shift left and input x in the MSB position.\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\n\t// Slicing to reverse each byte order of the 32 bit input vector.\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0],in[15:8],in[23:16],in[31:24]}; \nendmodule\n\n"}
{"task_id": "vector2", "completion": "\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};  //Reversed Byte Order \nendmodule\n"}
{"task_id": "vector2", "completion": "\n\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};  //Reversing byte order of a 32 bit vector\n\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n     assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};  //Reverses the byte order of a 32-bit vector.\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0],in[15:8],in[23:16],in[31:24]};\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\n\t// This is achieved by slicing the input into bytes and rearranging them.\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]}; \n\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n    \n\tassign out = {in[7:0],  in[15:8],  in[23:16],  in[31:24]};\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n\n"}
{"task_id": "vector2", "completion": "\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\t//reversed output with same bit width can be achieved by slicing and concatenating the input in reverse order. \n\tassign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule\n"}
{"task_id": "vector2", "completion": "\n\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};  // Reverse byte order of 32-bit vector.\n\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @(y or w) begin\n\t    case ({w, y}) \n\t\t    5'b0_000 : Y2 = 0; // A\n\t\t    5'b0_001 : Y2 = 1; // B\n\t\t    5'b0_010 : Y2 = 0; // C\n\t\t    5'b0_011 : Y2 = 1; // D\n\t\t    5'b0_100 : Y2 = 1; // E\n\t\t    5'b0_101 : Y2 = 1; // F\n\t\t    default:   Y2 = 0; \n\t    endcase\t\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @(*) begin  // next-state logic for y[2] in Verilog. The output Y2 is y[2].\n\tcase (y)  \n\t\t3'b001, 3'b011, 3'b101: Y2 <= w;\t\t// States B, C, D, E\n\t\t3'b010, 3'b110: Y2 <= ~w;\t\t\t\t// States A, F\n\tendcase\nend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n  always @ (*) begin\n    case (y)\n      3'b000 : if (!w) Y2 = 1; else Y2 = 0; // A\n      3'b001 : if (!w) Y2 = 1; else Y2 = 0; // B\n      3'b010 : if (!w) Y2 = 0; else Y2 = 1; // C\n      3'b011 : if (!w) Y2 = 1; else Y2 = 0; // D\n      3'b100 : if ( w) Y2 = Y2;             // E\n      3'b101 : if ( w) Y2 = Y2;             // F\n      default: Y2 = 'x;\n    endcase\n  end\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @* begin\n\tcase (y) \n\t\t3'b000 : if (!w) Y2 = 0; else Y2 = 0;\n\t\t3'b001 : if (!w) Y2 = 0; else Y2 = 0;\n\t\t3'b010 : if (!w) Y2 = 1; else Y2 = 0;\n\t\t3'b011 : if (!w) Y2 = 0; else Y2 = 1;\n\t\t3'b100 : if (!w) Y2 = 0; else Y2 = 0;\n\t\t3'b101 : if (!w) Y2 = 1; else Y2 = 1;\n\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\nalways @* begin\n\tcase (y) \n\t\t3'b000 : if (!w) Y2 = 0; else Y2 = 0; // A\n\t\t3'b001 : if (!w) Y2 = 1; else Y2 = 0; // B\n\t\t3'b010 : if (!w) Y2 = 0; else Y2 = 1; // C\n\t\t3'b011 : if (!w) Y2 = 1; // D (two cases due to w input)\n\t\t\t\t  else Y2 = 0;\n\t\t3'b100 : if (!w) Y2 = 1; else Y2 = 0; // E\n\t\t3'b101 : if (!w) Y2 = 0; else Y2 = 1; // F\n\t\tdefault: Y2 = 'x; \t// Default case, when y is not a valid state.\n\tendcase\nend\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @* begin\n\tcase (y)\n\t\t3'b000: if (!w) Y2 = 0; else Y2 = 0;  // State A\n\t\t3'b001: if (!w) Y2 = 0; else Y2 = 0;  // State B\n\t\t3'b010: if (!w) Y2 = 0; else Y2 = 1;  // State C\n\t\t3'b011: if (!w) Y2 = 1; else Y2 = 0;  // State D\n\t\t3'b100: if (!w) Y2 = 0; else Y2 = 1;  // State E\n\t\t3'b101: if (!w) Y2 = 1; else Y2 = 0;  // State F\n\t\tdefault: Y2 = 'x;\n\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n\n\t// Next-state logic for y[2] \n\talways @* begin\n\t\tcase (y) \n\t\t\t3'b000 : if (!w) Y2 = 1; else Y2 = 0; // A\n      \t\t3'b001 : if (!w) Y2 = 1; else Y2 = 0; // B\n      \t\t3'b010 : if (!w) Y2 = 0; else Y2 = 1; // C\n      \t\t3'b011 : if (!w) Y2 = 0; else Y2 = 0; // D\n      \t\t3'b100 : if (w)  Y2 = 0; else Y2 = 0; // E\n      \t\t3'b101 : if (w)  Y2 = 1; else Y2 = 0; // F\n\t\tendcase\n    end\n    \nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @(y or w) begin\n\t\tcase ({w,y}) \n\t\t\t4'b00_00, 4'b01_01, 4'b10_10, 4'b11_00 : Y2 = 0;\n\t\t\t4'b00_01, 4'b01_10, 4'b10_00, 4'b11_01 : Y2 = 1;\n\t\t\tdefault: Y2 = 'x; // uninitialized\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @(*) begin\n\t\tcase (y) \n\t\t\t3'b000 : if (!w) Y2 <= 0; else Y2 <= 1; // state A\n\t\t\t3'b001 : if (!w) Y2 <= 1; else Y2 <= 0; // state B\n\t\t\t3'b010 : if (!w) Y2 <= 0; else Y2 <= 1; // state C\n\t\t\t3'b011 : if (!w) Y2 <= 1; else Y2 <= 0; // state D\n\t\t\t3'b100 : if ( w) Y2 <= Y2;             // state E\n\t\t\t3'b101 : if (!w) Y2 <= 1; else Y2 <= 0; // state F\n\t\t\tdefault: Y2 <= 0; \n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\nalways @(*) begin\n\tcase (y) \n\t\t3'b000 : if (!w) Y2 = 1'b0; else Y2 = 1'b0; // A\n\t\t3'b001 : if (!w) Y2 = 1'b1; else Y2 = 1'b0; // B\n\t\t3'b010 : if (!w) Y2 = 1'b0; else Y2 = 1'b1; // C\n\t\t3'b011 : if (!w) Y2 = 1'b1; else Y2 = 1'b0; // D\n\t\t3'b100 : if ( w) Y2 = Y2;                 // E \n\t\t3'b101 : if ( w) Y2 = Y2;                 // F\n\t\tdefault: Y2 = 1'bx;                        // X\n\tendcase\nend\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\nalways @(*) begin\n\tcase (y) \n\t\t3'b000 : if (!w) Y2 = 1; else Y2 = 0; // state A\n\t\t3'b001 : if (!w) Y2 = 0; else Y2 = 0; // state B\n\t\t3'b010 : if (!w) Y2 = 1; else Y2 = 0; // state C\n\t\t3'b011 : if (!w) Y2 = 1; else Y2 = 1; // state D\n\t\t3'b100 : if (!w) Y2 = 0; else Y2 = 0; // state E\n\t\t3'b101 : if (!w) Y2 = 1; else Y2 = 1; // state F\n\tendcase\nend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @(*) begin\n\t\tcase (y)\n\t\t\t3'b000 : if (!w) Y2 <= 0; else Y2 <= 1; // state A\n      \t\t3'b001 : if (!w) Y2 <= 0; else Y2 <= 0; // state B\n      \t\t3'b010 : if (!w) Y2 <= 0; else Y2 <= 0; // state C\n      \t\t3'b011 : if (!w) Y2 <= 0; else Y2 <= 0; // state D\n\t\t\t3'b100 : if (!w) Y2 <= 1; else Y2 <= 0; // state E\n      \t\t3'b101 : if (!w) Y2 <= 0; else Y2 <= 0; // state F\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n\talways @* begin\n\t\tcase (y) \n\t\t\t3'b000 : if (!w) Y2 = 0; else Y2 = 1; // state A\n\t\t\t3'b001 : if (!w) Y2 = 1; else Y2 = 0; // state B\n\t\t\t3'b010 : if (!w) Y2 = 0; else Y2 = 1; // state C\n\t\t\t3'b011 : if (!w) Y2 = 0; else Y2 = 0; // state D\n\t\t\t3'b100 : if (!w) Y2 = 1; else Y2 = 1; // state E\n\t\t\t3'b101 : if (!w) Y2 = 0; else Y2 = 0; // state F\n\t\t\tdefault: Y2 = 'x; \n\t\tendcase \n\tend\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\n\n\talways @(*) begin \n\t\tcase (y)   // using case statements to handle all the different states.\n\t\t    \n\t\t\t3'b000 : if (w == 1'b0) Y2 = 0; else Y2 = 1; \t// State A, y[3:1]=000.\n\t\t\t3'b001 : if (w == 1'b0) Y2 = 1; else Y2 = 0; \t// State B, y[3:1]=001.\n\t\t\t3'b010 : if (w == 1'b0) Y2 = 0; else Y2 = 1; \t// State C, y[3:1]=010.\n\t\t\t3'b011 : if (w == 1'b0) Y2 = 1; else Y2 = 1; \t// State D, y[3:1]=011.\n\t\t\t3'b100 : if (w == 1'b0) Y2 = 0; else Y2 = 0; \t// State E, y[3:1]=100.\n\t\t\t3'b101 : if (w == 1'b0) Y2 = 1; else Y2 = 0; \t// State F, y[3:1]=101.\n\t\t\tdefault : Y2 = 'x; // Default case for unhandled states\n      \n        endcase\n   end\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n    \n    always @(*) begin\n        case (y) \n            3'b000 : if (!w) Y2 <= 1; else Y2 <= 0; // A\n            3'b001 : if (!w) Y2 <= 1; else Y2 <= 0; // B\n            3'b010 : if (!w) Y2 <= 0; else Y2 <= 1; // C\n            3'b011 : if (!w) Y2 <= 0; else Y2 <= 1; // D\n            3'b100 : if ( w) Y2 <= Y2; else Y2 <= 0; // E\n            3'b101 : if (!w) Y2 <= 0; else Y2 <= 1; // F\n            default: Y2 <= 0;\n        endcase \n    end\n    \nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n\n    always @* begin\n        case (y) \n            3'b000 : if (!w) Y2 = 1; else Y2 = 0; // A\n            3'b001 : if (!w) Y2 = 1; else Y2 = 0; // B\n            3'b010 : if (!w) Y2 = 0; else Y2 = 1; // C\n            3'b011 : if (!w) Y2 = 0; else Y2 = 0; // D\n            3'b100 : if ( w) Y2 = Y2; else Y2 = 0; // E\n            3'b101 : if ( w) Y2 = 1; else Y2 = 0; // F\n            default: Y2 = 0;\n        endcase\n    end\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\n\t//Next State Logic\n\talways @ (y or w) begin\n\tcase({w, y}) \n\t\t4'b00_00 : next_state = 3; // A -> 00(B), 0(A)\n\t\t4'b10_01 : next_state = 6; // B -> 01(C), 0(D)\n\t\t4'b00_10 : next_state = 9; // C -> 10(E), 0(D)\n\t\t4'b00_11 : next_state = 8; // D -> 11(F), 0(A)\n\t\t4'b10_10 : next_state = 7; // E -> 10(E), 1(D)\n\t\t4'b01_10 : next_state = 5; // F -> 10(C), 1(D)\n\t\tdefault: next_state = 3; // default to A\n\tendcase\n\tY2 = next_state[1];\n\tend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n\n\talways @* begin \n\t\tcase (y)\t\t\t// Inputs are the current states\n\t\t\t3'b000 : if (!w) Y2 <= 0; else Y2 <= y[1]; // A --> B = 000 to 0\n\t\t\t3'b001 : if (!w) Y2 <= y[0]; else Y2 <= ~y[1]; // B --> A = 001 to 0 or B --> B = 001 to 1\n\t\t\t3'b010 : if (!w) Y2 <= y[0]; else Y2 <= y[1]; // C --> E = 010 to 0 or E --> E = 010 to 1\n\t\t\t3'b011 : if (!w) Y2 <= ~y[0]; else Y2 <= y[1]; // D --> F = 011 to 0 or F --> D = 011 to 1\n\t\t\t3'b100 : if ( w) Y2 <= y[1]; else Y2 <= 0;     // E --> E = 100 to 1\n\t\t\t3'b101 : if (!w) Y2 <= ~y[0]; else Y2 <= 0;\t   // F --> C = 101 to 1 or D --> D = 101 to 0\n\t\t\tdefault: Y2 <= 0;\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q6b", "completion": "\n\n\talways @(*) begin\n\t\tcase (y) \n\t\t\t3'b000: if (w) Y2 <= 0; else Y2 <= y[2]; // A\n\t\t\t3'b001: if (w) Y2 <= 1; else Y2 <= y[2]; // B\n\t\t\t3'b010: if (w) Y2 <= 0; else Y2 <= y[2]; // C\n\t\t\t3'b011: if (w) Y2 <= 1; else Y2 <= y[2]; // D\n\t\t\t3'b100: if (w) Y2 <= 0; else Y2 <= y[2]; // E\n\t\t\t3'b101: if (w) Y2 <= 1; else Y2 <= y[2]; // F\n\t\t\tdefault: Y2 <= y[2]; \n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\n    always @* begin\n        case (y) \n            3'b000 : if (w == 0) Y2 = 1; else Y2 = 0; // A (0) --0--> B\n            3'b001 : if (w == 0) Y2 = 0; else Y2 = 1; // A (0) --1--> A\n            3'b010 : if (w == 0) Y2 = 1; else Y2 = 0; // B (0) --0--> C\n            3'b011 : if (w == 0) Y2 = 0; else Y2 = 1; // B (0) --1--> D\n            3'b100 : if (w == 0) Y2 = 0; else Y2 = 1; // C (0) --0--> E\n            3'b101 : if (w == 0) Y2 = 0; else Y2 = 1; // C (0) --1--> D\n            3'b110 : if (w == 0) Y2 = 0; else Y2 = 1; // D (0) --0--> F\n            3'b111 : if (w == 0) Y2 = 1; else Y2 = 0; // D (0) --1--> A\n            default: Y2 = Y2;  // Default Case\n        endcase\n    end\nendmodule\n"}
{"task_id": "kmap1", "completion": "\n   assign out = (~a & ~b & ~c) | (~a & ~b & c )|(~a & b & c)  | (b & a & c );\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n    assign out = (b & ~c) | a | (b & c) | (~a & ~b & c);\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\tassign out = (b == 1'b0 && c == 1'b0) ? 1'b0 :\n\t\t\t\t(a == 1'b1 || (c==1'b1)) ? 1'b1 :\n\t\t\t\t1'b1;\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\tassign out = ((~b&c)|a)&~c;\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\t// Using the given Karnaugh map and using logic gates to implement it.\n\tassign out = ((~b & ~c) | (~a & ~c) | a | b);  // Equivalent to Karnaugh map equation for given truth table\nendmodule\n"}
{"task_id": "kmap1", "completion": "\nassign out = (a && !b) || (!c && b) || c;\nendmodule\n"}
{"task_id": "kmap1", "completion": "\n\tassign out = (a & ~b & ~c) | (~a & ~b & ~c) | (~a & b & ~c) |( a & b & c);\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\t// Using Karnaugh Maps to find the equation for the given map.\n\t// We can see that if (a && !c) || (!b && c), then f = 1 which is same as \n    // !(!(a&&c))||b = a'c + b\n\tassign out = a ~^ c;  \nendmodule\n"}
{"task_id": "kmap1", "completion": "\n    assign out = (c & ~b) | (~a & c & ~b) | (~a & ~b) | (~a & c & b);\nendmodule \n"}
{"task_id": "kmap1", "completion": "\n\nassign out = (c & ~b) | ((~a) & ~c & b) | ((~a) & c) | ((~a) & ~c & ~b);\n\nendmodule \n\n"}
{"task_id": "kmap1", "completion": "\nassign out = (a & ~b) | (~c);\nendmodule\n"}
{"task_id": "kmap1", "completion": "\nassign out = (~b & ~c) | (~a & c & ~b) | (~a & ~b & c) | (a & ~b & ~c); \nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\nassign out = (a && !b) || (!c && ((a && b)||(!a && !b)));\n\nendmodule\n"}
{"task_id": "kmap1", "completion": "\n    assign out = (b&c)|a;\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n    assign out = (~b & ~c) | (~a & c) | (~a & ~b) | (~a & ~c);\nendmodule\n"}
{"task_id": "kmap1", "completion": "\nassign out = (a & ~c) | (b | c) | b;\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\tassign out = (b & ~c) | a;\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\tassign out = (~b & ~c) | (~a & c ) | ( a & ~b );\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n    assign out = (b & ~c) | a | (~b & c) | (b & c);\nendmodule\n\n"}
{"task_id": "kmap1", "completion": "\n\tassign out = (!b && !c) || (a && !b && c) || (a && b && c);\nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\nwire w1;\n\tassign w1 = a | b | c;\n\tassign q = d & w1;\nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\n\twire [3:0] wire_a;\n\tassign wire_a = {a,b,c,d};\n\t\t\n\talways @(*) begin\n\t\tcase (wire_a) \n\t\t\t4'h1 : q = 0;\n\t\t\t4'h2 : q = 1;\n\t\t\t4'h3 : q = 0;\n\t\t\t4'h4 : q = 1;\n\t\t\t4'h5 : q = 0;\n\t\t\t4'h6 : q = 1;\n\t\t\t4'h7 : q = 0;\n\t\t\t4'h8 : q = 1;\n\t\t\tdefault: q = wire_a[3]; // in case of other values, we maintain the last bit\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit2", "completion": "\nassign q = ~((a&(b|c))^d) & ~(b&c)&a; //This is equivalent to the given truth table.\nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\nwire nand_ab;\nwire nand_bc;\nwire nand_cd;\n\nnand n1(a,b,nand_ab);\nnand n2(b,c,nand_bc);\nnand n3(c,d,nand_cd);\nnand n4(nand_ab,nand_cd,q);\nendmodule \n"}
{"task_id": "circuit2", "completion": "\nreg [3:0] m; // Declare a four-bit register to store intermediate values.\n\n// First stage of combinational logic using XOR gates and NOT gates.\nassign m[0] = (a&&d) || (b&&c); \nassign m[1] = d && !(a||b||c);\nassign m[2] =  a^c;  \nassign m[3] = b^(!c&&d);   \n\n// Output is the OR of all four intermediate values.\nassign q = |m; \nendmodule \n"}
{"task_id": "circuit2", "completion": "\n\n\tassign q = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (a & ~b & ~c & ~d);\nendmodule\n \n"}
{"task_id": "circuit2", "completion": "\n\n\tassign q = ((~a & ~b & d) | (~c & ~d)) ;\nendmodule\n"}
{"task_id": "circuit2", "completion": "\nwire x;\nassign x = ((a & ~b) | (~c & b)) ^ d;\nassign q = ~(x | a | b) & ~c;\nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\n\tassign #5 q = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (a & ~b & ~c & d);\nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\n\twire [3:0] data;\n\tassign data = {a,b,c,d};\n\t\t  \n\t// Combinational logic\n\tassign q = (data==4'b1000) || (data==4'b0111) || (data==4'b0011) || \n           \t    (data==4'b1100) || (data==4'b1011) || (data==4'b1101) || \n                    (data==4'b0001);\nendmodule \n"}
{"task_id": "circuit2", "completion": "\nassign q = ~(a & b & c & d) & (b | c | d);\nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\n\treg q;\n\t\n\talways @(*) begin\n\t    if (a) \n\t        q <= d;\n        else if (b) \n            q <= ~c;\n        else if (c) \n            q <= b & ~d;\n        else if (d) \n            q <= a | c;\n    end\nendmodule\n"}
{"task_id": "circuit2", "completion": "\n    reg q;\n    \n    always @(*) begin\n        case({a,b,c,d})\n            4'h1 : q <= 0;\n            4'h2 : q <= 1;\n            4'h4 : q <= ~q;\n            default: q <= q;\n        endcase\n    end \nendmodule\n"}
{"task_id": "circuit2", "completion": "\n\twire w;\n\t\n\t// Combinational logic to determine the output based on inputs.\n\tassign q = (~a & ~b & c) | (d & b & ~c); // Based on given waveforms this is equivalent to OR operation of a,b and c or d when b is true else 0. \nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\n\twire w; // Temporary wire to store value of q during d flip-flop stage.\n    \n\t// Using 4 D Flip-Flops with asynchronous reset and clocked by inputs a, b, c and d respectively.\n    always @(a or b or c or d) begin\n        if (b == 1'b0 && c == 1'b0 && d == 1'b0) q <= 1; // For time 5ns and higher as per given table.\n        else if (c == 1'b1 && d == 1'b0) w <= a ? ~w : w; // Rotate right by one bit at time 25ns, 40ns and so on.\n        else if (b == 1'b1 && c == 1'b0) w <= a ? w : ~w; // Rotate left by one bit at time 30ns, 45ns and so on.\n\t\telse q <= 0; // Reset for other inputs at earlier times or after rotation operation.\n    end\n    \nendmodule\n"}
{"task_id": "circuit2", "completion": "\nassign #5 a or (b and not(c) and not(d)) or (not(a) and c and not(d));\nassign #10 b or (c and not(d)) or (not(a) and d);\nassign #15 c or d;\nassign #20 not (a and b and c) or a;\n  \t\nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\nwire nota;\nwire notb;\nwire notc;\nwire notd;\n\nnot n1(nota, a);\nnot n2(notb, b);\nnot n3(notc, c);\nnot n4(notd, d);\n\nor o1(q, \n      (nota & b & c & notd),  // at 5ns\n      (a & notb & notc & d),   // at 20ns\n      (a & b & notc & notd),    // at 25ns\n      (nota & notb & c & d));   // at 30ns\n      \nendmodule\n"}
{"task_id": "circuit2", "completion": "\n\treg q;\n\n\talways @(*) begin\n\t\tif(a == 0 && b == 0 && c == 0 && d == 0)\n\t\t    q <= 1;\n\t\telse if(a == 0 && b == 0 && c == 0 && d == 1)\n\t\t    q <= 0;\n\t\telse if(a == 0 && b == 0 && c == 1 && d == 0)\n\t\t    q <= 1;\n\t\telse if(a == 0 && b == 0 && c == 1 && d == 1)\n\t\t    q <= 0;\n\t\telse if(a == 0 && b == 1 && c == 0 && d == 0)\n\t\t    q <= 0;\n\t\telse if(a == 0 && b == 1 && c == 0 && d == 1)\n\t\t    q <= 1;\n\t\telse if(a == 0 && b == 1 && c == 1 && d == 0)\n\t\t    q <= 0;\n\t\telse if(a == 0 && b == 1 && c == 1 && d == 1)\n\t\t    q <= 1;\n\t\telse if(a == 1 && b == 0 && c == 0 && d == 0)\n\t\t    q <= 0;\n\t\telse if(a == 1 && b == 0 && c == 0 && d == 1)\n\t\t    q <= 1;\n\t\telse if(a == 1 && b == 0 && c == 1 && d == 0)\n\t\t    q <= 1;\n\t\telse if(a == 1 && b == 0 && c == 1 && d == 1)\n\t\t    q <= 0;\n\t\telse if(a == 1 && b == 1 && c == 0 && d == 0)\n\t\t    q <= 1;\n\t\telse if(a == 1 && b == 1 && c == 0 && d == 1)\n\t\t    q <= 0;\n\t\telse if(a == 1 && b == 1 && c == 1 && d == 0)\n\t\t    q <= 0;\n\t\telse if(a == 1 && b == 1 && c == 1 && d == 1)\n\t\t    q <= 1;\n\tend \nendmodule\n"}
{"task_id": "circuit2", "completion": "\n    reg temp;\n    \n    always @(a or b or c or d) begin\n\t    if(!d && !c && a && !b ) temp = 1'b0 ;\n      else if (!d && !b && !a && c )  temp =  1'b0 ;\n      else if (d && b && !c && !a )  temp =  1'b0;\n      else if(d && !b && a && !c) temp = 1'b0;\n      else if(!d && b && c && !a) temp= 1'b1 ;\n      else if(!d && !b && c && a )  temp =  1'b1 ;\n      else if (d && b && c && !a )  temp = 1'b1;\n      else if(d && !b && c && a) temp= 1'b1;\n      else if(!d && b && !c && a) temp= 1'b1;\n    \n    end\n\tassign q=temp;\nendmodule\n\n"}
{"task_id": "circuit2", "completion": "\n\tassign q = ~(a & b) | c & d;\nendmodule\n\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n\tassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\t\n\t// Using always block with if statement\n\talways @(*) begin\n\t    if ((sel_b1 == 1'b1) && (sel_b2 == 1'b1)) \n\t        out_always = b;\n\t    else\n\t\t    out_always = a;\n\tend\n\t\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n\tassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\t\t\n\t// Using always block and procedural if statement.\n\talways @(*) begin\n\t\tif ((sel_b1 == 1) && (sel_b2 == 1))\n\t\t\tout_always <= b;\n\t\telse \n\t\t\tout_always <= a;\n\tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// using assign statements\n\tassign out_assign = ((sel_b1 & sel_b2) ? b : a);\n  \n\t// using always procedural blocks\n\talways @* begin\n\tif (sel_b1 & sel_b2) \n\t    out_always <= b;\n\telse \n\t    out_always <= a;\n\tend\nendmodule\n\n"}
{"task_id": "always_if", "completion": "\n\tassign out_assign = ((sel_b1 && sel_b2) ? b : a);\n\t\n\talways @(*) begin\n\t\tif (sel_b1 && sel_b2) \n\t\t\tout_always <= b;\n\t\telse \n\t\t\tout_always <= a;\n\tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements \n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n\t// Using always procedural block\n\talways @(*) begin\n\t\tif ((sel_b1 && sel_b2)) \n\t\t\tout_always <= b;\n\t\telse \n\t\t\tout_always <= a;\n\tend\nendmodule\n\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n\tassign out_assign = ((~sel_b1 & ~sel_b2) ? a : (sel_b1 & sel_b2) ? b : 'x);\n\t\n\t// Using always block and procedural if-else\n\talways @(*) begin\n\t\tif (~sel_b1 & ~sel_b2) \n\t\t\tout_always = a;\n\t\telse if (sel_b1 & sel_b2) \n\t\t\tout_always = b;\n\t\telse \n\t\t\tout_always = 'x; // undefined\n\tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n\tassign out_assign = sel_b1 & sel_b2 ? b : a;\n\t\n\t// Using always block and if statement\n\talways @(*) begin\n\t\tif (sel_b1 && sel_b2) \n\t\t\tout_always = b;\n\t\telse\n\t\t\tout_always = a;\n\tend\nendmodule\n\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a; \n\n\t// Using always @* block for procedural if statement\n\talways @(*) begin\n\t    if((sel_b1 & sel_b2)) begin\n\t        out_always <= b;\n        end else begin\n            out_always <= a;\n        end\n    end\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a; \n    \n    // Using procedural if statement\n\talways @(*) begin\n        \tif (sel_b1 & sel_b2)\n            \t\tout_always <= b;\n        \telse\n            \t\tout_always <= a;\n    \tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n    \n    always @(*) begin \n        if ((sel_b1 && sel_b2))\n            out_always <= b;\n        else \n            out_always <= a;\n\tend  \nendmodule\n"}
{"task_id": "always_if", "completion": "\n\n\t// Using assign statements\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n    \n    // Using always block and if-else statement\n    always @* begin\n        if(sel_b1 && sel_b2) \n            out_always <= b;\n        else \n            out_always <= a;\n\tend\nendmodule\n\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n\tassign out_assign = sel_b1 & sel_b2 ? b : a;  // if sel_b1 and sel_b2 are true then output is 'b' else 'a'\n\n\t// Using always block (procedural statement)\n\talways @(*) begin  // this is combinational logic, so * means \"any change\"\n\t\tif (sel_b1 && sel_b2)   // if sel_b1 and sel_b2 are true then output is 'b' else 'a'\n\t\t\tout_always = b;\n\t\telse \n\t\t\tout_always = a;\n\tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\tassign out_assign = ((sel_b1 || sel_b2) ? b : a);\n\t\t\n\talways @(*) begin\n\tif (sel_b1 && sel_b2) \n\t    out_always = b;\n\telse \n            out_always = a;\n        end\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements \n\tassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\t\t\n\t// Using always blocks\n\talways @(*) begin\n\t\tif ((sel_b1 == 1'b1) && (sel_b2 ==1'b1)) \n\t\t    out_always <= b;\n\t\telse\n\t\t    out_always <= a;\n\tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\tassign out_assign = (sel_b1 && sel_b2) ? b : a; // using assign statements\n\n\t// using procedural if statement\n\talways @(*) begin \n\t\tif((sel_b1 == 1'b1) && (sel_b2 == 1'b1))\n\t\t\tout_always = b;\n\t\telse\n\t\t\tout_always = a;\n\tend\n\t\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n\tassign out_assign = ((~sel_b1 & ~sel_b2) ? a : b);  // If both sel_b1 and sel_b2 are false (0), choose a, else choose b\n\tassign out_always = ((~sel_b1 & ~sel_b2) ? a : b);  // The same logic as above line\n\n\t// Using procedural if statement\n\talways @(*) begin\n\t\tif (~sel_b1 & ~sel_b2)\n\t\t\tout_always <= a;\n\t\telse \n\t\t\tout_always <= b;\n\tend\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statement\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\t\t\n\t// Using always block\n\talways @(*) begin\n\t\tif ((sel_b1 & sel_b2)) \n\t\t\tout_always <= b;\n\t\telse\n\t\t\tout_always <= a;\n\tend\n\t\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\tassign out_assign = sel_b1 & sel_b2 ? b : a;\n\n\talways @(*) begin\n\t    if (sel_b1 & sel_b2)\n\t        out_always <= b;\n\t    else \n\t        out_always <= a;\n    end\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements.\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n\t// Using always blocks with if-else statement.\n\talways @(*) begin\n\t\tif (sel_b1 && sel_b2) \n\t\t\tout_always = b;\n\t\telse \n\t\t\tout_always = a;\n\tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\n\t// Using assign statements\n    assign out_assign = (sel_b1 && sel_b2) ? b : a; \n    \n    // Using always block and if statement\n    always @(*) begin\n        if ((sel_b1 == 1'b1) && (sel_b2 ==1'b1))\n            out_always = b;\n        else\n            out_always = a;\n   end \nendmodule\n\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\treg [7:0] Q;\n\tinteger i;\n\talways @(posedge clk) begin\n\t\tif (enable) begin\n\t\t\tfor (i = 6; i>=0 ; i--) begin\n\t\t\t\tQ[i+1] <= Q[i];\n\t\t\tend\n\t\t\tQ[0] <= S;\n\t\tend\n\tend\n\n\t// 3-input multiplexer to select correct bit from the shift register\n\tassign Z = (A ? Q[2] : B ? Q[1] : C ? Q[0] : Q[7]);\n\t\t\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\n\treg [7:0] Q; // 8-bit shift register\n\tassign Z = Q[{(A*2^2) + (B*2^1) + C}];\n\n\t// Shift Register\n\talways @(posedge clk) begin\n\t\tif (enable)\n\t\t\tQ <= {S, Q[7:1]};\n\tend\n\t\nendmodule\n\n"}
{"task_id": "ece241_2013_q12", "completion": "\n   // Define internal signals\n\treg [7:0] Q;\n\n\t// Shift register with D-type flip flops\n\talways @(posedge clk) begin\n\t    if (enable)\n\t\t    Q <= {Q[6:0], S};\n\tend\n\n\t// Multiplexer for Z\n\tassign Z = A ? Q[2] :\n\t\t\t     B ? Q[1] :\n\t\t\t\t\t C ? Q[0] : \n\t\t\t\t\t   Q[7];\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n  \n\treg [7:0] Q;\n  \n\talways @(posedge clk) begin\n\t\tif (enable)\n\t\t\tQ <= {S, Q[7:1]};\n\tend\n  \n\tassign Z = Q[0];\n\tassign Z = A ? Q[1] : \n\t           B ? Q[2] : \n\t\t\t     C ? Q[3] : \n\t\t\t\t       Q[0];\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\n\treg [7:0] Q; // 8-bit register\n    wire [2:0] ABC = {A,B,C}; // concatenation of inputs A, B and C to form a 3 bit output.\n    \n\talways @(posedge clk) begin\n\t    if (enable)\n\t        Q <= {S,Q[7:1]};   // shifting the register\n    end\n\t \n\t// 4-to-16 multiplexer based on inputs A, B and C\n\talways @(ABC or Q) begin\n\t\tcase (ABC) \n\t\t\t3'b000: Z <= Q[0];\n\t\t\t3'b001: Z <= Q[1];\n            3'b010: Z <= Q[2];\n            // complete the other cases here\n\t\t\t// ...\n\t\tendcase\n    end \nendmodule  \n"}
{"task_id": "ece241_2013_q12", "completion": "\n\treg [7:0] Q;  //8-bit shift register\n    \n    always @(posedge clk) begin  \n        if (enable) begin        \n            Q <= {Q[6:0], S};      \n        end                      \n    end                          \n                                                   \n    assign Z = Q[A+B*2+C*4];  //3-input logic function\nendmodule                        \n\n"}
{"task_id": "ece241_2013_q12", "completion": "\n   // D flip flop declaration\n    wire [7:0] q; \n    \n    genvar i;\n    generate\n        for(i=0; i<8; i++) begin: dff_loop\n            DFF my_dff (\n                .clk(clk),\n                .enable(enable && ((A && !B && !C)? q[i]: \n                               (!A && B && !C)? q[((i+1)%8)]:\n                               (!A && !B && C)? q[((i-1)==-1?7:(i-1))]: 0),\n                .D(S),\n                .Q(q[i])\n            );    \n        end: dff_loop\n    endgenerate  \n    \n\tassign Z = q[0]; //output is always first bit of register as ABC=000\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n    // D Flip-flops for each bit of the 8-bit shift register\n\treg [7:0] Q;\n\talways @(posedge clk) begin\n\t\tif (enable)\n\t\t\tQ <= {S, Q[7:1]};\n\tend\n   // 3-to-8 line multiplexer for selecting which bit of the shift register to output as Z\n    assign Z = A ? Q[0]:(B? Q[1]:(C? Q[2]:Q[3]));\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\t// Declare 8 D-type flip flops for the memory.\n\treg [7:0] Q;\n\talways @(posedge clk) begin\n\t\tif (enable)\n\t\t\tQ <= {Q[6:0], S}; // Shift in input on MSB position if enable is high. \n\tend\n\t\n\t// Declare three multiplexers for the ABC inputs to select different positions of Q.\n\twire [2:0] sel = {A, B, C};\n\talways @(sel or Q) begin\n\t\tcase (sel)\n\t\t\t3'b000 : Z <= Q[0]; // If ABC is 000, output Z=Q[0].\n\t\t\t3'b001 : Z <= Q[1]; // If ABC is 001, output Z=Q[1].\n\t\t\t// Continue this pattern for all other combinations.\n\t\t\t3'b010 : Z <= Q[2];\n\t\t\t3'b011 : Z <= Q[3];\n\t\t\t3'b100 : Z <= Q[4];\n\t\t\t3'b101 : Z <= Q[5];\n\t\t\t3'b110 : Z <= Q[6];\n\t\t\t3'b111 : Z <= Q[7]; // If ABC is 111, output Z=Q[7].\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\treg [7:0] Q;\t// 8-bit shift register\n\twire [2:0] ABC = {A,B,C}; // Combined inputs A,B,C\n\t\t  \n\talways @(posedge clk) begin  // Shift Register\n\t\tif (enable)\n\t\t\tQ <= {S, Q[7:1]};\n\tend\n\t\t\t   \n\tassign Z = Q[ABC];\t// Multiplexer\n\t    \nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\n\t// Declare 8-bit shift register\n\treg [7:0] Q;\n\t\n\t// Shift register\n\talways @(posedge clk) begin\n    \tif (enable)\n        \tQ <= {S, Q[7:1]}; // MSB is shifted in first\n\tend \n\t\t\n\t// Multiplexer to select output bit based on inputs A, B and C\n\tassign Z = Q[0]; \n  \talways @(*) begin\n    \tif (A==1'b0 && B==1'b0 && C==1'b0)\n      \t\tZ <= Q[0];\n    \telse if (A==1'b0 && B==1'b0 && C==1'b1) \n\t\t    Z <= Q[1];\n\t    else if (A==1'b0 && B==1'b1 && C==1'b0) \n\t\t  \tZ <= Q[2];\n    \telse if (A==1'b0 && B==1'b1 && C==1'b1) \n          \tZ <= Q[3];\n    \telse if (A==1'b1 && B==1'b0 && C==1'b0) \n      \t\tZ <= Q[4];\n    \telse if (A==1'b1 && B==1'b0 && C==1'b1) \n          \tZ <= Q[5];\n\t    else if (A==1'b1 && B==1'b1 && C==1'b0) \n\t\t    Z <= Q[6];\n    \telse //if (A==1'b1 && B==1'b1 && C==1'b1)\n          \tZ <= Q[7];\n  \tend\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n    reg [7:0] Q; // 8-bit shift register\n    wire [2:0] ABC = {A,B,C}; // 3-bit input combination\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S}; // Shift in new bit on MSB\n        end\n    end\n\n    always @(ABC or Q) begin \n         case (ABC)\n            3'b000 : Z = Q[0];\n\t    3'b001 : Z = Q[1];\n\t    3'b010 : Z = Q[2];\n\t    3'b011 : Z = Q[3];\n\t    3'b100 : Z = Q[4];\n\t    3'b101 : Z = Q[5];\n\t    3'b110 : Z = Q[6];\n\t    3'b111 : Z = Q[7];\n            default: Z = 1'bx; // undefined condition for invalid ABC input\n        endcase \n    end\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\treg [7:0] q; // 8-bit shift register\n\twire [2:0] sel = {A,B,C}; // Multiplexer select input\n\t\n\t// Shift Register\n\talways @(posedge clk) begin\n\t    if (enable)\n\t        q <= {S, q[7:1]}; \n\tend\n\n\t// 3-to-8 Decoder and Mux\n    assign Z = sel == 3'b000 ? q[0] : \n              sel == 3'b001 ? q[1] : \n              sel == 3'b010 ? q[2] : \n              sel == 3'b011 ? q[3] :\n              sel == 3'b100 ? q[4] :\n              sel == 3'b101 ? q[5] :\n              sel == 3'b110 ? q[6] : \n\t            q[7]; //default case\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\treg [7:0] Q;\n\tinteger i;\n  \n\talways @(posedge clk) begin\n\t\tif (enable)\n\t\t\tQ <= {S, Q[7:1]};\n\t\t\t\n\t\tfor (i=0; i<8; i++) \n\t\t\tif ((A==0 && B==0 && C==0 && i==0) || \n\t\t\t    (A==0 && B==0 && C==1 && i==1) ||\n                (A==0 && B==1 && C==0 && i==2) ||\n                (A==0 && B==1 && C==1 && i==3) ||\n                (A==1 && B==0 && C==0 && i==4) || \n\t\t\t    (A==1 && B==0 && C==1 && i==5) ||\n                (A==1 && B==1 && C==0 && i==6) ||\n                (A==1 && B==1 && C==1 && i==7))\n\t\t\t\t Z <= Q[i];\n\tend\n\nendmodule \n"}
{"task_id": "ece241_2013_q12", "completion": "\n\treg [7:0] Q; \n    wire [2:0] ABC = {A,B,C};\n    \n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n     \n\talways @* begin\n\t    case (ABC) \n\t\t    3'b000 : Z = Q[0];\n\t\t    3'b001 : Z = Q[1];\n\t\t    3'b010 : Z = Q[2];\n\t\t    3'b011 : Z = Q[3];\n\t\t    3'b100 : Z = Q[4];\n\t\t    3'b101 : Z = Q[5];\n\t\t    3'b110 : Z = Q[6];\n\t\t    3'b111 : Z = Q[7];\n            default: Z = 1'bx; \n        endcase\n    end\t\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\t// Declare the 8-bit shift register and flip flops.\n\treg [7:0] q;\n\t\n\t// Declare a temporary wire to hold the selected value from the multiplexer.\n\twire sel_val;\n\t\t\n\t// The first bit of Q is shifted in on every clock edge, unless enable is 0.\n\talways @(posedge clk) begin\n\t    if (enable)\n\t        q <= {S, q[7:1]};\n\tend\n\n   // Multiplexer to select the value from the selected bit of Q.\n\tm3_input mux (.a(A), .b(B), .c(C), .s({2'd0,q}), .y(sel_val));\n \n\t// Assign the output Z to be the selected value from the multiplexer.\n\tassign Z = sel_val;\n\t\t\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\n\treg [7:0] Q; //8-bit register\n\tassign Z = Q[{A,B,C}];\n\n\talways @(posedge clk) begin\n\t\tif (enable) \n\t\t\tQ <= {S, Q[7:1]};\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2013_q12", "completion": "\n    \n    wire [7:0] Q;\n    D_FF dffs[7:0] (clk, enable, S, Q[0], Q[1], Q[2], Q[3], Q[4], Q[5], Q[6], Q[7]);\n\tassign Z = Q[(~{A,B,C}+9'h8)]; //binary to gray decoder \n    \nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\t// Declare 8 D-type flip flops with synchronous reset.\n   wire [7:0] Q;\n   \n   dff8bit u1 (.clk(clk), .enable(enable), .S(S), .Q(Q));\n\t\n\t// Use 3 multiplexers to select the correct bit from Q based on ABC input.\n   assign Z = (A ? Q[7] : (B ? Q[6] : (C ? Q[5] : Q[0])));\n   \nendmodule\n\n// Define a single D-type flip flop.\nmodule dff (\n\tinput clk,\n\tinput enable,\n\tinput D,\n\toutput reg Q);\n\t\t \n   always @(posedge clk) begin\n      if(enable)\n         Q <= D;\n   end\n   \nendmodule\n\n// Define an 8-bit shift register.\nmodule dff8bit (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\toutput reg [7:0] Q);\n\t\t \n   always @(posedge clk) begin\n      if(enable)\n         Q <= {Q[6:0],S};\n   end\n   \nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "\n\treg [7:0] Q;  // 8-bit shift register\n\twire [2:0] ABC = {A,B,C};  \n    \n    always @(posedge clk) begin\n        if (enable)\n            Q <= {Q[6:0], S};\n    end\n        \n    assign Z = Q[ABC];\n\t\nendmodule\n"}
{"task_id": "shift4", "completion": "\n    \n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 4'b0;\n\t\telse if (load) \n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tq <= {2'b0, q[3:1]};\n\tend\n    \nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 4'b0;\n\t\telse if (load) \n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tq <= {q[2:0],1'b0};\n\tend\nendmodule\n\n"}
{"task_id": "shift4", "completion": "\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tq <= 4'b0;\n\t\telse if (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tq <= {q[2:0], 1'b0};\n\tend\n\nendmodule\n\n"}
{"task_id": "shift4", "completion": "\n\t\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 4'h0;\n\t\telse if (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tq <= {q[2:0], 1'b0};\n\tend\n\t\nendmodule\n\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin \n\t    if (areset) \n\t\t\tq <= 4'b0; \n        else if (load) \n            q <= data; \n        else if (ena) \n            q <= {q[2:0],1'b0}; \n    end \nendmodule\n\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n    \tif (areset) \n        \tq <= 4'b0;\n      \telse if (load)\n        \tq <= data;\n      \telse if (ena)\n        \tq <= {1'b0, q[3:1]};\n    end\nendmodule\n"}
{"task_id": "shift4", "completion": "\n  \n\talways @(posedge clk or posedge areset) begin \n\t\tif (areset)\n\t\t\tq <= 4'b0;\n\t\telse if (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tq <= {q[2:0],1'b0};\n\tend\nendmodule\n\n"}
{"task_id": "shift4", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1)  // Reset asynchronous\n\t\tq <= 4'd0;   // Synchronous reset\n\telse if (load)\n\t\tq <= data;\n\telse if (ena)\n\t\tq <= { q[2:0], 1'b0 };\t// Shift right\n\tend\nendmodule\n"}
{"task_id": "shift4", "completion": "\n   initial begin\n    q = 4'b0;\n  end\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tq <= 4'h0;\n\t\telse if (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tq <= { q[2:0], 1'b0 };\n\tend\nendmodule\n"}
{"task_id": "shift4", "completion": "\n    \n    always @ (posedge clk or posedge areset) begin\n        if(areset) \n            q <= 4'b0;\n         else if(load) \n             q <= data;\n         else if(ena)  \n              q <= {q[2:0],1'b0};\n    end\nendmodule\n"}
{"task_id": "shift4", "completion": "\n\n\t// Reset synchronous and asynchronous \n    always @(posedge clk or posedge areset) begin \n        if (areset) \n            q <= 4'b0; \n        else begin \n             // Load priority over shift right operation \n\t         if (load)  \n\t\t          q <= data;\n             else if (ena)\n                 q <= {q[2:0],1'b0};\n      end  \n    end    \nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tq <= 4'b0;\n\t\telse if (load)\n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tq <= {q[2:0], 1'b0};\n\tend\n\nendmodule\n\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tq <= 4'b0;\n\t\telse if (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tq <= {q[2:0],1'b0};\n\tend\n\t\nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t\t    q <= 4'b0;\n\t\telse if (load)\n\t\t    q <= data;\n\t\telse if (ena)\n\t\t    q <= {q[2:0], 1'b0};\n\tend\nendmodule\n"}
{"task_id": "shift4", "completion": "\n    always @(posedge clk or posedge areset) begin \n        if (areset) \n            q <= 4'b0; \n        else if (load)  \n            q <= data; \n        else if (ena)  \n\t\t\tq <= {q[2:0],1'b0}; \n    end\nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t\t    q <= 4'b0;\n\t    else if (load)\n\t\t    q <= data;\n        else if (ena)\n            q <= {q[2:0], 1'b0}; // Shift right\n\tend\nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset == 1'b1) \n\t\t\tq <= 4'h0;\n\t\telse if (load == 1'b1)\n\t\t\tq <= data;\n\t\telse if (ena == 1'b1)\n\t\t\tq <= { q[2:0], 1'b0 };\n\tend\nendmodule\n"}
{"task_id": "shift4", "completion": "\nalways @(posedge clk or posedge areset) begin\n\tif (areset == 1'b1) \n\t\tq <= 4'b0;\n\telse if (load == 1'b1) \n\t\tq <= data;\n\telse if (ena == 1'b1)  \n\t\tq <= {q[2:0], q[3]};  \t\t\t//Right Shift by one bit.\nend\nendmodule\n"}
{"task_id": "shift4", "completion": "\n\talways @(posedge clk or posedge areset) begin\n\t    if (areset) \n\t\t    q <= 4'b0;\n        else if (load)  \n            q <= data;\n       else if (ena)   \n           q <= {q[2:0],1'b0};  //shift right\n\tend\nendmodule\n\n"}
{"task_id": "shift4", "completion": "\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            q <= 4'b0;\n        else if (load) \n            q <= data;\n\t\telse if (ena) \n\t\t\tq <= {q[2:0], 1'b0}; // The new bit is always zero in a right shift register. So, it's just shifting the existing bits and appending a 0 at LSB position\n    end\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse if (ena) begin\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= {q[63:1], 1'b0}; // shift left by 1 bit\n\t\t\t\t2'b01: q <= {q[55:0], 8'h00}; // shift left by 8 bits\n\t\t\t\t2'b10: q <= {1'b0, q[63:1]}; // arithmetic right shift by 1 bit\n\t\t\t\t2'b11: q <= {{8{q[55]}}, q[55:8]}; // arithmetic right shift by 8 bits\n\t\t\tendcase\n\t\tend\n\tend\n\t\nendmodule\n"}
{"task_id": "shift18", "completion": "\nalways @(posedge clk) begin\n\tif (load)\n\t\tq <= data;\n\telse if (ena) begin  // Shifting enabled.\n\t\tcase (amount)  \n\t\t\t2'b00: q <= {q[62:0],1'b0};    // shift left by 1 bit\n\t\t\t2'b01: q <= {q[47:0],48'd0};    // shift left by 8 bits\n\t\t\t2'b10: q <= {1'b0,q[63:1]};     // Arithmetic shift right by 1 bit. Sign is preserved.\n\t\t\t2'b11: q <= {4'hF,q[63:4]};      // Arithmetic shift right by 8 bits. Sign is preserved.\n\t\tendcase  \n\tend\nend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\nalways @(posedge clk) begin\n\tif (load) \n\t\tq <= data;\n\telse if (ena) begin\n\t\tcase (amount)\n\t\t\t2'b00 : q <= q << 1; // Shift left by one bit.\n\t\t\t2'b01 : q <= q << 8; // Shift left by eight bits. \n            2'b10 : q <= q >> 1; // Shift right by one bit. Arithmetic shift.\n\t\t\t2'b11 : q <= q >> 8; // Shift right by eight bits. Arithmetic shift.\n\t\tendcase\n\tend\nend\n\nendmodule \n"}
{"task_id": "shift18", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\t\tif (load) \n\t\t\t\tq <= data;\n\t\t\telse if (ena) \n\t\t\t\tcase(amount)\n\t\t\t\t\t2'b00: q <= {q[62:0],1'b0}; // shift left by 1 bit\n\t\t\t\t\t2'b01: q <= {q[55:0],8'h00}; // shift left by 8 bits\n\t\t\t\t\t2'b10: q <= {1'b0,q[63:1]}; // arithmetic right shift by 1 bit\n\t\t\t\t\t2'b11: q <= {8'h00,q[55:0]}; // arithmetic right shift by 8 bits\n\t\t\t\tendcase\n\t\tend\nendmodule\n\n"}
{"task_id": "shift18", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\t\tif (load) \n\t\t\t\tq <= data;\n\t\t\telse if(ena) begin\n\t\t\t\t\tcase(amount)\n\t\t\t\t\t\t2'b00: q <= {q[62:0],1'b0}; // shift left by 1 bit.\n\t\t\t\t\t\t2'b01: q <= {q[55:0],8'd0};// shift left by 8 bits.\n\t\t\t\t\t\t2'b10: q <= {1'b0,q[63:1]};// shift right by 1 bit.\n\t\t\t\t\t\t2'b11: q <= {8'd0,q[55:0]}; // shift right by 8 bits.\n\t\t\t\t\tendcase\n\t\t\tend\n\t end   \nendmodule\n\n"}
{"task_id": "shift18", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tcase(amount) \n\t\t\t\t2'b00 : q <= {q[62:0],1'b0}; // shift left by one bit \n\t\t\t\t2'b01 : q <= {q[55:0],8'h0}; // shift left by eight bits \n\t\t\t\t2'b10 : q <= {1'b0,q[63:1]}; // arithmetic right shift by one bit\n\t\t\t\t2'b11 : q <= {{8{q[7]}},q[63:8]}; // arithmetic right shift by eight bits \n\t\t\tendcase\n\tend\n\t\nendmodule\n\n"}
{"task_id": "shift18", "completion": "\n\t//Arithmetic Right shift by 8 bits and Left shift by 8 bits are equivalent to Dividing and Multiplying with 256 respectively. We can use the same logic for both operations using addition/subtraction instead of logical shifts in this case.\n\treg [7:0] shft; //Shift amount between 1 and 8 is represented by 3 bits so we need to extend it to a byte.\n\talways @(*) begin\n\t\tcase (amount) \n\t\t\t2'b00: shft = 8'd1;  \n\t\t\t2'b01: shft = 8'd8;   \n\t\t\t2'b10: shft = 8'd1;     \n\t\t\t2'b11: shft = 8'd8;       \n\t\t\tdefault : shft=8'd0;     //If any other value comes default is 0.\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) begin\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= {q[55:0], 64'd0};   //Left shift by 1 bit.\n\t\t\t\t2'b01: q <= {{shft{q[7]}},q[63:shft]}; //Left shift by 8 bits.\n\t\t\t\t2'b10: q <= {q[shft-1:0], {64{q[63]}} };   //Right shift by 1 bit Arithmetic shift.\n\t\t\t\t2'b11: q <= {{64{q[55+shft]}},q[55+shft:0]}; // Right shift by 8 bits arithmetic shift.\n\t\t\t\tdefault : q<=q;   //If any other value comes remain the same.\n\t\t\tendcase\n\t\tend\n\tend\n\t\nendmodule\n"}
{"task_id": "shift18", "completion": "\nalways @(posedge clk) begin\n\tif (load)\n\t\tq <= data;\n\telse if (ena) \n\t\tcase (amount)\n\t\t\t2'b00: q <= {q[62:0],1'b0};\t// Shift Left by one bit\n\t\t\t2'b01: q <= {q[55:0],8'h00};   // Shift Left by 8 bits\n\t\t\t2'b10: q <= {1'b0,q[63:1]};   \t// Shift Right by one bit (Arithmetic)\n\t\t\t2'b11: q <= {q[55:0],8{1'b0}};  // Shift Right by 8 bits (Arithmetic)\n\t\tendcase\nend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\n\talways @(posedge clk) begin\n\t\t if (load) \n\t\t\t   q <= data;\n\t\t else if (ena)\n\t\t\t case (amount)\n\t\t\t\t2'b00 : q <= {q[62:0],1'b0};     // Shift Left by 1 Bit\n\t\t\t\t2'b01 : q <= {q[55:0],8'd0};    // Shift Left by 8 Bits\n\t\t\t\t2'b10 : q <= {1'b0,q[63:1]};    // Arithmetic Shift Right by 1 Bit\n\t\t\t\t2'b11 : q <= {{8{q[7]}},q[55:8]};// Arithmetic Shift Right by 8 Bits\t\n\t\t   endcase\n\tend\n\t\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tcase(amount)\n\t\t\t\t2'b00: \n\t\t\t\t\t\tq <= {q[62:0], 1'b0}; // Left shift by one bit, MSB is always zero.\n\t\t\t\t2'b01:\n\t\t\t\t\t\tq <= {q[55:0], 8'h00}; // Left shift by eight bits, lower 8 bits are always zero.\n\t\t\t\t2'b10:\n\t\t\t\t\t\tq <= {1'b0, q[63:1]}; // Right shift by one bit, LSB is always zero for arithmetic right shift.\n\t\t\t\t2'b11:\n\t\t\t\t\t\tq <= {8'h00, q[55:0]}; // Right shift by eight bits, lower 8 bits are always zero for arithmetic right shift.\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tcase(amount)\n\t\t\t\t2'b00 : q <= {q[63:1], 1'b0}; //shift left by one bit\n\t\t\t\t2'b01 : q <= {q[55:0], 8'b0}; //shift left by eight bits\n\t\t\t\t2'b10 : q <= {q[62:7], q[63]}; //arithmetic shift right by one bit\n\t\t\t\t2'b11 : q <= {q[55:0], 8{q[63]}}; //arithmetic shift right by eight bits\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tcase(amount)\n\t\t\t\t2'b00: q <= {q[62:0], 1'b0};   //Shift left by 1 bit\n\t\t\t\t2'b01: q <= {q[55:0], 8'h00};   //Shift left by 8 bits\n\t\t\t\t2'b10: q <= {1'b0, q[63:1]};    //Arithmetic shift right by 1 bit\n\t\t\t\t2'b11: q <= {8'h00, q[55:0]};   //Arithmetic shift right by 8 bits\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tcase(amount)\n\t\t\t\t2'b00: q <= {q[62:0], 1'b0};\t// shift left by 1 bit\n\t\t\t\t2'b01: q <= {q[55:0], 8'd0};\t\t// shift left by 8 bits\n\t\t\t\t2'b10: q <= {1'b0, q[63:1]};\t\t// arithmetic right shift by 1 bit\n\t\t\t\t2'b11: q <= {{8{q[7]}}, q[63:8]};\t// arithmetic right shift by 8 bits\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\n\talways @(posedge clk) begin\n\t\t\tif (load) \n\t\t\t\tq <= data;\n\t\t\telse if (ena) begin\n\t\t\t\tcase (amount)\n\t\t\t\t\t2'b00 : q <= {q[63:1],1'b0}; // Shift left by 1 bit.\n\t\t\t\t\t2'b01 : q <= {q[55:0],8'h00}; //Shift left by 8 bits.\n\t\t\t\t\t2'b10 : q <= {1'b0,q[63:8]}; // Arithmetic right shift by 1 bit.\n\t\t\t\t\t2'b11 : q <= {8'hFF,q[55:0]}; //Arithmetic right shift by 8 bits.\t\n\t\t\t\t\tdefault : ;\n\t\t\t\tendcase\n\t\t\tend\n\tend\n\t\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tcase(amount)\n\t\t\t\t2'b00: q <= {q[63:1], 1'b0}; // Shift Left by 1 bit.\n\t\t\t\t2'b01: q <= {q[55:0], 8'b0}; // Shift left by 8 bits.\n\t\t\t\t2'b10: q <= {1'b0, q[63:1]}; // Arithmetic Right shift by 1 bit.\n\t\t\t\t2'b11: q <= {q[62:56], 7'b0}; // Arithmetic Right Shift by 8 bits.\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse if (ena == 1'b1)\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= {q[63:1], 1'b0}; // Shift left by 1 bit\n\t\t\t\t2'b01: q <= {q[55:0], 8'h00}; // Shift left by 8 bits\n\t\t\t\t2'b10: q <= {1'b0, q[63:1]}; // Arithmetic shift right by 1 bit\n\t\t\t\t2'b11: q <= {8'h00, q[55:0]}; // Arithmetic shift right by 8 bits\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse if(ena) begin\n\t\t\tcase(amount)\n\t\t\t\t2'b00 : q <= {q[62:0], 1'b0}; // shift left by 1 bit.\n\t\t\t\t2'b01 : q <= {q[55:0], 8'b0}; // shift left by 8 bits.\n\t\t\t\t2'b10 : q <= {1'b0, q[63:1]}; // arithmetic shift right by 1 bit.\n\t\t\t\t2'b11 : q <= {{8{q[7]}}, q[63:8]}; // arithmetic shift right by 8 bits.\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) \n\t\t\tcase(amount) \n\t\t\t\t2'b00: q <= {q[62:0], 1'b0}; // Shift left by one bit\n\t\t\t\t2'b01: q <= {q[55:0], 8'b0};   // Shift left by eight bits\n\t\t\t\t2'b10: q <= {1'b0, q[63:1]};  // Arithmetic shift right by one bit\n\t\t\t\t2'b11: q <= {8'b0, q[55:0]};   // Arithmetic shift right by eight bits\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "shift18", "completion": "\n\t\t\n\talways @(posedge clk) begin\n\t\tif (load) \n\t\t\tq <= data;\n\t\telse if (ena) begin\n\t\t\tcase(amount)\n\t\t\t\t2'b00: q <= {q[62:0], 1'b0}; // shift left by 1 bit.\n\t\t\t\t2'b01: q <= {q[55:0], 8'b0}; // shift left by 8 bits.\n\t\t\t\t2'b10: q <= {q[1:63], 1'b0}; // shift right by 1 bit - arithmetic\n\t\t\t\t2'b11: q <= {q[7:63], 8'b0}; // shift right by 8 bits - arithmetic\t\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "shift18", "completion": "\n\talways @ (posedge clk) begin\n\t\tif(load) \n\t\t\tq <= data;\n\t\telse if(ena)begin\n\t\t\tcase(amount)\n\t\t\t\t2'b00: q <= {q[62:0],1'b0}; // Shift left by one bit\n\t\t\t\t2'b01: q <= {q[47:0],48'd0};// shift left by 8 bits\n\t\t\t\t2'b10: q <= {1'b0,q[63:1]}; // arithmetic right shift by one bit\n\t\t\t\t2'b11: q <= {48'd0,q[55:60]};// arithmetic right shift by 8 bits\t\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "m2014_q4c", "completion": "\n    \n    always @(posedge clk or posedge r) begin\n        if (r) \n            q <= 0;\n        else \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\nalways @(posedge clk or posedge r) begin\n\tif (r)\n\t\tq <= 0;\n\telse \n\t\tq <= d;\nend\n\nendmodule\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n\t    if(r == 1'b1) \n\t        q <= 0;\n        else \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\nalways @(posedge clk or posedge r) begin\n\tif (r)\n\t\tq <= 0;\n\telse \n\t\tq <= d;\nend\n\nendmodule\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n    \tif (r == 1'b1) \n        \tq <= 0;\n    \telse\n        \tq <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n    always @(posedge clk or posedge r) begin\n        if(r) \n            q <= 0;\n        else \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n  \t\tif(r) \n    \t\t\tq <= 0;\n  \t\telse \n   \t \t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n\tif (r) \n\t    q <= 0;\n\telse\n            q <= d;\n     end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk) begin\n\t\tif(r) \n\t\t\tq <= 0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif(r == 1'b1) \n\t\t\tq <= 0;\n\t\telse \n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n  \tif (r)\n    \tq <= 0;\n  \telse \n    \tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n    always @(posedge clk or posedge r) begin\n        if(r == 1'b1) \n            q <= 0;\n        else \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n\nalways @(posedge clk or posedge r) begin\n\tif(r)\n\t\tq <= 0;\n\telse \n\t\tq <= d;\nend\n\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n\n\talways @(posedge clk or posedge r) begin\n    \tif (r) \n        \tq <= 0;\n    \telse \n        \tq <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\nalways @(posedge clk or posedge r) begin\n    if (r) \n        q <= 1'b0;\n    else \n        q <= d;\nend\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n\t\tif(r) \n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n    \n    always @(posedge clk) begin\n        if(r == 1'b1) \n            q <= 0; // synchronous reset\n        else  \n            q <= d; // flip flop action\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n    always @(posedge clk or posedge r) begin\n        if(r) \n            q <= 0;\n        else \n            q <= d;\n    end\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\nalways @(posedge clk or posedge r) begin\n\tif (r == 1'b1) \n\t\tq <= 0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n\n"}
{"task_id": "m2014_q4c", "completion": "\n\talways @(posedge clk or posedge r) begin\n\t\tif(r)\n\t\t  q <= 0;\n        else\n          q <= d;\n    end\nendmodule\n  \n"}
{"task_id": "ece241_2013_q8", "completion": "\nreg [1:0] state; \nparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10; // State declarations\n\nalways @(posedge clk or negedge aresetn) begin\n\tif(!aresetn) begin  // Asynchronous reset (active low)\n\t\tstate <= S0;   // Reset state to 0\n\t\tz <= 0;      // Reset output z\n\tend else case (state)\n\tS0: if(x==1) state <= S1;    // If x is 1, next state is 1\n\t\telse state <= S0;         // Else stay in same state\n\tS1: if(x==0) begin state <= S2; end  // If x is 0, next state is 2\n\t\telse state <= S1;         // Else stay in same state\n\tS2: if(x==1) begin state <= S0; z <= 1'b1; end   // If x is 1, reset to start and set output z = 1\n\t\telse state <= S2;           // Else stay in same state\n\tendcase\nend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n    reg [1:0] state; // Define states as 2 bits for simplification.\n    \n    always @(posedge clk or negedge aresetn) begin\n        if (~aresetn) state <= 2'b00;   // Async reset, set the state to initial/state 0 when not asserted.\n\telse\n\tcase (state)\n\t    2'b00: if(x == 1'b1) state <= 2'b01;    // Transition from state 0 to state 1 on input '1'.\n            2'b01: if(x == 1'b0) state <= 2'b10;    // Transition from state 1 to state 2 on input '0'.\n\t    2'b10: if(x == 1'b1) begin           // Transitions to final state when '101' is detected.\n                z <= 1'b1;                     // Output '1' for one clock cycle after '101' detecting. \n\t        state <= 2'b10;                    // Remain in the same state until next rising edge of clock or reset.\n\t       end else state <= 2'b00;               // If input is not '1', transition back to initial/state 0.\n            default: state <= 2'b00;    // Default state, should never happen.\n        endcase\n    end  \nendmodule\n\n"}
{"task_id": "ece241_2013_q8", "completion": "\n    reg [1:0] state;\n    \n    always @(posedge clk or negedge aresetn) begin\n        if(!aresetn) \n            state <= 2'b00;\n        else \n            case (state)\n                2'b00: x ? state <= 2'b01 : state <=  2'b00; // State 0, input = 0 -> stay in state 0\n                2'b01: x ? state <= 2'b10 : state <=  2'b00; // State 1, input = 0 -> go to state 0\n                2'b10: begin // State 2, input = 1\n                    if(x) \n                        state <= 2'b11;                      // input = 1 -> go to state 3\n                    else \n                        state <= 2'b01;                      // input = 0 -> stay in state 1\n                end                \n                2'b11: x ? state <= 2'b11 : begin            // State 3, input = 1 -> go to state 3\n                          z <= 1'b1;                         // Sequence detected\n                          state <= 2'b00;                    // Reset the sequence\n                      end               \n            endcase\n    end  \nendmodule\n\n"}
{"task_id": "ece241_2013_q8", "completion": "\n    parameter [1:0] s0 = 2'b00;\n    parameter [1:0] s1 = 2'b01;\n    parameter [1:0] s2 = 2'b10;\n    \n\treg [1:0] current_state, next_state;  \n\t\t \n\t// state transition\n\talways @(posedge clk or negedge aresetn) begin\n\t    if (!aresetn)\n            current_state <= s0; // asynchronous reset to state zero\n        else\n            current_state <= next_state;    \n    end\n\t  \n\t// next-state logic and output decoder \n\talways @(x or current_state) begin\n\t    case (current_state)\n\t\t\ts0: begin \n\t\t\t\tif (x) \n                    next_state = s1;\n                else\n                    next_state = s0;\n                    \n\t\t\t    z = 1'b0; // default output value\n            end\n                \n\t\t\ts1: begin  \n\t\t\t\tif (x)\n                    next_state = s2;\n                else \n                    next_state = s0;\n\t\t\t\t\t\n                z = 1'b0; // default output value\n            end\n            \n\t\t\ts2: begin\t    \n\t\t\t    if(x) begin  \n\t\t\t\t    next_state = s2; \n                    z = 1'b1; \n                end\n\t\t\t    else begin \n                    next_state = s0;\n                    z = 1'b0; // default output value\n                end\t\t    \t\n            end   \t \t   \n        endcase  \t\n    end \nendmodule \n\n"}
{"task_id": "ece241_2013_q8", "completion": "\nlocalparam [1:0] S1 = 2'b00;\nlocalparam [1:0] S2 = 2'b01;\nlocalparam [1:0] S3 = 2'b10;\n\treg [1:0] state, next_state;\n\t\t \n\t// State register\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn)\n\t\t\tstate <= S1;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next-state logic and output decoder\n\talways @(*) begin\n\t\tcase (state) \n\t\t\tS1: if (x==1'b1) next_state = S2; else next_state = S1;\n\t\t\tS2: if (x==1'b0) next_state = S3; else next_state = S2;\n\t\t\tS3: if (x==1'b1) begin \n\t\t\t\tnext_state = S2;\n\t\t\t    z = 1'b1; // assert z for one clock cycle on \"101\" sequence detecting\n\t\t\t    end else next_state = S3;\n\t\t\tdefault : next_state = S1;\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state;\n\tparameter S0 = 2'd0, S1 = 2'd1, S2 = 2'd2;  // state definitions\n\n\t// state transitions\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tcase (state)\n\t\t\t\tS0: if (x) state <= S1;  // move to next state on input x = 1\n\t\t\t\tS1: if (!x) state <= S2;  // stay at current state until input x = 0\n\t\t\t\tS2: if (x) begin state <= S0; z <= 1'b1; end  // return to initial state and assert output z when sequence \"101\" detected\n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n   reg [1:0] state; \n   \n   always @(posedge clk or negedge aresetn) begin\n       if (!aresetn) \n           state <= 2'b00;\n        else \n            case (state)\n                2'b00 : if (x==1'b1) state <= 2'b01;   // From State 0 to State 1 on input 1.\n                2'b01 : if (x==1'b0) state <= 2'b10;   // From State 1 to State 2 on input 0.\n                2'b10 : if (x==1'b1) begin state <= 2'b11; z<=1'b1; end// From State 2 to State 3 on input 1 & setting output Z\n                default: state <= 2'b00;               // Anything else reset back to State 0.\n            endcase\n    end\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\nreg [1:0] state;\nparameter IDLE = 2'b00;\nparameter S1 = 2'b01;\nparameter S2 = 2'b10;\n\nalways @(posedge clk or negedge aresetn) begin\n\tif (aresetn == 0) begin  // asynchronous reset\n\t\tstate <= IDLE;\n\t\tz <= 0;\n\tend else begin  // state transitions and outputs\n\t\tcase (state) \n\t\t\tIDLE: begin\n\t\t\t\tif (x == 1'b1)\n\t\t\t\t\tstate <= S1;\n\t\t\t\telse\n\t\t\t\t\tstate <= IDLE;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (x == 1'b0)\n\t\t\t\t\tstate <= S2;\n\t\t\t\telse \n\t\t\t\t\tstate <= S1;\n\t\t end\n\t\t\tS2: begin\n\t\t\t\tif (x == 1'b1) begin\n\t\t\t\t\tz <= 1'b1; // Output assertion on '101' sequence detection.\n\t\t\t\t\tstate <= IDLE; // transition back to idle state \n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S2;\n\t\t\t\tend\n\t\t end\n\t\tdefault: state <= IDLE; // Default case and error case, return to idle state.\n\t\tendcase\n\tend\nend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n// State definition\n    localparam STATE0 = 2'b00;  // Initial state\n    localparam STATE1 = 2'b01;  // State when first bit '1' is detected\n    localparam STATE2 = 2'b10;  // State when sequence '101' is detected\n    \n    reg [1:0] state_reg, state_next;   // State registers\n    \n    always @(posedge clk or negedge aresetn) begin\n        if (~aresetn)                   // Asynchronous reset\n            state_reg <= STATE0;        // Resets to state 0\n        else                            // Synchronous transitions\n            state_reg <= state_next;    // Next state is current state\n    end\n    \n    always @(state_reg, x) begin        \n        case (state_reg)                \n            STATE0:                     // If in initial state \n                if (x==1'b1)            \n                    state_next = STATE1;// If input 'x' is '1', go to next state 1\n                else                  \n                    state_next = STATE0;// Stay in the current state 0\n            STATE1:                     // If in state 1\n                if (x==1'b0)            \n                    state_next = STATE0;// If input 'x' is '0', go back to initial state 0\n                else                  \n                    state_next = STATE2;// If input 'x' is '1', go to next state 2\n            STATE2:                     // If in state 2\n                if (x==1'b1)            \n                    state_next = STATE2;// If input 'x' is '1', stay in the current state 2\n                else                  \n                    state_next = STATE0;// If input 'x' is '0', go back to initial state 0\n            default:                     // Catchall, shouldn't occur\n                state_next = 2'bXX;      // Take care of undefined states\n        endcase\n    end\n    \n    assign z = (state_reg == STATE2);   // Output '1' when sequence '101' is detected \n\nendmodule\n\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state;\n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\t\n\talways @(posedge clk or negedge aresetn) begin \n\t\tif(!aresetn) begin\n\t\t\tstate <= S0;\n\t\t\tz <= 0;\n\t\tend\n\t\telse case (state)   // State transitions\n\t\t\tS0: if (x == 1'b1) begin state <= S1; z <= 0; end  // When sequence is \"1\"\n\t\t\tS1: if (x == 1'b0) begin state <= S2; z <= 0; end  // When sequence is \"10\"\n\t\t\tS2: if (x == 1'b1) begin state <= S0; z <= 1; end ;// When sequence is \"101\", reset and assert z=1\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\ntypedef enum {STATE0, STATE1, STATE2} state;\nstate curr_st, next_st;\n    \nalways @(posedge clk or negedge aresetn) begin \n   if(!aresetn) \n      curr_st <= STATE0;\n   else\n      curr_st <= next_st;\nend \n\nalways @(*) begin\n\tcase (curr_st)\n\t\tSTATE0: begin\n\t\t\tif (!x)\n\t\t\t\tnext_st = STATE1;\n\t\t\telse \n\t\t\t\tnext_st = curr_st;\n\t\tend\n\t\tSTATE1: begin \n\t\t\tif(x) \n\t\t\t\tnext_st = STATE2;\n\t\t\telse \n\t\t\t\tnext_st = curr_st;\n\t\tend\n\t\tSTATE2: begin \n\t\t\tif (!x) begin\n\t\t\t\tz = 1'b1;\n\t\t\t\tnext_st = STATE0;\n\t\t\tend else begin\n\t\t\t\tz = 1'b0;\n\t\t\t\tnext_st = curr_st;\n\t\t\tend\n\t\tend\n\tdefault: next_st = STATE0;  // default state.\n   endcase\nend\nendmodule\n\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state;\n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10; //state definition\n\t\n\t//state transition function\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn) \n\t\t\tstate <= S0;\n\t\telse\n\t\t\tcase (state)\n\t\t\t\tS0: if (x == 1'b1) state <= S1; //if x = 1 go to next state S1\n\t\t\t\tS1: if (x == 1'b0) state <= S2; //if x = 0 go to next state S2\n\t\t\t\tS2: if (x == 1'b1) begin \n\t\t\t\t\t      z <= 1'b1; end //if x = 1 assert output z, return to start state S0\n\t\t\t\tdefault :state <= S0; \n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state;\n\tparameter S0 = 2'b00;\n\tparameter S1 = 2'b01;\n\tparameter S2 = 2'b10;\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn) begin\n\t\t\tstate <= S0;\n\t\t\tz <= 0;\n\t\tend\n\t\telse case (state) \n\t\t\t\tS0: if (x == 1'b1) state <= S1; else state <= S0;\n\t\t\t\tS1: if (x == 1'b0) begin z<=1; state <= S2; end else state <= S1;\n\t\t\t\tS2: if (x == 1'b1) begin z<=1; state <= S1; end else state <= S2;\n\t\t\tendcase \n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state; // 2 bit state declaration\n\n\talways @(posedge clk or negedge aresetn) begin // reset synchronous to clock\n\tif (aresetn == 0) begin // asynchronous active low reset\n\t\tstate <= 0; // initialize state\n\t\tz<=0; // output z initialized with 0\n\tend else begin\n\t\tcase(state)\n\t\t2'b00: if(x==1) state <= state + 1'b1;\n\t\t2'b01: if(x==0) state <= state + 1'b1;\n\t\t\t\telse state <= 2'b00; //if x is 1 go back to state 0 as we found a '1' and reset the sequence count\n\t\t2'b10: begin if (x==1) state <= state; else state <= 2'b00; end// waiting for next '1'. So, start over again.\n\t\t// since state = 2'b10 implies we have seen \"10\" and now expecting a '1', if x=0 it means the sequence did not continue with 101 anymore, so resetting back to starting point i.e., '0'\n\t\t\tdefault: state <= 0; // default case for safety, should never be reached in our implementation of the FSM\n\t\tendcase\n\t\tif(state == 2'b10) z<=1'b1; else z<= 1'b0; \n\t\t// if we are currently at state '10', then set output to 1, as \"101\" is detected.\n\tend\n\tend // end of reset synchronous part\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\t//state definitions\n\ttypedef enum logic [1:0] {S0 = 2'b00, S1 = 2'b01, S2 = 2'b10} state_t;\n\n    //current and next states\n\tstate_t current_state, next_state;\n\t\t  \n\t//sequential logic\n\talways @(posedge clk or negedge aresetn) begin\n\t    if (!aresetn) begin \n            current_state <= S0;    \n        end else begin              \n           current_state <= next_state; \n       end\n    end  \n\n\t//comb logic: Moore type\n\talways @(*) begin\n\t  case (current_state) \n\t    S0 : if (x == 1'b1) \n\t\t            next_state = S1;\n               else \n                  next_state = S0;\n        S1 : if (x == 1'b0)  \n                \tnext_state = S2;\n              else \n                next_state = S1; \n\t    S2 : if (x == 1'b1)  \n\t\t            next_state = S0;\n               else \n                  next_state = S2;\n       endcase\n\tend  \n\n\t//output logic: Mealy type\n\talways @(*) begin \n\t  case(current_state) \n\t    S0,S1 : z = 1'b0;\n        S2    : z = 1'b1;\n      endcase      \n\tend\n\t\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\t// State declaration\n\tlocalparam \n\t    STATE0 = 2'b00,\n        STATE1 = 2'b01,\n        STATE2 = 2'b10;\n        \n    // Current and next state register\n\treg [1:0] state_reg, state_next;\n    \n    // Output Logic \n\tassign z = (state_reg == STATE2) ? 1'b1 : 1'b0;\n    \n    // State update logic process\n\talways @(posedge clk or negedge aresetn) begin\n\t    if (!aresetn)\n            state_reg <= STATE0;   // Reset state to S0 on asynchronous reset (active low)\n        else \n            state_reg <= state_next;    // Update state otherwise\n\tend\n    \n    // Next State Logic process\n\talways @(state_reg,x) begin\n\t    case (state_reg)\n\t        STATE0 : if (x) state_next = STATE1; else state_next = STATE0; \n            STATE1 : if (x) state_next = STATE2; else state_next = STATE0; \n            default: state_next = STATE0; //STATE2 is also default, will reset to S0 for any other value of x in this state.\n\t    endcase\t    \n    end     \nendmodule  \n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state;  // FSM states\n  \n\t// State transition function\n\talways @(posedge clk or negedge aresetn) begin\n\t  if (!aresetn) \n\t    state <= 2'b00;     // Reset state\n\t  else \n\t    case (state)\n\t      2'b00: state <= x ? 2'b01 : 2'b00;    // State transitions based on input 'x'\n\t      2'b01: state <= x ? 2'b10 : 2'b00;\n\t      2'b10: state <= x ? 2'b11 : 2'b00;\n\t      2'b11: state <= x ? 2'b11 : 2'b00;    // Stay in the final state if input 'x' is 1\n\t    endcase\n\tend\n  \n\t// Output function\n\talways @(*) begin\n\t  case (state)\n\t    2'b00: z = 1'b0;      // In state 0, output 'z' should be zero.\n\t    2'b01: z = 1'b0;      \n\t    2'b10: z = 1'b0;  \n\t    2'b11: z = 1'b1;      // In final state 3, output 'z' should be one.\n\t  endcase\n\tend\n\t\nendmodule\n\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state;\n\tparameter IDLE = 2'b00, SECOND = 2'b01, THIRD = 2'b10;\n\t\t\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn)\n\t\t\tstate <= IDLE;\n\t\telse \n\t\t\tcase (state) \n\t\t\t\tIDLE: if (x == 1'b1) state <= SECOND;\n\t\t\t\tSECOND: if (x == 1'b0) begin z <= 1'b1; state <= THIRD; end else state <= IDLE;\n\t\t\t\tTHIRD: if (x == 1'b1) begin z <= 1'b1; state <= THIRD; end else begin z <= 1'b0; state <= IDLE; end \n\t\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state; \n    parameter S0=2'b00, S1=2'b01, S2=2'b10; //States definition\n    \n\talways @(posedge clk or negedge aresetn) begin\n        if (!aresetn) begin // Asynchronous reset \n            state <= S0;  \n            z <= 0;        \n        end else case (state)      \n          S0: begin               \n             if (x == 1'b1 ) begin   \n                 state <= S1 ;    \n                  z <= 0;     \n              end                  \n             else state <= S0 ; \n           end                    \n          \n          S1: begin              \n            if(x==1'b0)begin       \n                state<=S2;      \n                z<= 0 ;        \n            end                 \n            else state<=S1 ;  \n           end                  \n\n          S2: begin             \n            if (x == 1'b1 ) begin   \n                 state <= S0;     \n                  z <= 1;     // Output Asserted \n             end                   \n             else state <= S2 ; \n        endcase                    \n\tend                     \nendmodule      \n"}
{"task_id": "ece241_2013_q8", "completion": "\n\treg [1:0] state; \n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\t\t\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif(!aresetn) begin\n\t\t\tstate <= S0;  // Asynchronous reset\n\t\t\tz <= 1'b0;    // Deassert output signal z\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tS0: if(x == 1'b1) begin state <= S1; z <= 1'b0; end  \n\t\t\t\t\telse state <= S0;\n\t\t\t\tS1: if(x == 1'b0) begin state <= S2; z <= 1'b0; end \n\t\t\t\t\telse state <= S1;\n\t\t\t\tS2: if(x == 1'b1) begin state <= S0; z <= 1'b1; end // Assert output signal when \"101\" sequence is detected.\n\t\t\t\t\telse state <= S2;\n\t\t\tendcase \n\t\tend  \n\tend    \nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n\nreg state;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset == 1'b1) \n\t\tstate <= 1'b1; // B state\n\telse\n\tcase(state)\n\t\t1'b0 : if (in == 1'b0) state <= 1'b1; else state <= 1'b0;\n\t\t1'b1 : if (in == 1'b0) state <= 1'b0; else state <= 1'b1; \n\tendcase\nend\n\tassign out = state;\n\t\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n\n\treg state;\n\tassign out = state;  // Moore machine - Output is dependent on the current state\n    \n\t// State transitions occur synchronously with the clock\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset)   // Reset to B state\n\t\t    state <= 1'b1;\n        else \n            case ({state,in}) \n                2'b00: state <= 1'b0; // State A transition when in=0\n                2'b01: state <=1'b0;  // Stay in A when in = 1\n                2'b10: state<= 1'b0;  // State B transitions on in=0\n\t\t        2'b11: state <= 1'b1;  // State stay at B on in =1\n            endcase\n\tend\n\t\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n    reg state;\n    \n    always @(posedge clk or posedge reset) begin \n        if(reset)\n            state <= 1'b1; // Reset to B State\n        else\n        \tcase ({state, in}) \n            \t2'b00: state <= 1'b0; // From B To A when input is 0\n                2'b01: state <=  1'b1; // From B To B when input is 1\n                2'b10: state <= 1'b0; // From A to B when input is 0\n            \tdefault : state <= 1'b0;// From A To A when input is 1 or others.\n        \tendcase\n    end\n    \nassign out = state;\nendmodule\n\n"}
{"task_id": "fsm1s", "completion": "\n   reg state;\n    always @(posedge clk or posedge reset) begin \n        if (reset) // active high synchronous reset \n            state <= 1'b0; // to B state \n        else begin  \n             case({state,in}) \n                2'b00: begin state <= 1'b0; end // from B to A\n                2'b01: begin state <= 1'b1; end // remains in B\n                2'b10: begin state <= 1'b0; end // from A back to B\n                2'b11: begin state <= 1'b0; end // stays in A\n             endcase \n        end \n    end \n     assign out = state;  \nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n\treg state;\n\n\t// State machine\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) \n\t\t    state <= 1'b1; // B state on reset\n\t\telse \n\t\t\tcase ({state, in}) \n\t\t\t\t2'b00: state <= 1'b1; // from B to A when input is 0\n\t\t\t\t2'b01: state <= state; // retains A if the input is 1\n\t\t\t\t2'b10: state <= 1'b0; // from A to B when input is 0\n\t\t\t\t2'b11: state <= state; // retains B if the input is 1\n\t\t\tendcase\n\tend\n\t// output logic\n\tassign out = state;\nendmodule\n\n"}
{"task_id": "fsm1s", "completion": "\n    reg state; // State register\n    \n    always @(posedge clk or posedge reset) begin \n        if(reset) \n            state <= 1'b0; // Set to B state on reset\n        else \n           case ({state,in}) \n                2'b00: state <= 1'b0; // From B to B with 0 input\n                2'b01: state <= 1'b1; // From B to A with 1 input\n                2'b10: state <= 1'b0; // From A to B with 0 input\n\t\t2'b11: state <= 1'b1; // From A to A with 1 input\n           endcase\n    end\n\nassign out = state;\n    \nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n   reg state;\n   \n   always @(posedge clk or posedge reset) begin  // Reset is active high\n      if(reset == 1'b1)\n         state <= 1'b0;     // Reset state to B\n      else\n        case ({state, in}) \n          2'b00 : begin\n             state <= 1'b0;   // Maintain current state A and output 0\n             out <= 1'b0;\n            end\n          2'b01 : begin\n             state <= 1'b1;   // Go to next state B and output 1\n             out <= 1'b1;\n            end    \n          2'b10 : begin\n             state <= 1'b0;   // Maintain current state A and output 0\n             out <= 1'b0;     \n            end   \n          2'b11 : begin\n             state <= 1'b1;   // Go to next state B and output 1\n             out <= 1'b1;      \n            end   \n        endcase\n    end\nendmodule\n\n"}
{"task_id": "fsm1s", "completion": "\n\treg state;\n\twire nextState = (!state && !in) || (state && in);\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 1'b0; //B State\n\t\telse \n\t\t\tstate <= nextState;\n\tend\n\n\tassign out = state ^ 1'b1 ;\n\n"}
{"task_id": "fsm1s", "completion": "\nreg [1:0] state;\nwire [1:0] ns; //Next State\nparameter B=2'b00, A=2'b01; \nassign out = (state == B)? 1'b1 : 1'b0 ;\nassign ns = reset? B : in? A : B ;\nalways @(posedge clk) \n\tstate <= ns;\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n\treg state;\n\t\n\talways @(posedge clk or posedge reset) begin \n\t\tif(reset)\n\t\t\tstate <= 1'b0;\n\t\telse if (in == 1'b1)\n\t\t\tstate <= !state;\n\tend\n\tassign out = state;\n\nendmodule\n\n"}
{"task_id": "fsm1s", "completion": "\n\treg state; // Declare the state\n\t\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t  if (reset) \n\t    state <= 1'b1;  // B State for reset\n\t  else \n\t   case ({state,in})\n\t\t   2'b00 : state <= 1'b0;\t// From A to B\n       \t\t 2'b01 : state <= state;  // Stay at A\n        \t     2'b10 : state <= 1'b1;  // From B to A\n        \t     2'b11 : state <= ~state; // Change between states on in=1 transition\n\t   endcase\n\tend\n\t\n\t// Output logic\n\tassign out = state;\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n   reg state; \n\n    always @(posedge clk or posedge reset) begin\n        if(reset) //reset is active-high\n            state <= 1'b0;  // to B\n        else begin        \n          case ({state,in}) \n            2'b00 : state <= 1'b1; // A --in=0--> B\n            2'b01 : state <= 1'b1; // A --in=1--> B\n            2'b10 : state <= 1'b0; // B --in=0--> A\n            2'b11 : state <= 1'b0; // B --in=1--> A\n          endcase\n        end \n    end\n\nassign out = state; \n\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n\treg state; \n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset == 1'b1)\n\t\t\tstate <= 1'b0; // B State\n\t\telse if (in == 1'b0) \n\t\t\tstate <= state; // no change\n\t\telse if (in == 1'b1 && state==1'b0) // from A to B\n\t\t\tstate <= ~state;  \n\t\telse if (in == 1'b1 && state==1'b1) // from B to B\n\t\t\tstate <= state; \t\t\t\n\tend\n\tassign out = ~state; // not operator as per given transition table \nendmodule\n\n"}
{"task_id": "fsm1s", "completion": "\nreg state; // Current state of the FSM\n\nalways @(posedge clk or posedge reset) begin \n\tif(reset) \n\t\tstate <= 1'b0; // Reset to B\n\telse\n\t\tcase ({state,in})\n\t\t\t2'b00: begin state <= 1'b0; end // From A to B on input 0\n\t\t\t2'b01: begin state <= 1'b1; end // From A to A on input 1\n\t\t\t2'b10: begin state <= 1'b0; end // From B to B on input 0\n\t\t\t2'b11: begin state <= 1'b0; end // From B to A on input 1\n\t\tendcase\nend\nassign out = state;\n\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\n\treg state;\n\twire nextState;\n\t\t\n\t// State transitions\n\tassign nextState = !state & in | state & ~in;  // Combinational logic for the transition functions\n\t\n\t// Output assignments\n\tassign out = state;    // Moore output\n\t\n\t// State register\n\talways @(posedge clk or posedge reset) begin   // Synchronous reset and clocked state transitions\n\t    if (reset)\n\t        state <= 1'b0;  // Reset to B\n\t    else\n    \t    state <= nextState;  \n    end\nendmodule\n\n"}
{"task_id": "fsm1s", "completion": "\n\n\treg state;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= 1'b0; // B\n\t\telse \n\t\t\tcase ({state, in}) \n\t\t\t\t2'b00: state <= 1'b0; // A,B --> 00 --> B\n\t\t\t\t2'b01: state <= 1'b1; // A,B --> 01 --> B\n\t\t\t\t2'b10: state <= 1'b0; // A,B --> 10 --> A\n\t\t\t\t2'b11: state <= 1'b1; // A,B --> 11 --> B\n\t\t\tendcase\n\tend\n\n\tassign out = state;\nendmodule \n"}
{"task_id": "fsm1s", "completion": "\n\treg state;\n\talways @(posedge clk or posedge reset) begin\n    \tif(reset) \n        \tstate <= 1'b0; // B State\n    \telse if (!in && !state)  \n        \tstate <= 1'b0;// A state\n      \telse if (in && state)   \n\t\t\tstate <= 1'b1; // B state\n     \telse                    \n         \tstate <= 1'b1;  // A state\n     end\n\nassign out = state;\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\nreg state; // internal state of the state machine\nalways @(posedge clk or posedge reset) begin  // synchronous reset\n\tif (reset) \n\t\tstate <= 1'b0;\t// setting initial state to B.\n\telse if (!in & state == 1'b0) // transition from B to A on a '0' input\n        \tstate <= 1'b1;\n  \telse if (in & state == 1'b0)  //transition from B to B on a '1' input\n       \t\tstate <=1'b0;\n    \telse if (!in & state == 1'b1)  //transition from A to B on a '0' input\n        \tstate <= 1'b0;\n  \telse if (in & state == 1'b1)  // transition from A to A on a '1' input\n       \t\tstate <= 1'b1;\nend\nassign out = state;\t//output is the current state.\nendmodule\n"}
{"task_id": "fsm1s", "completion": "\nreg state;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) \n\t\tstate <= 1'b0; // B state\n\telse if (!in & !state)\n\t\tstate <= 1'b0; // stay in A state\n\telse if (!in & state)\n\t\tstate <= 1'b1; // transition to B state from A\n\telse if (in & !state) \n\t\tstate <= 1'b1; // stay in B state\n\telse if (in & state)\n\t\tstate <= 1'b0; // transition to A state from B\nend\n    \nassign out = state;\n"}
{"task_id": "fsm1s", "completion": "\n    reg state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= 1'b0;\n        else if (!in && !state) \n            state <= 1'b0;\n        else if (!in && state) \n            state <= 1'b1;\n        else if (in && !state) \n            state <= 1'b1;\n        else if (in && state) \n            state <= 1'b0;\n    end\n    \n\tassign out = state;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0; // Driving 0 to the output\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n   assign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n    assign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0; // Assigning the value '0' to the output 'out' which is the driving signal for always 0 circuit.\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n"}
{"task_id": "m2014_q4i", "completion": "\n\n\tassign out = 1'b0;\nendmodule\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n    \n\tassign out = 1'b0;\n\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n    assign out = 1'b0;\nendmodule\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "m2014_q4i", "completion": "\n\n\tassign out = 1'b0; // assigns out to 0 on every clock cycle, causing it to stay at 0 forever.\nendmodule\n  \n"}
{"task_id": "m2014_q4i", "completion": "\n\t// Output is driven by a constant '1'\n\tassign out = 1'b0;\nendmodule\n\n"}
{"task_id": "countbcd", "completion": "\n\n\treg [2:0] digit;  // which decimal place are we currently counting\n\tassign ena = (digit == 3'b111) ? 3'h7 : 3'(digit + 1); // if at last digit, enable all else increment the next one.\n\t\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) begin\n\t\t    q <= 16'd0;\n            digit <= 2'h0; \n        end\n\t    else if (digit == 3'b111 && q[7:4] == 4'd9) begin // if at last digit and it overflows reset back to zero\n\t\t    q <= 16'(8'h0);\n            digit <= 2'h0; \n        end\t        \n\t    else if (digit == 3'b111 && q[7:4] < 4'd9) begin // if at last digit but it does not overflow increment the upper digit and reset this one.\n\t\t    q <= {q[7:4], 4'h0};\n            digit <= 2'h0;  \t\t\t      \t        \n        end\t       \n\t    else if (digit < 3'b111) begin // otherwise simply increment this digit and leave others as is\n\t\t    q <= {q[7:4], q[3:0] + 4'd1}; \n            digit <= digit + 2'h1;  \t\t\t      \t        \n        end\t   \n     end\nendmodule\n\n"}
{"task_id": "countbcd", "completion": "\n    wire overflow;\n    \n    assign ena = {q[7],q[11]} ;   // enabling the upper two digits to increment when 4th digit (lower left bit) overflows.\n     \n\talways @(posedge clk or posedge reset) begin\n        if (reset) \n\t\t\tq <= 16'b0;\n        else begin\n            q[3:0] <= q[3:0] + 4'd1;     //increment the ones digit by 1.\n\t\t\tif(overflow) begin           //check if the ones digit overflowed i.e., 10 (BCD).\n\t\t\t\tq[7:4] <= q[7:4] +4'd1;   //increment tens place by 1.\n                if(&q[11:8]) begin         //check for a carry in the tens digit i.e., 6 (BCD) .\n                    q[15:12] <= q[15:12] + 4'd1;   //increment hundreds place by 1.\n\t\t\t\t\tif(&q[15:12]) begin     //check for a carry in the hundreds digit i.e., 9 (BCD).\n\t\t\t\t\t\tq[15:12] <= 4'd0;      //reset the hundreds digit to 0.\n                    end\n                end\n\t\t\tend\n        end\n    end\n\t \n\t//overflow condition for ones place\n\tassign overflow = &q[3:0];  \n        \nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\treg [19:0] counter;\n\tassign {ena,q[15:4]} = counter[19:4]; // BCD conversion for upper 3 digits and enable signal for the last digit.\n\t\t\n\talways @(posedge clk or posedge reset) begin\n\t  if (reset)\n\t    counter <= 0;\n\t  else\n\t    counter <= (counter==9999)? 0 : counter+1; // Count up to 9999 and then back to zero.\n\tend\n\t  \nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\t// The BCD counter is a 16-bit counter where each digit is 4 bits.\n\t// To enable the incrementation of upper digits, we use a binary number system and set ena[i] when 2^(3-i) <= q < 2^(2-i), for i in [3:1].\n\tinteger i; // loop variable for BCD counter calculation\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) begin\n\t        q <= 0;\n\t    end \n\t    else begin\n\t\t    q <= q + 4'd1; // increment the counter\n\t\t\t// calculate enable signals: ena[i] = ~(q < ((2^(3-i)) % 16)) & (q >= ((2^((2-i)%4)) % 16));\n\t        for(i=0; i<4; i++) begin // loop through all four BCD digits\n\t        \tif(i == 0 || i == 3 ) begin // special case because we rotate by 8\n\t\t\t        ena[i+1] <= ~(q < ((2^(7-i)) % 64)) & (q >= ((2^((3-i)%6)) % 64));   \t        \t\t  \t           \t      \t         \t\t\n\t\t\t     end else begin\n\t\t\t\t\t ena[i+1] <= ~(q < ((2^(3-i)) % 100)) & (q >= ((2^((2-i)%4)) % 100));     \n\t\t\t\t end  \t\t\t      \t         \t\t  \t           \t        \t\t\n\t        end\n\t    end\n\tend\nendmodule\n"}
{"task_id": "countbcd", "completion": "\nreg [2:0] carry; \nwire [14:0] incremented_q; // We only use the most significant byte of this value. \nassign ena = {3{carry[2]}}; \n  \nalways @(posedge clk or posedge reset) begin \n    if (reset) begin \n        q <= 16'b0; \n        carry <= 3'b0; \n    end \n    else begin \n        incremented_q = q[15:1] + 4'd1; // Increment every byte. \n        {carry, q} <= reset ? 16'b0 : (incremented_q[3:0] == 4'b1001) ? {1'b1, incremented_q[14:4], 4'b0000} : {carry[2:0], incremented_q};\n    end \nend\n"}
{"task_id": "countbcd", "completion": "\n\n    // BCD values from 0 to 9\n    localparam [6:0] bcd_vals[0:9] = '{7'b0000000, 7'b0000001, 7'b0000010, 7'b0000100,\n7'b0001000, 7'b0010000, 7'b0100000, 7'b1000000,\n7'b0000011, 7'b0000110};\n\t\n    // Output enable signals\n    reg [3:1] ena;\n    \n\t// BCD counter\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) q <= 16'h0000;  // reset state\n        else begin   // increment counters and update enable signals\n\t\t    for (integer i=3; i>=1; --i) begin\n                ena[i] <= ((q[(i-1)*4+2: (i-1)*4] == bcd_vals[8]) & q[(i-1)*4 +: 4]); // increment upper digits if the current digit is at its max value and all other digits are at their max values\n\t\t        if ((q[(i-1)*4+2 : (i-1)*4] < bcd_vals[9]) & ena[i]) begin   // increment current digit if it's not at its max value\n\t\t\t        q[(i-1)*4 +: 4] <= bcd_vals[q[(i-1)*4+2 : (i-1)*4]] + 4'h1;\n\t\t        end else if ((q[(i-1)*4+2 : (i-1)*4] == bcd_vals[9]) & ena[i]) begin   // reset current digit to 0 if it is at its max value\n\t\t\t        q[(i-1)*4 +: 4] <= bcd_vals[0];\t    \n\t\t        end\n            end\n\t\tend\n    end\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\treg [2:0] cnt;\n\tassign ena = {cnt[2], cnt[1], 1'b0}; // Only enable the first and second digit counters\n\t\t\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) begin\n\t        q <= 16'h0;\n\t        cnt <= 3'h0;\n\t    end else begin\n            cnt <= cnt + 1; // increment the counter\n    \t    case(cnt) \n\t\t        3'b000 : q[3:0]   <= (q[3:0]+1);   // increment ones digit\n\t            3'b001 : begin \n                            if(&q[3:0]) cnt <= cnt + 2; // if there is carry, enable tens counter and increment it as well\n        \t\t            q[3:0]   <= 4'h0;     // reset ones digit\n                        end  \t            \n                3'b010 : q[7:4]  <= (q[7:4]+1); \t// increment tens digit\n\t            3'b011 : begin \n                            if(&q[7:4]) cnt <= cnt + 2; // if there is carry, enable hundreds counter and increment it as well\n        \t\t            q[7:4]  <= 4'h0;     // reset tens digit\n                        end   \t          \t            \n                3'b100 : q[11:8] <= (q[11:8]+1);\t// increment hundreds digit\n\t            3'b101 : begin \n                            if(&q[11:8]) cnt <= cnt + 2; // if there is carry, enable thousands counter and increment it as well\n        \t\t            q[11:8] <= 4'h0;   \t// reset hundreds digit\n                        end  \t                \n                3'b110 : q[15:12] <= (q[15:12]+1);  // increment thousands digit\n    \t        default: cnt <= 3'h0;                // if none of the above, reset all\n            endcase\t\t     \t            \t  \t\t\t\n\t    end\n    end\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\treg [16:0] nextq;  // one extra bit for carry\n\n\t// define BCD increment function\n\tfunction automatic [15:0] inc_bcd;\n\t\tinput [15:0] x;\n\t\tbegin\n\t\t\tif (x[3:0] < 4'd9)\n\t\t\t\tinc_bcd = {x[15:4], x[3:0] + 1'b1, 2'b0};\n\t\t\telse if (x[7:4] < 4'd9)\n\t\t\t\tinc_bcd = {x[15:8], x[3:0], x[7:4] + 1'b1, 1'b0};\n\t\t\telse if (x[11:8] < 4'd9)\n\t\t\t\tinc_bcd = {x[15:12], x[3:0], x[7:4], x[11:8] + 1'b1, 0};\n\t\t\telse\n\t\t\t\tinc_bcd = {x[15:12], x[3:0], x[7:4], x[11:8] + 1'b1}; // overflow\n\t\tend\n\tendfunction\n\n\t// generate next state logic\n\talways @(*) begin\n\t\tif (reset) \n\t\t\tnextq = 16'h0;\n\t\telse if ((q[3:0] == 4'd9 && q[7:4] == 4'd5 && q[11:8] < 4'd5 )||(q[3:0] >= 4'd9 )) // increment upper digits at roll-over\n\t\t\tnextq = inc_bcd(q) ;\n\t\telse if ((ena == 3'b100 && q[7:4] >= 4'd9) || (ena != 3'b000 && ena !=3'b100)) // increment upper digits when corresponding enable is 1, but not at 9\n\t\t\tnextq = {inc_bcd(q)[15:8], q[7:4], inc_bcd(q)[3:0], q[11:8]}; \n\t\telse if (ena == 3'b010) // increment tens digit when enable is 1 and not at 9\n\t\t\tnextq = {q[15:12], q[7:4], inc_bcd(q)[3:0], q[11:8]};  \n\t\telse if (ena == 3'b001) // increment ones digit when enable is 1 and not at 9\n\t\t\tnextq = {q[15:12], q[7:4], q[3:0], inc_bcd(q)[3:0]};  \n\t\telse \n\t\t\tnextq = q; // no change\n\tend\n\t\n\t// register update\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tena <= 3'b111;\n\t\telse if ((q[7:4] == 4'd9 && ena != 3'b000 )||(q[3:0] >= 4'd9 )) // increment upper digits at roll-over\n\t\t\tena <= ena + ~ (3'b100);  \n\t\t\t\n\t\telse if (( q[7:4] < 4'd5 && ena != 3'b000 )||(q[7:4] >= 4'd9 )) // increment upper digits when corresponding enable is 1, but not at 9\n\t\t\tena <= ena + ~ (3'b100);  \n\t\t\t\n\t\telse if (( q[7:4] < 4'd5 && ena != 3'b000 )||(q[7:4] >= 4'd9 )) // increment tens digit when enable is 1 and not at 9\n\t\t\tena <= ena + ~ (3'b010);  \n\t\t\t\n\t\telse if (( q[3:0] < 4'd5 && ena != 3'b000 )||(q[7:4] >= 4'd9 )) // increment ones digit when enable is 1 and not at 9\n\t\t\tena <= ena + ~ (3'b001);  \n\t\t\t\n\t\telse if (( q[7:4] < 4'd5 && ena != 3"}
{"task_id": "countbcd", "completion": "\n\treg[2:0] digit;\n\tassign ena = (digit == 3'b100) ? 3'h4 : 3'h0; //enable the upper three digits when reaching 9\n\t\n\talways @(posedge clk or posedge reset) begin\n\t    if(reset) begin\n\t        q <= 16'd0;\n\t        digit <= 3'b000;\n\t    end else begin\n\t\t    case (digit)\n\t\t\t    3'b000: if (q[3:0] == 4'd9) begin q[3:0] <= 4'd0; digit <= digit + 1; end else q[3:0] <= q[3:0] + 1; \n\t\t        3'b001: if (q[7:4] == 4'd9) begin q[7:4] <= 4'd0; digit <= digit + 1; end else q[7:4] <= q[7:4] + 1;   \n\t\t\t    3'b010: if (q[11:8] == 4'd9) begin q[11:8] <= 4'd0; digit <= digit + 1; end else q[11:8] <= q[11:8] + 1; \n\t\t\t    3'b011: if (q[15:12] == 4'd9) begin q[15:12] <= 4'd0; digit <= 3'b000; end else q[15:12] <= q[15:12] + 1; \n\t\t        default: digit <= 3'b000; //This will never happen but is a good practice to handle in case of error.\n\t\t\t    \t  \t      \t \n\t        endcase\n\t   end\n\tend\nendmodule\n\n"}
{"task_id": "countbcd", "completion": "\n\treg [2:0] digit;\n\n\t// BCD counter\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset) begin\n\t        q <= 16'h0000;\n\t        digit <= 3'b000;\n\t    end else begin \n\t\t    unique case (digit) \n\t\t\t    3'd0: ena <= 3'b100;\n                3'd1: ena <= 3'b010;\n\t\t\t\t3'd2: ena <= 3'b001;\n\t\t\t\tdefault : begin end\n\t\t    endcase\n\t        // Increment the current digit\n            q[digit*4+3 : digit*4] <= (q[digit*4+3 : digit*4] == 4'd9) ? 4'd0 : q[digit*4+3 : digit*4] + 1;\n\t        // Move to the next digit if current digit is 9\n            digit <= (q[digit*4+3 : digit*4] == 4'd9) ? digit + 1 : digit;\n\t    end\t  \n   \tend\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\t// BCD encoding for numbers 0 to 9 is as follows:\n\t// 0 => 4'b0000\n\t// 1 => 4'b0001\n\t// ...\n\t// 9 => 4'b1001\n\treg [4:0] digit_values[3:0]; // BCD representations for the digits in q[15:12], q[11:8], q[7:4], and q[3:0].\n\t\n\t// Initialization of values.\n\tinitial begin\n\t\tdigit_values[3] = 5'b1001; // 9\n\t\tdigit_values[2] = 5'b1001; // 9\n\t\tdigit_values[1] = 5'b1001; // 9\n\t\tdigit_values[0] = 5'b1001; // 9\n\tend\n\t\n\t// Enable signals for the upper three digits.\n\tassign ena = (q[3:1] == 3'd2) || (q[3:1] == 3'd1);\n\t\n\talways @(posedge clk or posedge reset) begin // synchronous counter with reset\n\t\tif (reset) \n\t\t\tq <= 16'h0; // resetting the counter to zero on active high reset signal.\n\t\telse if (ena) begin // incrementing only enabled digits\n\t\t\t// increment current digit and roll over to next when we hit its maximum value of '9'.\n\t\t\tif(digit_values[q[15:12]] + 4'd1 == digit_values[3]) begin \n\t\t\t\tdigit_values[q[15:12]] <= 5'b0; // roll over to zero on next increment.\n\t\t\t\t// incrementing the next digit if it is not last digit, else just keep it as '9'.\n\t\t\t\tif (q[15:12] != 3) \n\t\t\t\t\tdigit_values[{|(~&{(4'd7 >> q[15:12]) + 4'd0}), {&{(4'd7 >> q[15:12]) + 4'd0}}}] <= digit_values[{|(~&{(4'd7 >> (q[15:12]+1)) + 4'd0}), {&{(4'd7 >> (q[15:12]+1)) + 4'd0}}}] + ((q[15:12] == 3'd3) ? 5'b1 : digit_values[(4'd7 >> q[15:12])]);\n\t\t\tend else begin\n\t\t\t\tdigit_values[q[15:12]] <= digit_values[{|(~&{(4'd7 >> q[15:12]) + 4'd0}), {&{(4'd7 >> q[15:12]) + 4'd0}}}] + (q[15:12] == 3) ? 5'b1 : digit_values[(4'd7 >> q[15:12])];\n\t\t\tend\n\t\t\t\n\t\tend\n\tend\n\tassign q = {digit_values[3], digit_values[2], digit_values[1], digit_values[0]}; // assembling the output from BCD values.\nendmodule\n\n"}
{"task_id": "countbcd", "completion": "\n\treg[4:0] digit = 5'b10000; // Start counting from 10 (digits are ones-place first)\n\tassign ena = {q[7], q[3], q[1]};\n\t \n\talways @(posedge clk or posedge reset) begin\n\t    if(reset) begin\n\t        digit <= 5'b10000; // Reset to 10 (digits are ones-place first)\n\t\t      q <= 16'h0;  \n\t    end else begin\n\t    \tcase (digit)\n\t    \t    4'd9: begin digit<=5'b1000; q[{q[7],q[3],q[1]} + 2'd3] <= {q[3:0]+1,4'h0}; end // Ones increment \n\t\t      \t  4'd8: begin digit<=5'b1001; q[{q[7],q[3],q[1]} + 2'd6] <= {q[3:0]+1,4'h0}; end // Tens increment \n\t\t      \t  4'd7: begin digit<=5'b1010; q[{q[7],q[3],q[1]} + 2'd9] <= {q[3:0]+1,4'h0}; end // Hundreds increment \n\t\t      \t  4'd6: begin digit<=5'b1011; q[{q[7],q[3],q[1]} + 2'd2] <= {q[3:0]+1,4'h0}; end // Thousands increment\n\t\t      \t  4'd5: begin digit<=5'b1100; q[{q[7],q[3],q[1]} + 2'd5] <= {q[3:0]+1,4'h0}; end // Tens of thousands increment\n\t\t      \tdefault: digit<= 5'b10000;  // reset to 0\n     \t    endcase\n    \tend   \n\tend\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\t// Local variables to hold the enable signals for each digit.\n\treg [2:0] local_ena;\n\tassign {local_ena[1], local_ena[2]} = local_ena[1:0];  // Shift ena bits.\n\tassign {ena} = ~{local_ena[2:1]} & {local_ena[1:0]};    // Enable for upper two digits.\n\t\t\n\t// Reset and clocked process.\n\talways @(posedge clk or posedge reset) begin\n\t    if (reset == 1'b1)  q <= 16'h0;  // Active-high synchronous reset.\n\t    else if (local_ena[1])  q <= {q[3:2], q[7:4] + 1'h1, q[15:8]};   // Increment tens digit and roll over to ones digit for overflow.\n\t    else if (local_ena[0])  q <= {q[3:0] + 1'h1, q[15:4]};           // Just increment ones digit.\n\tend\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\treg [3:0] carry; // To keep track of the carry out for each digit \n\twire [3:1] increment_enable; // To enable incrementing digits. \n\tassign ena = increment_enable & {4{carry[2]}}; \n\t// Only enable upper three digits if carry is high (which happens when lower count resets to zero)\n    \n\talways @(posedge clk or posedge reset) begin\n\t   \tif (reset) begin\n\t\t    q <= 16'h0;\n            carry <= 4'b0; // Reset the carry flag. \n        end\n\telse begin\n      \t\tcarry[0] <= ((q[3:0] == 4'd9)); // If current count is at its maximum, set the carry flag high for next digit\n        \tq[3:0] <= (((q[3:0] == 4'd9)) ? 4'h0 : q[3:0] + 1); \n\t\t\t// If carry is high, reset current count to zero else increment it by one.\n    \n       \t    // Propagate the carry flag upwards for all digits\n        \tcarry[1] <= ((q[7:4] == 4'd9)) & (q[3]); \n        \tq[7:4] <=  (((q[7:4] == 4'd9) && q[3]) ? 4'h0 : q[7:4] + carry[0]);   \n    \n\t        // Propagate the carry flag upwards for all digits\n        \tcarry[2] <= ((q[11:8] == 4'd9)) & (q[7]);  \n        \tq[11:8] <=  (((q[11:8] == 4'd9) && q[7]) ? 4'h0 : q[11:8] + carry[1]);   \n    \n\t        // Propagate the carry flag upwards for all digits.  \n        \tcarry[3] <= ((q[15:12] == 4'd9)) & (q[11]); \n       \t \tq[15:12] <=  (((q[15:12] == 4'd9) && q[11]) ? 4'h0 : q[15:12] + carry[2]);  \n    \tend\n    end\n\n\tassign increment_enable = ~{carry[3], ((carry[3] & (q[15:12] == 4'd9)) | carry[2]), ((carry[3] & carry[2]) && q[11])}; \n\t// This generates enable signals for digits that can be incremented. \nendmodule\n"}
{"task_id": "countbcd", "completion": "\n    \n    wire [4:0] carry;  // carries for the ripple carry addition\n  \n\tassign carry[1] = (q[3:0] == 4'd9);  // carry from ones place\n\tassign carry[2] = (q[7:4] == 4'd9) & carry[1];  // carry from tens place\n\tassign carry[3] = (q[11:8] == 4'd9) & carry[2];  // carry from hundreds place\n\tassign carry[4] = (q[15:12] == 4'd9) & carry[3];  // carry from thousands place\n  \n\t// enable signals for the upper three digits, with carries on lower digit enables\n\tassign ena = ~{carry[4], ~carry[3], ~carry[2]};\n   \n\talways @(posedge clk or posedge reset) begin\n    \tif (reset) \n        \tq <= 16'b0; // synchronous active high reset\n    \telse if (ena[1])  \n          \tq <= { q[3:0]+4'd1, q[7:4], q[11:8], q[15:12] }; \n        else if (ena[2])   \n        \tq <= { q[3], q[7:4]+4'd1, q[11:8], q[15:12] } ;\n        else if (ena[3])  \n          \tq <= { q[3], q[7:0]+4'd1, q[11:8], q[15:12] };  // increment thousands place \n     end\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\treg [2:0] counter;  // Internal 3-bit counter for the BCD digits.\n   wire overflow = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\n   \n\talways @(posedge clk, posedge reset) begin\n    \tif(reset)\n        \tbegin\n          \tq <= 16'h0;\n       \t  counter <= 3'b0;\n          ena <= {3{1'b1}};  // Enable all digits initially.\n       end\n      else if (counter == 3'd4)\n       begin\n        \tcounter <= 3'b0;   // Reset the counter after counting to 4th digit.\n       \t  ena <= {3{1'b1}};  // Enable all digits again as we have rolled over from last digit.\n    \tend \n      else if(overflow) begin   \n        \t{q[7:0], q[15:8]} <= q[7:0] + 2, q[15:8];\n           ena <= 3'b110;       // Enable tens and hundreds digits to increment.\n       \tcounter <= counter + 3'd1; \n      end\n     else begin\n        \t{q[7:0], q[15:8]} <= q[7:0], q[15:8] + 2, ;\n           ena <= 3'b011;        // Enable ones and tens digits to increment.\n        \tcounter <= counter + 3'd1; \n      end\n   end\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\t// Internal signals to indicate when each of the upper three digits should be incremented. \n\treg [2:1] increment;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tq <= 0;\n\t\t\tincrement <= 0;\n\t\tend else begin\n\t\t\t// Increment the upper three digits if needed.\n\t\t\tif (increment[2:1] == 2'b11) begin\n\t\t\t\tq[15:8] <= q[7:0];\n\t\t\t\tincrement <= 0;\n\t\t\tend else if (increment[1]) begin  // increment upper two digits\n\t\t\t\tq[7:4] <= q[3:0] == 4'd9 ? 4'd0 : q[3:0] + 1;\n\t\t\t\tif (q[3:0] == 4'd9) increment <= 2'b10; else increment <= 2'b11;\n\t\t\tend else begin // increment upper digit\n\t\t\t\tq[3:0] <= q[3:0] == 4'd9 ? 4'd0 : q[3:0] + 1;\n\t\t\t\tincrement <= 2'b11;\n\t\t end\n      ena = increment;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\t// Assuming that BCD counter starts at 0 (i.e., 4'b0000)\n\tlocalparam START = 4'd0;\n\t\n\t// Possible states of BCD counter for tens digit [7:4] and ones digit [3:0]\n\tlocalparam TEN_ONE = 2, TEN_TEN = 2, ONE_ZERO = 1, TEN_ZERO = 1, ZERO_ZERO = 0; // 2 and 1 are for incrementing tens and ones digit respectively. 0 means no increment\n\t\n\t// Mapping of each state to corresponding enable signals [3:1]\n\tlocalparam ENABLE = {1'b1, 1'b0, 1'b0}, TEN_ENABLE = {1'b0, 1'b1, 1'b0}, ONE_ENABLE = {1'b0, 1'b0, 1'b1};\n\t\n\treg [1:0] state; // current state of BCD counter\n\tassign ena = (state == TEN_ONE)? TEN_ENABLE : ((state == TEN_TEN)? ONE_ENABLE : ((state == ZERO_ZERO) ? ENABLE : {1'b0, 1'b0})); // assign enable signals\n\t\n\t// counter logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tq <= START; // Reset to 4'd0 i.e., BCD equivalent of 0\n\t\t\tstate <= ZERO_ZERO; // state at 4'b0000 means tens and ones digit is not incrementing\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tTEN_ONE: begin q <= ~(q[15]|q[8]) ? {q[7:0], ~q[3]} + 4'd1 : 96; state <= TEN_TEN; end // increment tens digit if not at 9 and increment ones otherwise\n\t\t\t\tONE_ZERO: begin q <= ~(q[15]|q[8]) ? {q[7:0], ~q[3]} + 4'd1 : 96; state <= TEN_ONE; end // reset ones digit if not at 9 and increment otherwise\n\t\t\t\tTEN_ZERO: begin q <= ~(q[15]|q[8]) ? {q[7:0], ~q[3]} + 4'd1 : 96; state <= ONE_ZERO; end // reset tens digit if not at 9 and increment otherwise\n\t\t\t\tTEN_TEN: begin q <= ~(q[15]|q[8]) ? {q[7:0], ~q[3]} + 4'd1 : 96; state <= TEN_ZERO; end // reset tens digit if not at 9 and increment otherwise\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "countbcd", "completion": "\n\t// Define the state encoding for each digit position\n\tparameter BCD_ONES = 4'b0001;   // ones digit\n\tparameter BCD_TENS = 4'b0010;   // tens digit\n\tparameter BCD_HUNDREDS = 4'b0100;  // hundreds digit\n\tparameter BCD_THOUSANDS = 4'b1000; // thousands digit\n\n\t// Define the state encoding for enable signals\n\tparameter ENABLE_ONES = 2'b01;   \n\tparameter ENABLE_TENS = 2'b10;  \n\n\treg [3:0] digit_state;  // current position of BCD counter\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset == 1'b1) begin\n\t\t\t// Asynchronous reset to zero\n\t\t\tq <= 16'b0;   \n\t\t\tdigit_state <= BCD_ONES;   // start at ones digit\n\t\tend \n\t\telse begin\n\t\t\tcase (digit_state)\n\t\t\t\tBCD_ONES: begin \n\t\t\t\t\t// For the ONEs digit, enable when incrementing to 10\n\t\t\t\t\tena <= ENABLE_ONES;   \n\t\t\t\t\tif (q[3:0] == 4'd9) begin // if we are at 9, rollover to TENS\n\t\t\t\t\t\tdigit_state <= BCD_TENS;  \n\t\t\t\t\t\tq <= 4'b1000 + q[7:4]; // shift the 1 in position of TENS digit to left and add it with the existing value\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\t// increment ONEs digit without rolling over\n\t\t\t\t\t\tena <= 2'b0;   // disable enable signals for all digits but ONES\n\t\t\t\t\t\tq <= q + 4'd1;  // just increment the ones digit\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tBCD_TENS: begin \n\t\t\t\t\t// For TENs digit, enable when incrementing to 10\n\t\t\t\t\tena <= ENABLE_ONES;   \n\t\t\t\t\tif (q[7:4] == 4'd9) begin // if we are at 9, rollover to HUNDREDS\n\t\t\t\t\t\tdigit_state <= BCD_HUNDREDS;  \n\t\t\t\t\t\tq <= 4'b1000 + q[7:4]; // shift the 1 in position of HUNDREDs digit to left and add it with the existing value\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\t// increment TENS digit without rolling over\n\t\t\t\t\t\tena <= ENABLE_TENS;   // enable for ONEs and TENS digits\n\t\t\t\t\t\tq <= 4'b100 + q[7:4];  // just increment the tens digit\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tBCD_HUNDREDS: begin \n\t\t\t\t\t// For HUNDReS digit, enable when incrementing to 10\n\t\t\t\t\tena <= ENABLE_ONES;   \n\t\t\t\t\tif (q[11:8] == 4'd9) begin // if we are at 9, rollover to THOUSANDS\n\t\t\t\t\t\tdigit_state <= BCD_THOUSANDS;  \n\t\t\t\t\t\tq <= 4'b1000 + q[11:4]; // shift the 1 in position of THOUSANDs digit to left and add it with the existing value\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\t// increment HUNDReS digit without rolling over\n\t\t\t\t\t\tena <= ENABLE_TENS;   // enable for ONEs, TENS & HUNDREDS digits\n\t\t\t\t\t\tq <= 4'b10 + q[11:8];  // just increment the hundreds digit\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tBCD_THOUSANDS: begin \n\t\t\t\t\t// For THOUSANd digit, enable when incrementing to 10\n\t\t\t\t\tif (q[15] == 1'b1) begin   // if we are at 9, reset all digits back to zero\n\t\t\t\t\t\tdigit_state <= BCD_ONES;  \n\t\t\t\t\t\tq <= 16'b0;    \n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\t// increment THOUSANd digit without rolling over\n\t\t\t\t\t\tena <= ENABLE_TENS;  // enable for ONEs, TENS & HUNDREDS digits\n\t\t\t\t\t\tdigit_state <= BCD_ONES;  \n\t\t\t\t\t\tq <= 4'b1 + q"}
{"task_id": "countbcd", "completion": "\n\treg [2:0] counter;\n    wire [4:0] incrementer = {ena[1], q[7:4]} + ({q[3], 4'b0} + 4'h1);\n    \n    always @(posedge clk, posedge reset) begin\n        if (reset)\n            counter <= 3'b0;\n\t\telse \n\t\t\tcounter <= incrementer[2:0];\n\tend\n\t\n\t// Assigning the outputs\n    assign ena = {incrementer[4], incrementer[2]};\n\tassign q[15:8] = (~reset & counter[2]) ? 4'd0 : ((counter == 3) ? 4'd9 : q[7:0]);\n    assign q[7:4]  = (~reset & counter[2]) ? 4'd0 : ((counter == 2) ? 4'd9 : q[15:12]);\n\tassign q[3:0]  = (~reset & counter[2]) ? 4'd0 : ((counter == 1) ? 4'd9 : q[19:16]);\n\tassign q[19:16] = incrementer[4];\nendmodule\n\n"}
{"task_id": "popcount255", "completion": "\n\n    always @* begin\n        out = 8'h0;\n        for(i=0; i<255; i=i+1) begin\n            out = out + in[i]; \n        end\n   end\nendmodule\n\n"}
{"task_id": "popcount255", "completion": "\ninteger i;\nalways @* begin\n    out = 8'b0;\n\tfor(i=0; i<255; i++) begin\n\t    if (in[i]) \n\t\t\tout = out + 1;\n\tend\nend\n\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n// This solution uses two nested generate loops to build a 16x16 population count circuit. \n\t// For larger vectors you would need more instances and possibly additional logic.\n\n\tgenvar i, j; // General variables used for the nested loop indexing\n\n\tgenerate\n\t  for (i = 0; i < 16; ++i) begin: row_loop // Iterate over each row of 16 bit blocks\n\t    for (j = 0; j < 16; ++j) begin : col_loop // For each of these rows, iterate over the columns of 16 bit blocks\n\t      always @(*) begin\n\t        out[7-i] += in[(i*16+j)*8 +: 8]; \n\t        // This increment adds the population count for every block to the output. The range (i*16+j)*8 +: 8 selects the correct 8 bit section of 'in' and increments accordingly.\n\t      end\n\t    end\n\t  end\n\tendgenerate\n"}
{"task_id": "popcount255", "completion": "\n\t// Popcount function definition\n\tfunction [7:0] popCount;\n\t\tinput [31:0] x;  // using a subfunction for population count on 4 bytes (32 bits)\n\t\tinteger i;\n\t\tbegin\n\t\t\tpopCount = 0;\n\t\t\tfor(i=0; i<32; i=i+1) begin\n\t\t\t\tif(x[i])\n\t\t\t\t\tpopCount = popCount + 1;\n\t\t\tend\n\t\tend\n\tendfunction \n\t\n\t// main module code\n\talways @*\n\tbegin\n\t  out = 8'd0;\n  \tfor (int i=254; i>=0; i=i-32) begin // looping for each 32 bit substring in the input\n    \t\tout = out + popCount(in[i+:32]);  // adding result of population count of current 32 bit substring to output\n  \t  end\t\t\n\tend\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\t// Population Count\n\tfunction [8:0] countOnes;  // helper function to determine the number of '1's in an input vector\n\t\tinput [254:0] data;  \n\t\tbegin   \n\t\t\tcountOnes = (data == 255'b0) ? 9'd0 : (countOnes(data[253:0]) + (data[254])); // Recursive case\n\t\tend    \n\tendfunction  \n\n\talways @* begin\n\t\tout = countOnes(in);  // Call the helper function for each clock cycle.\n\tend\n\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\t// Create an array of counters for each bit position.\n\treg [7:0] cnts[255:0];  // 1-bit counter for each input index\n  \n\t// Initialize the counters.\n\tfor(genvar i=0; i<256; ++i) begin : init_counters\n\t  initial cnts[i] = 0;\n\tend\n  \n\t// For every bit position, count the number of '1's in the input vector and store it in cnts.\n\tfor(genvar i=0; i<256; ++i) begin : counting_loop\n\t  always @* if (in[i]) \n\t    cnts[i] <= cnts[i-1] + 1; \n      else\n        cnts[i] <= cnts[i-1];  // If the bit is '0', keep counting.\n\tend\n  \n\t// Assign output as last counter in array of counters (which contains the total count).\n\tassign out = cnts[254];\n\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\t// Population Count implementation using the reduce OR operator \"|\". \n\tfunction automatic [7:0] population;\n\t\tinput [254:0] in;\n\t\treg [7:0] count;\n\t\t\n\t\tfor(count = 8'b0; count < 8'd255 ; count++) begin\n\t\t\tif (in[count]) out = count + 1; \n\t\tend\n\t\treturn out; // Returns the population count of in.\n\tendfunction\n\t\n\t// Calling above function to calculate population count of 'in'.\n\talways @(*) begin\n\t    out <= population(in);  \n\tend\n\t\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\talways @* begin\n\t\tout = 8'd0; // Initialize the output to zero.\n\t\t\n        for(i=0; i<255; i++)  begin // Loop through each bit in the input vector.\n            if (in[i])   // If that specific bit is '1', then increment the count in out by one.\n                out = out + 8'd1;    \t\n        end\t\n    end\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n    always @(*) begin\n        for (out = 0; in != 255'b0 ; out++) \n            in = in >> 1;\n    end\nendmodule\n\n"}
{"task_id": "popcount255", "completion": "\nalways @(*) begin\n   integer i;\n   out = 8'b0;\n   for(i=0; i<255; i=i+1) \n      if (in[i]) \n         out = out + 1;\nend\n\t\nendmodule\n\n"}
{"task_id": "popcount255", "completion": "\n\tfor(genvar i=0; i<255; ++i) begin : gen_loop\n\t\tassign out[i] = |in[8*i+7:8*i];\n\tend\n\t// the last 8 bits of out will not be used, as in[254] doesn't have a corresponding out bit. \n\tassign out[7:0] = 8'b0;\n\n"}
{"task_id": "popcount255", "completion": "\n    always @* begin\n        out = 'h0;\n        for(integer i = 0; i < 255; i++) \n            if (in[i]) \n                out = out + 'h1;\n    end\nendmodule\n\n"}
{"task_id": "popcount255", "completion": "\n\treg [7:0] count;\n  integer i;\n  \n  always @(*) begin\n    count = 8'd0;\n    for (i=254; i>=0 ;i--) begin\n      if(in[i])begin\n        count = count + 1;\n      end\n    end\n\tout = count;\n  end\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\t// Bitwise XOR to count '1's using Population Count \n\tassign out = {3'b0,in[253:128]}^{6'b0,in[127:64],5'b0,in[63:0]};\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\t// Solution uses bit counting to count the number of '1' bits. The LSB represents 2^0 and so on.\n\talways @* begin\n\t\tout = 8'b0; // Reset output value\n\t\t\tfor (integer i=0; i<255; i++) begin // For each bit in input vector\n\t\t\t\tif(in[i]) // If the bit is '1'\n\t\t\t\t\tout = out + 1;  // Increment count\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\n\t// Population Count Circuit\n    always @(*) begin  // combinatorial logic, no clock\n        integer i;     // need a loop counter here\n        out = 8'b0;    // start with zero result\n        for (i=0; i<255; i=i+1) begin  // count from 0 to 254\n            if (in[i])\n                out = out + 1;   // add one to the current result whenever a '1' is detected\n        end\n    end\nendmodule\n\n"}
{"task_id": "popcount255", "completion": "\n// This solution uses a parallel bit count circuit \n\talways @(*) begin\n\t\tout = 8'b0; // Reset the output to zero\n\t\tfor (integer i=0; i<255; i++) begin\n\t\t\tif (in[i] == 1'b1)\n\t\t\t\tout = out + 1'b1; // If the bit is 1, increment the count\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "popcount255", "completion": "\n   wire [63:0] a[7:0];\n   assign a[0] = in[15:0];\n   genvar i;\n   generate \n\tfor(i=1; i<8; i++) begin : popcount_gen\n\t\tif (2*i < 255) // We need to split input into chunks of size 32\n\t\t\tassign a[i] = in[(2*i+1)-1:2*i-1];\n\t\telse // Last chunk, we can take the entire remaining part of the input\n\t\t\tassign a[i] = in[254:2*(i-1)];\n       end \n   endgenerate \n   \n\t// Compute population count for each chunk (8 chunks total)\n\tgenvar j;\n\tgenerate \n\tfor(j=0; j<8; j++) begin : popcount_out\n      assign out[j] = |a[j]; // Use the OR gate to compute population count of a[i][15:0]\n   end\n\tendgenerate \nendmodule\n"}
{"task_id": "popcount255", "completion": "\n\t// 8 bit population count lookup table\n\treg[7:0] popcountLUT[0:255];\n\n\tfunction void create_popcountLUT();\n\t    integer i;\n    \tfor (i = 0; i < 256; i = i + 1) begin\n        \tinteger j;\n          \tpopcountLUT[i][7] = popcountLUT[i >> 4][6];\n      \t\tfor (j = 6; j >= 0; j--) \n            \tpopcountLUT[i][j] = popcountLUT[i >>  1][j + 1] + ((i & 1'b1) ? 1 : 0);\n    \tend\n\tendfunction\n\n\t// Create the population count Look-up table\n\tinitial create_popcountLUT();\n\n\t// Population count circuit\n    always @* begin\n      integer i;\n      \tfor (i = 254; i >= 0; i = i - 8)\n        \tout += popcountLUT[in[i + 7:i]];\n    end\nendmodule\n\n"}
{"task_id": "popcount255", "completion": "\n\talways @* begin\n\t\tout = 8'b0;\n\t\tfor(integer i=0; i<255; i++) begin\n\t\t\tif (in[i]) \n\t\t\t\tout = out + 1;\n\t\tend\n\tend\nendmodule\n\n"}
{"task_id": "2014_q3c", "completion": "\n\t// State assignment.\n\treg [2:0] nextState;\n\talways @(*) begin\n\t\tcase (y) \n\t\t\t3'b000: if (!x) nextState = 3'd0; else nextState = 3'd1; // y=000\n\t\t\t3'b001: if (!x) nextState = 3'd0; else nextState = 3'd2; // y=001\n\t\t\t3'b010: if (!x) nextState = 3'd1; else nextState = 3'd1; // y=010\n\t\t\t3'b011: if (!x) nextState = 3'd1; else nextState = 3'd2; // y=011\n\t\t\t3'b100: if (!x) nextState = 3'd3; else nextState = 3'd4; // y=100\n\t\t\tdefault: nextState = 'X; \t\t\t\t\t// default to unknown state\n\t\tendcase\n\tend\n\n\t// Output assignment.\n\tassign Y0 = nextState[0];\n\tassign z = (nextState == 3'b001) || (nextState == 3'b011);\n\n\t// Register update for clocked states.\n\talways @(posedge clk) begin\n\t\t y <= nextState; \n\tend\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n\t// state machine variables\n\treg [2:0] Y;\n  \n\t// State Assignment\n\talways @(*) begin  // combinational logic (assignments)\n\t  case(y) \n\t\t3'b000: begin if(!x) Y = 3'd0; else Y = 3'd1; z = 1'b0; end\n\t\t3'b001: begin if(!x) Y = 3'd2; else Y = 3'd0; z = 1'b0; end\n\t\t3'b010: begin if(!x) Y = 3'd3; else Y = 3'd2; z = 1'b0; end\n\t\t3'b011: begin if(!x) Y = 3'd4; else Y = 3'd1; z = 1'b1; end\n\t\t3'b100: begin if(!x) Y = 3'd5; else Y = 3'd2; z = 1'b1; end\n\t\tdefault: begin Y = y; z=1'bx; end  // undefined state.\n\t  endcase  \n\tend  \n\n\t// output assignment (parallel to latches)\n\tassign Y0 = Y[0]; \n\n\t// State update with clock\n\talways @(posedge clk) begin\n\t    y <= Y;\n    end \n\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n   \n\treg [1:0] nextstate;  // intermediate register for calculating next state\n   always @(*) begin      \n      case (y)            // assigning the values according to y input\n         3'b000, 3'b001 : nextstate <= 2'b00;\n         3'b001, 3'b100: nextstate <= 2'b00;  \n         3'b010, 3'b001: nextstate <= 2'b00;    \n          \n         //for the states that match with the table above (only case not handled yet) we will assign the values here.\n      endcase   \n      \n\t\tcase(y[2:1],nextstate,x)   // using y and next state to calculate output z \n\t\t    2'b00, 2'b00, x: begin Y0 = y[0]; z = 1'b0; end     \n            2'b00, 2'b01, x: begin Y0 = y[0]; z = 1'b0; end     //same as above in the table      \n         //for other combinations we will assign values here.\n\t\tendcase   \n   end\n   \n\t// updating y after every clock edge with new calculated state\n\talways @(posedge clk) begin \n      Y0 <= nextstate[1];\n      z <= nextstate[0];\n\tend\n    \nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\nalways @(posedge clk) begin\n\tcase ({y,x}) \n\t\t3'b000 : begin \n\t\t\tY0 <= ~y[2];\n\t\t\tz <= 1'b0;\n\t\tend\n\t\t3'b001: begin \n\t\t\tY0 <= y[0] & ~y[2];\n\t\t\tz <= 1'b0;\n\t\t\tend\n\t\t3'b010 : begin\n\t\t\tY0 <= y[0];\n\t\t\tz <= 1'b0;\n\t\tend\n\t\t3'b011: begin \n\t\t\tY0 <= y[0] | ~y[2];\n\t\t\tz <= 1'b1;\n\t\tend\n\t\t3'b100 : begin \n\t\t\tY0 <= y[1] | y[0];\n\t\t\tz <= 1'b1;\n\t\tend\n\t\tdefault: ;\n\tendcase\nend\n"}
{"task_id": "2014_q3c", "completion": "\nalways @(posedge clk) begin\n\tcase(y)\n\t\t3'b000: if (x) begin Y<=1; Z<=0; end else begin Y<=0; Z<=0; end\n\t\t3'b001: if (x) begin Y<=2; Z<=0; end else begin Y<=1; Z<=0; end\n\t\t3'b010: if (x) begin Y<=4; Z<=0; end else begin Y<=2; Z<=0; end\n\t\t3'b011: if (x) begin Y<=1; Z<=1; end else begin Y<=1; Z<=0; end\n\t\t3'b100: if (x) begin Y<=3; Z<=1; end else begin Y<=3; Z<=0; end\n\tendcase\n\tY0 <= Y[0]; //assign the first bit of next state to output Y0\nend\n"}
{"task_id": "2014_q3c", "completion": "\n\talways @(posedge clk) begin\n\t\tcase (y) \n\t\t\t3'b000: begin\n\t\t\t\tif (x == 1'b0)\n\t\t\t\t\t{Y0, y} <= 3'b000;\n\t\t\t\telse\n\t\t\t\t\t{Y0, y} <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\tif (x == 1'b0)\n\t\t\t\t\t{Y0, y} <= 3'b001;\n\t\t\t\telse\n\t\t\t\t\t{Y0, y} <= 3'b100;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tif (x == 1'b0)\n\t\t\t\t\t{Y0, y} <= 3'b010;\n\t\t\t\telse\n\t\t\t\t\t{Y0, y} <= 3'b001;\n\t\t\tend\n\t\t\t3'b011: begin\n\t\t\t\tif (x == 1'b0)\n\t\t\t\t\t{Y0, y} <= 3'b001;\n\t\t\t\telse\n\t\t\t\t\t{Y0, y} <= 3'b010;\n\t\t\t\tz = 1'b1;\n\t\t\tend\n\t\t\t3'b100: begin\n\t\t\t\tif (x == 1'b0)\n\t\t\t\t\t{Y0, y} <= 3'b011;\n\t\t\t\telse\n\t\t\t\t\t{Y0, y} <= 3'b100;\n\t\t\t\tz = 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n\n"}
{"task_id": "2014_q3c", "completion": "\n\n\t// Create lookup table for outputs Y[0] and z.\n\treg [1:0] lut_yx [7:0]; \n\tint i;\n\tinitial begin\t\t   // Initialization of the look up table.\n\t\tfor (i=0; i<8; i++) begin\n\t\t\tcase(i)\t\t\t   \n\t\t\t\t3'b000 : lut_yx[i] = 2'b00;\t   \n\t\t\t\t3'b001 : lut_yx[i] = x ? 2'b00 : 2'b01;\n\t\t\t\t3'b010 : lut_yx[i] = x ? 2'b01 : 2'b00;  \n\t\t\t\t3'b011 : lut_yx[i] = {~x, 1'b1};\t   \n\t\t\t\t3'b100 : lut_yx[i] = 2'b11;\t           \n\t\t\t\tdefault: lut_yx[i] = 2'bx;\t\t   \n\t\t\tendcase\n\t\tend\n\tend\n\n\t// Update state and output values on every clock edge.\n\talways @(posedge clk) begin \t   \n\t\tY0 <= y[0];\t\t\t   // Y0 is directly tied to the MSB of current state y[2:0].\n\t\t{z,y} <= lut_yx[{x,y}];    // Update next-state and output value based on lookup table.\n\tend\t\t\t\t\t \nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n\treg [2:0] Y;\n\n\talways @(posedge clk) begin\n\t\tcase (y) \n\t\t\t3'b000 : begin Y <= x ? 3'b001 : 3'b000; end\n\t\t\t3'b001 : begin Y <= x ? 3'b001 : 3'b001; end\n\t\t\t3'b010 : begin Y <= x ? 3'b010 : 3'b001; end\n\t\t\t3'b011 : begin Y <= x ? 3'b001 : 3'b010; z <= 1'b1; end\n\t\t\t3'b100 : begin Y <= x ? 3'b011 : 3'b100; z <= 1'b1; end\n\t\t\tdefault: begin Y <= y; z <= 1'b0; end\n\t\tendcase\n  \tY0 <= Y[0];\n\tend\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n\talways @(posedge clk) begin\n\t\tcase (y)\n\t\t\t3'b000: begin\n\t\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b000;\n\t\t\t\t\tend else if (x==1'b1) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b001;\n\t\t\t\t\tend\n\t\t\t\tz <= x == 1'b0 ? 1'b0 : 1'b0;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b001;\n\t\t\t\t\tend else if (x==1'b1) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b100;\n\t\t\t\t\tend\n\t\t\t\tz <= x == 1'b0 ? 1'b0 : 1'b0;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b010;\n\t\t\t\t\tend else if (x==1'b1) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b001;\n\t\t\t\t\tend\n\t\t\t\tz <= x == 1'b0 ? 1'b0 : 1'b0;\n\t\t\tend\n\t\t\t3'b011: begin\n\t\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b001;\n\t\t\t\t\tend else if (x==1'b1) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b010;\n\t\t\t\t\tend\n\t\t\t\tz <= x == 1'b0 ? 1'b1 : 1'b1;\n\t\t\tend\n\t\t\t3'b100: begin\n\t\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b011;\n\t\t\t\t\tend else if (x==1'b1) begin \n\t\t\t\t\t\t{Y0, y} <= 3'b100;\n\t\t\t\t\tend\n\t\t\t\tz <= x == 1'b0 ? 1'b1 : 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\n\n"}
{"task_id": "2014_q3c", "completion": "\n\treg [2:0] next;\n\twire [1:0] state = {Y[2], Y[0]};\n\t\n\t// Next State Logic\n\talways @(*) begin\n\t    case (state) \n\t\t    2'b00 : if (!x) next = 3'b000; else next = 3'b001;\n\t\t    2'b01 : if (!x) next = 3'b001; else next = 3'b100;\n\t\t    2'b10 : if (!x) next = 3'b010; else next = 3'b001;\n\t\t    2'b11 : if (!x) next = 3'b001; else next = 3'b010;\n\t    endcase\n\tend \n\t\n\t// Output Logic\n\talways @(*) begin\n\t    case (state)\n\t\t    2'b00, 2'b10 : z = 1'b0; // z is set to zero for states 00 and 10.\n\t\t    default: z = 1'b1;         // z is set to one for states 01 and 11.\n\t    endcase\n\tend \n\t\n\t// State Register\n\talways @(posedge clk) begin\n\t    Y[2:0] <= next;\n\tend\n\tassign Y0 = Y[0]; // Assign Y0 the value of bit 0 of y[]\n\n"}
{"task_id": "2014_q3c", "completion": "\n    always @(posedge clk) begin \n        case (y) \n            3'b000: begin \n                if (!x) \n                    Y <= y; // no change in state\n                else \n                    Y <= 3'b001; // go to next state based on transition table\n            end\n            3'b001: begin \n                if (!x) \n                    Y <= y; // no change in state\n                else \n                    Y <= 3'b100; // go to next state based on transition table\n            end\n            3'b010: begin \n                if (!x) \n                    Y <= y; // no change in state\n                else \n                    Y <= 3'b001; // go to next state based on transition table\n            end\n            3'b011: begin \n                if (!x) \n                    Y <= y; // no change in state\n                else \n                    Y <= 3'b010; // go to next state based on transition table\n                z <= 1'b1;    // Output z is set to '1'\n            end\n            3'b100: begin \n                if (!x) \n                    Y <= y; // no change in state\n                else \n                    Y <= 3'b100; // go to next state based on transition table\n            end\n        endcase\n    end\n   assign Y0 = Y[0]; // assigning the first bit of current state to output Y0\n"}
{"task_id": "2014_q3c", "completion": "\nalways @(posedge clk) begin \n\tcase ({x,y})\n\t\t2'b00 : begin Y0 <= 1'b0; z <= 1'b0; end\n\t\t2'b01 : begin Y0 <= y[0]; z <= 1'b0; end\n\t\t2'b10 : begin Y0 <= y[1:0] == 2'b00 ? 1'b0 : y[0]; z <= 1'b0; end\n\t\t2'b11 : begin Y0 <= y[0] ^ y[1]; z <= |{y[0], ~x}; end\n\tendcase\nend\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n    always @(posedge clk) begin\n        case(y)\n            3'b000:  if (x == 1'b0)   {Y0, y} <= 3'b000; else {Y0, y} <= 3'b001;\n            3'b001:  if (x == 1'b0)   {Y0, y} <= 3'b001; else {Y0, y} <= 3'b100;\n            3'b010:  if (x == 1'b0)   {Y0, y} <= 3'b010; else {Y0, y} <= 3'b001;\n            3'b011:  if (x == 1'b0)   {@, z}  <= 2'b00; else {@, z}  <= 2'b10;\n            3'b100:  if (x == 1'b0)   {Y0, y} <= 3'b011; else {Y0, y} <= 3'b100;\n            default: {@, z}  <= 2'bx;\n        endcase\n    end\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n\talways @(posedge clk) begin\n\t\tcase (y) \n\t\t\t3'b000 : begin\n\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t{Y0, y} <= 3'b000; z<=1'b0; end\n\t\t\t\telse           begin {Y0, y} <= 3'b001; z<=1'b0; end \n\t\t\tend\n\t\t\t3'b001 : begin\n\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t{Y0, y} <= 3'b001; z<=1'b0; end\n\t\t\t\telse           begin {Y0, y} <= 3'b100; z<=1'b0; end \n\t\t\tend\n\t\t\t3'b010 : begin\n\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t{Y0, y} <= 3'b010; z<=1'b0; end\n\t\t\t\telse           begin {Y0, y} <= 3'b001; z<=1'b0; end \n\t\t\tend\n\t\t\t3'b011 : begin\n\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t{Y0, y} <= 3'b001; z<=1'b1; end\n\t\t\t\telse           begin {Y0, y} <= 3'b010; z<=1'b0; end \n\t\t\tend\n\t\t\t3'b100 : begin\n\t\t\t\tif (x==1'b0) begin \n\t\t\t\t\t{Y0, y} <= 3'b011; z<=1'b1; end\n\t\t\t\telse           begin {Y0, y} <= 3'b100; z<=1'b0; end \n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n\n\talways @(posedge clk) begin\n\t\tcase (y) \n\t\t\t3'b000 : if (!x) y <= 3'b000; else y <= 3'b001;\n\t\t\t3'b001 : if (!x) y <= 3'b001; else y <= 3'b100;\n            3'b010 : if (!x) y <= 3'b010; else y <= 3'b001;\n\t\t\t3'b011 : if (!x) y <= 3'b001; else y <= 3'b010;\n\t\t\t3'b100 : if (!x) y <= 3'b011; else y <= 3'b100; \n\t\tendcase\n\t\t\n        Y0 = y[0]; // The first bit of state y is outputted\n        \n        z = 0; // Default value for z\n\t\tcase (y) \n\t\t\t3'b001 : if (!x) z <= 0;\n            3'b001 : if (x)  z <= 0;\n            3'b010 : if (!x) z <= 0;\n            3'b011 : if (!x) z <= 1;\n\t\t\t3'b011 : if (x)  z <= 0;\n\t\tendcase\t\n    end\n    \nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\nalways @(posedge clk) begin\n\tcase (y)\n\t\t3'b000: if (!x) Y0 <=  1'b0; else Y0 <= 1'b0;\n        3'b001: if (!x) Y0 <=  1'b0; else Y0 <= 1'b0;\n        3'b010: if (!x) Y0 <=  1'b0; else Y0 <= 1'b0;\n        3'b011: if (!x) Y0 <=  1'b1; else Y0 <= 1'b1;\n        3'b100: if (!x) Y0 <=  1'b1; else Y0 <= 1'b0; \t\t\n\tendcase\n    case (y)\n\t\t3'b000: z <= 1'b0;\n        3'b001: if (!x) z <= 1'b0; else z <= 1'b0;\n        3'b010: z <= 1'b0;\n        3'b011: if (!x) z <= 1'b0; else z <= 1'b1;\n        3'b100: if (!x) z <= 1'b1; else z <= 1'b1; \t\t\n\tendcase\nend\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\nalways @(posedge clk or posedge x) begin\n\tif (!x) begin\n\t\tcase (y)\n\t\t\t3'b000: begin Y0 = 1'b0; z = 1'b0; end\n\t\t\t3'b001: begin Y0 = 1'b0; z = 1'b0; end\n\t\t\t3'b010: begin Y0 = 1'b0; z = 1'b0; end\n\t\t\t3'b011: begin Y0 = 1'b0; z = 1'b1; end\n\t\t\t3'b100: begin Y0 = 1'b0; z = 1'b0; end\n\t\t\tdefault: begin Y0 = y[2]; z = ~y[2]; end\n\t\tendcase\n\tend else if (x) begin \n\t\tcase (y)\n\t\t\t3'b000: begin Y0 = 1'b0; z = 1'b0; end\n\t\t\t3'b001: begin Y0 = 1'b0; z = 1'b0; end\n\t\t\t3'b010: begin Y0 = 1'b0; z = 1'b0; end\n\t\t\t3'b011: begin Y0 = 1'b0; z = 1'b1; end\n\t\t\t3'b100: begin Y0 = 1'b1; z = 1'b1; end\n\t\t\tdefault: begin Y0 = y[2]; z = ~y[2]; end\n\t\tendcase\n\tend\nend\nendmodule \n"}
{"task_id": "2014_q3c", "completion": "\n\treg [2:0] Y;\n\talways @(*) begin\n\t\tcase (y) \n\t\t\t3'b000 : if (x == 1'b0) Y <= 3'b000; else Y <= 3'b001;\n\t\t\t3'b001 : if (x == 1'b0) Y <= 3'b001; else Y <= 3'b100;\n\t\t\t3'b010 : if (x == 1'b0) Y <= 3'b010; else Y <= 3'b001;\n\t\t\t3'b011 : if (x == 1'b0) Y <= 3'b001; else Y <= 3'b010;\n\t\t\t3'b100 : if (x == 1'b0) Y <= 3'b011; else Y <= 3'b100;\n\t\t\tdefault:  Y <= y;\n\t\tendcase\n\tend\n\n\tassign Y0 = Y[0];\n\tassign z  = (Y == 3'b001 && x==1'b0) || (Y ==3'b010 && x==1'b1);\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\n    wire [2:0] next_y;\n    \n\t//next state logic\n\tassign next_y = (x == 1'b1) ? {y[0], y[2], ~y[0]} : y;\n\t\n\t//state assignment for Y[0] and z\n\talways @(*) begin\n\t    if (y==3'b000 || y==3'b001) begin\n\t        {Y0,z} = (x == 1'b1) ? 2'b0 : 2'b0;\n\t    end else if (y==3'b001 || y==3'b100) begin\n\t         {Y0,z} = (x == 1'b1) ? 2'b0 : 2'b0;\n\t    ] else if (y==3'b010) begin\n\t        {Y0,z} = (x == 1'b1) ? 2'b0 : 2'b0;\n\t   } else if (y==3'b011 || y==3'b110) begin\n\t        {Y0,z} = (x == 1'b1) ? 2'b1 : 2'b0;\n\t    end \n\tend\n"}
{"task_id": "2014_q3c", "completion": "\n\treg [2:0] next_state;\n\n\t// state transition function\n\talways @* begin\n\t\tcase(y)\n\t\t\t3'b000: if (x==1) next_state = 3'b001; else next_state = 3'b000; // x=0 or 1 -> y[2] = 0, z=0\n\t\t\t3'b001: if (x==1) next_state = 3'b100; else next_state = 3'b001; // x=0 or 1 -> y[2] = 0, z=0\n\t\t\t3'b010: if (x==1) next_state = 3'b001; else next_state = 3'b010; // x=0 or 1 -> y[2] = 0, z=0\n\t\t\t3'b011: if (x==1) next_state = 3'b010; else next_state = 3'b001; // x=0 -> y[2] = 0, z=1 / x=1 -> y[2] = 0, z=0\n\t\t\t3'b100: if (x==1) next_state = 3'b100; else next_state = 3'b100; // x=0 or 1 -> y[2] = 1, z=1\n\t\t\tdefault : next_state = 3'bx;  \t\t\t\t\t\t// invalid input (should never happen)\n\t\tendcase\n\tend\n\t\n\t// output function\n\tassign Y0 = next_state[0]; // MSB of next state is Y[0]\n\tassign z = |(next_state & 3'b101); // z is set when y[2] and y[1] are '1', so it corresponds to bits in the form (y[2],y[1]) = (1,1)\n\t\t\nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\n\n    assign heater = (mode == 1'b0) && too_cold; // If mode is 0 (Cooling), then turn on Heater if it is too cold\n    assign aircon = (mode == 1'b1) && too_hot; // If mode is 1 (Heating), then turn on AC if it is too hot\n\tassign fan = (heater || aircon) || fan_on; // If heater or ac are turned on, also turn on the fan. And if user wants to manually force the fan on, also do that.\n    \nendmodule\n"}
{"task_id": "thermostat", "completion": "\n\n\tassign heater = (mode == 1'b0) & too_cold;\n\tassign aircon = (mode == 1'b1) & too_hot;\n\tassign fan    = ((heater | aircon) | fan_on);\n\nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\nassign heater = (mode & ~too_cold) | fan_on;\nassign aircon = ((~mode) & too_hot) | fan_on;\nassign fan = heater | aircon | fan_on;\n\nendmodule \n\n"}
{"task_id": "thermostat", "completion": "\nalways @* begin\n\tif (mode) begin // Cooling mode\n\t\tif(too_cold) \n\t\t\taircon = 1'b1; \n\t\telse if (fan_on)\n\t\t\taircon = 1'b0;  \n\t\telse \n\t\t\taircon = 1'b0; \n\t\t\t\n\t\theater = 1'b0; // Always off in cooling mode\n\tend else begin // Heating mode\n\t\tif(too_hot) \n\t\t\theater = 1'b1;  \n\t\telse if (fan_on) \n\t\t\theater = 1'b0; \n\t\telse \n\t\t\theater = 1'b0;\n\t\t\t\n\t\taircon = 1'b0; // Always off in heating mode\n\tend\n\tif(too_cold || too_hot || fan_on)\n\t\tfan = 1'b1; // Fan on if any of the above conditions are true\n\telse \n\t\tfan = 1'b0; // Fan off otherwise\nend\n"}
{"task_id": "thermostat", "completion": "\nassign heater = (mode & ~too_cold);\nassign aircon = ((~mode) & too_hot);\nassign fan = (heater | aircon | fan_on);\n\nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\n\t// Declare the outputs as reg because we're going to change them.\n\treg h, a, f;\n\t\n\tassign heater = (mode == 1 && too_cold) ? 1 : ((h || f)? 1 : 0);\n\tassign aircon = (mode == 0 && too_hot) ? 1 : ((a || f)? 1 : 0);\n\tassign fan = (h || a || fan_on) ? 1 : 0;\n"}
{"task_id": "thermostat", "completion": "\n\tassign heater = (mode & ~too_cold);\n\tassign aircon = ((~mode) & too_hot);\n\tassign fan = (heater | aircon | fan_on);\n\nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\n\tassign heater = (mode == 1'b0) ? 1'b0 : ((too_cold == 1'b1) ? 1'b1 : 1'b0);\n\tassign aircon = (mode == 1'b1) ? 1'b0 : ((too_hot == 1'b1) ? 1'b1 : 1'b0);\n\tassign fan = (heater | aircon | fan_on);\nendmodule\n"}
{"task_id": "thermostat", "completion": "\n\n    assign heater = (mode == 1'b0) ? 1'b0 : too_cold;\n    assign aircon = (mode == 1'b1) ? 1'b0 : too_hot;\n    assign fan = (heater | aircon) | fan_on;\n    \nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\n    assign heater = (mode & ~too_cold) | fan_on;\n    assign aircon = ((~mode)& too_hot) | fan_on ;\n    assign fan    = heater | aircon | fan_on ;\nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\nassign heater = (mode && too_cold) ? 1'b1 : 1'b0;\nassign aircon = (!mode && too_hot) ? 1'b1 : 1'b0;\nassign fan = (heater || aircon || fan_on) ? 1'b1 : 1'b0;\n"}
{"task_id": "thermostat", "completion": "\nassign heater = (mode & ~too_cold) | fan_on;\nassign aircon = ~mode & too_hot;\nassign fan = (heater | aircon) | fan_on;\n\nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\nalways @(*) begin\n\tif (mode == 1'b0) begin // cooling mode\n\t\theater = ~too_hot & ~fan_on;  // If it is too hot turn on the AC but not heater and if fan is also turned ON.\n\t\taircon = too_hot | fan_on;    // If it's too hot or fan is turned ON, turn on air conditioner\n\t\tfan = too_hot | (~too_cold & fan_on);  // If it\u2019s too hot or if it\u2019s not too cold and fan has been turned ON.\n\tend else begin // heating mode\n\t\theater = too_cold;   // If it's too cold, turn on heater.\n\t\taircon = 1'b0;       // In heating mode, always OFF the AC.\n\t\tfan = too_cold | fan_on;  // If it\u2019s too cold or fan has been turned ON, turn the Fan ON.\n\tend\nend\n"}
{"task_id": "thermostat", "completion": "\n\tassign heater = (mode == 1'b0) ? 1'b0 : too_cold; //if mode=0(cooling), then donot turn on the heater. If it is too cold, turn on.\n\tassign aircon = (mode == 1'b1) ? 1'b0 : too_hot; //If mode=1(heating), then donot turn on the air conditioner. If it is too hot, turn on.\n\tassign fan = (fan_on | heater | aircon); //if either the heater or the air conditioner is on, or if the fan is requested to be on.\nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\n    assign heater = (mode == 1'b0 && too_cold) ? 1'b1 : 1'b0;\n\tassign aircon = (mode == 1'b1 && too_hot) ? 1'b1 : 1'b0;\n\tassign fan = ((heater || aircon) || fan_on) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "thermostat", "completion": "\n\n    assign heater = (mode & ~too_cold) ;\n    assign aircon = (~mode & too_hot) ;\n    assign fan = (heater | aircon) | fan_on;\n    \nendmodule\n\n"}
{"task_id": "thermostat", "completion": "\nassign heater = (mode & ~too_cold) | fan_on;\nassign aircon = ~mode & too_hot;\nassign fan = (heater | aircon) | fan_on;\n\nendmodule \n\n"}
{"task_id": "thermostat", "completion": "\nassign heater = mode ? 0 : too_cold;\nassign aircon = !mode && too_hot;\nassign fan = (heater || aircon) || fan_on ;\nendmodule\n"}
{"task_id": "thermostat", "completion": "\n\tassign heater = (mode == 1'b0) ? 1'b0 : too_cold; // if mode is cooling and it's too cold then turn on the heater otherwise keep the heater off\n\tassign aircon = (mode == 1'b1) ? 1'b0 : too_hot; // if mode is heating and it's too hot then turn on the air conditioning, else keep the air conditioner off\n\tassign fan = too_cold | too_hot | fan_on | heater | aircon;  \t// always turn on the fan when either of these conditions are true.\nendmodule \n"}
{"task_id": "thermostat", "completion": "\n\tassign heater = (mode == 1'b0) & too_cold; // In heating mode, turn on the heater if it is too cold.\n\tassign aircon = (mode == 1'b1) & too_hot; // In cooling mode, turn on the air conditioner if it is too hot.\n\tassign fan = (heater | aircon) | fan_on;  // Turn on the fan if heater or air conditioner are on, or if user requests.\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\t// Assuming state assignments as in the problem statement\n\tassign Y1 = (y[0]) | ((~y[2]) & w) | (y[4] & ~w);\n\tassign Y3 = (y[2]) | ((~y[4]) & w) | (y[0] & ~w); \nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\n\t// Assuming that we are using a one-hot encoding. \n\t// The state machine transitions as follows: A -> B, B -> C, C -> D, D -> E, etc... If y[5] is high (1), it means we are at state F and should transition to state A.\n\tassign Y1 = ((y == 6'b000001) || (y == 6'b100000)) ? w : ~w;  // When in state A or F, the output is high, else it's low.\n\t// The state machine transitions as follows: A -> D, B -> E, C -> F, D -> F, E -> B, etc... If y[2] is high (1), it means we are at state C or E and should transition to state B.\n\tassign Y3 = ((y == 6'b000100) || (y == 6'b001000)) ? w : ~w;  // When in state C or E, the output is high, else it's low.\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\n\tassign Y1 = y[0];  // for state A Y1=0 and for B/C Y1 = 1 (since when y[0]=0 it implies we are in state B or C)\n   assign Y3 = y[2];  // for state A/B Y3 = 0, for D Y3 = 1 etc.\n\t\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\t//Y1 is the input of state flip-flop y[1], and Y3 is the input of state flip-flop y[3]. \n\tassign Y1 = (y == 6'b000010 | y == 6'b001000 | y == 6'b010000) ? w : ~w; // For states B, E, F we want the output to be positive and for all others it should be negative\n\tassign Y3 = (y == 6'b000001 | y == 6'b000100 | y == 6'b001000) ? w : ~w; // For states A, C, E we want the output to be positive and for all others it should be negative\nendmodule \n"}
{"task_id": "2012_q2b", "completion": "\n\tassign Y1 = w ? y[4] : y[2]; //y[4] corresponds to E and y[2] corresponds to C in one-hot encoding. So Y1 will be the input for state flip flop y[1].\n\tassign Y3 = w ? y[5] : y[3]; //y[5] corresponds to F and y[3] corresponds to D in one-hot encoding. So Y3 will be the input for state flip flop y[3].\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\tassign Y1 = y[2]; // y[2] corresponds to the input of state flip-flop y[1]. From the given transition table, we can see that only B and F go to A when w=0. Therefore, the only way for y[1] to be 1 is if the current state is B or F with w=0. In both states, the value of y[2] (corresponding to Y1) is 1.\n\tassign Y3 = y[4]; // y[4] corresponds to the input of state flip-flop y[3]. From the given transition table, we can see that only E and F go to A when w=0 or D when w=1. Therefore, if the current state is either B (w=0) or E (w=1), then the value of y[4] (corresponding to Y3) will be 1. In other states, it's 0.\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\nassign Y1 = (y[1] & ~w) | (y[2] & w);\nassign Y3 = (y[3] & ~w) | (~y[3] & y[5]);\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\t// Verilog Code for Signal Y1 and Y3\n\tassign Y1 = y[0]; // For state A (y[0]) we need to select the 1st bit of the 6-bit one-hot encoded vector.\n\n\t// Verilog code for Signal Y3\n\tassign Y3 = w ? ~(|y[5:4]) : y[2]; // If input 'w' is high, then we need to select only if states B (y[1]), C (y[2]) or E (y[4]) are NOT set. Otherwise, for state D (y[3]) we need to select the 3rd bit of the 6-bit one-hot encoded vector.\n\t\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n   assign Y1 = y[1];  // input of state flip-flop y[1], based on the one hot encoding of the states. It will be high when 'y' is in state B or D (000010 or 001000).\n   assign Y3 = y[3];  // input of state flip-flop y[3], based on the one hot encoding of the states. It will be high when 'y' is in state C or E (000100 or 010000).\n\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\n\tassign Y1 = (y[4] & ~y[3]) | (~w & y[2]); // from B to A or F to D through C states.\n\tassign Y3 =  w | (~y[5] & y[0]);            // from E to D when w=1; if y=F then go back to state D. \n\t // if y =A or B, stay on same state and let w toggle through C and D states.  \nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\t// Since the inputs are 6 bits long with a one-hot encoding where only one bit is high at any given time, we can derive the outputs as follows:\n\tassign Y1 = y[0] & w; // If y[5:0] = 000001(A), then input to state flip-flop y[1] will be '1' only when y is A (0) and w is 1. Therefore, if y[0] == 1 and w == 1, Y1 == 1\n\tassign Y3 = y[2] & w; // If y[5:0] = 000100(C), then input to state flip-flop y[3] will be '1' only when y is C (0) and w is 1. Therefore, if y[2] == 1 and w == 1, Y3 == 1\n\t\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\tassign Y1 = (y[0]) ? 1'b1 : 1'b0;\n\tassign Y3 = (y[2]) ? ((w) ? 1'b1 : 1'b0 ) : ((~w) ? 1'b1: 1'b0);\nendmodule\n\n"}
{"task_id": "2012_q2b", "completion": "\n\t// One-hot decoding for the state y[5:0], where each bit corresponds to a specific state.\n\tassign Y1 = (y == 6'b000001) ? w : ((y == 6'b000100) ? ~w : 1'b0); // State A or B\n\tassign Y3 = (y == 6'b000010) ? w : ((y == 64'b000100) ? ~w : 1'b0); // State B or C\nendmodule\n\n"}
{"task_id": "2012_q2b", "completion": "\n    wire A = |(y & 6'b000001); // When 'A' is the current state.\n    wire B = |(y & 6'b000010); // When 'B' is the current state.\n    wire C = |(y & 6'b000100); // When 'C' is the current state.\n    wire D = |(y & 6'b001000); // When 'D' is the current state.\n    wire E = |(y & 6'b010000); // When 'E' is the current state.\n    \n\tassign Y1 = ~B & ~C & D & E & w;\n\tassign Y3 = B & C & ~D & E & w;\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\tassign Y1 = y[2]; //For state A we get 000010 and for B we get 000010 so y1 is the third bit in binary representation of 'B'.\n\tassign Y3 = y[4]; //For state C we get 000100 and for D we get 000100 so y3 is the fourth bit in binary representation of 'D' & 'C'.\n\t\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\n\tassign Y1 = w & ~y[4]; // 0->B and 1->A transitions will set bit 1 high\n    assign Y3 = ~w & y[2] | (~w & ~y[5]) & y[4]; // for D and E states, if W is low, else F state.\n\t\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n     assign Y1 = ((y[5:4] == 2'b10) || (y[5:4] == 2'b01 && w)) ? 1'b1 : 1'b0;\n\t assign Y3 = ((y[3]) || (y[5:4] == 2'b01 && !w)) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\tassign Y1 = |y[2:0]; // When the state is A or B, Y1 will be 0. For C to F states it would be 1.\n\tassign Y3 = y[4] & w; // If we are in E (w==1) state and w is also active (1), then Y3 will be 1. Else, Y3 will be 0.\n\t\nendmodule\n\n"}
{"task_id": "2012_q2b", "completion": "\n\tassign Y1 = (y[2:1] == 2'b10) ? 1 : 0;\n\tassign Y3 = ((y[5:4] == 2'b01 && w == 0) || (y[5:4] == 2'b10 && w == 1)) ? 1 : 0;\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\n\n\tassign Y1 = w & ~y[4]; // For state A it's 1 when W=1 and for states B and F (when W=0), y[5] is not active. \n\tassign Y3 = ~w | y[2]; // For states C, E and D it's 1 when W=0 or for states A and F (when W=1), y[3] is active.\n\nendmodule\n"}
